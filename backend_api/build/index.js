var __create = Object.create;
var __defProp = Object.defineProperty;
var __getProtoOf = Object.getPrototypeOf;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __toESM = (mod, isNodeMode, target) => {
  target = mod != null ? __create(__getProtoOf(mod)) : {};
  const to = isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target;
  for (let key of __getOwnPropNames(mod))
    if (!__hasOwnProp.call(to, key))
      __defProp(to, key, {
        get: () => mod[key],
        enumerable: true
      });
  return to;
};
var __commonJS = (cb, mod) => () => (mod || cb((mod = { exports: {} }).exports, mod), mod.exports);
var __require = (id) => {
  return import.meta.require(id);
};
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, {
      get: all[name],
      enumerable: true,
      configurable: true,
      set: (newValue) => all[name] = () => newValue
    });
};

// node_modules/uuid/dist/rng.js
var require_rng = __commonJS((exports) => {
  var _interopRequireDefault = function(obj) {
    return obj && obj.__esModule ? obj : { default: obj };
  };
  var rng = function() {
    if (poolPtr > rnds8Pool.length - 16) {
      _crypto.default.randomFillSync(rnds8Pool);
      poolPtr = 0;
    }
    return rnds8Pool.slice(poolPtr, poolPtr += 16);
  };
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = rng;
  var _crypto = _interopRequireDefault(__require("crypto"));
  var rnds8Pool = new Uint8Array(256);
  var poolPtr = rnds8Pool.length;
});

// node_modules/uuid/dist/regex.js
var require_regex = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = undefined;
  var _default = /^(?:[0-9a-f]{8}-[0-9a-f]{4}-[1-5][0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}|00000000-0000-0000-0000-000000000000)$/i;
  exports.default = _default;
});

// node_modules/uuid/dist/validate.js
var require_validate = __commonJS((exports) => {
  var _interopRequireDefault = function(obj) {
    return obj && obj.__esModule ? obj : { default: obj };
  };
  var validate = function(uuid) {
    return typeof uuid === "string" && _regex.default.test(uuid);
  };
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = undefined;
  var _regex = _interopRequireDefault(require_regex());
  var _default = validate;
  exports.default = _default;
});

// node_modules/uuid/dist/stringify.js
var require_stringify = __commonJS((exports) => {
  var _interopRequireDefault = function(obj) {
    return obj && obj.__esModule ? obj : { default: obj };
  };
  var unsafeStringify = function(arr, offset = 0) {
    return byteToHex[arr[offset + 0]] + byteToHex[arr[offset + 1]] + byteToHex[arr[offset + 2]] + byteToHex[arr[offset + 3]] + "-" + byteToHex[arr[offset + 4]] + byteToHex[arr[offset + 5]] + "-" + byteToHex[arr[offset + 6]] + byteToHex[arr[offset + 7]] + "-" + byteToHex[arr[offset + 8]] + byteToHex[arr[offset + 9]] + "-" + byteToHex[arr[offset + 10]] + byteToHex[arr[offset + 11]] + byteToHex[arr[offset + 12]] + byteToHex[arr[offset + 13]] + byteToHex[arr[offset + 14]] + byteToHex[arr[offset + 15]];
  };
  var stringify = function(arr, offset = 0) {
    const uuid = unsafeStringify(arr, offset);
    if (!(0, _validate.default)(uuid)) {
      throw TypeError("Stringified UUID is invalid");
    }
    return uuid;
  };
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = undefined;
  exports.unsafeStringify = unsafeStringify;
  var _validate = _interopRequireDefault(require_validate());
  var byteToHex = [];
  for (let i = 0;i < 256; ++i) {
    byteToHex.push((i + 256).toString(16).slice(1));
  }
  var _default = stringify;
  exports.default = _default;
});

// node_modules/uuid/dist/v1.js
var require_v1 = __commonJS((exports) => {
  var _interopRequireDefault = function(obj) {
    return obj && obj.__esModule ? obj : { default: obj };
  };
  var v1 = function(options, buf, offset) {
    let i = buf && offset || 0;
    const b = buf || new Array(16);
    options = options || {};
    let node4 = options.node || _nodeId;
    let clockseq = options.clockseq !== undefined ? options.clockseq : _clockseq;
    if (node4 == null || clockseq == null) {
      const seedBytes = options.random || (options.rng || _rng.default)();
      if (node4 == null) {
        node4 = _nodeId = [seedBytes[0] | 1, seedBytes[1], seedBytes[2], seedBytes[3], seedBytes[4], seedBytes[5]];
      }
      if (clockseq == null) {
        clockseq = _clockseq = (seedBytes[6] << 8 | seedBytes[7]) & 16383;
      }
    }
    let msecs = options.msecs !== undefined ? options.msecs : Date.now();
    let nsecs = options.nsecs !== undefined ? options.nsecs : _lastNSecs + 1;
    const dt = msecs - _lastMSecs + (nsecs - _lastNSecs) / 1e4;
    if (dt < 0 && options.clockseq === undefined) {
      clockseq = clockseq + 1 & 16383;
    }
    if ((dt < 0 || msecs > _lastMSecs) && options.nsecs === undefined) {
      nsecs = 0;
    }
    if (nsecs >= 1e4) {
      throw new Error("uuid.v1(): Can't create more than 10M uuids/sec");
    }
    _lastMSecs = msecs;
    _lastNSecs = nsecs;
    _clockseq = clockseq;
    msecs += 12219292800000;
    const tl = ((msecs & 268435455) * 1e4 + nsecs) % 4294967296;
    b[i++] = tl >>> 24 & 255;
    b[i++] = tl >>> 16 & 255;
    b[i++] = tl >>> 8 & 255;
    b[i++] = tl & 255;
    const tmh = msecs / 4294967296 * 1e4 & 268435455;
    b[i++] = tmh >>> 8 & 255;
    b[i++] = tmh & 255;
    b[i++] = tmh >>> 24 & 15 | 16;
    b[i++] = tmh >>> 16 & 255;
    b[i++] = clockseq >>> 8 | 128;
    b[i++] = clockseq & 255;
    for (let n = 0;n < 6; ++n) {
      b[i + n] = node4[n];
    }
    return buf || (0, _stringify.unsafeStringify)(b);
  };
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = undefined;
  var _rng = _interopRequireDefault(require_rng());
  var _stringify = require_stringify();
  var _nodeId;
  var _clockseq;
  var _lastMSecs = 0;
  var _lastNSecs = 0;
  var _default = v1;
  exports.default = _default;
});

// node_modules/uuid/dist/parse.js
var require_parse = __commonJS((exports) => {
  var _interopRequireDefault = function(obj) {
    return obj && obj.__esModule ? obj : { default: obj };
  };
  var parse2 = function(uuid) {
    if (!(0, _validate.default)(uuid)) {
      throw TypeError("Invalid UUID");
    }
    let v;
    const arr = new Uint8Array(16);
    arr[0] = (v = parseInt(uuid.slice(0, 8), 16)) >>> 24;
    arr[1] = v >>> 16 & 255;
    arr[2] = v >>> 8 & 255;
    arr[3] = v & 255;
    arr[4] = (v = parseInt(uuid.slice(9, 13), 16)) >>> 8;
    arr[5] = v & 255;
    arr[6] = (v = parseInt(uuid.slice(14, 18), 16)) >>> 8;
    arr[7] = v & 255;
    arr[8] = (v = parseInt(uuid.slice(19, 23), 16)) >>> 8;
    arr[9] = v & 255;
    arr[10] = (v = parseInt(uuid.slice(24, 36), 16)) / 1099511627776 & 255;
    arr[11] = v / 4294967296 & 255;
    arr[12] = v >>> 24 & 255;
    arr[13] = v >>> 16 & 255;
    arr[14] = v >>> 8 & 255;
    arr[15] = v & 255;
    return arr;
  };
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = undefined;
  var _validate = _interopRequireDefault(require_validate());
  var _default = parse2;
  exports.default = _default;
});

// node_modules/uuid/dist/v35.js
var require_v35 = __commonJS((exports) => {
  var _interopRequireDefault = function(obj) {
    return obj && obj.__esModule ? obj : { default: obj };
  };
  var stringToBytes = function(str) {
    str = unescape(encodeURIComponent(str));
    const bytes = [];
    for (let i = 0;i < str.length; ++i) {
      bytes.push(str.charCodeAt(i));
    }
    return bytes;
  };
  var v35 = function(name, version, hashfunc) {
    function generateUUID(value, namespace, buf, offset) {
      var _namespace;
      if (typeof value === "string") {
        value = stringToBytes(value);
      }
      if (typeof namespace === "string") {
        namespace = (0, _parse.default)(namespace);
      }
      if (((_namespace = namespace) === null || _namespace === undefined ? undefined : _namespace.length) !== 16) {
        throw TypeError("Namespace must be array-like (16 iterable integer values, 0-255)");
      }
      let bytes = new Uint8Array(16 + value.length);
      bytes.set(namespace);
      bytes.set(value, namespace.length);
      bytes = hashfunc(bytes);
      bytes[6] = bytes[6] & 15 | version;
      bytes[8] = bytes[8] & 63 | 128;
      if (buf) {
        offset = offset || 0;
        for (let i = 0;i < 16; ++i) {
          buf[offset + i] = bytes[i];
        }
        return buf;
      }
      return (0, _stringify.unsafeStringify)(bytes);
    }
    try {
      generateUUID.name = name;
    } catch (err) {
    }
    generateUUID.DNS = DNS;
    generateUUID.URL = URL2;
    return generateUUID;
  };
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.URL = exports.DNS = undefined;
  exports.default = v35;
  var _stringify = require_stringify();
  var _parse = _interopRequireDefault(require_parse());
  var DNS = "6ba7b810-9dad-11d1-80b4-00c04fd430c8";
  exports.DNS = DNS;
  var URL2 = "6ba7b811-9dad-11d1-80b4-00c04fd430c8";
  exports.URL = URL2;
});

// node_modules/uuid/dist/md5.js
var require_md5 = __commonJS((exports) => {
  var _interopRequireDefault = function(obj) {
    return obj && obj.__esModule ? obj : { default: obj };
  };
  var md5 = function(bytes) {
    if (Array.isArray(bytes)) {
      bytes = Buffer.from(bytes);
    } else if (typeof bytes === "string") {
      bytes = Buffer.from(bytes, "utf8");
    }
    return _crypto.default.createHash("md5").update(bytes).digest();
  };
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = undefined;
  var _crypto = _interopRequireDefault(__require("crypto"));
  var _default = md5;
  exports.default = _default;
});

// node_modules/uuid/dist/v3.js
var require_v3 = __commonJS((exports) => {
  var _interopRequireDefault = function(obj) {
    return obj && obj.__esModule ? obj : { default: obj };
  };
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = undefined;
  var _v = _interopRequireDefault(require_v35());
  var _md = _interopRequireDefault(require_md5());
  var v3 = (0, _v.default)("v3", 48, _md.default);
  var _default = v3;
  exports.default = _default;
});

// node_modules/uuid/dist/native.js
var require_native = __commonJS((exports) => {
  var _interopRequireDefault = function(obj) {
    return obj && obj.__esModule ? obj : { default: obj };
  };
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = undefined;
  var _crypto = _interopRequireDefault(__require("crypto"));
  var _default = {
    randomUUID: _crypto.default.randomUUID
  };
  exports.default = _default;
});

// node_modules/uuid/dist/v4.js
var require_v4 = __commonJS((exports) => {
  var _interopRequireDefault = function(obj) {
    return obj && obj.__esModule ? obj : { default: obj };
  };
  var v4 = function(options, buf, offset) {
    if (_native.default.randomUUID && !buf && !options) {
      return _native.default.randomUUID();
    }
    options = options || {};
    const rnds = options.random || (options.rng || _rng.default)();
    rnds[6] = rnds[6] & 15 | 64;
    rnds[8] = rnds[8] & 63 | 128;
    if (buf) {
      offset = offset || 0;
      for (let i = 0;i < 16; ++i) {
        buf[offset + i] = rnds[i];
      }
      return buf;
    }
    return (0, _stringify.unsafeStringify)(rnds);
  };
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = undefined;
  var _native = _interopRequireDefault(require_native());
  var _rng = _interopRequireDefault(require_rng());
  var _stringify = require_stringify();
  var _default = v4;
  exports.default = _default;
});

// node_modules/uuid/dist/sha1.js
var require_sha1 = __commonJS((exports) => {
  var _interopRequireDefault = function(obj) {
    return obj && obj.__esModule ? obj : { default: obj };
  };
  var sha1 = function(bytes) {
    if (Array.isArray(bytes)) {
      bytes = Buffer.from(bytes);
    } else if (typeof bytes === "string") {
      bytes = Buffer.from(bytes, "utf8");
    }
    return _crypto.default.createHash("sha1").update(bytes).digest();
  };
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = undefined;
  var _crypto = _interopRequireDefault(__require("crypto"));
  var _default = sha1;
  exports.default = _default;
});

// node_modules/uuid/dist/v5.js
var require_v5 = __commonJS((exports) => {
  var _interopRequireDefault = function(obj) {
    return obj && obj.__esModule ? obj : { default: obj };
  };
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = undefined;
  var _v = _interopRequireDefault(require_v35());
  var _sha = _interopRequireDefault(require_sha1());
  var v5 = (0, _v.default)("v5", 80, _sha.default);
  var _default = v5;
  exports.default = _default;
});

// node_modules/uuid/dist/nil.js
var require_nil = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = undefined;
  var _default = "00000000-0000-0000-0000-000000000000";
  exports.default = _default;
});

// node_modules/uuid/dist/version.js
var require_version = __commonJS((exports) => {
  var _interopRequireDefault = function(obj) {
    return obj && obj.__esModule ? obj : { default: obj };
  };
  var version = function(uuid) {
    if (!(0, _validate.default)(uuid)) {
      throw TypeError("Invalid UUID");
    }
    return parseInt(uuid.slice(14, 15), 16);
  };
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = undefined;
  var _validate = _interopRequireDefault(require_validate());
  var _default = version;
  exports.default = _default;
});

// node_modules/uuid/dist/index.js
var require_dist = __commonJS((exports) => {
  var _interopRequireDefault = function(obj) {
    return obj && obj.__esModule ? obj : { default: obj };
  };
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  Object.defineProperty(exports, "NIL", {
    enumerable: true,
    get: function() {
      return _nil.default;
    }
  });
  Object.defineProperty(exports, "parse", {
    enumerable: true,
    get: function() {
      return _parse.default;
    }
  });
  Object.defineProperty(exports, "stringify", {
    enumerable: true,
    get: function() {
      return _stringify.default;
    }
  });
  Object.defineProperty(exports, "v1", {
    enumerable: true,
    get: function() {
      return _v.default;
    }
  });
  Object.defineProperty(exports, "v3", {
    enumerable: true,
    get: function() {
      return _v2.default;
    }
  });
  Object.defineProperty(exports, "v4", {
    enumerable: true,
    get: function() {
      return _v3.default;
    }
  });
  Object.defineProperty(exports, "v5", {
    enumerable: true,
    get: function() {
      return _v4.default;
    }
  });
  Object.defineProperty(exports, "validate", {
    enumerable: true,
    get: function() {
      return _validate.default;
    }
  });
  Object.defineProperty(exports, "version", {
    enumerable: true,
    get: function() {
      return _version.default;
    }
  });
  var _v = _interopRequireDefault(require_v1());
  var _v2 = _interopRequireDefault(require_v3());
  var _v3 = _interopRequireDefault(require_v4());
  var _v4 = _interopRequireDefault(require_v5());
  var _nil = _interopRequireDefault(require_nil());
  var _version = _interopRequireDefault(require_version());
  var _validate = _interopRequireDefault(require_validate());
  var _stringify = _interopRequireDefault(require_stringify());
  var _parse = _interopRequireDefault(require_parse());
});

// node_modules/celery-node/node_modules/uuid/lib/rng.js
var require_rng2 = __commonJS((exports, module) => {
  var crypto6 = __require("crypto");
  module.exports = function nodeRNG() {
    return crypto6.randomBytes(16);
  };
});

// node_modules/celery-node/node_modules/uuid/lib/bytesToUuid.js
var require_bytesToUuid = __commonJS((exports, module) => {
  var bytesToUuid = function(buf, offset) {
    var i2 = offset || 0;
    var bth = byteToHex;
    return [
      bth[buf[i2++]],
      bth[buf[i2++]],
      bth[buf[i2++]],
      bth[buf[i2++]],
      "-",
      bth[buf[i2++]],
      bth[buf[i2++]],
      "-",
      bth[buf[i2++]],
      bth[buf[i2++]],
      "-",
      bth[buf[i2++]],
      bth[buf[i2++]],
      "-",
      bth[buf[i2++]],
      bth[buf[i2++]],
      bth[buf[i2++]],
      bth[buf[i2++]],
      bth[buf[i2++]],
      bth[buf[i2++]]
    ].join("");
  };
  var byteToHex = [];
  for (i = 0;i < 256; ++i) {
    byteToHex[i] = (i + 256).toString(16).substr(1);
  }
  var i;
  module.exports = bytesToUuid;
});

// node_modules/celery-node/node_modules/uuid/v1.js
var require_v12 = __commonJS((exports, module) => {
  var v12 = function(options, buf, offset) {
    var i = buf && offset || 0;
    var b2 = buf || [];
    options = options || {};
    var node4 = options.node || _nodeId;
    var clockseq = options.clockseq !== undefined ? options.clockseq : _clockseq;
    if (node4 == null || clockseq == null) {
      var seedBytes = rng();
      if (node4 == null) {
        node4 = _nodeId = [
          seedBytes[0] | 1,
          seedBytes[1],
          seedBytes[2],
          seedBytes[3],
          seedBytes[4],
          seedBytes[5]
        ];
      }
      if (clockseq == null) {
        clockseq = _clockseq = (seedBytes[6] << 8 | seedBytes[7]) & 16383;
      }
    }
    var msecs = options.msecs !== undefined ? options.msecs : new Date().getTime();
    var nsecs = options.nsecs !== undefined ? options.nsecs : _lastNSecs + 1;
    var dt = msecs - _lastMSecs + (nsecs - _lastNSecs) / 1e4;
    if (dt < 0 && options.clockseq === undefined) {
      clockseq = clockseq + 1 & 16383;
    }
    if ((dt < 0 || msecs > _lastMSecs) && options.nsecs === undefined) {
      nsecs = 0;
    }
    if (nsecs >= 1e4) {
      throw new Error("uuid.v1(): Can\'t create more than 10M uuids/sec");
    }
    _lastMSecs = msecs;
    _lastNSecs = nsecs;
    _clockseq = clockseq;
    msecs += 12219292800000;
    var tl = ((msecs & 268435455) * 1e4 + nsecs) % 4294967296;
    b2[i++] = tl >>> 24 & 255;
    b2[i++] = tl >>> 16 & 255;
    b2[i++] = tl >>> 8 & 255;
    b2[i++] = tl & 255;
    var tmh = msecs / 4294967296 * 1e4 & 268435455;
    b2[i++] = tmh >>> 8 & 255;
    b2[i++] = tmh & 255;
    b2[i++] = tmh >>> 24 & 15 | 16;
    b2[i++] = tmh >>> 16 & 255;
    b2[i++] = clockseq >>> 8 | 128;
    b2[i++] = clockseq & 255;
    for (var n = 0;n < 6; ++n) {
      b2[i + n] = node4[n];
    }
    return buf ? buf : bytesToUuid(b2);
  };
  var rng = require_rng2();
  var bytesToUuid = require_bytesToUuid();
  var _nodeId;
  var _clockseq;
  var _lastMSecs = 0;
  var _lastNSecs = 0;
  module.exports = v12;
});

// node_modules/celery-node/node_modules/uuid/v4.js
var require_v42 = __commonJS((exports, module) => {
  var v42 = function(options, buf, offset) {
    var i = buf && offset || 0;
    if (typeof options == "string") {
      buf = options === "binary" ? new Array(16) : null;
      options = null;
    }
    options = options || {};
    var rnds = options.random || (options.rng || rng)();
    rnds[6] = rnds[6] & 15 | 64;
    rnds[8] = rnds[8] & 63 | 128;
    if (buf) {
      for (var ii = 0;ii < 16; ++ii) {
        buf[i + ii] = rnds[ii];
      }
    }
    return buf || bytesToUuid(rnds);
  };
  var rng = require_rng2();
  var bytesToUuid = require_bytesToUuid();
  module.exports = v42;
});

// node_modules/celery-node/node_modules/uuid/index.js
var require_uuid = __commonJS((exports, module) => {
  var v12 = require_v12();
  var v42 = require_v42();
  var uuid2 = v42;
  uuid2.v1 = v12;
  uuid2.v4 = v42;
  module.exports = uuid2;
});

// node_modules/celery-node/dist/app/conf.js
var require_conf = __commonJS((exports) => {
  var cloneObject = function(obj) {
    const clone = {};
    for (const i in obj) {
      if (typeof obj[i] == "object" && obj[i] != null)
        clone[i] = cloneObject(obj[i]);
      else
        clone[i] = obj[i];
    }
    return clone;
  };
  var defaultConf = function() {
    return cloneObject(DEFAULT_CELERY_CONF);
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.defaultConf = undefined;
  var DEFAULT_CELERY_CONF = {
    CELERY_BROKER: "amqp://",
    CELERY_BROKER_OPTIONS: {},
    CELERY_BACKEND: "amqp://",
    CELERY_BACKEND_OPTIONS: {},
    CELERY_QUEUE: "celery",
    TASK_PROTOCOL: 2
  };
  exports.defaultConf = defaultConf;
});

// node_modules/lodash.defaults/index.js
var require_lodash = __commonJS((exports, module) => {
  var apply = function(func, thisArg, args) {
    switch (args.length) {
      case 0:
        return func.call(thisArg);
      case 1:
        return func.call(thisArg, args[0]);
      case 2:
        return func.call(thisArg, args[0], args[1]);
      case 3:
        return func.call(thisArg, args[0], args[1], args[2]);
    }
    return func.apply(thisArg, args);
  };
  var baseTimes = function(n, iteratee) {
    var index = -1, result2 = Array(n);
    while (++index < n) {
      result2[index] = iteratee(index);
    }
    return result2;
  };
  var arrayLikeKeys = function(value, inherited) {
    var result2 = isArray(value) || isArguments(value) ? baseTimes(value.length, String) : [];
    var length = result2.length, skipIndexes = !!length;
    for (var key in value) {
      if ((inherited || hasOwnProperty.call(value, key)) && !(skipIndexes && (key == "length" || isIndex(key, length)))) {
        result2.push(key);
      }
    }
    return result2;
  };
  var assignInDefaults = function(objValue, srcValue, key, object) {
    if (objValue === undefined || eq(objValue, objectProto[key]) && !hasOwnProperty.call(object, key)) {
      return srcValue;
    }
    return objValue;
  };
  var assignValue = function(object, key, value) {
    var objValue = object[key];
    if (!(hasOwnProperty.call(object, key) && eq(objValue, value)) || value === undefined && !(key in object)) {
      object[key] = value;
    }
  };
  var baseKeysIn = function(object) {
    if (!isObject2(object)) {
      return nativeKeysIn(object);
    }
    var isProto = isPrototype(object), result2 = [];
    for (var key in object) {
      if (!(key == "constructor" && (isProto || !hasOwnProperty.call(object, key)))) {
        result2.push(key);
      }
    }
    return result2;
  };
  var baseRest = function(func, start) {
    start = nativeMax(start === undefined ? func.length - 1 : start, 0);
    return function() {
      var args = arguments, index = -1, length = nativeMax(args.length - start, 0), array = Array(length);
      while (++index < length) {
        array[index] = args[start + index];
      }
      index = -1;
      var otherArgs = Array(start + 1);
      while (++index < start) {
        otherArgs[index] = args[index];
      }
      otherArgs[start] = array;
      return apply(func, this, otherArgs);
    };
  };
  var copyObject = function(source, props, object, customizer) {
    object || (object = {});
    var index = -1, length = props.length;
    while (++index < length) {
      var key = props[index];
      var newValue = customizer ? customizer(object[key], source[key], key, object, source) : undefined;
      assignValue(object, key, newValue === undefined ? source[key] : newValue);
    }
    return object;
  };
  var createAssigner = function(assigner) {
    return baseRest(function(object, sources) {
      var index = -1, length = sources.length, customizer = length > 1 ? sources[length - 1] : undefined, guard = length > 2 ? sources[2] : undefined;
      customizer = assigner.length > 3 && typeof customizer == "function" ? (length--, customizer) : undefined;
      if (guard && isIterateeCall(sources[0], sources[1], guard)) {
        customizer = length < 3 ? undefined : customizer;
        length = 1;
      }
      object = Object(object);
      while (++index < length) {
        var source = sources[index];
        if (source) {
          assigner(object, source, index, customizer);
        }
      }
      return object;
    });
  };
  var isIndex = function(value, length) {
    length = length == null ? MAX_SAFE_INTEGER : length;
    return !!length && (typeof value == "number" || reIsUint.test(value)) && (value > -1 && value % 1 == 0 && value < length);
  };
  var isIterateeCall = function(value, index, object) {
    if (!isObject2(object)) {
      return false;
    }
    var type = typeof index;
    if (type == "number" ? isArrayLike(object) && isIndex(index, object.length) : type == "string" && (index in object)) {
      return eq(object[index], value);
    }
    return false;
  };
  var isPrototype = function(value) {
    var Ctor = value && value.constructor, proto = typeof Ctor == "function" && Ctor.prototype || objectProto;
    return value === proto;
  };
  var nativeKeysIn = function(object) {
    var result2 = [];
    if (object != null) {
      for (var key in Object(object)) {
        result2.push(key);
      }
    }
    return result2;
  };
  var eq = function(value, other) {
    return value === other || value !== value && other !== other;
  };
  var isArguments = function(value) {
    return isArrayLikeObject(value) && hasOwnProperty.call(value, "callee") && (!propertyIsEnumerable.call(value, "callee") || objectToString.call(value) == argsTag);
  };
  var isArrayLike = function(value) {
    return value != null && isLength(value.length) && !isFunction(value);
  };
  var isArrayLikeObject = function(value) {
    return isObjectLike2(value) && isArrayLike(value);
  };
  var isFunction = function(value) {
    var tag = isObject2(value) ? objectToString.call(value) : "";
    return tag == funcTag || tag == genTag;
  };
  var isLength = function(value) {
    return typeof value == "number" && value > -1 && value % 1 == 0 && value <= MAX_SAFE_INTEGER;
  };
  var isObject2 = function(value) {
    var type = typeof value;
    return !!value && (type == "object" || type == "function");
  };
  var isObjectLike2 = function(value) {
    return !!value && typeof value == "object";
  };
  var keysIn = function(object) {
    return isArrayLike(object) ? arrayLikeKeys(object, true) : baseKeysIn(object);
  };
  var MAX_SAFE_INTEGER = 9007199254740991;
  var argsTag = "[object Arguments]";
  var funcTag = "[object Function]";
  var genTag = "[object GeneratorFunction]";
  var reIsUint = /^(?:0|[1-9]\d*)$/;
  var objectProto = Object.prototype;
  var hasOwnProperty = objectProto.hasOwnProperty;
  var objectToString = objectProto.toString;
  var propertyIsEnumerable = objectProto.propertyIsEnumerable;
  var nativeMax = Math.max;
  var isArray = Array.isArray;
  var assignInWith = createAssigner(function(object, source, srcIndex, customizer) {
    copyObject(source, keysIn(source), object, customizer);
  });
  var defaults = baseRest(function(args) {
    args.push(undefined, assignInDefaults);
    return apply(assignInWith, undefined, args);
  });
  module.exports = defaults;
});

// node_modules/lodash.flatten/index.js
var require_lodash2 = __commonJS((exports, module) => {
  var arrayPush = function(array, values2) {
    var index = -1, length = values2.length, offset = array.length;
    while (++index < length) {
      array[offset + index] = values2[index];
    }
    return array;
  };
  var baseFlatten = function(array, depth, predicate, isStrict, result2) {
    var index = -1, length = array.length;
    predicate || (predicate = isFlattenable);
    result2 || (result2 = []);
    while (++index < length) {
      var value = array[index];
      if (depth > 0 && predicate(value)) {
        if (depth > 1) {
          baseFlatten(value, depth - 1, predicate, isStrict, result2);
        } else {
          arrayPush(result2, value);
        }
      } else if (!isStrict) {
        result2[result2.length] = value;
      }
    }
    return result2;
  };
  var isFlattenable = function(value) {
    return isArray(value) || isArguments(value) || !!(spreadableSymbol && value && value[spreadableSymbol]);
  };
  var flatten = function(array) {
    var length = array ? array.length : 0;
    return length ? baseFlatten(array, 1) : [];
  };
  var isArguments = function(value) {
    return isArrayLikeObject(value) && hasOwnProperty.call(value, "callee") && (!propertyIsEnumerable.call(value, "callee") || objectToString.call(value) == argsTag);
  };
  var isArrayLike = function(value) {
    return value != null && isLength(value.length) && !isFunction(value);
  };
  var isArrayLikeObject = function(value) {
    return isObjectLike2(value) && isArrayLike(value);
  };
  var isFunction = function(value) {
    var tag = isObject2(value) ? objectToString.call(value) : "";
    return tag == funcTag || tag == genTag;
  };
  var isLength = function(value) {
    return typeof value == "number" && value > -1 && value % 1 == 0 && value <= MAX_SAFE_INTEGER;
  };
  var isObject2 = function(value) {
    var type = typeof value;
    return !!value && (type == "object" || type == "function");
  };
  var isObjectLike2 = function(value) {
    return !!value && typeof value == "object";
  };
  var MAX_SAFE_INTEGER = 9007199254740991;
  var argsTag = "[object Arguments]";
  var funcTag = "[object Function]";
  var genTag = "[object GeneratorFunction]";
  var freeGlobal = typeof global == "object" && global && global.Object === Object && global;
  var freeSelf = typeof self == "object" && self && self.Object === Object && self;
  var root = freeGlobal || freeSelf || Function("return this")();
  var objectProto = Object.prototype;
  var hasOwnProperty = objectProto.hasOwnProperty;
  var objectToString = objectProto.toString;
  var Symbol2 = root.Symbol;
  var propertyIsEnumerable = objectProto.propertyIsEnumerable;
  var spreadableSymbol = Symbol2 ? Symbol2.isConcatSpreadable : undefined;
  var isArray = Array.isArray;
  module.exports = flatten;
});

// node_modules/lodash.isarguments/index.js
var require_lodash3 = __commonJS((exports, module) => {
  var isArguments = function(value) {
    return isArrayLikeObject(value) && hasOwnProperty.call(value, "callee") && (!propertyIsEnumerable.call(value, "callee") || objectToString.call(value) == argsTag);
  };
  var isArrayLike = function(value) {
    return value != null && isLength(value.length) && !isFunction(value);
  };
  var isArrayLikeObject = function(value) {
    return isObjectLike2(value) && isArrayLike(value);
  };
  var isFunction = function(value) {
    var tag = isObject2(value) ? objectToString.call(value) : "";
    return tag == funcTag || tag == genTag;
  };
  var isLength = function(value) {
    return typeof value == "number" && value > -1 && value % 1 == 0 && value <= MAX_SAFE_INTEGER;
  };
  var isObject2 = function(value) {
    var type = typeof value;
    return !!value && (type == "object" || type == "function");
  };
  var isObjectLike2 = function(value) {
    return !!value && typeof value == "object";
  };
  var MAX_SAFE_INTEGER = 9007199254740991;
  var argsTag = "[object Arguments]";
  var funcTag = "[object Function]";
  var genTag = "[object GeneratorFunction]";
  var objectProto = Object.prototype;
  var hasOwnProperty = objectProto.hasOwnProperty;
  var objectToString = objectProto.toString;
  var propertyIsEnumerable = objectProto.propertyIsEnumerable;
  module.exports = isArguments;
});

// node_modules/ioredis/built/utils/lodash.js
var require_lodash4 = __commonJS((exports) => {
  var noop3 = function() {
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  var defaults = require_lodash();
  exports.defaults = defaults;
  var flatten = require_lodash2();
  exports.flatten = flatten;
  var isArguments = require_lodash3();
  exports.isArguments = isArguments;
  exports.noop = noop3;
});

// node_modules/denque/index.js
var require_denque = __commonJS((exports, module) => {
  var Denque = function(array, options) {
    var options = options || {};
    this._head = 0;
    this._tail = 0;
    this._capacity = options.capacity;
    this._capacityMask = 3;
    this._list = new Array(4);
    if (Array.isArray(array)) {
      this._fromArray(array);
    }
  };
  Denque.prototype.peekAt = function peekAt(index) {
    var i = index;
    if (i !== (i | 0)) {
      return;
    }
    var len = this.size();
    if (i >= len || i < -len)
      return;
    if (i < 0)
      i += len;
    i = this._head + i & this._capacityMask;
    return this._list[i];
  };
  Denque.prototype.get = function get(i) {
    return this.peekAt(i);
  };
  Denque.prototype.peek = function peek() {
    if (this._head === this._tail)
      return;
    return this._list[this._head];
  };
  Denque.prototype.peekFront = function peekFront() {
    return this.peek();
  };
  Denque.prototype.peekBack = function peekBack() {
    return this.peekAt(-1);
  };
  Object.defineProperty(Denque.prototype, "length", {
    get: function length() {
      return this.size();
    }
  });
  Denque.prototype.size = function size() {
    if (this._head === this._tail)
      return 0;
    if (this._head < this._tail)
      return this._tail - this._head;
    else
      return this._capacityMask + 1 - (this._head - this._tail);
  };
  Denque.prototype.unshift = function unshift(item) {
    if (item === undefined)
      return this.size();
    var len = this._list.length;
    this._head = this._head - 1 + len & this._capacityMask;
    this._list[this._head] = item;
    if (this._tail === this._head)
      this._growArray();
    if (this._capacity && this.size() > this._capacity)
      this.pop();
    if (this._head < this._tail)
      return this._tail - this._head;
    else
      return this._capacityMask + 1 - (this._head - this._tail);
  };
  Denque.prototype.shift = function shift() {
    var head = this._head;
    if (head === this._tail)
      return;
    var item = this._list[head];
    this._list[head] = undefined;
    this._head = head + 1 & this._capacityMask;
    if (head < 2 && this._tail > 1e4 && this._tail <= this._list.length >>> 2)
      this._shrinkArray();
    return item;
  };
  Denque.prototype.push = function push(item) {
    if (item === undefined)
      return this.size();
    var tail = this._tail;
    this._list[tail] = item;
    this._tail = tail + 1 & this._capacityMask;
    if (this._tail === this._head) {
      this._growArray();
    }
    if (this._capacity && this.size() > this._capacity) {
      this.shift();
    }
    if (this._head < this._tail)
      return this._tail - this._head;
    else
      return this._capacityMask + 1 - (this._head - this._tail);
  };
  Denque.prototype.pop = function pop() {
    var tail = this._tail;
    if (tail === this._head)
      return;
    var len = this._list.length;
    this._tail = tail - 1 + len & this._capacityMask;
    var item = this._list[this._tail];
    this._list[this._tail] = undefined;
    if (this._head < 2 && tail > 1e4 && tail <= len >>> 2)
      this._shrinkArray();
    return item;
  };
  Denque.prototype.removeOne = function removeOne(index) {
    var i = index;
    if (i !== (i | 0)) {
      return;
    }
    if (this._head === this._tail)
      return;
    var size2 = this.size();
    var len = this._list.length;
    if (i >= size2 || i < -size2)
      return;
    if (i < 0)
      i += size2;
    i = this._head + i & this._capacityMask;
    var item = this._list[i];
    var k;
    if (index < size2 / 2) {
      for (k = index;k > 0; k--) {
        this._list[i] = this._list[i = i - 1 + len & this._capacityMask];
      }
      this._list[i] = undefined;
      this._head = this._head + 1 + len & this._capacityMask;
    } else {
      for (k = size2 - 1 - index;k > 0; k--) {
        this._list[i] = this._list[i = i + 1 + len & this._capacityMask];
      }
      this._list[i] = undefined;
      this._tail = this._tail - 1 + len & this._capacityMask;
    }
    return item;
  };
  Denque.prototype.remove = function remove(index, count) {
    var i = index;
    var removed;
    var del_count = count;
    if (i !== (i | 0)) {
      return;
    }
    if (this._head === this._tail)
      return;
    var size2 = this.size();
    var len = this._list.length;
    if (i >= size2 || i < -size2 || count < 1)
      return;
    if (i < 0)
      i += size2;
    if (count === 1 || !count) {
      removed = new Array(1);
      removed[0] = this.removeOne(i);
      return removed;
    }
    if (i === 0 && i + count >= size2) {
      removed = this.toArray();
      this.clear();
      return removed;
    }
    if (i + count > size2)
      count = size2 - i;
    var k;
    removed = new Array(count);
    for (k = 0;k < count; k++) {
      removed[k] = this._list[this._head + i + k & this._capacityMask];
    }
    i = this._head + i & this._capacityMask;
    if (index + count === size2) {
      this._tail = this._tail - count + len & this._capacityMask;
      for (k = count;k > 0; k--) {
        this._list[i = i + 1 + len & this._capacityMask] = undefined;
      }
      return removed;
    }
    if (index === 0) {
      this._head = this._head + count + len & this._capacityMask;
      for (k = count - 1;k > 0; k--) {
        this._list[i = i + 1 + len & this._capacityMask] = undefined;
      }
      return removed;
    }
    if (i < size2 / 2) {
      this._head = this._head + index + count + len & this._capacityMask;
      for (k = index;k > 0; k--) {
        this.unshift(this._list[i = i - 1 + len & this._capacityMask]);
      }
      i = this._head - 1 + len & this._capacityMask;
      while (del_count > 0) {
        this._list[i = i - 1 + len & this._capacityMask] = undefined;
        del_count--;
      }
      if (index < 0)
        this._tail = i;
    } else {
      this._tail = i;
      i = i + count + len & this._capacityMask;
      for (k = size2 - (count + index);k > 0; k--) {
        this.push(this._list[i++]);
      }
      i = this._tail;
      while (del_count > 0) {
        this._list[i = i + 1 + len & this._capacityMask] = undefined;
        del_count--;
      }
    }
    if (this._head < 2 && this._tail > 1e4 && this._tail <= len >>> 2)
      this._shrinkArray();
    return removed;
  };
  Denque.prototype.splice = function splice(index, count) {
    var i = index;
    if (i !== (i | 0)) {
      return;
    }
    var size2 = this.size();
    if (i < 0)
      i += size2;
    if (i > size2)
      return;
    if (arguments.length > 2) {
      var k;
      var temp;
      var removed;
      var arg_len = arguments.length;
      var len = this._list.length;
      var arguments_index = 2;
      if (!size2 || i < size2 / 2) {
        temp = new Array(i);
        for (k = 0;k < i; k++) {
          temp[k] = this._list[this._head + k & this._capacityMask];
        }
        if (count === 0) {
          removed = [];
          if (i > 0) {
            this._head = this._head + i + len & this._capacityMask;
          }
        } else {
          removed = this.remove(i, count);
          this._head = this._head + i + len & this._capacityMask;
        }
        while (arg_len > arguments_index) {
          this.unshift(arguments[--arg_len]);
        }
        for (k = i;k > 0; k--) {
          this.unshift(temp[k - 1]);
        }
      } else {
        temp = new Array(size2 - (i + count));
        var leng = temp.length;
        for (k = 0;k < leng; k++) {
          temp[k] = this._list[this._head + i + count + k & this._capacityMask];
        }
        if (count === 0) {
          removed = [];
          if (i != size2) {
            this._tail = this._head + i + len & this._capacityMask;
          }
        } else {
          removed = this.remove(i, count);
          this._tail = this._tail - leng + len & this._capacityMask;
        }
        while (arguments_index < arg_len) {
          this.push(arguments[arguments_index++]);
        }
        for (k = 0;k < leng; k++) {
          this.push(temp[k]);
        }
      }
      return removed;
    } else {
      return this.remove(i, count);
    }
  };
  Denque.prototype.clear = function clear() {
    this._head = 0;
    this._tail = 0;
  };
  Denque.prototype.isEmpty = function isEmpty() {
    return this._head === this._tail;
  };
  Denque.prototype.toArray = function toArray() {
    return this._copyArray(false);
  };
  Denque.prototype._fromArray = function _fromArray(array) {
    for (var i = 0;i < array.length; i++)
      this.push(array[i]);
  };
  Denque.prototype._copyArray = function _copyArray(fullCopy) {
    var newArray = [];
    var list = this._list;
    var len = list.length;
    var i;
    if (fullCopy || this._head > this._tail) {
      for (i = this._head;i < len; i++)
        newArray.push(list[i]);
      for (i = 0;i < this._tail; i++)
        newArray.push(list[i]);
    } else {
      for (i = this._head;i < this._tail; i++)
        newArray.push(list[i]);
    }
    return newArray;
  };
  Denque.prototype._growArray = function _growArray() {
    if (this._head) {
      this._list = this._copyArray(true);
      this._head = 0;
    }
    this._tail = this._list.length;
    this._list.length <<= 1;
    this._capacityMask = this._capacityMask << 1 | 1;
  };
  Denque.prototype._shrinkArray = function _shrinkArray() {
    this._list.length >>>= 1;
    this._capacityMask >>>= 1;
  };
  module.exports = Denque;
});

// node_modules/redis-commands/commands.json
var require_commands = __commonJS((exports, module) => {
  module.exports = {
    acl: {
      arity: -2,
      flags: [
        "admin",
        "noscript",
        "loading",
        "stale",
        "skip_slowlog"
      ],
      keyStart: 0,
      keyStop: 0,
      step: 0
    },
    append: {
      arity: 3,
      flags: [
        "write",
        "denyoom",
        "fast"
      ],
      keyStart: 1,
      keyStop: 1,
      step: 1
    },
    asking: {
      arity: 1,
      flags: [
        "fast"
      ],
      keyStart: 0,
      keyStop: 0,
      step: 0
    },
    auth: {
      arity: -2,
      flags: [
        "noscript",
        "loading",
        "stale",
        "skip_monitor",
        "skip_slowlog",
        "fast",
        "no_auth"
      ],
      keyStart: 0,
      keyStop: 0,
      step: 0
    },
    bgrewriteaof: {
      arity: 1,
      flags: [
        "admin",
        "noscript"
      ],
      keyStart: 0,
      keyStop: 0,
      step: 0
    },
    bgsave: {
      arity: -1,
      flags: [
        "admin",
        "noscript"
      ],
      keyStart: 0,
      keyStop: 0,
      step: 0
    },
    bitcount: {
      arity: -2,
      flags: [
        "readonly"
      ],
      keyStart: 1,
      keyStop: 1,
      step: 1
    },
    bitfield: {
      arity: -2,
      flags: [
        "write",
        "denyoom"
      ],
      keyStart: 1,
      keyStop: 1,
      step: 1
    },
    bitfield_ro: {
      arity: -2,
      flags: [
        "readonly",
        "fast"
      ],
      keyStart: 1,
      keyStop: 1,
      step: 1
    },
    bitop: {
      arity: -4,
      flags: [
        "write",
        "denyoom"
      ],
      keyStart: 2,
      keyStop: -1,
      step: 1
    },
    bitpos: {
      arity: -3,
      flags: [
        "readonly"
      ],
      keyStart: 1,
      keyStop: 1,
      step: 1
    },
    blmove: {
      arity: 6,
      flags: [
        "write",
        "denyoom",
        "noscript"
      ],
      keyStart: 1,
      keyStop: 2,
      step: 1
    },
    blpop: {
      arity: -3,
      flags: [
        "write",
        "noscript"
      ],
      keyStart: 1,
      keyStop: -2,
      step: 1
    },
    brpop: {
      arity: -3,
      flags: [
        "write",
        "noscript"
      ],
      keyStart: 1,
      keyStop: -2,
      step: 1
    },
    brpoplpush: {
      arity: 4,
      flags: [
        "write",
        "denyoom",
        "noscript"
      ],
      keyStart: 1,
      keyStop: 2,
      step: 1
    },
    bzpopmax: {
      arity: -3,
      flags: [
        "write",
        "noscript",
        "fast"
      ],
      keyStart: 1,
      keyStop: -2,
      step: 1
    },
    bzpopmin: {
      arity: -3,
      flags: [
        "write",
        "noscript",
        "fast"
      ],
      keyStart: 1,
      keyStop: -2,
      step: 1
    },
    client: {
      arity: -2,
      flags: [
        "admin",
        "noscript",
        "random",
        "loading",
        "stale"
      ],
      keyStart: 0,
      keyStop: 0,
      step: 0
    },
    cluster: {
      arity: -2,
      flags: [
        "admin",
        "random",
        "stale"
      ],
      keyStart: 0,
      keyStop: 0,
      step: 0
    },
    command: {
      arity: -1,
      flags: [
        "random",
        "loading",
        "stale"
      ],
      keyStart: 0,
      keyStop: 0,
      step: 0
    },
    config: {
      arity: -2,
      flags: [
        "admin",
        "noscript",
        "loading",
        "stale"
      ],
      keyStart: 0,
      keyStop: 0,
      step: 0
    },
    copy: {
      arity: -3,
      flags: [
        "write",
        "denyoom"
      ],
      keyStart: 1,
      keyStop: 2,
      step: 1
    },
    dbsize: {
      arity: 1,
      flags: [
        "readonly",
        "fast"
      ],
      keyStart: 0,
      keyStop: 0,
      step: 0
    },
    debug: {
      arity: -2,
      flags: [
        "admin",
        "noscript",
        "loading",
        "stale"
      ],
      keyStart: 0,
      keyStop: 0,
      step: 0
    },
    decr: {
      arity: 2,
      flags: [
        "write",
        "denyoom",
        "fast"
      ],
      keyStart: 1,
      keyStop: 1,
      step: 1
    },
    decrby: {
      arity: 3,
      flags: [
        "write",
        "denyoom",
        "fast"
      ],
      keyStart: 1,
      keyStop: 1,
      step: 1
    },
    del: {
      arity: -2,
      flags: [
        "write"
      ],
      keyStart: 1,
      keyStop: -1,
      step: 1
    },
    discard: {
      arity: 1,
      flags: [
        "noscript",
        "loading",
        "stale",
        "fast"
      ],
      keyStart: 0,
      keyStop: 0,
      step: 0
    },
    dump: {
      arity: 2,
      flags: [
        "readonly",
        "random"
      ],
      keyStart: 1,
      keyStop: 1,
      step: 1
    },
    echo: {
      arity: 2,
      flags: [
        "fast"
      ],
      keyStart: 0,
      keyStop: 0,
      step: 0
    },
    eval: {
      arity: -3,
      flags: [
        "noscript",
        "may_replicate",
        "movablekeys"
      ],
      keyStart: 0,
      keyStop: 0,
      step: 0
    },
    evalsha: {
      arity: -3,
      flags: [
        "noscript",
        "may_replicate",
        "movablekeys"
      ],
      keyStart: 0,
      keyStop: 0,
      step: 0
    },
    exec: {
      arity: 1,
      flags: [
        "noscript",
        "loading",
        "stale",
        "skip_monitor",
        "skip_slowlog"
      ],
      keyStart: 0,
      keyStop: 0,
      step: 0
    },
    exists: {
      arity: -2,
      flags: [
        "readonly",
        "fast"
      ],
      keyStart: 1,
      keyStop: -1,
      step: 1
    },
    expire: {
      arity: 3,
      flags: [
        "write",
        "fast"
      ],
      keyStart: 1,
      keyStop: 1,
      step: 1
    },
    expireat: {
      arity: 3,
      flags: [
        "write",
        "fast"
      ],
      keyStart: 1,
      keyStop: 1,
      step: 1
    },
    failover: {
      arity: -1,
      flags: [
        "admin",
        "noscript",
        "stale"
      ],
      keyStart: 0,
      keyStop: 0,
      step: 0
    },
    flushall: {
      arity: -1,
      flags: [
        "write"
      ],
      keyStart: 0,
      keyStop: 0,
      step: 0
    },
    flushdb: {
      arity: -1,
      flags: [
        "write"
      ],
      keyStart: 0,
      keyStop: 0,
      step: 0
    },
    geoadd: {
      arity: -5,
      flags: [
        "write",
        "denyoom"
      ],
      keyStart: 1,
      keyStop: 1,
      step: 1
    },
    geodist: {
      arity: -4,
      flags: [
        "readonly"
      ],
      keyStart: 1,
      keyStop: 1,
      step: 1
    },
    geohash: {
      arity: -2,
      flags: [
        "readonly"
      ],
      keyStart: 1,
      keyStop: 1,
      step: 1
    },
    geopos: {
      arity: -2,
      flags: [
        "readonly"
      ],
      keyStart: 1,
      keyStop: 1,
      step: 1
    },
    georadius: {
      arity: -6,
      flags: [
        "write",
        "denyoom",
        "movablekeys"
      ],
      keyStart: 1,
      keyStop: 1,
      step: 1
    },
    georadius_ro: {
      arity: -6,
      flags: [
        "readonly"
      ],
      keyStart: 1,
      keyStop: 1,
      step: 1
    },
    georadiusbymember: {
      arity: -5,
      flags: [
        "write",
        "denyoom",
        "movablekeys"
      ],
      keyStart: 1,
      keyStop: 1,
      step: 1
    },
    georadiusbymember_ro: {
      arity: -5,
      flags: [
        "readonly"
      ],
      keyStart: 1,
      keyStop: 1,
      step: 1
    },
    geosearch: {
      arity: -7,
      flags: [
        "readonly"
      ],
      keyStart: 1,
      keyStop: 1,
      step: 1
    },
    geosearchstore: {
      arity: -8,
      flags: [
        "write",
        "denyoom"
      ],
      keyStart: 1,
      keyStop: 2,
      step: 1
    },
    get: {
      arity: 2,
      flags: [
        "readonly",
        "fast"
      ],
      keyStart: 1,
      keyStop: 1,
      step: 1
    },
    getbit: {
      arity: 3,
      flags: [
        "readonly",
        "fast"
      ],
      keyStart: 1,
      keyStop: 1,
      step: 1
    },
    getdel: {
      arity: 2,
      flags: [
        "write",
        "fast"
      ],
      keyStart: 1,
      keyStop: 1,
      step: 1
    },
    getex: {
      arity: -2,
      flags: [
        "write",
        "fast"
      ],
      keyStart: 1,
      keyStop: 1,
      step: 1
    },
    getrange: {
      arity: 4,
      flags: [
        "readonly"
      ],
      keyStart: 1,
      keyStop: 1,
      step: 1
    },
    getset: {
      arity: 3,
      flags: [
        "write",
        "denyoom",
        "fast"
      ],
      keyStart: 1,
      keyStop: 1,
      step: 1
    },
    hdel: {
      arity: -3,
      flags: [
        "write",
        "fast"
      ],
      keyStart: 1,
      keyStop: 1,
      step: 1
    },
    hello: {
      arity: -1,
      flags: [
        "noscript",
        "loading",
        "stale",
        "skip_monitor",
        "skip_slowlog",
        "fast",
        "no_auth"
      ],
      keyStart: 0,
      keyStop: 0,
      step: 0
    },
    hexists: {
      arity: 3,
      flags: [
        "readonly",
        "fast"
      ],
      keyStart: 1,
      keyStop: 1,
      step: 1
    },
    hget: {
      arity: 3,
      flags: [
        "readonly",
        "fast"
      ],
      keyStart: 1,
      keyStop: 1,
      step: 1
    },
    hgetall: {
      arity: 2,
      flags: [
        "readonly",
        "random"
      ],
      keyStart: 1,
      keyStop: 1,
      step: 1
    },
    hincrby: {
      arity: 4,
      flags: [
        "write",
        "denyoom",
        "fast"
      ],
      keyStart: 1,
      keyStop: 1,
      step: 1
    },
    hincrbyfloat: {
      arity: 4,
      flags: [
        "write",
        "denyoom",
        "fast"
      ],
      keyStart: 1,
      keyStop: 1,
      step: 1
    },
    hkeys: {
      arity: 2,
      flags: [
        "readonly",
        "sort_for_script"
      ],
      keyStart: 1,
      keyStop: 1,
      step: 1
    },
    hlen: {
      arity: 2,
      flags: [
        "readonly",
        "fast"
      ],
      keyStart: 1,
      keyStop: 1,
      step: 1
    },
    hmget: {
      arity: -3,
      flags: [
        "readonly",
        "fast"
      ],
      keyStart: 1,
      keyStop: 1,
      step: 1
    },
    hmset: {
      arity: -4,
      flags: [
        "write",
        "denyoom",
        "fast"
      ],
      keyStart: 1,
      keyStop: 1,
      step: 1
    },
    "host:": {
      arity: -1,
      flags: [
        "readonly",
        "loading",
        "stale"
      ],
      keyStart: 0,
      keyStop: 0,
      step: 0
    },
    hrandfield: {
      arity: -2,
      flags: [
        "readonly",
        "random"
      ],
      keyStart: 1,
      keyStop: 1,
      step: 1
    },
    hscan: {
      arity: -3,
      flags: [
        "readonly",
        "random"
      ],
      keyStart: 1,
      keyStop: 1,
      step: 1
    },
    hset: {
      arity: -4,
      flags: [
        "write",
        "denyoom",
        "fast"
      ],
      keyStart: 1,
      keyStop: 1,
      step: 1
    },
    hsetnx: {
      arity: 4,
      flags: [
        "write",
        "denyoom",
        "fast"
      ],
      keyStart: 1,
      keyStop: 1,
      step: 1
    },
    hstrlen: {
      arity: 3,
      flags: [
        "readonly",
        "fast"
      ],
      keyStart: 1,
      keyStop: 1,
      step: 1
    },
    hvals: {
      arity: 2,
      flags: [
        "readonly",
        "sort_for_script"
      ],
      keyStart: 1,
      keyStop: 1,
      step: 1
    },
    incr: {
      arity: 2,
      flags: [
        "write",
        "denyoom",
        "fast"
      ],
      keyStart: 1,
      keyStop: 1,
      step: 1
    },
    incrby: {
      arity: 3,
      flags: [
        "write",
        "denyoom",
        "fast"
      ],
      keyStart: 1,
      keyStop: 1,
      step: 1
    },
    incrbyfloat: {
      arity: 3,
      flags: [
        "write",
        "denyoom",
        "fast"
      ],
      keyStart: 1,
      keyStop: 1,
      step: 1
    },
    info: {
      arity: -1,
      flags: [
        "random",
        "loading",
        "stale"
      ],
      keyStart: 0,
      keyStop: 0,
      step: 0
    },
    keys: {
      arity: 2,
      flags: [
        "readonly",
        "sort_for_script"
      ],
      keyStart: 0,
      keyStop: 0,
      step: 0
    },
    lastsave: {
      arity: 1,
      flags: [
        "random",
        "loading",
        "stale",
        "fast"
      ],
      keyStart: 0,
      keyStop: 0,
      step: 0
    },
    latency: {
      arity: -2,
      flags: [
        "admin",
        "noscript",
        "loading",
        "stale"
      ],
      keyStart: 0,
      keyStop: 0,
      step: 0
    },
    lindex: {
      arity: 3,
      flags: [
        "readonly"
      ],
      keyStart: 1,
      keyStop: 1,
      step: 1
    },
    linsert: {
      arity: 5,
      flags: [
        "write",
        "denyoom"
      ],
      keyStart: 1,
      keyStop: 1,
      step: 1
    },
    llen: {
      arity: 2,
      flags: [
        "readonly",
        "fast"
      ],
      keyStart: 1,
      keyStop: 1,
      step: 1
    },
    lmove: {
      arity: 5,
      flags: [
        "write",
        "denyoom"
      ],
      keyStart: 1,
      keyStop: 2,
      step: 1
    },
    lolwut: {
      arity: -1,
      flags: [
        "readonly",
        "fast"
      ],
      keyStart: 0,
      keyStop: 0,
      step: 0
    },
    lpop: {
      arity: -2,
      flags: [
        "write",
        "fast"
      ],
      keyStart: 1,
      keyStop: 1,
      step: 1
    },
    lpos: {
      arity: -3,
      flags: [
        "readonly"
      ],
      keyStart: 1,
      keyStop: 1,
      step: 1
    },
    lpush: {
      arity: -3,
      flags: [
        "write",
        "denyoom",
        "fast"
      ],
      keyStart: 1,
      keyStop: 1,
      step: 1
    },
    lpushx: {
      arity: -3,
      flags: [
        "write",
        "denyoom",
        "fast"
      ],
      keyStart: 1,
      keyStop: 1,
      step: 1
    },
    lrange: {
      arity: 4,
      flags: [
        "readonly"
      ],
      keyStart: 1,
      keyStop: 1,
      step: 1
    },
    lrem: {
      arity: 4,
      flags: [
        "write"
      ],
      keyStart: 1,
      keyStop: 1,
      step: 1
    },
    lset: {
      arity: 4,
      flags: [
        "write",
        "denyoom"
      ],
      keyStart: 1,
      keyStop: 1,
      step: 1
    },
    ltrim: {
      arity: 4,
      flags: [
        "write"
      ],
      keyStart: 1,
      keyStop: 1,
      step: 1
    },
    memory: {
      arity: -2,
      flags: [
        "readonly",
        "random",
        "movablekeys"
      ],
      keyStart: 0,
      keyStop: 0,
      step: 0
    },
    mget: {
      arity: -2,
      flags: [
        "readonly",
        "fast"
      ],
      keyStart: 1,
      keyStop: -1,
      step: 1
    },
    migrate: {
      arity: -6,
      flags: [
        "write",
        "random",
        "movablekeys"
      ],
      keyStart: 0,
      keyStop: 0,
      step: 0
    },
    module: {
      arity: -2,
      flags: [
        "admin",
        "noscript"
      ],
      keyStart: 0,
      keyStop: 0,
      step: 0
    },
    monitor: {
      arity: 1,
      flags: [
        "admin",
        "noscript",
        "loading",
        "stale"
      ],
      keyStart: 0,
      keyStop: 0,
      step: 0
    },
    move: {
      arity: 3,
      flags: [
        "write",
        "fast"
      ],
      keyStart: 1,
      keyStop: 1,
      step: 1
    },
    mset: {
      arity: -3,
      flags: [
        "write",
        "denyoom"
      ],
      keyStart: 1,
      keyStop: -1,
      step: 2
    },
    msetnx: {
      arity: -3,
      flags: [
        "write",
        "denyoom"
      ],
      keyStart: 1,
      keyStop: -1,
      step: 2
    },
    multi: {
      arity: 1,
      flags: [
        "noscript",
        "loading",
        "stale",
        "fast"
      ],
      keyStart: 0,
      keyStop: 0,
      step: 0
    },
    object: {
      arity: -2,
      flags: [
        "readonly",
        "random"
      ],
      keyStart: 2,
      keyStop: 2,
      step: 1
    },
    persist: {
      arity: 2,
      flags: [
        "write",
        "fast"
      ],
      keyStart: 1,
      keyStop: 1,
      step: 1
    },
    pexpire: {
      arity: 3,
      flags: [
        "write",
        "fast"
      ],
      keyStart: 1,
      keyStop: 1,
      step: 1
    },
    pexpireat: {
      arity: 3,
      flags: [
        "write",
        "fast"
      ],
      keyStart: 1,
      keyStop: 1,
      step: 1
    },
    pfadd: {
      arity: -2,
      flags: [
        "write",
        "denyoom",
        "fast"
      ],
      keyStart: 1,
      keyStop: 1,
      step: 1
    },
    pfcount: {
      arity: -2,
      flags: [
        "readonly",
        "may_replicate"
      ],
      keyStart: 1,
      keyStop: -1,
      step: 1
    },
    pfdebug: {
      arity: -3,
      flags: [
        "write",
        "denyoom",
        "admin"
      ],
      keyStart: 2,
      keyStop: 2,
      step: 1
    },
    pfmerge: {
      arity: -2,
      flags: [
        "write",
        "denyoom"
      ],
      keyStart: 1,
      keyStop: -1,
      step: 1
    },
    pfselftest: {
      arity: 1,
      flags: [
        "admin"
      ],
      keyStart: 0,
      keyStop: 0,
      step: 0
    },
    ping: {
      arity: -1,
      flags: [
        "stale",
        "fast"
      ],
      keyStart: 0,
      keyStop: 0,
      step: 0
    },
    post: {
      arity: -1,
      flags: [
        "readonly",
        "loading",
        "stale"
      ],
      keyStart: 0,
      keyStop: 0,
      step: 0
    },
    psetex: {
      arity: 4,
      flags: [
        "write",
        "denyoom"
      ],
      keyStart: 1,
      keyStop: 1,
      step: 1
    },
    psubscribe: {
      arity: -2,
      flags: [
        "pubsub",
        "noscript",
        "loading",
        "stale"
      ],
      keyStart: 0,
      keyStop: 0,
      step: 0
    },
    psync: {
      arity: -3,
      flags: [
        "admin",
        "noscript"
      ],
      keyStart: 0,
      keyStop: 0,
      step: 0
    },
    pttl: {
      arity: 2,
      flags: [
        "readonly",
        "random",
        "fast"
      ],
      keyStart: 1,
      keyStop: 1,
      step: 1
    },
    publish: {
      arity: 3,
      flags: [
        "pubsub",
        "loading",
        "stale",
        "fast",
        "may_replicate"
      ],
      keyStart: 0,
      keyStop: 0,
      step: 0
    },
    pubsub: {
      arity: -2,
      flags: [
        "pubsub",
        "random",
        "loading",
        "stale"
      ],
      keyStart: 0,
      keyStop: 0,
      step: 0
    },
    punsubscribe: {
      arity: -1,
      flags: [
        "pubsub",
        "noscript",
        "loading",
        "stale"
      ],
      keyStart: 0,
      keyStop: 0,
      step: 0
    },
    quit: {
      arity: 1,
      flags: [
        "loading",
        "stale",
        "readonly"
      ],
      keyStart: 0,
      keyStop: 0,
      step: 0
    },
    randomkey: {
      arity: 1,
      flags: [
        "readonly",
        "random"
      ],
      keyStart: 0,
      keyStop: 0,
      step: 0
    },
    readonly: {
      arity: 1,
      flags: [
        "fast"
      ],
      keyStart: 0,
      keyStop: 0,
      step: 0
    },
    readwrite: {
      arity: 1,
      flags: [
        "fast"
      ],
      keyStart: 0,
      keyStop: 0,
      step: 0
    },
    rename: {
      arity: 3,
      flags: [
        "write"
      ],
      keyStart: 1,
      keyStop: 2,
      step: 1
    },
    renamenx: {
      arity: 3,
      flags: [
        "write",
        "fast"
      ],
      keyStart: 1,
      keyStop: 2,
      step: 1
    },
    replconf: {
      arity: -1,
      flags: [
        "admin",
        "noscript",
        "loading",
        "stale"
      ],
      keyStart: 0,
      keyStop: 0,
      step: 0
    },
    replicaof: {
      arity: 3,
      flags: [
        "admin",
        "noscript",
        "stale"
      ],
      keyStart: 0,
      keyStop: 0,
      step: 0
    },
    reset: {
      arity: 1,
      flags: [
        "noscript",
        "loading",
        "stale",
        "fast"
      ],
      keyStart: 0,
      keyStop: 0,
      step: 0
    },
    restore: {
      arity: -4,
      flags: [
        "write",
        "denyoom"
      ],
      keyStart: 1,
      keyStop: 1,
      step: 1
    },
    "restore-asking": {
      arity: -4,
      flags: [
        "write",
        "denyoom",
        "asking"
      ],
      keyStart: 1,
      keyStop: 1,
      step: 1
    },
    role: {
      arity: 1,
      flags: [
        "noscript",
        "loading",
        "stale",
        "fast"
      ],
      keyStart: 0,
      keyStop: 0,
      step: 0
    },
    rpop: {
      arity: -2,
      flags: [
        "write",
        "fast"
      ],
      keyStart: 1,
      keyStop: 1,
      step: 1
    },
    rpoplpush: {
      arity: 3,
      flags: [
        "write",
        "denyoom"
      ],
      keyStart: 1,
      keyStop: 2,
      step: 1
    },
    rpush: {
      arity: -3,
      flags: [
        "write",
        "denyoom",
        "fast"
      ],
      keyStart: 1,
      keyStop: 1,
      step: 1
    },
    rpushx: {
      arity: -3,
      flags: [
        "write",
        "denyoom",
        "fast"
      ],
      keyStart: 1,
      keyStop: 1,
      step: 1
    },
    sadd: {
      arity: -3,
      flags: [
        "write",
        "denyoom",
        "fast"
      ],
      keyStart: 1,
      keyStop: 1,
      step: 1
    },
    save: {
      arity: 1,
      flags: [
        "admin",
        "noscript"
      ],
      keyStart: 0,
      keyStop: 0,
      step: 0
    },
    scan: {
      arity: -2,
      flags: [
        "readonly",
        "random"
      ],
      keyStart: 0,
      keyStop: 0,
      step: 0
    },
    scard: {
      arity: 2,
      flags: [
        "readonly",
        "fast"
      ],
      keyStart: 1,
      keyStop: 1,
      step: 1
    },
    script: {
      arity: -2,
      flags: [
        "noscript",
        "may_replicate"
      ],
      keyStart: 0,
      keyStop: 0,
      step: 0
    },
    sdiff: {
      arity: -2,
      flags: [
        "readonly",
        "sort_for_script"
      ],
      keyStart: 1,
      keyStop: -1,
      step: 1
    },
    sdiffstore: {
      arity: -3,
      flags: [
        "write",
        "denyoom"
      ],
      keyStart: 1,
      keyStop: -1,
      step: 1
    },
    select: {
      arity: 2,
      flags: [
        "loading",
        "stale",
        "fast"
      ],
      keyStart: 0,
      keyStop: 0,
      step: 0
    },
    set: {
      arity: -3,
      flags: [
        "write",
        "denyoom"
      ],
      keyStart: 1,
      keyStop: 1,
      step: 1
    },
    setbit: {
      arity: 4,
      flags: [
        "write",
        "denyoom"
      ],
      keyStart: 1,
      keyStop: 1,
      step: 1
    },
    setex: {
      arity: 4,
      flags: [
        "write",
        "denyoom"
      ],
      keyStart: 1,
      keyStop: 1,
      step: 1
    },
    setnx: {
      arity: 3,
      flags: [
        "write",
        "denyoom",
        "fast"
      ],
      keyStart: 1,
      keyStop: 1,
      step: 1
    },
    setrange: {
      arity: 4,
      flags: [
        "write",
        "denyoom"
      ],
      keyStart: 1,
      keyStop: 1,
      step: 1
    },
    shutdown: {
      arity: -1,
      flags: [
        "admin",
        "noscript",
        "loading",
        "stale"
      ],
      keyStart: 0,
      keyStop: 0,
      step: 0
    },
    sinter: {
      arity: -2,
      flags: [
        "readonly",
        "sort_for_script"
      ],
      keyStart: 1,
      keyStop: -1,
      step: 1
    },
    sinterstore: {
      arity: -3,
      flags: [
        "write",
        "denyoom"
      ],
      keyStart: 1,
      keyStop: -1,
      step: 1
    },
    sismember: {
      arity: 3,
      flags: [
        "readonly",
        "fast"
      ],
      keyStart: 1,
      keyStop: 1,
      step: 1
    },
    slaveof: {
      arity: 3,
      flags: [
        "admin",
        "noscript",
        "stale"
      ],
      keyStart: 0,
      keyStop: 0,
      step: 0
    },
    slowlog: {
      arity: -2,
      flags: [
        "admin",
        "random",
        "loading",
        "stale"
      ],
      keyStart: 0,
      keyStop: 0,
      step: 0
    },
    smembers: {
      arity: 2,
      flags: [
        "readonly",
        "sort_for_script"
      ],
      keyStart: 1,
      keyStop: 1,
      step: 1
    },
    smismember: {
      arity: -3,
      flags: [
        "readonly",
        "fast"
      ],
      keyStart: 1,
      keyStop: 1,
      step: 1
    },
    smove: {
      arity: 4,
      flags: [
        "write",
        "fast"
      ],
      keyStart: 1,
      keyStop: 2,
      step: 1
    },
    sort: {
      arity: -2,
      flags: [
        "write",
        "denyoom",
        "movablekeys"
      ],
      keyStart: 1,
      keyStop: 1,
      step: 1
    },
    spop: {
      arity: -2,
      flags: [
        "write",
        "random",
        "fast"
      ],
      keyStart: 1,
      keyStop: 1,
      step: 1
    },
    srandmember: {
      arity: -2,
      flags: [
        "readonly",
        "random"
      ],
      keyStart: 1,
      keyStop: 1,
      step: 1
    },
    srem: {
      arity: -3,
      flags: [
        "write",
        "fast"
      ],
      keyStart: 1,
      keyStop: 1,
      step: 1
    },
    sscan: {
      arity: -3,
      flags: [
        "readonly",
        "random"
      ],
      keyStart: 1,
      keyStop: 1,
      step: 1
    },
    stralgo: {
      arity: -2,
      flags: [
        "readonly",
        "movablekeys"
      ],
      keyStart: 0,
      keyStop: 0,
      step: 0
    },
    strlen: {
      arity: 2,
      flags: [
        "readonly",
        "fast"
      ],
      keyStart: 1,
      keyStop: 1,
      step: 1
    },
    subscribe: {
      arity: -2,
      flags: [
        "pubsub",
        "noscript",
        "loading",
        "stale"
      ],
      keyStart: 0,
      keyStop: 0,
      step: 0
    },
    substr: {
      arity: 4,
      flags: [
        "readonly"
      ],
      keyStart: 1,
      keyStop: 1,
      step: 1
    },
    sunion: {
      arity: -2,
      flags: [
        "readonly",
        "sort_for_script"
      ],
      keyStart: 1,
      keyStop: -1,
      step: 1
    },
    sunionstore: {
      arity: -3,
      flags: [
        "write",
        "denyoom"
      ],
      keyStart: 1,
      keyStop: -1,
      step: 1
    },
    swapdb: {
      arity: 3,
      flags: [
        "write",
        "fast"
      ],
      keyStart: 0,
      keyStop: 0,
      step: 0
    },
    sync: {
      arity: 1,
      flags: [
        "admin",
        "noscript"
      ],
      keyStart: 0,
      keyStop: 0,
      step: 0
    },
    time: {
      arity: 1,
      flags: [
        "random",
        "loading",
        "stale",
        "fast"
      ],
      keyStart: 0,
      keyStop: 0,
      step: 0
    },
    touch: {
      arity: -2,
      flags: [
        "readonly",
        "fast"
      ],
      keyStart: 1,
      keyStop: -1,
      step: 1
    },
    ttl: {
      arity: 2,
      flags: [
        "readonly",
        "random",
        "fast"
      ],
      keyStart: 1,
      keyStop: 1,
      step: 1
    },
    type: {
      arity: 2,
      flags: [
        "readonly",
        "fast"
      ],
      keyStart: 1,
      keyStop: 1,
      step: 1
    },
    unlink: {
      arity: -2,
      flags: [
        "write",
        "fast"
      ],
      keyStart: 1,
      keyStop: -1,
      step: 1
    },
    unsubscribe: {
      arity: -1,
      flags: [
        "pubsub",
        "noscript",
        "loading",
        "stale"
      ],
      keyStart: 0,
      keyStop: 0,
      step: 0
    },
    unwatch: {
      arity: 1,
      flags: [
        "noscript",
        "loading",
        "stale",
        "fast"
      ],
      keyStart: 0,
      keyStop: 0,
      step: 0
    },
    wait: {
      arity: 3,
      flags: [
        "noscript"
      ],
      keyStart: 0,
      keyStop: 0,
      step: 0
    },
    watch: {
      arity: -2,
      flags: [
        "noscript",
        "loading",
        "stale",
        "fast"
      ],
      keyStart: 1,
      keyStop: -1,
      step: 1
    },
    xack: {
      arity: -4,
      flags: [
        "write",
        "random",
        "fast"
      ],
      keyStart: 1,
      keyStop: 1,
      step: 1
    },
    xadd: {
      arity: -5,
      flags: [
        "write",
        "denyoom",
        "random",
        "fast"
      ],
      keyStart: 1,
      keyStop: 1,
      step: 1
    },
    xautoclaim: {
      arity: -6,
      flags: [
        "write",
        "random",
        "fast"
      ],
      keyStart: 1,
      keyStop: 1,
      step: 1
    },
    xclaim: {
      arity: -6,
      flags: [
        "write",
        "random",
        "fast"
      ],
      keyStart: 1,
      keyStop: 1,
      step: 1
    },
    xdel: {
      arity: -3,
      flags: [
        "write",
        "fast"
      ],
      keyStart: 1,
      keyStop: 1,
      step: 1
    },
    xgroup: {
      arity: -2,
      flags: [
        "write",
        "denyoom"
      ],
      keyStart: 2,
      keyStop: 2,
      step: 1
    },
    xinfo: {
      arity: -2,
      flags: [
        "readonly",
        "random"
      ],
      keyStart: 2,
      keyStop: 2,
      step: 1
    },
    xlen: {
      arity: 2,
      flags: [
        "readonly",
        "fast"
      ],
      keyStart: 1,
      keyStop: 1,
      step: 1
    },
    xpending: {
      arity: -3,
      flags: [
        "readonly",
        "random"
      ],
      keyStart: 1,
      keyStop: 1,
      step: 1
    },
    xrange: {
      arity: -4,
      flags: [
        "readonly"
      ],
      keyStart: 1,
      keyStop: 1,
      step: 1
    },
    xread: {
      arity: -4,
      flags: [
        "readonly",
        "movablekeys"
      ],
      keyStart: 0,
      keyStop: 0,
      step: 0
    },
    xreadgroup: {
      arity: -7,
      flags: [
        "write",
        "movablekeys"
      ],
      keyStart: 0,
      keyStop: 0,
      step: 0
    },
    xrevrange: {
      arity: -4,
      flags: [
        "readonly"
      ],
      keyStart: 1,
      keyStop: 1,
      step: 1
    },
    xsetid: {
      arity: 3,
      flags: [
        "write",
        "denyoom",
        "fast"
      ],
      keyStart: 1,
      keyStop: 1,
      step: 1
    },
    xtrim: {
      arity: -2,
      flags: [
        "write",
        "random"
      ],
      keyStart: 1,
      keyStop: 1,
      step: 1
    },
    zadd: {
      arity: -4,
      flags: [
        "write",
        "denyoom",
        "fast"
      ],
      keyStart: 1,
      keyStop: 1,
      step: 1
    },
    zcard: {
      arity: 2,
      flags: [
        "readonly",
        "fast"
      ],
      keyStart: 1,
      keyStop: 1,
      step: 1
    },
    zcount: {
      arity: 4,
      flags: [
        "readonly",
        "fast"
      ],
      keyStart: 1,
      keyStop: 1,
      step: 1
    },
    zdiff: {
      arity: -3,
      flags: [
        "readonly",
        "movablekeys"
      ],
      keyStart: 0,
      keyStop: 0,
      step: 0
    },
    zdiffstore: {
      arity: -4,
      flags: [
        "write",
        "denyoom",
        "movablekeys"
      ],
      keyStart: 1,
      keyStop: 1,
      step: 1
    },
    zincrby: {
      arity: 4,
      flags: [
        "write",
        "denyoom",
        "fast"
      ],
      keyStart: 1,
      keyStop: 1,
      step: 1
    },
    zinter: {
      arity: -3,
      flags: [
        "readonly",
        "movablekeys"
      ],
      keyStart: 0,
      keyStop: 0,
      step: 0
    },
    zinterstore: {
      arity: -4,
      flags: [
        "write",
        "denyoom",
        "movablekeys"
      ],
      keyStart: 1,
      keyStop: 1,
      step: 1
    },
    zlexcount: {
      arity: 4,
      flags: [
        "readonly",
        "fast"
      ],
      keyStart: 1,
      keyStop: 1,
      step: 1
    },
    zmscore: {
      arity: -3,
      flags: [
        "readonly",
        "fast"
      ],
      keyStart: 1,
      keyStop: 1,
      step: 1
    },
    zpopmax: {
      arity: -2,
      flags: [
        "write",
        "fast"
      ],
      keyStart: 1,
      keyStop: 1,
      step: 1
    },
    zpopmin: {
      arity: -2,
      flags: [
        "write",
        "fast"
      ],
      keyStart: 1,
      keyStop: 1,
      step: 1
    },
    zrandmember: {
      arity: -2,
      flags: [
        "readonly",
        "random"
      ],
      keyStart: 1,
      keyStop: 1,
      step: 1
    },
    zrange: {
      arity: -4,
      flags: [
        "readonly"
      ],
      keyStart: 1,
      keyStop: 1,
      step: 1
    },
    zrangebylex: {
      arity: -4,
      flags: [
        "readonly"
      ],
      keyStart: 1,
      keyStop: 1,
      step: 1
    },
    zrangebyscore: {
      arity: -4,
      flags: [
        "readonly"
      ],
      keyStart: 1,
      keyStop: 1,
      step: 1
    },
    zrangestore: {
      arity: -5,
      flags: [
        "write",
        "denyoom"
      ],
      keyStart: 1,
      keyStop: 2,
      step: 1
    },
    zrank: {
      arity: 3,
      flags: [
        "readonly",
        "fast"
      ],
      keyStart: 1,
      keyStop: 1,
      step: 1
    },
    zrem: {
      arity: -3,
      flags: [
        "write",
        "fast"
      ],
      keyStart: 1,
      keyStop: 1,
      step: 1
    },
    zremrangebylex: {
      arity: 4,
      flags: [
        "write"
      ],
      keyStart: 1,
      keyStop: 1,
      step: 1
    },
    zremrangebyrank: {
      arity: 4,
      flags: [
        "write"
      ],
      keyStart: 1,
      keyStop: 1,
      step: 1
    },
    zremrangebyscore: {
      arity: 4,
      flags: [
        "write"
      ],
      keyStart: 1,
      keyStop: 1,
      step: 1
    },
    zrevrange: {
      arity: -4,
      flags: [
        "readonly"
      ],
      keyStart: 1,
      keyStop: 1,
      step: 1
    },
    zrevrangebylex: {
      arity: -4,
      flags: [
        "readonly"
      ],
      keyStart: 1,
      keyStop: 1,
      step: 1
    },
    zrevrangebyscore: {
      arity: -4,
      flags: [
        "readonly"
      ],
      keyStart: 1,
      keyStop: 1,
      step: 1
    },
    zrevrank: {
      arity: 3,
      flags: [
        "readonly",
        "fast"
      ],
      keyStart: 1,
      keyStop: 1,
      step: 1
    },
    zscan: {
      arity: -3,
      flags: [
        "readonly",
        "random"
      ],
      keyStart: 1,
      keyStop: 1,
      step: 1
    },
    zscore: {
      arity: 3,
      flags: [
        "readonly",
        "fast"
      ],
      keyStart: 1,
      keyStop: 1,
      step: 1
    },
    zunion: {
      arity: -3,
      flags: [
        "readonly",
        "movablekeys"
      ],
      keyStart: 0,
      keyStop: 0,
      step: 0
    },
    zunionstore: {
      arity: -4,
      flags: [
        "write",
        "denyoom",
        "movablekeys"
      ],
      keyStart: 1,
      keyStop: 1,
      step: 1
    }
  };
});

// node_modules/redis-commands/index.js
var require_redis_commands = __commonJS((exports) => {
  var getExternalKeyNameLength = function(key) {
    if (typeof key !== "string") {
      key = String(key);
    }
    var hashPos = key.indexOf("->");
    return hashPos === -1 ? key.length : hashPos;
  };
  var commands = require_commands();
  exports.list = Object.keys(commands);
  var flags3 = {};
  exports.list.forEach(function(commandName) {
    flags3[commandName] = commands[commandName].flags.reduce(function(flags4, flag) {
      flags4[flag] = true;
      return flags4;
    }, {});
  });
  exports.exists = function(commandName) {
    return Boolean(commands[commandName]);
  };
  exports.hasFlag = function(commandName, flag) {
    if (!flags3[commandName]) {
      throw new Error("Unknown command " + commandName);
    }
    return Boolean(flags3[commandName][flag]);
  };
  exports.getKeyIndexes = function(commandName, args, options) {
    var command = commands[commandName];
    if (!command) {
      throw new Error("Unknown command " + commandName);
    }
    if (!Array.isArray(args)) {
      throw new Error("Expect args to be an array");
    }
    var keys = [];
    var i, keyStart, keyStop, parseExternalKey;
    switch (commandName) {
      case "zunionstore":
      case "zinterstore":
        keys.push(0);
      case "eval":
      case "evalsha":
        keyStop = Number(args[1]) + 2;
        for (i = 2;i < keyStop; i++) {
          keys.push(i);
        }
        break;
      case "sort":
        parseExternalKey = options && options.parseExternalKey;
        keys.push(0);
        for (i = 1;i < args.length - 1; i++) {
          if (typeof args[i] !== "string") {
            continue;
          }
          var directive = args[i].toUpperCase();
          if (directive === "GET") {
            i += 1;
            if (args[i] !== "#") {
              if (parseExternalKey) {
                keys.push([i, getExternalKeyNameLength(args[i])]);
              } else {
                keys.push(i);
              }
            }
          } else if (directive === "BY") {
            i += 1;
            if (parseExternalKey) {
              keys.push([i, getExternalKeyNameLength(args[i])]);
            } else {
              keys.push(i);
            }
          } else if (directive === "STORE") {
            i += 1;
            keys.push(i);
          }
        }
        break;
      case "migrate":
        if (args[2] === "") {
          for (i = 5;i < args.length - 1; i++) {
            if (args[i].toUpperCase() === "KEYS") {
              for (var j = i + 1;j < args.length; j++) {
                keys.push(j);
              }
              break;
            }
          }
        } else {
          keys.push(2);
        }
        break;
      case "xreadgroup":
      case "xread":
        for (i = commandName === "xread" ? 0 : 3;i < args.length - 1; i++) {
          if (String(args[i]).toUpperCase() === "STREAMS") {
            for (j = i + 1;j <= i + (args.length - 1 - i) / 2; j++) {
              keys.push(j);
            }
            break;
          }
        }
        break;
      default:
        if (command.step > 0) {
          keyStart = command.keyStart - 1;
          keyStop = command.keyStop > 0 ? command.keyStop : args.length + command.keyStop + 1;
          for (i = keyStart;i < keyStop; i += command.step) {
            keys.push(i);
          }
        }
        break;
    }
    return keys;
  };
});

// node_modules/cluster-key-slot/lib/index.js
var require_lib = __commonJS((exports, module) => {
  var lookup = [
    0,
    4129,
    8258,
    12387,
    16516,
    20645,
    24774,
    28903,
    33032,
    37161,
    41290,
    45419,
    49548,
    53677,
    57806,
    61935,
    4657,
    528,
    12915,
    8786,
    21173,
    17044,
    29431,
    25302,
    37689,
    33560,
    45947,
    41818,
    54205,
    50076,
    62463,
    58334,
    9314,
    13379,
    1056,
    5121,
    25830,
    29895,
    17572,
    21637,
    42346,
    46411,
    34088,
    38153,
    58862,
    62927,
    50604,
    54669,
    13907,
    9842,
    5649,
    1584,
    30423,
    26358,
    22165,
    18100,
    46939,
    42874,
    38681,
    34616,
    63455,
    59390,
    55197,
    51132,
    18628,
    22757,
    26758,
    30887,
    2112,
    6241,
    10242,
    14371,
    51660,
    55789,
    59790,
    63919,
    35144,
    39273,
    43274,
    47403,
    23285,
    19156,
    31415,
    27286,
    6769,
    2640,
    14899,
    10770,
    56317,
    52188,
    64447,
    60318,
    39801,
    35672,
    47931,
    43802,
    27814,
    31879,
    19684,
    23749,
    11298,
    15363,
    3168,
    7233,
    60846,
    64911,
    52716,
    56781,
    44330,
    48395,
    36200,
    40265,
    32407,
    28342,
    24277,
    20212,
    15891,
    11826,
    7761,
    3696,
    65439,
    61374,
    57309,
    53244,
    48923,
    44858,
    40793,
    36728,
    37256,
    33193,
    45514,
    41451,
    53516,
    49453,
    61774,
    57711,
    4224,
    161,
    12482,
    8419,
    20484,
    16421,
    28742,
    24679,
    33721,
    37784,
    41979,
    46042,
    49981,
    54044,
    58239,
    62302,
    689,
    4752,
    8947,
    13010,
    16949,
    21012,
    25207,
    29270,
    46570,
    42443,
    38312,
    34185,
    62830,
    58703,
    54572,
    50445,
    13538,
    9411,
    5280,
    1153,
    29798,
    25671,
    21540,
    17413,
    42971,
    47098,
    34713,
    38840,
    59231,
    63358,
    50973,
    55100,
    9939,
    14066,
    1681,
    5808,
    26199,
    30326,
    17941,
    22068,
    55628,
    51565,
    63758,
    59695,
    39368,
    35305,
    47498,
    43435,
    22596,
    18533,
    30726,
    26663,
    6336,
    2273,
    14466,
    10403,
    52093,
    56156,
    60223,
    64286,
    35833,
    39896,
    43963,
    48026,
    19061,
    23124,
    27191,
    31254,
    2801,
    6864,
    10931,
    14994,
    64814,
    60687,
    56684,
    52557,
    48554,
    44427,
    40424,
    36297,
    31782,
    27655,
    23652,
    19525,
    15522,
    11395,
    7392,
    3265,
    61215,
    65342,
    53085,
    57212,
    44955,
    49082,
    36825,
    40952,
    28183,
    32310,
    20053,
    24180,
    11923,
    16050,
    3793,
    7920
  ];
  var toUTF8Array = function toUTF8Array(str) {
    var char;
    var i = 0;
    var p = 0;
    var utf8 = [];
    var len = str.length;
    for (;i < len; i++) {
      char = str.charCodeAt(i);
      if (char < 128) {
        utf8[p++] = char;
      } else if (char < 2048) {
        utf8[p++] = char >> 6 | 192;
        utf8[p++] = char & 63 | 128;
      } else if ((char & 64512) === 55296 && i + 1 < str.length && (str.charCodeAt(i + 1) & 64512) === 56320) {
        char = 65536 + ((char & 1023) << 10) + (str.charCodeAt(++i) & 1023);
        utf8[p++] = char >> 18 | 240;
        utf8[p++] = char >> 12 & 63 | 128;
        utf8[p++] = char >> 6 & 63 | 128;
        utf8[p++] = char & 63 | 128;
      } else {
        utf8[p++] = char >> 12 | 224;
        utf8[p++] = char >> 6 & 63 | 128;
        utf8[p++] = char & 63 | 128;
      }
    }
    return utf8;
  };
  var generate = module.exports = function generate(str) {
    var char;
    var i = 0;
    var start = -1;
    var result2 = 0;
    var resultHash = 0;
    var utf8 = typeof str === "string" ? toUTF8Array(str) : str;
    var len = utf8.length;
    while (i < len) {
      char = utf8[i++];
      if (start === -1) {
        if (char === 123) {
          start = i;
        }
      } else if (char !== 125) {
        resultHash = lookup[(char ^ resultHash >> 8) & 255] ^ resultHash << 8;
      } else if (i - 1 !== start) {
        return resultHash & 16383;
      }
      result2 = lookup[(char ^ result2 >> 8) & 255] ^ result2 << 8;
    }
    return result2 & 16383;
  };
  module.exports.generateMulti = function generateMulti(keys) {
    var i = 1;
    var len = keys.length;
    var base = generate(keys[0]);
    while (i < len) {
      if (generate(keys[i++]) !== base)
        return -1;
    }
    return base;
  };
});

// node_modules/standard-as-callback/built/utils.js
var require_utils = __commonJS((exports) => {
  var tryCatcher = function(err, val) {
    try {
      const target = tryCatchTarget;
      tryCatchTarget = null;
      return target.apply(this, arguments);
    } catch (e) {
      exports.errorObj.e = e;
      return exports.errorObj;
    }
  };
  var tryCatch = function(fn) {
    tryCatchTarget = fn;
    return tryCatcher;
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.tryCatch = exports.errorObj = undefined;
  exports.errorObj = { e: {} };
  var tryCatchTarget;
  exports.tryCatch = tryCatch;
});

// node_modules/standard-as-callback/built/index.js
var require_built = __commonJS((exports) => {
  var throwLater = function(e) {
    setTimeout(function() {
      throw e;
    }, 0);
  };
  var asCallback = function(promise, nodeback, options) {
    if (typeof nodeback === "function") {
      promise.then((val) => {
        let ret;
        if (options !== undefined && Object(options).spread && Array.isArray(val)) {
          ret = utils_1.tryCatch(nodeback).apply(undefined, [null].concat(val));
        } else {
          ret = val === undefined ? utils_1.tryCatch(nodeback)(null) : utils_1.tryCatch(nodeback)(null, val);
        }
        if (ret === utils_1.errorObj) {
          throwLater(ret.e);
        }
      }, (cause) => {
        if (!cause) {
          const newReason = new Error(cause + "");
          Object.assign(newReason, { cause });
          cause = newReason;
        }
        const ret = utils_1.tryCatch(nodeback)(cause);
        if (ret === utils_1.errorObj) {
          throwLater(ret.e);
        }
      });
    }
    return promise;
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  var utils_1 = require_utils();
  exports.default = asCallback;
});

// node_modules/ms/index.js
var require_ms = __commonJS((exports, module) => {
  var parse4 = function(str) {
    str = String(str);
    if (str.length > 100) {
      return;
    }
    var match = /^(-?(?:\d+)?\.?\d+) *(milliseconds?|msecs?|ms|seconds?|secs?|s|minutes?|mins?|m|hours?|hrs?|h|days?|d|weeks?|w|years?|yrs?|y)?$/i.exec(str);
    if (!match) {
      return;
    }
    var n = parseFloat(match[1]);
    var type = (match[2] || "ms").toLowerCase();
    switch (type) {
      case "years":
      case "year":
      case "yrs":
      case "yr":
      case "y":
        return n * y;
      case "weeks":
      case "week":
      case "w":
        return n * w;
      case "days":
      case "day":
      case "d":
        return n * d;
      case "hours":
      case "hour":
      case "hrs":
      case "hr":
      case "h":
        return n * h;
      case "minutes":
      case "minute":
      case "mins":
      case "min":
      case "m":
        return n * m;
      case "seconds":
      case "second":
      case "secs":
      case "sec":
      case "s":
        return n * s;
      case "milliseconds":
      case "millisecond":
      case "msecs":
      case "msec":
      case "ms":
        return n;
      default:
        return;
    }
  };
  var fmtShort = function(ms) {
    var msAbs = Math.abs(ms);
    if (msAbs >= d) {
      return Math.round(ms / d) + "d";
    }
    if (msAbs >= h) {
      return Math.round(ms / h) + "h";
    }
    if (msAbs >= m) {
      return Math.round(ms / m) + "m";
    }
    if (msAbs >= s) {
      return Math.round(ms / s) + "s";
    }
    return ms + "ms";
  };
  var fmtLong = function(ms) {
    var msAbs = Math.abs(ms);
    if (msAbs >= d) {
      return plural(ms, msAbs, d, "day");
    }
    if (msAbs >= h) {
      return plural(ms, msAbs, h, "hour");
    }
    if (msAbs >= m) {
      return plural(ms, msAbs, m, "minute");
    }
    if (msAbs >= s) {
      return plural(ms, msAbs, s, "second");
    }
    return ms + " ms";
  };
  var plural = function(ms, msAbs, n, name) {
    var isPlural = msAbs >= n * 1.5;
    return Math.round(ms / n) + " " + name + (isPlural ? "s" : "");
  };
  var s = 1000;
  var m = s * 60;
  var h = m * 60;
  var d = h * 24;
  var w = d * 7;
  var y = d * 365.25;
  module.exports = function(val, options) {
    options = options || {};
    var type = typeof val;
    if (type === "string" && val.length > 0) {
      return parse4(val);
    } else if (type === "number" && isFinite(val)) {
      return options.long ? fmtLong(val) : fmtShort(val);
    }
    throw new Error("val is not a non-empty string or a valid number. val=" + JSON.stringify(val));
  };
});

// node_modules/debug/src/common.js
var require_common = __commonJS((exports, module) => {
  var setup = function(env) {
    createDebug.debug = createDebug;
    createDebug.default = createDebug;
    createDebug.coerce = coerce;
    createDebug.disable = disable;
    createDebug.enable = enable;
    createDebug.enabled = enabled;
    createDebug.humanize = require_ms();
    createDebug.destroy = destroy;
    Object.keys(env).forEach((key) => {
      createDebug[key] = env[key];
    });
    createDebug.names = [];
    createDebug.skips = [];
    createDebug.formatters = {};
    function selectColor(namespace) {
      let hash = 0;
      for (let i = 0;i < namespace.length; i++) {
        hash = (hash << 5) - hash + namespace.charCodeAt(i);
        hash |= 0;
      }
      return createDebug.colors[Math.abs(hash) % createDebug.colors.length];
    }
    createDebug.selectColor = selectColor;
    function createDebug(namespace) {
      let prevTime;
      let enableOverride = null;
      let namespacesCache;
      let enabledCache;
      function debug(...args) {
        if (!debug.enabled) {
          return;
        }
        const self2 = debug;
        const curr = Number(new Date);
        const ms = curr - (prevTime || curr);
        self2.diff = ms;
        self2.prev = prevTime;
        self2.curr = curr;
        prevTime = curr;
        args[0] = createDebug.coerce(args[0]);
        if (typeof args[0] !== "string") {
          args.unshift("%O");
        }
        let index = 0;
        args[0] = args[0].replace(/%([a-zA-Z%])/g, (match, format) => {
          if (match === "%%") {
            return "%";
          }
          index++;
          const formatter = createDebug.formatters[format];
          if (typeof formatter === "function") {
            const val = args[index];
            match = formatter.call(self2, val);
            args.splice(index, 1);
            index--;
          }
          return match;
        });
        createDebug.formatArgs.call(self2, args);
        const logFn = self2.log || createDebug.log;
        logFn.apply(self2, args);
      }
      debug.namespace = namespace;
      debug.useColors = createDebug.useColors();
      debug.color = createDebug.selectColor(namespace);
      debug.extend = extend;
      debug.destroy = createDebug.destroy;
      Object.defineProperty(debug, "enabled", {
        enumerable: true,
        configurable: false,
        get: () => {
          if (enableOverride !== null) {
            return enableOverride;
          }
          if (namespacesCache !== createDebug.namespaces) {
            namespacesCache = createDebug.namespaces;
            enabledCache = createDebug.enabled(namespace);
          }
          return enabledCache;
        },
        set: (v) => {
          enableOverride = v;
        }
      });
      if (typeof createDebug.init === "function") {
        createDebug.init(debug);
      }
      return debug;
    }
    function extend(namespace, delimiter) {
      const newDebug = createDebug(this.namespace + (typeof delimiter === "undefined" ? ":" : delimiter) + namespace);
      newDebug.log = this.log;
      return newDebug;
    }
    function enable(namespaces) {
      createDebug.save(namespaces);
      createDebug.namespaces = namespaces;
      createDebug.names = [];
      createDebug.skips = [];
      let i;
      const split = (typeof namespaces === "string" ? namespaces : "").split(/[\s,]+/);
      const len = split.length;
      for (i = 0;i < len; i++) {
        if (!split[i]) {
          continue;
        }
        namespaces = split[i].replace(/\*/g, ".*?");
        if (namespaces[0] === "-") {
          createDebug.skips.push(new RegExp("^" + namespaces.slice(1) + "$"));
        } else {
          createDebug.names.push(new RegExp("^" + namespaces + "$"));
        }
      }
    }
    function disable() {
      const namespaces = [
        ...createDebug.names.map(toNamespace),
        ...createDebug.skips.map(toNamespace).map((namespace) => "-" + namespace)
      ].join(",");
      createDebug.enable("");
      return namespaces;
    }
    function enabled(name) {
      if (name[name.length - 1] === "*") {
        return true;
      }
      let i;
      let len;
      for (i = 0, len = createDebug.skips.length;i < len; i++) {
        if (createDebug.skips[i].test(name)) {
          return false;
        }
      }
      for (i = 0, len = createDebug.names.length;i < len; i++) {
        if (createDebug.names[i].test(name)) {
          return true;
        }
      }
      return false;
    }
    function toNamespace(regexp) {
      return regexp.toString().substring(2, regexp.toString().length - 2).replace(/\.\*\?$/, "*");
    }
    function coerce(val) {
      if (val instanceof Error) {
        return val.stack || val.message;
      }
      return val;
    }
    function destroy() {
      console.warn("Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`.");
    }
    createDebug.enable(createDebug.load());
    return createDebug;
  };
  module.exports = setup;
});

// node_modules/debug/src/browser.js
var require_browser = __commonJS((exports, module) => {
  var useColors = function() {
    if (typeof window !== "undefined" && window.process && (window.process.type === "renderer" || window.process.__nwjs)) {
      return true;
    }
    if (typeof navigator !== "undefined" && navigator.userAgent && navigator.userAgent.toLowerCase().match(/(edge|trident)\/(\d+)/)) {
      return false;
    }
    return typeof document !== "undefined" && document.documentElement && document.documentElement.style && document.documentElement.style.WebkitAppearance || typeof window !== "undefined" && window.console && (window.console.firebug || window.console.exception && window.console.table) || typeof navigator !== "undefined" && navigator.userAgent && navigator.userAgent.toLowerCase().match(/firefox\/(\d+)/) && parseInt(RegExp.$1, 10) >= 31 || typeof navigator !== "undefined" && navigator.userAgent && navigator.userAgent.toLowerCase().match(/applewebkit\/(\d+)/);
  };
  var formatArgs = function(args) {
    args[0] = (this.useColors ? "%c" : "") + this.namespace + (this.useColors ? " %c" : " ") + args[0] + (this.useColors ? "%c " : " ") + "+" + exports.humanize(this.diff);
    if (!this.useColors) {
      return;
    }
    const c = "color: " + this.color;
    args.splice(1, 0, c, "color: inherit");
    let index = 0;
    let lastC = 0;
    args[0].replace(/%[a-zA-Z%]/g, (match) => {
      if (match === "%%") {
        return;
      }
      index++;
      if (match === "%c") {
        lastC = index;
      }
    });
    args.splice(lastC, 0, c);
  };
  var save = function(namespaces) {
    try {
      if (namespaces) {
        exports.storage.setItem("debug", namespaces);
      } else {
        exports.storage.removeItem("debug");
      }
    } catch (error) {
    }
  };
  var load = function() {
    let r;
    try {
      r = exports.storage.getItem("debug");
    } catch (error) {
    }
    if (!r && typeof process !== "undefined" && ("env" in process)) {
      r = process.env.DEBUG;
    }
    return r;
  };
  var localstorage = function() {
    try {
      return localStorage;
    } catch (error) {
    }
  };
  exports.formatArgs = formatArgs;
  exports.save = save;
  exports.load = load;
  exports.useColors = useColors;
  exports.storage = localstorage();
  exports.destroy = (() => {
    let warned = false;
    return () => {
      if (!warned) {
        warned = true;
        console.warn("Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`.");
      }
    };
  })();
  exports.colors = [
    "#0000CC",
    "#0000FF",
    "#0033CC",
    "#0033FF",
    "#0066CC",
    "#0066FF",
    "#0099CC",
    "#0099FF",
    "#00CC00",
    "#00CC33",
    "#00CC66",
    "#00CC99",
    "#00CCCC",
    "#00CCFF",
    "#3300CC",
    "#3300FF",
    "#3333CC",
    "#3333FF",
    "#3366CC",
    "#3366FF",
    "#3399CC",
    "#3399FF",
    "#33CC00",
    "#33CC33",
    "#33CC66",
    "#33CC99",
    "#33CCCC",
    "#33CCFF",
    "#6600CC",
    "#6600FF",
    "#6633CC",
    "#6633FF",
    "#66CC00",
    "#66CC33",
    "#9900CC",
    "#9900FF",
    "#9933CC",
    "#9933FF",
    "#99CC00",
    "#99CC33",
    "#CC0000",
    "#CC0033",
    "#CC0066",
    "#CC0099",
    "#CC00CC",
    "#CC00FF",
    "#CC3300",
    "#CC3333",
    "#CC3366",
    "#CC3399",
    "#CC33CC",
    "#CC33FF",
    "#CC6600",
    "#CC6633",
    "#CC9900",
    "#CC9933",
    "#CCCC00",
    "#CCCC33",
    "#FF0000",
    "#FF0033",
    "#FF0066",
    "#FF0099",
    "#FF00CC",
    "#FF00FF",
    "#FF3300",
    "#FF3333",
    "#FF3366",
    "#FF3399",
    "#FF33CC",
    "#FF33FF",
    "#FF6600",
    "#FF6633",
    "#FF9900",
    "#FF9933",
    "#FFCC00",
    "#FFCC33"
  ];
  exports.log = console.debug || console.log || (() => {
  });
  module.exports = require_common()(exports);
  var { formatters } = module.exports;
  formatters.j = function(v) {
    try {
      return JSON.stringify(v);
    } catch (error) {
      return "[UnexpectedJSONParseError]: " + error.message;
    }
  };
});

// node_modules/debug/src/node.js
var require_node = __commonJS((exports, module) => {
  var useColors = function() {
    return "colors" in exports.inspectOpts ? Boolean(exports.inspectOpts.colors) : tty.isatty(process.stderr.fd);
  };
  var formatArgs = function(args) {
    const { namespace: name, useColors: useColors2 } = this;
    if (useColors2) {
      const c = this.color;
      const colorCode = "\x1B[3" + (c < 8 ? c : "8;5;" + c);
      const prefix = `  ${colorCode};1m${name} \x1B[0m`;
      args[0] = prefix + args[0].split("\n").join("\n" + prefix);
      args.push(colorCode + "m+" + exports.humanize(this.diff) + "\x1B[0m");
    } else {
      args[0] = getDate() + name + " " + args[0];
    }
  };
  var getDate = function() {
    if (exports.inspectOpts.hideDate) {
      return "";
    }
    return new Date().toISOString() + " ";
  };
  var log = function(...args) {
    return process.stderr.write(util3.format(...args) + "\n");
  };
  var save = function(namespaces) {
    if (namespaces) {
      process.env.DEBUG = namespaces;
    } else {
      delete process.env.DEBUG;
    }
  };
  var load = function() {
    return process.env.DEBUG;
  };
  var init = function(debug) {
    debug.inspectOpts = {};
    const keys = Object.keys(exports.inspectOpts);
    for (let i = 0;i < keys.length; i++) {
      debug.inspectOpts[keys[i]] = exports.inspectOpts[keys[i]];
    }
  };
  var tty = __require("tty");
  var util3 = __require("util");
  exports.init = init;
  exports.log = log;
  exports.formatArgs = formatArgs;
  exports.save = save;
  exports.load = load;
  exports.useColors = useColors;
  exports.destroy = util3.deprecate(() => {
  }, "Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`.");
  exports.colors = [6, 2, 3, 4, 5, 1];
  try {
    const supportsColor = (()=>{ throw new Error(`Cannot require module "supports-color"`);})();
    if (supportsColor && (supportsColor.stderr || supportsColor).level >= 2) {
      exports.colors = [
        20,
        21,
        26,
        27,
        32,
        33,
        38,
        39,
        40,
        41,
        42,
        43,
        44,
        45,
        56,
        57,
        62,
        63,
        68,
        69,
        74,
        75,
        76,
        77,
        78,
        79,
        80,
        81,
        92,
        93,
        98,
        99,
        112,
        113,
        128,
        129,
        134,
        135,
        148,
        149,
        160,
        161,
        162,
        163,
        164,
        165,
        166,
        167,
        168,
        169,
        170,
        171,
        172,
        173,
        178,
        179,
        184,
        185,
        196,
        197,
        198,
        199,
        200,
        201,
        202,
        203,
        204,
        205,
        206,
        207,
        208,
        209,
        214,
        215,
        220,
        221
      ];
    }
  } catch (error) {
  }
  exports.inspectOpts = Object.keys(process.env).filter((key) => {
    return /^debug_/i.test(key);
  }).reduce((obj, key) => {
    const prop = key.substring(6).toLowerCase().replace(/_([a-z])/g, (_, k) => {
      return k.toUpperCase();
    });
    let val = process.env[key];
    if (/^(yes|on|true|enabled)$/i.test(val)) {
      val = true;
    } else if (/^(no|off|false|disabled)$/i.test(val)) {
      val = false;
    } else if (val === "null") {
      val = null;
    } else {
      val = Number(val);
    }
    obj[prop] = val;
    return obj;
  }, {});
  module.exports = require_common()(exports);
  var { formatters } = module.exports;
  formatters.o = function(v) {
    this.inspectOpts.colors = this.useColors;
    return util3.inspect(v, this.inspectOpts).split("\n").map((str) => str.trim()).join(" ");
  };
  formatters.O = function(v) {
    this.inspectOpts.colors = this.useColors;
    return util3.inspect(v, this.inspectOpts);
  };
});

// node_modules/debug/src/index.js
var require_src = __commonJS((exports, module) => {
  if (typeof process === "undefined" || process.type === "renderer" || false || process.__nwjs) {
    module.exports = require_browser();
  } else {
    module.exports = require_node();
  }
});

// node_modules/ioredis/built/utils/debug.js
var require_debug = __commonJS((exports) => {
  var getStringValue = function(v) {
    if (v === null) {
      return;
    }
    switch (typeof v) {
      case "boolean":
        return;
      case "number":
        return;
      case "object":
        if (Buffer.isBuffer(v)) {
          return v.toString("hex");
        }
        if (Array.isArray(v)) {
          return v.join(",");
        }
        try {
          return JSON.stringify(v);
        } catch (e) {
          return;
        }
      case "string":
        return v;
    }
  };
  var genRedactedString = function(str, maxLen) {
    const { length } = str;
    return length <= maxLen ? str : str.slice(0, maxLen) + ' ... <REDACTED full-length="' + length + '">';
  };
  var genDebugFunction = function(namespace) {
    const fn = debug_1.default(`${NAMESPACE_PREFIX}:${namespace}`);
    function wrappedDebug(...args) {
      if (!fn.enabled) {
        return;
      }
      for (let i = 1;i < args.length; i++) {
        const str = getStringValue(args[i]);
        if (typeof str === "string" && str.length > MAX_ARGUMENT_LENGTH) {
          args[i] = genRedactedString(str, MAX_ARGUMENT_LENGTH);
        }
      }
      return fn.apply(null, args);
    }
    Object.defineProperties(wrappedDebug, {
      namespace: {
        get() {
          return fn.namespace;
        }
      },
      enabled: {
        get() {
          return fn.enabled;
        }
      },
      destroy: {
        get() {
          return fn.destroy;
        }
      },
      log: {
        get() {
          return fn.log;
        },
        set(l) {
          fn.log = l;
        }
      }
    });
    return wrappedDebug;
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  var debug_1 = require_src();
  var MAX_ARGUMENT_LENGTH = 200;
  exports.MAX_ARGUMENT_LENGTH = MAX_ARGUMENT_LENGTH;
  var NAMESPACE_PREFIX = "ioredis";
  exports.getStringValue = getStringValue;
  exports.genRedactedString = genRedactedString;
  exports.default = genDebugFunction;
});

// node_modules/ioredis/built/constants/TLSProfiles.js
var require_TLSProfiles = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.default = {
    RedisCloudFixed: {
      ca: "-----BEGIN CERTIFICATE-----\nMIIDTzCCAjegAwIBAgIJAKSVpiDswLcwMA0GCSqGSIb3DQEBBQUAMD4xFjAUBgNV\nBAoMDUdhcmFudGlhIERhdGExJDAiBgNVBAMMG1NTTCBDZXJ0aWZpY2F0aW9uIEF1\ndGhvcml0eTAeFw0xMzEwMDExMjE0NTVaFw0yMzA5MjkxMjE0NTVaMD4xFjAUBgNV\nBAoMDUdhcmFudGlhIERhdGExJDAiBgNVBAMMG1NTTCBDZXJ0aWZpY2F0aW9uIEF1\ndGhvcml0eTCCASIwDQYJKoZIhvcNAQEBBQADggEPADCCAQoCggEBALZqkh/DczWP\nJnxnHLQ7QL0T4B4CDKWBKCcisriGbA6ZePWVNo4hfKQC6JrzfR+081NeD6VcWUiz\nrmd+jtPhIY4c+WVQYm5PKaN6DT1imYdxQw7aqO5j2KUCEh/cznpLxeSHoTxlR34E\nQwF28Wl3eg2vc5ct8LjU3eozWVk3gb7alx9mSA2SgmuX5lEQawl++rSjsBStemY2\nBDwOpAMXIrdEyP/cVn8mkvi/BDs5M5G+09j0gfhyCzRWMQ7Hn71u1eolRxwVxgi3\nTMn+/vTaFSqxKjgck6zuAYjBRPaHe7qLxHNr1So/Mc9nPy+3wHebFwbIcnUojwbp\n4nctkWbjb2cCAwEAAaNQME4wHQYDVR0OBBYEFP1whtcrydmW3ZJeuSoKZIKjze3w\nMB8GA1UdIwQYMBaAFP1whtcrydmW3ZJeuSoKZIKjze3wMAwGA1UdEwQFMAMBAf8w\nDQYJKoZIhvcNAQEFBQADggEBAG2erXhwRAa7+ZOBs0B6X57Hwyd1R4kfmXcs0rta\nlbPpvgULSiB+TCbf3EbhJnHGyvdCY1tvlffLjdA7HJ0PCOn+YYLBA0pTU/dyvrN6\nSu8NuS5yubnt9mb13nDGYo1rnt0YRfxN+8DM3fXIVr038A30UlPX2Ou1ExFJT0MZ\nuFKY6ZvLdI6/1cbgmguMlAhM+DhKyV6Sr5699LM3zqeI816pZmlREETYkGr91q7k\nBpXJu/dtHaGxg1ZGu6w/PCsYGUcECWENYD4VQPd8N32JjOfu6vEgoEAwfPP+3oGp\nZ4m3ewACcWOAenqflb+cQYC4PsF7qbXDmRaWrbKntOlZ3n0=\n-----END CERTIFICATE-----\n"
    },
    RedisCloudFlexible: {
      ca: "-----BEGIN CERTIFICATE-----\nMIIGMTCCBBmgAwIBAgICEAAwDQYJKoZIhvcNAQELBQAwajELMAkGA1UEBhMCVVMx\nCzAJBgNVBAgMAkNBMQswCQYDVQQHDAJDQTESMBAGA1UECgwJUmVkaXNMYWJzMS0w\nKwYDVQQDDCRSZWRpc0xhYnMgUm9vdCBDZXJ0aWZpY2F0ZSBBdXRob3JpdHkwHhcN\nMTgwMjI1MTUzNzM3WhcNMjgwMjIzMTUzNzM3WjBfMQswCQYDVQQGEwJVUzELMAkG\nA1UECAwCQ0ExEjAQBgNVBAoMCVJlZGlzTGFiczEvMC0GA1UEAwwmUkNQIEludGVy\nbWVkaWF0ZSBDZXJ0aWZpY2F0ZSBBdXRob3JpdHkwggIiMA0GCSqGSIb3DQEBAQUA\nA4ICDwAwggIKAoICAQDf9dqbxc8Bq7Ctq9rWcxrGNKKHivqLAFpPq02yLPx6fsOv\nTq7GsDChAYBBc4v7Y2Ap9RD5Vs3dIhEANcnolf27QwrG9RMnnvzk8pCvp1o6zSU4\nVuOE1W66/O1/7e2rVxyrnTcP7UgK43zNIXu7+tiAqWsO92uSnuMoGPGpeaUm1jym\nhjWKtkAwDFSqvHY+XL5qDVBEjeUe+WHkYUg40cAXjusAqgm2hZt29c2wnVrxW25W\nP0meNlzHGFdA2AC5z54iRiqj57dTfBTkHoBczQxcyw6hhzxZQ4e5I5zOKjXXEhZN\nr0tA3YC14CTabKRus/JmZieyZzRgEy2oti64tmLYTqSlAD78pRL40VNoaSYetXLw\nhhNsXCHgWaY6d5bLOc/aIQMAV5oLvZQKvuXAF1IDmhPA+bZbpWipp0zagf1P1H3s\nUzsMdn2KM0ejzgotbtNlj5TcrVwpmvE3ktvUAuA+hi3FkVx1US+2Gsp5x4YOzJ7u\nP1WPk6ShF0JgnJH2ILdj6kttTWwFzH17keSFICWDfH/+kM+k7Y1v3EXMQXE7y0T9\nMjvJskz6d/nv+sQhY04xt64xFMGTnZjlJMzfQNi7zWFLTZnDD0lPowq7l3YiPoTT\nt5Xky83lu0KZsZBo0WlWaDG00gLVdtRgVbcuSWxpi5BdLb1kRab66JptWjxwXQID\nAQABo4HrMIHoMDoGA1UdHwQzMDEwL6AtoCuGKWh0dHBzOi8vcmwtY2Etc2VydmVy\nLnJlZGlzbGFicy5jb20vdjEvY3JsMEYGCCsGAQUFBwEBBDowODA2BggrBgEFBQcw\nAYYqaHR0cHM6Ly9ybC1jYS1zZXJ2ZXIucmVkaXNsYWJzLmNvbS92MS9vY3NwMB0G\nA1UdDgQWBBQHar5OKvQUpP2qWt6mckzToeCOHDAfBgNVHSMEGDAWgBQi42wH6hM4\nL2sujEvLM0/u8lRXTzASBgNVHRMBAf8ECDAGAQH/AgEAMA4GA1UdDwEB/wQEAwIB\nhjANBgkqhkiG9w0BAQsFAAOCAgEAirEn/iTsAKyhd+pu2W3Z5NjCko4NPU0EYUbr\nAP7+POK2rzjIrJO3nFYQ/LLuC7KCXG+2qwan2SAOGmqWst13Y+WHp44Kae0kaChW\nvcYLXXSoGQGC8QuFSNUdaeg3RbMDYFT04dOkqufeWVccoHVxyTSg9eD8LZuHn5jw\n7QDLiEECBmIJHk5Eeo2TAZrx4Yx6ufSUX5HeVjlAzqwtAqdt99uCJ/EL8bgpWbe+\nXoSpvUv0SEC1I1dCAhCKAvRlIOA6VBcmzg5Am12KzkqTul12/VEFIgzqu0Zy2Jbc\nAUPrYVu/+tOGXQaijy7YgwH8P8n3s7ZeUa1VABJHcxrxYduDDJBLZi+MjheUDaZ1\njQRHYevI2tlqeSBqdPKG4zBY5lS0GiAlmuze5oENt0P3XboHoZPHiqcK3VECgTVh\n/BkJcuudETSJcZDmQ8YfoKfBzRQNg2sv/hwvUv73Ss51Sco8GEt2lD8uEdib1Q6z\nzDT5lXJowSzOD5ZA9OGDjnSRL+2riNtKWKEqvtEG3VBJoBzu9GoxbAc7wIZLxmli\niF5a/Zf5X+UXD3s4TMmy6C4QZJpAA2egsSQCnraWO2ULhh7iXMysSkF/nzVfZn43\niqpaB8++9a37hWq14ZmOv0TJIDz//b2+KC4VFXWQ5W5QC6whsjT+OlG4p5ZYG0jo\n616pxqo=\n-----END CERTIFICATE-----\n-----BEGIN CERTIFICATE-----\nMIIFujCCA6KgAwIBAgIJAJ1aTT1lu2ScMA0GCSqGSIb3DQEBCwUAMGoxCzAJBgNV\nBAYTAlVTMQswCQYDVQQIDAJDQTELMAkGA1UEBwwCQ0ExEjAQBgNVBAoMCVJlZGlz\nTGFiczEtMCsGA1UEAwwkUmVkaXNMYWJzIFJvb3QgQ2VydGlmaWNhdGUgQXV0aG9y\naXR5MB4XDTE4MDIyNTE1MjA0MloXDTM4MDIyMDE1MjA0MlowajELMAkGA1UEBhMC\nVVMxCzAJBgNVBAgMAkNBMQswCQYDVQQHDAJDQTESMBAGA1UECgwJUmVkaXNMYWJz\nMS0wKwYDVQQDDCRSZWRpc0xhYnMgUm9vdCBDZXJ0aWZpY2F0ZSBBdXRob3JpdHkw\nggIiMA0GCSqGSIb3DQEBAQUAA4ICDwAwggIKAoICAQDLEjXy7YrbN5Waau5cd6g1\nG5C2tMmeTpZ0duFAPxNU4oE3RHS5gGiok346fUXuUxbZ6QkuzeN2/2Z+RmRcJhQY\nDm0ZgdG4x59An1TJfnzKKoWj8ISmoHS/TGNBdFzXV7FYNLBuqZouqePI6ReC6Qhl\npp45huV32Q3a6IDrrvx7Wo5ZczEQeFNbCeCOQYNDdTmCyEkHqc2AGo8eoIlSTutT\nULOC7R5gzJVTS0e1hesQ7jmqHjbO+VQS1NAL4/5K6cuTEqUl+XhVhPdLWBXJQ5ag\n54qhX4v+ojLzeU1R/Vc6NjMvVtptWY6JihpgplprN0Yh2556ewcXMeturcKgXfGJ\nxeYzsjzXerEjrVocX5V8BNrg64NlifzTMKNOOv4fVZszq1SIHR8F9ROrqiOdh8iC\nJpUbLpXH9hWCSEO6VRMB2xJoKu3cgl63kF30s77x7wLFMEHiwsQRKxooE1UhgS9K\n2sO4TlQ1eWUvFvHSTVDQDlGQ6zu4qjbOpb3Q8bQwoK+ai2alkXVR4Ltxe9QlgYK3\nStsnPhruzZGA0wbXdpw0bnM+YdlEm5ffSTpNIfgHeaa7Dtb801FtA71ZlH7A6TaI\nSIQuUST9EKmv7xrJyx0W1pGoPOLw5T029aTjnICSLdtV9bLwysrLhIYG5bnPq78B\ncS+jZHFGzD7PUVGQD01nOQIDAQABo2MwYTAdBgNVHQ4EFgQUIuNsB+oTOC9rLoxL\nyzNP7vJUV08wHwYDVR0jBBgwFoAUIuNsB+oTOC9rLoxLyzNP7vJUV08wDwYDVR0T\nAQH/BAUwAwEB/zAOBgNVHQ8BAf8EBAMCAYYwDQYJKoZIhvcNAQELBQADggIBAHfg\nz5pMNUAKdMzK1aS1EDdK9yKz4qicILz5czSLj1mC7HKDRy8cVADUxEICis++CsCu\nrYOvyCVergHQLREcxPq4rc5Nq1uj6J6649NEeh4WazOOjL4ZfQ1jVznMbGy+fJm3\n3Hoelv6jWRG9iqeJZja7/1s6YC6bWymI/OY1e4wUKeNHAo+Vger7MlHV+RuabaX+\nhSJ8bJAM59NCM7AgMTQpJCncrcdLeceYniGy5Q/qt2b5mJkQVkIdy4TPGGB+AXDJ\nD0q3I/JDRkDUFNFdeW0js7fHdsvCR7O3tJy5zIgEV/o/BCkmJVtuwPYOrw/yOlKj\nTY/U7ATAx9VFF6/vYEOMYSmrZlFX+98L6nJtwDqfLB5VTltqZ4H/KBxGE3IRSt9l\nFXy40U+LnXzhhW+7VBAvyYX8GEXhHkKU8Gqk1xitrqfBXY74xKgyUSTolFSfFVgj\nmcM/X4K45bka+qpkj7Kfv/8D4j6aZekwhN2ly6hhC1SmQ8qjMjpG/mrWOSSHZFmf\nybu9iD2AYHeIOkshIl6xYIa++Q/00/vs46IzAbQyriOi0XxlSMMVtPx0Q3isp+ji\nn8Mq9eOuxYOEQ4of8twUkUDd528iwGtEdwf0Q01UyT84S62N8AySl1ZBKXJz6W4F\nUhWfa/HQYOAPDdEjNgnVwLI23b8t0TozyCWw7q8h\n-----END CERTIFICATE-----\n"
    }
  };
});

// node_modules/ioredis/built/utils/index.js
var require_utils2 = __commonJS((exports) => {
  var bufferEqual = function(a, b2) {
    if (typeof a.equals === "function") {
      return a.equals(b2);
    }
    if (a.length !== b2.length) {
      return false;
    }
    for (let i = 0;i < a.length; ++i) {
      if (a[i] !== b2[i]) {
        return false;
      }
    }
    return true;
  };
  var convertBufferToString = function(value, encoding) {
    if (value instanceof Buffer) {
      return value.toString(encoding);
    }
    if (Array.isArray(value)) {
      const length = value.length;
      const res = Array(length);
      for (let i = 0;i < length; ++i) {
        res[i] = value[i] instanceof Buffer && encoding === "utf8" ? value[i].toString() : convertBufferToString(value[i], encoding);
      }
      return res;
    }
    return value;
  };
  var wrapMultiResult = function(arr) {
    if (!arr) {
      return null;
    }
    const result2 = [];
    const length = arr.length;
    for (let i = 0;i < length; ++i) {
      const item = arr[i];
      if (item instanceof Error) {
        result2.push([item]);
      } else {
        result2.push([null, item]);
      }
    }
    return result2;
  };
  var isInt = function(value) {
    const x = parseFloat(value);
    return !isNaN(value) && (x | 0) === x;
  };
  var packObject = function(array) {
    const result2 = {};
    const length = array.length;
    for (let i = 1;i < length; i += 2) {
      result2[array[i - 1]] = array[i];
    }
    return result2;
  };
  var timeout = function(callback, timeout2) {
    let timer2;
    const run = function() {
      if (timer2) {
        clearTimeout(timer2);
        timer2 = null;
        callback.apply(this, arguments);
      }
    };
    timer2 = setTimeout(run, timeout2, new Error("timeout"));
    return run;
  };
  var convertObjectToArray = function(obj) {
    const result2 = [];
    const keys = Object.keys(obj);
    for (let i = 0, l = keys.length;i < l; i++) {
      result2.push(keys[i], obj[keys[i]]);
    }
    return result2;
  };
  var convertMapToArray = function(map) {
    const result2 = [];
    let pos = 0;
    map.forEach(function(value, key) {
      result2[pos] = key;
      result2[pos + 1] = value;
      pos += 2;
    });
    return result2;
  };
  var toArg = function(arg) {
    if (arg === null || typeof arg === "undefined") {
      return "";
    }
    return String(arg);
  };
  var optimizeErrorStack = function(error, friendlyStack, filterPath) {
    const stacks = friendlyStack.split("\n");
    let lines = "";
    let i;
    for (i = 1;i < stacks.length; ++i) {
      if (stacks[i].indexOf(filterPath) === -1) {
        break;
      }
    }
    for (let j = i;j < stacks.length; ++j) {
      lines += "\n" + stacks[j];
    }
    const pos = error.stack.indexOf("\n");
    error.stack = error.stack.slice(0, pos) + lines;
    return error;
  };
  var parseURL = function(url7) {
    if (isInt(url7)) {
      return { port: url7 };
    }
    let parsed = url_1.parse(url7, true, true);
    if (!parsed.slashes && url7[0] !== "/") {
      url7 = "//" + url7;
      parsed = url_1.parse(url7, true, true);
    }
    const options = parsed.query || {};
    const allowUsernameInURI = options.allowUsernameInURI && options.allowUsernameInURI !== "false";
    delete options.allowUsernameInURI;
    const result2 = {};
    if (parsed.auth) {
      const index = parsed.auth.indexOf(":");
      if (allowUsernameInURI) {
        result2.username = index === -1 ? parsed.auth : parsed.auth.slice(0, index);
      }
      result2.password = index === -1 ? "" : parsed.auth.slice(index + 1);
    }
    if (parsed.pathname) {
      if (parsed.protocol === "redis:" || parsed.protocol === "rediss:") {
        if (parsed.pathname.length > 1) {
          result2.db = parsed.pathname.slice(1);
        }
      } else {
        result2.path = parsed.pathname;
      }
    }
    if (parsed.host) {
      result2.host = parsed.hostname;
    }
    if (parsed.port) {
      result2.port = parsed.port;
    }
    lodash_1.defaults(result2, options);
    return result2;
  };
  var resolveTLSProfile = function(options) {
    let tls2 = options === null || options === undefined ? undefined : options.tls;
    if (typeof tls2 === "string")
      tls2 = { profile: tls2 };
    const profile = TLSProfiles_1.default[tls2 === null || tls2 === undefined ? undefined : tls2.profile];
    if (profile) {
      tls2 = Object.assign({}, profile, tls2);
      delete tls2.profile;
      options = Object.assign({}, options, { tls: tls2 });
    }
    return options;
  };
  var sample = function(array, from = 0) {
    const length = array.length;
    if (from >= length) {
      return;
    }
    return array[from + Math.floor(Math.random() * (length - from))];
  };
  var shuffle = function(array) {
    let counter = array.length;
    while (counter > 0) {
      const index = Math.floor(Math.random() * counter);
      counter--;
      [array[counter], array[index]] = [array[index], array[counter]];
    }
    return array;
  };
  var zipMap = function(keys, values2) {
    const map = new Map;
    keys.forEach((key, index) => {
      map.set(key, values2[index]);
    });
    return map;
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  var url_1 = __require("url");
  var lodash_1 = require_lodash4();
  exports.defaults = lodash_1.defaults;
  exports.noop = lodash_1.noop;
  exports.flatten = lodash_1.flatten;
  var debug_1 = require_debug();
  exports.Debug = debug_1.default;
  var TLSProfiles_1 = require_TLSProfiles();
  exports.bufferEqual = bufferEqual;
  exports.convertBufferToString = convertBufferToString;
  exports.wrapMultiResult = wrapMultiResult;
  exports.isInt = isInt;
  exports.packObject = packObject;
  exports.timeout = timeout;
  exports.convertObjectToArray = convertObjectToArray;
  exports.convertMapToArray = convertMapToArray;
  exports.toArg = toArg;
  exports.optimizeErrorStack = optimizeErrorStack;
  exports.parseURL = parseURL;
  exports.resolveTLSProfile = resolveTLSProfile;
  exports.sample = sample;
  exports.shuffle = shuffle;
  exports.CONNECTION_CLOSED_ERROR_MSG = "Connection is closed.";
  exports.zipMap = zipMap;
});

// node_modules/ioredis/built/promiseContainer.js
var require_promiseContainer = __commonJS((exports) => {
  var isPromise = function(obj) {
    return !!obj && (typeof obj === "object" || typeof obj === "function") && typeof obj.then === "function";
  };
  var get = function() {
    return promise;
  };
  var set = function(lib) {
    if (typeof lib !== "function") {
      throw new Error(`Provided Promise must be a function, got ${lib}`);
    }
    promise = lib;
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.isPromise = isPromise;
  var promise = Promise;
  exports.get = get;
  exports.set = set;
});

// node_modules/ioredis/built/command.js
var require_command = __commonJS((exports) => {
  var __dirname = "/Users/dipesh/Library/Mobile Documents/com~apple~CloudDocs/Projects/bun/railway_poc/backend_api/node_modules/ioredis/built";
  Object.defineProperty(exports, "__esModule", { value: true });
  var commands = require_redis_commands();
  var calculateSlot = require_lib();
  var standard_as_callback_1 = require_built();
  var utils_1 = require_utils2();
  var lodash_1 = require_lodash4();
  var promiseContainer_1 = require_promiseContainer();

  class Command {
    constructor(name, args = [], options = {}, callback) {
      this.name = name;
      this.transformed = false;
      this.isCustomCommand = false;
      this.inTransaction = false;
      this.isResolved = false;
      this.replyEncoding = options.replyEncoding;
      this.errorStack = options.errorStack;
      this.args = lodash_1.flatten(args);
      this.callback = callback;
      this.initPromise();
      if (options.keyPrefix) {
        this._iterateKeys((key) => options.keyPrefix + key);
      }
      if (options.readOnly) {
        this.isReadOnly = true;
      }
    }
    static getFlagMap() {
      if (!this.flagMap) {
        this.flagMap = Object.keys(Command.FLAGS).reduce((map, flagName) => {
          map[flagName] = {};
          Command.FLAGS[flagName].forEach((commandName) => {
            map[flagName][commandName] = true;
          });
          return map;
        }, {});
      }
      return this.flagMap;
    }
    static checkFlag(flagName, commandName) {
      return !!this.getFlagMap()[flagName][commandName];
    }
    static setArgumentTransformer(name, func) {
      this._transformer.argument[name] = func;
    }
    static setReplyTransformer(name, func) {
      this._transformer.reply[name] = func;
    }
    initPromise() {
      const Promise2 = promiseContainer_1.get();
      const promise = new Promise2((resolve, reject) => {
        if (!this.transformed) {
          this.transformed = true;
          const transformer = Command._transformer.argument[this.name];
          if (transformer) {
            this.args = transformer(this.args);
          }
          this.stringifyArguments();
        }
        this.resolve = this._convertValue(resolve);
        if (this.errorStack) {
          this.reject = (err) => {
            reject(utils_1.optimizeErrorStack(err, this.errorStack.stack, __dirname));
          };
        } else {
          this.reject = reject;
        }
      });
      this.promise = standard_as_callback_1.default(promise, this.callback);
    }
    getSlot() {
      if (typeof this.slot === "undefined") {
        const key = this.getKeys()[0];
        this.slot = key == null ? null : calculateSlot(key);
      }
      return this.slot;
    }
    getKeys() {
      return this._iterateKeys();
    }
    _iterateKeys(transform = (key) => key) {
      if (typeof this.keys === "undefined") {
        this.keys = [];
        if (commands.exists(this.name)) {
          const keyIndexes = commands.getKeyIndexes(this.name, this.args);
          for (const index of keyIndexes) {
            this.args[index] = transform(this.args[index]);
            this.keys.push(this.args[index]);
          }
        }
      }
      return this.keys;
    }
    toWritable() {
      let bufferMode = false;
      for (const arg of this.args) {
        if (arg instanceof Buffer) {
          bufferMode = true;
          break;
        }
      }
      let result2;
      const commandStr = "*" + (this.args.length + 1) + "\r\n$" + Buffer.byteLength(this.name) + "\r\n" + this.name + "\r\n";
      if (bufferMode) {
        const buffers = new MixedBuffers;
        buffers.push(commandStr);
        for (const arg of this.args) {
          if (arg instanceof Buffer) {
            if (arg.length === 0) {
              buffers.push("$0\r\n\r\n");
            } else {
              buffers.push("$" + arg.length + "\r\n");
              buffers.push(arg);
              buffers.push("\r\n");
            }
          } else {
            buffers.push("$" + Buffer.byteLength(arg) + "\r\n" + arg + "\r\n");
          }
        }
        result2 = buffers.toBuffer();
      } else {
        result2 = commandStr;
        for (const arg of this.args) {
          result2 += "$" + Buffer.byteLength(arg) + "\r\n" + arg + "\r\n";
        }
      }
      return result2;
    }
    stringifyArguments() {
      for (let i = 0;i < this.args.length; ++i) {
        const arg = this.args[i];
        if (!(arg instanceof Buffer) && typeof arg !== "string") {
          this.args[i] = utils_1.toArg(arg);
        }
      }
    }
    _convertValue(resolve) {
      return (value) => {
        try {
          const existingTimer = this._commandTimeoutTimer;
          if (existingTimer) {
            clearTimeout(existingTimer);
            delete this._commandTimeoutTimer;
          }
          resolve(this.transformReply(value));
          this.isResolved = true;
        } catch (err) {
          this.reject(err);
        }
        return this.promise;
      };
    }
    transformReply(result2) {
      if (this.replyEncoding) {
        result2 = utils_1.convertBufferToString(result2, this.replyEncoding);
      }
      const transformer = Command._transformer.reply[this.name];
      if (transformer) {
        result2 = transformer(result2);
      }
      return result2;
    }
    setTimeout(ms) {
      if (!this._commandTimeoutTimer) {
        this._commandTimeoutTimer = setTimeout(() => {
          if (!this.isResolved) {
            this.reject(new Error("Command timed out"));
          }
        }, ms);
      }
    }
  }
  exports.default = Command;
  Command.FLAGS = {
    VALID_IN_SUBSCRIBER_MODE: [
      "subscribe",
      "psubscribe",
      "unsubscribe",
      "punsubscribe",
      "ping",
      "quit"
    ],
    VALID_IN_MONITOR_MODE: ["monitor", "auth"],
    ENTER_SUBSCRIBER_MODE: ["subscribe", "psubscribe"],
    EXIT_SUBSCRIBER_MODE: ["unsubscribe", "punsubscribe"],
    WILL_DISCONNECT: ["quit"]
  };
  Command._transformer = {
    argument: {},
    reply: {}
  };
  var msetArgumentTransformer = function(args) {
    if (args.length === 1) {
      if (typeof Map !== "undefined" && args[0] instanceof Map) {
        return utils_1.convertMapToArray(args[0]);
      }
      if (typeof args[0] === "object" && args[0] !== null) {
        return utils_1.convertObjectToArray(args[0]);
      }
    }
    return args;
  };
  var hsetArgumentTransformer = function(args) {
    if (args.length === 2) {
      if (typeof Map !== "undefined" && args[1] instanceof Map) {
        return [args[0]].concat(utils_1.convertMapToArray(args[1]));
      }
      if (typeof args[1] === "object" && args[1] !== null) {
        return [args[0]].concat(utils_1.convertObjectToArray(args[1]));
      }
    }
    return args;
  };
  Command.setArgumentTransformer("mset", msetArgumentTransformer);
  Command.setArgumentTransformer("msetnx", msetArgumentTransformer);
  Command.setArgumentTransformer("hset", hsetArgumentTransformer);
  Command.setArgumentTransformer("hmset", hsetArgumentTransformer);
  Command.setReplyTransformer("hgetall", function(result2) {
    if (Array.isArray(result2)) {
      const obj = {};
      for (let i = 0;i < result2.length; i += 2) {
        const key = result2[i];
        const value = result2[i + 1];
        if (key in obj) {
          Object.defineProperty(obj, key, {
            value,
            configurable: true,
            enumerable: true,
            writable: true
          });
        } else {
          obj[key] = value;
        }
      }
      return obj;
    }
    return result2;
  });

  class MixedBuffers {
    constructor() {
      this.length = 0;
      this.items = [];
    }
    push(x) {
      this.length += Buffer.byteLength(x);
      this.items.push(x);
    }
    toBuffer() {
      const result2 = Buffer.allocUnsafe(this.length);
      let offset = 0;
      for (const item of this.items) {
        const length = Buffer.byteLength(item);
        Buffer.isBuffer(item) ? item.copy(result2, offset) : result2.write(item, offset, length);
        offset += length;
      }
      return result2;
    }
  }
});

// node_modules/ioredis/built/script.js
var require_script = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  var crypto_1 = __require("crypto");
  var promiseContainer_1 = require_promiseContainer();
  var command_1 = require_command();
  var standard_as_callback_1 = require_built();

  class Script {
    constructor(lua, numberOfKeys = null, keyPrefix = "", readOnly = false) {
      this.lua = lua;
      this.numberOfKeys = numberOfKeys;
      this.keyPrefix = keyPrefix;
      this.readOnly = readOnly;
      this.sha = crypto_1.createHash("sha1").update(lua).digest("hex");
    }
    execute(container, args, options, callback) {
      if (typeof this.numberOfKeys === "number") {
        args.unshift(this.numberOfKeys);
      }
      if (this.keyPrefix) {
        options.keyPrefix = this.keyPrefix;
      }
      if (this.readOnly) {
        options.readOnly = true;
      }
      const evalsha = new command_1.default("evalsha", [this.sha].concat(args), options);
      evalsha.isCustomCommand = true;
      const result2 = container.sendCommand(evalsha);
      if (promiseContainer_1.isPromise(result2)) {
        return standard_as_callback_1.default(result2.catch((err) => {
          if (err.toString().indexOf("NOSCRIPT") === -1) {
            throw err;
          }
          return container.sendCommand(new command_1.default("eval", [this.lua].concat(args), options));
        }), callback);
      }
      standard_as_callback_1.default(evalsha.promise, callback);
      return result2;
    }
  }
  exports.default = Script;
});

// node_modules/ioredis/built/autoPipelining.js
var require_autoPipelining = __commonJS((exports) => {
  var executeAutoPipeline = function(client, slotKey) {
    if (client._runningAutoPipelines.has(slotKey)) {
      return;
    }
    if (!client._autoPipelines.has(slotKey)) {
      return;
    }
    client._runningAutoPipelines.add(slotKey);
    const pipeline = client._autoPipelines.get(slotKey);
    client._autoPipelines.delete(slotKey);
    const callbacks = pipeline[exports.kCallbacks];
    pipeline[exports.kCallbacks] = null;
    pipeline.exec(function(err, results) {
      client._runningAutoPipelines.delete(slotKey);
      if (err) {
        for (let i = 0;i < callbacks.length; i++) {
          process.nextTick(callbacks[i], err);
        }
      } else {
        for (let i = 0;i < callbacks.length; i++) {
          process.nextTick(callbacks[i], ...results[i]);
        }
      }
      if (client._autoPipelines.has(slotKey)) {
        executeAutoPipeline(client, slotKey);
      }
    });
  };
  var shouldUseAutoPipelining = function(client, functionName, commandName) {
    return functionName && client.options.enableAutoPipelining && !client.isPipeline && !exports.notAllowedAutoPipelineCommands.includes(commandName) && !client.options.autoPipeliningIgnoredCommands.includes(commandName);
  };
  var getFirstValueInFlattenedArray = function(args) {
    for (let i = 0;i < args.length; i++) {
      const arg = args[i];
      if (typeof arg === "string") {
        return arg;
      } else if (Array.isArray(arg) || lodash_1.isArguments(arg)) {
        if (arg.length === 0) {
          continue;
        }
        return arg[0];
      }
      const flattened = lodash_1.flatten([arg]);
      if (flattened.length > 0) {
        return flattened[0];
      }
    }
    return;
  };
  var executeWithAutoPipelining = function(client, functionName, commandName, args, callback) {
    const CustomPromise = PromiseContainer.get();
    if (client.isCluster && !client.slots.length) {
      if (client.status === "wait")
        client.connect().catch(lodash_1.noop);
      return standard_as_callback_1.default(new CustomPromise(function(resolve, reject) {
        client.delayUntilReady((err) => {
          if (err) {
            reject(err);
            return;
          }
          executeWithAutoPipelining(client, functionName, commandName, args, null).then(resolve, reject);
        });
      }), callback);
    }
    const prefix = client.options.keyPrefix || "";
    const slotKey = client.isCluster ? client.slots[calculateSlot(`${prefix}${getFirstValueInFlattenedArray(args)}`)].join(",") : "main";
    if (!client._autoPipelines.has(slotKey)) {
      const pipeline2 = client.pipeline();
      pipeline2[exports.kExec] = false;
      pipeline2[exports.kCallbacks] = [];
      client._autoPipelines.set(slotKey, pipeline2);
    }
    const pipeline = client._autoPipelines.get(slotKey);
    if (!pipeline[exports.kExec]) {
      pipeline[exports.kExec] = true;
      setImmediate(executeAutoPipeline, client, slotKey);
    }
    const autoPipelinePromise = new CustomPromise(function(resolve, reject) {
      pipeline[exports.kCallbacks].push(function(err, value) {
        if (err) {
          reject(err);
          return;
        }
        resolve(value);
      });
      pipeline[functionName](...args);
    });
    return standard_as_callback_1.default(autoPipelinePromise, callback);
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  var PromiseContainer = require_promiseContainer();
  var lodash_1 = require_lodash4();
  var calculateSlot = require_lib();
  var standard_as_callback_1 = require_built();
  exports.kExec = Symbol("exec");
  exports.kCallbacks = Symbol("callbacks");
  exports.notAllowedAutoPipelineCommands = [
    "auth",
    "info",
    "script",
    "quit",
    "cluster",
    "pipeline",
    "multi",
    "subscribe",
    "psubscribe",
    "unsubscribe",
    "unpsubscribe"
  ];
  exports.shouldUseAutoPipelining = shouldUseAutoPipelining;
  exports.getFirstValueInFlattenedArray = getFirstValueInFlattenedArray;
  exports.executeWithAutoPipelining = executeWithAutoPipelining;
});

// node_modules/ioredis/built/commander.js
var require_commander = __commonJS((exports) => {
  var Commander = function() {
    this.options = lodash_1.defaults({}, this.options || {}, {
      showFriendlyErrorStack: false
    });
    this.scriptsSet = {};
    this.addedBuiltinSet = new Set;
  };
  var generateFunction = function(functionName, _commandName, _encoding) {
    if (typeof _encoding === "undefined") {
      _encoding = _commandName;
      _commandName = null;
    }
    return function(...args) {
      const commandName = _commandName || args.shift();
      let callback = args[args.length - 1];
      if (typeof callback === "function") {
        args.pop();
      } else {
        callback = undefined;
      }
      const options = {
        errorStack: this.options.showFriendlyErrorStack ? new Error : undefined,
        keyPrefix: this.options.keyPrefix,
        replyEncoding: _encoding
      };
      if (this.options.dropBufferSupport && !_encoding) {
        return standard_as_callback_1.default(PromiseContainer.get().reject(new Error(DROP_BUFFER_SUPPORT_ERROR)), callback);
      }
      if (!autoPipelining_1.shouldUseAutoPipelining(this, functionName, commandName)) {
        return this.sendCommand(new command_1.default(commandName, args, options, callback));
      }
      return autoPipelining_1.executeWithAutoPipelining(this, functionName, commandName, args, callback);
    };
  };
  var generateScriptingFunction = function(functionName, commandName, script, encoding) {
    return function() {
      let length = arguments.length;
      const lastArgIndex = length - 1;
      let callback = arguments[lastArgIndex];
      if (typeof callback !== "function") {
        callback = undefined;
      } else {
        length = lastArgIndex;
      }
      const args = new Array(length);
      for (let i = 0;i < length; i++) {
        args[i] = arguments[i];
      }
      let options;
      if (this.options.dropBufferSupport) {
        if (!encoding) {
          return standard_as_callback_1.default(PromiseContainer.get().reject(new Error(DROP_BUFFER_SUPPORT_ERROR)), callback);
        }
        options = { replyEncoding: null };
      } else {
        options = { replyEncoding: encoding };
      }
      if (this.options.showFriendlyErrorStack) {
        options.errorStack = new Error;
      }
      if (!autoPipelining_1.shouldUseAutoPipelining(this, functionName, commandName)) {
        return script.execute(this, args, options, callback);
      }
      return autoPipelining_1.executeWithAutoPipelining(this, functionName, commandName, args, callback);
    };
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  var lodash_1 = require_lodash4();
  var command_1 = require_command();
  var script_1 = require_script();
  var PromiseContainer = require_promiseContainer();
  var standard_as_callback_1 = require_built();
  var autoPipelining_1 = require_autoPipelining();
  var DROP_BUFFER_SUPPORT_ERROR = '*Buffer methods are not available because "dropBufferSupport" option is enabled.Refer to https://github.com/luin/ioredis/wiki/Improve-Performance for more details.';
  exports.default = Commander;
  var commands = require_redis_commands().list.filter(function(command) {
    return command !== "monitor";
  });
  commands.push("sentinel");
  Commander.prototype.getBuiltinCommands = function() {
    return commands.slice(0);
  };
  Commander.prototype.createBuiltinCommand = function(commandName) {
    return {
      string: generateFunction(null, commandName, "utf8"),
      buffer: generateFunction(null, commandName, null)
    };
  };
  Commander.prototype.addBuiltinCommand = function(commandName) {
    this.addedBuiltinSet.add(commandName);
    this[commandName] = generateFunction(commandName, commandName, "utf8");
    this[commandName + "Buffer"] = generateFunction(commandName + "Buffer", commandName, null);
  };
  commands.forEach(function(commandName) {
    Commander.prototype[commandName] = generateFunction(commandName, commandName, "utf8");
    Commander.prototype[commandName + "Buffer"] = generateFunction(commandName + "Buffer", commandName, null);
  });
  Commander.prototype.call = generateFunction("call", "utf8");
  Commander.prototype.callBuffer = generateFunction("callBuffer", null);
  Commander.prototype.send_command = Commander.prototype.call;
  Commander.prototype.defineCommand = function(name, definition) {
    const script = new script_1.default(definition.lua, definition.numberOfKeys, this.options.keyPrefix, definition.readOnly);
    this.scriptsSet[name] = script;
    this[name] = generateScriptingFunction(name, name, script, "utf8");
    this[name + "Buffer"] = generateScriptingFunction(name + "Buffer", name, script, null);
  };
  Commander.prototype.sendCommand = function() {
  };
});

// node_modules/redis-errors/lib/old.js
var require_old = __commonJS((exports, module) => {
  var RedisError = function(message2) {
    Object.defineProperty(this, "message", {
      value: message2 || "",
      configurable: true,
      writable: true
    });
    Error.captureStackTrace(this, this.constructor);
  };
  var ParserError = function(message2, buffer2, offset) {
    assert(buffer2);
    assert.strictEqual(typeof offset, "number");
    Object.defineProperty(this, "message", {
      value: message2 || "",
      configurable: true,
      writable: true
    });
    const tmp = Error.stackTraceLimit;
    Error.stackTraceLimit = 2;
    Error.captureStackTrace(this, this.constructor);
    Error.stackTraceLimit = tmp;
    this.offset = offset;
    this.buffer = buffer2;
  };
  var ReplyError = function(message2) {
    Object.defineProperty(this, "message", {
      value: message2 || "",
      configurable: true,
      writable: true
    });
    const tmp = Error.stackTraceLimit;
    Error.stackTraceLimit = 2;
    Error.captureStackTrace(this, this.constructor);
    Error.stackTraceLimit = tmp;
  };
  var AbortError = function(message2) {
    Object.defineProperty(this, "message", {
      value: message2 || "",
      configurable: true,
      writable: true
    });
    Error.captureStackTrace(this, this.constructor);
  };
  var InterruptError = function(message2) {
    Object.defineProperty(this, "message", {
      value: message2 || "",
      configurable: true,
      writable: true
    });
    Error.captureStackTrace(this, this.constructor);
  };
  var assert = __require("assert");
  var util3 = __require("util");
  util3.inherits(RedisError, Error);
  Object.defineProperty(RedisError.prototype, "name", {
    value: "RedisError",
    configurable: true,
    writable: true
  });
  util3.inherits(ParserError, RedisError);
  Object.defineProperty(ParserError.prototype, "name", {
    value: "ParserError",
    configurable: true,
    writable: true
  });
  util3.inherits(ReplyError, RedisError);
  Object.defineProperty(ReplyError.prototype, "name", {
    value: "ReplyError",
    configurable: true,
    writable: true
  });
  util3.inherits(AbortError, RedisError);
  Object.defineProperty(AbortError.prototype, "name", {
    value: "AbortError",
    configurable: true,
    writable: true
  });
  util3.inherits(InterruptError, AbortError);
  Object.defineProperty(InterruptError.prototype, "name", {
    value: "InterruptError",
    configurable: true,
    writable: true
  });
  module.exports = {
    RedisError,
    ParserError,
    ReplyError,
    AbortError,
    InterruptError
  };
});

// node_modules/redis-errors/lib/modern.js
var require_modern = __commonJS((exports, module) => {
  var assert = __require("assert");

  class RedisError extends Error {
    get name() {
      return this.constructor.name;
    }
  }

  class ParserError extends RedisError {
    constructor(message2, buffer2, offset) {
      assert(buffer2);
      assert.strictEqual(typeof offset, "number");
      const tmp = Error.stackTraceLimit;
      Error.stackTraceLimit = 2;
      super(message2);
      Error.stackTraceLimit = tmp;
      this.offset = offset;
      this.buffer = buffer2;
    }
    get name() {
      return this.constructor.name;
    }
  }

  class ReplyError extends RedisError {
    constructor(message2) {
      const tmp = Error.stackTraceLimit;
      Error.stackTraceLimit = 2;
      super(message2);
      Error.stackTraceLimit = tmp;
    }
    get name() {
      return this.constructor.name;
    }
  }

  class AbortError extends RedisError {
    get name() {
      return this.constructor.name;
    }
  }

  class InterruptError extends AbortError {
    get name() {
      return this.constructor.name;
    }
  }
  module.exports = {
    RedisError,
    ParserError,
    ReplyError,
    AbortError,
    InterruptError
  };
});

// node_modules/redis-errors/index.js
var require_redis_errors = __commonJS((exports, module) => {
  var Errors2 = process.version.charCodeAt(1) < 55 && process.version.charCodeAt(2) === 46 ? require_old() : require_modern();
  module.exports = Errors2;
});

// node_modules/ioredis/built/errors/MaxRetriesPerRequestError.js
var require_MaxRetriesPerRequestError = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  var redis_errors_1 = require_redis_errors();

  class MaxRetriesPerRequestError extends redis_errors_1.AbortError {
    constructor(maxRetriesPerRequest) {
      const message2 = `Reached the max retries per request limit (which is ${maxRetriesPerRequest}). Refer to "maxRetriesPerRequest" option for details.`;
      super(message2);
      Error.captureStackTrace(this, this.constructor);
    }
    get name() {
      return this.constructor.name;
    }
  }
  exports.default = MaxRetriesPerRequestError;
});

// node_modules/ioredis/built/errors/index.js
var require_errors = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  var MaxRetriesPerRequestError_1 = require_MaxRetriesPerRequestError();
  exports.MaxRetriesPerRequestError = MaxRetriesPerRequestError_1.default;
});

// node_modules/redis-parser/lib/parser.js
var require_parser = __commonJS((exports, module) => {
  var parseSimpleNumbers = function(parser) {
    const length = parser.buffer.length - 1;
    var offset = parser.offset;
    var number = 0;
    var sign7 = 1;
    if (parser.buffer[offset] === 45) {
      sign7 = -1;
      offset++;
    }
    while (offset < length) {
      const c1 = parser.buffer[offset++];
      if (c1 === 13) {
        parser.offset = offset + 1;
        return sign7 * number;
      }
      number = number * 10 + (c1 - 48);
    }
  };
  var parseStringNumbers = function(parser) {
    const length = parser.buffer.length - 1;
    var offset = parser.offset;
    var number = 0;
    var res = "";
    if (parser.buffer[offset] === 45) {
      res += "-";
      offset++;
    }
    while (offset < length) {
      var c1 = parser.buffer[offset++];
      if (c1 === 13) {
        parser.offset = offset + 1;
        if (number !== 0) {
          res += number;
        }
        return res;
      } else if (number > 429496728) {
        res += number * 10 + (c1 - 48);
        number = 0;
      } else if (c1 === 48 && number === 0) {
        res += 0;
      } else {
        number = number * 10 + (c1 - 48);
      }
    }
  };
  var parseSimpleString = function(parser) {
    const start = parser.offset;
    const buffer2 = parser.buffer;
    const length = buffer2.length - 1;
    var offset = start;
    while (offset < length) {
      if (buffer2[offset++] === 13) {
        parser.offset = offset + 1;
        if (parser.optionReturnBuffers === true) {
          return parser.buffer.slice(start, offset - 1);
        }
        return parser.buffer.toString("utf8", start, offset - 1);
      }
    }
  };
  var parseLength = function(parser) {
    const length = parser.buffer.length - 1;
    var offset = parser.offset;
    var number = 0;
    while (offset < length) {
      const c1 = parser.buffer[offset++];
      if (c1 === 13) {
        parser.offset = offset + 1;
        return number;
      }
      number = number * 10 + (c1 - 48);
    }
  };
  var parseInteger = function(parser) {
    if (parser.optionStringNumbers === true) {
      return parseStringNumbers(parser);
    }
    return parseSimpleNumbers(parser);
  };
  var parseBulkString = function(parser) {
    const length = parseLength(parser);
    if (length === undefined) {
      return;
    }
    if (length < 0) {
      return null;
    }
    const offset = parser.offset + length;
    if (offset + 2 > parser.buffer.length) {
      parser.bigStrSize = offset + 2;
      parser.totalChunkSize = parser.buffer.length;
      parser.bufferCache.push(parser.buffer);
      return;
    }
    const start = parser.offset;
    parser.offset = offset + 2;
    if (parser.optionReturnBuffers === true) {
      return parser.buffer.slice(start, offset);
    }
    return parser.buffer.toString("utf8", start, offset);
  };
  var parseError2 = function(parser) {
    var string = parseSimpleString(parser);
    if (string !== undefined) {
      if (parser.optionReturnBuffers === true) {
        string = string.toString();
      }
      return new ReplyError(string);
    }
  };
  var handleError = function(parser, type) {
    const err = new ParserError("Protocol error, got " + JSON.stringify(String.fromCharCode(type)) + " as reply type byte", JSON.stringify(parser.buffer), parser.offset);
    parser.buffer = null;
    parser.returnFatalError(err);
  };
  var parseArray = function(parser) {
    const length = parseLength(parser);
    if (length === undefined) {
      return;
    }
    if (length < 0) {
      return null;
    }
    const responses = new Array(length);
    return parseArrayElements(parser, responses, 0);
  };
  var pushArrayCache = function(parser, array, pos) {
    parser.arrayCache.push(array);
    parser.arrayPos.push(pos);
  };
  var parseArrayChunks = function(parser) {
    const tmp = parser.arrayCache.pop();
    var pos = parser.arrayPos.pop();
    if (parser.arrayCache.length) {
      const res = parseArrayChunks(parser);
      if (res === undefined) {
        pushArrayCache(parser, tmp, pos);
        return;
      }
      tmp[pos++] = res;
    }
    return parseArrayElements(parser, tmp, pos);
  };
  var parseArrayElements = function(parser, responses, i) {
    const bufferLength = parser.buffer.length;
    while (i < responses.length) {
      const offset = parser.offset;
      if (parser.offset >= bufferLength) {
        pushArrayCache(parser, responses, i);
        return;
      }
      const response = parseType(parser, parser.buffer[parser.offset++]);
      if (response === undefined) {
        if (!(parser.arrayCache.length || parser.bufferCache.length)) {
          parser.offset = offset;
        }
        pushArrayCache(parser, responses, i);
        return;
      }
      responses[i] = response;
      i++;
    }
    return responses;
  };
  var parseType = function(parser, type) {
    switch (type) {
      case 36:
        return parseBulkString(parser);
      case 43:
        return parseSimpleString(parser);
      case 42:
        return parseArray(parser);
      case 58:
        return parseInteger(parser);
      case 45:
        return parseError2(parser);
      default:
        return handleError(parser, type);
    }
  };
  var decreaseBufferPool = function() {
    if (bufferPool.length > 50 * 1024) {
      if (counter === 1 || notDecreased > counter * 2) {
        const minSliceLen = Math.floor(bufferPool.length / 10);
        const sliceLength = minSliceLen < bufferOffset ? bufferOffset : minSliceLen;
        bufferOffset = 0;
        bufferPool = bufferPool.slice(sliceLength, bufferPool.length);
      } else {
        notDecreased++;
        counter--;
      }
    } else {
      clearInterval(interval);
      counter = 0;
      notDecreased = 0;
      interval = null;
    }
  };
  var resizeBuffer = function(length) {
    if (bufferPool.length < length + bufferOffset) {
      const multiplier = length > 1024 * 1024 * 75 ? 2 : 3;
      if (bufferOffset > 1024 * 1024 * 111) {
        bufferOffset = 1024 * 1024 * 50;
      }
      bufferPool = Buffer4.allocUnsafe(length * multiplier + bufferOffset);
      bufferOffset = 0;
      counter++;
      if (interval === null) {
        interval = setInterval(decreaseBufferPool, 50);
      }
    }
  };
  var concatBulkString = function(parser) {
    const list = parser.bufferCache;
    const oldOffset = parser.offset;
    var chunks = list.length;
    var offset = parser.bigStrSize - parser.totalChunkSize;
    parser.offset = offset;
    if (offset <= 2) {
      if (chunks === 2) {
        return list[0].toString("utf8", oldOffset, list[0].length + offset - 2);
      }
      chunks--;
      offset = list[list.length - 2].length + offset;
    }
    var res = decoder2.write(list[0].slice(oldOffset));
    for (var i = 1;i < chunks - 1; i++) {
      res += decoder2.write(list[i]);
    }
    res += decoder2.end(list[i].slice(0, offset - 2));
    return res;
  };
  var concatBulkBuffer = function(parser) {
    const list = parser.bufferCache;
    const oldOffset = parser.offset;
    const length = parser.bigStrSize - oldOffset - 2;
    var chunks = list.length;
    var offset = parser.bigStrSize - parser.totalChunkSize;
    parser.offset = offset;
    if (offset <= 2) {
      if (chunks === 2) {
        return list[0].slice(oldOffset, list[0].length + offset - 2);
      }
      chunks--;
      offset = list[list.length - 2].length + offset;
    }
    resizeBuffer(length);
    const start = bufferOffset;
    list[0].copy(bufferPool, start, oldOffset, list[0].length);
    bufferOffset += list[0].length - oldOffset;
    for (var i = 1;i < chunks - 1; i++) {
      list[i].copy(bufferPool, bufferOffset);
      bufferOffset += list[i].length;
    }
    list[i].copy(bufferPool, bufferOffset, 0, offset - 2);
    bufferOffset += offset - 2;
    return bufferPool.slice(start, bufferOffset);
  };
  var Buffer4 = __require("buffer").Buffer;
  var StringDecoder = __require("string_decoder").StringDecoder;
  var decoder2 = new StringDecoder;
  var errors15 = require_redis_errors();
  var ReplyError = errors15.ReplyError;
  var ParserError = errors15.ParserError;
  var bufferPool = Buffer4.allocUnsafe(32 * 1024);
  var bufferOffset = 0;
  var interval = null;
  var counter = 0;
  var notDecreased = 0;

  class JavascriptRedisParser {
    constructor(options) {
      if (!options) {
        throw new TypeError("Options are mandatory.");
      }
      if (typeof options.returnError !== "function" || typeof options.returnReply !== "function") {
        throw new TypeError("The returnReply and returnError options have to be functions.");
      }
      this.setReturnBuffers(!!options.returnBuffers);
      this.setStringNumbers(!!options.stringNumbers);
      this.returnError = options.returnError;
      this.returnFatalError = options.returnFatalError || options.returnError;
      this.returnReply = options.returnReply;
      this.reset();
    }
    reset() {
      this.offset = 0;
      this.buffer = null;
      this.bigStrSize = 0;
      this.totalChunkSize = 0;
      this.bufferCache = [];
      this.arrayCache = [];
      this.arrayPos = [];
    }
    setReturnBuffers(returnBuffers) {
      if (typeof returnBuffers !== "boolean") {
        throw new TypeError("The returnBuffers argument has to be a boolean");
      }
      this.optionReturnBuffers = returnBuffers;
    }
    setStringNumbers(stringNumbers) {
      if (typeof stringNumbers !== "boolean") {
        throw new TypeError("The stringNumbers argument has to be a boolean");
      }
      this.optionStringNumbers = stringNumbers;
    }
    execute(buffer2) {
      if (this.buffer === null) {
        this.buffer = buffer2;
        this.offset = 0;
      } else if (this.bigStrSize === 0) {
        const oldLength = this.buffer.length;
        const remainingLength = oldLength - this.offset;
        const newBuffer = Buffer4.allocUnsafe(remainingLength + buffer2.length);
        this.buffer.copy(newBuffer, 0, this.offset, oldLength);
        buffer2.copy(newBuffer, remainingLength, 0, buffer2.length);
        this.buffer = newBuffer;
        this.offset = 0;
        if (this.arrayCache.length) {
          const arr = parseArrayChunks(this);
          if (arr === undefined) {
            return;
          }
          this.returnReply(arr);
        }
      } else if (this.totalChunkSize + buffer2.length >= this.bigStrSize) {
        this.bufferCache.push(buffer2);
        var tmp = this.optionReturnBuffers ? concatBulkBuffer(this) : concatBulkString(this);
        this.bigStrSize = 0;
        this.bufferCache = [];
        this.buffer = buffer2;
        if (this.arrayCache.length) {
          this.arrayCache[0][this.arrayPos[0]++] = tmp;
          tmp = parseArrayChunks(this);
          if (tmp === undefined) {
            return;
          }
        }
        this.returnReply(tmp);
      } else {
        this.bufferCache.push(buffer2);
        this.totalChunkSize += buffer2.length;
        return;
      }
      while (this.offset < this.buffer.length) {
        const offset = this.offset;
        const type = this.buffer[this.offset++];
        const response = parseType(this, type);
        if (response === undefined) {
          if (!(this.arrayCache.length || this.bufferCache.length)) {
            this.offset = offset;
          }
          return;
        }
        if (type === 45) {
          this.returnError(response);
        } else {
          this.returnReply(response);
        }
      }
      this.buffer = null;
    }
  }
  module.exports = JavascriptRedisParser;
});

// node_modules/ioredis/built/SubscriptionSet.js
var require_SubscriptionSet = __commonJS((exports) => {
  var mapSet = function(set) {
    if (set === "unsubscribe") {
      return "subscribe";
    }
    if (set === "punsubscribe") {
      return "psubscribe";
    }
    return set;
  };
  Object.defineProperty(exports, "__esModule", { value: true });

  class SubscriptionSet {
    constructor() {
      this.set = {
        subscribe: {},
        psubscribe: {}
      };
    }
    add(set, channel) {
      this.set[mapSet(set)][channel] = true;
    }
    del(set, channel) {
      delete this.set[mapSet(set)][channel];
    }
    channels(set) {
      return Object.keys(this.set[mapSet(set)]);
    }
    isEmpty() {
      return this.channels("subscribe").length === 0 && this.channels("psubscribe").length === 0;
    }
  }
  exports.default = SubscriptionSet;
});

// node_modules/ioredis/built/DataHandler.js
var require_DataHandler = __commonJS((exports) => {
  var fillSubCommand = function(command, count) {
    if (typeof command.remainReplies === "undefined") {
      command.remainReplies = command.args.length;
    }
    if (--command.remainReplies === 0) {
      command.resolve(count);
      return true;
    }
    return false;
  };
  var fillUnsubCommand = function(command, count) {
    if (typeof command.remainReplies === "undefined") {
      command.remainReplies = command.args.length;
    }
    if (command.remainReplies === 0) {
      if (count === 0) {
        command.resolve(count);
        return true;
      }
      return false;
    }
    if (--command.remainReplies === 0) {
      command.resolve(count);
      return true;
    }
    return false;
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  var command_1 = require_command();
  var utils_1 = require_utils2();
  var RedisParser = require_parser();
  var SubscriptionSet_1 = require_SubscriptionSet();
  var debug = utils_1.Debug("dataHandler");

  class DataHandler {
    constructor(redis, parserOptions) {
      this.redis = redis;
      const parser = new RedisParser({
        stringNumbers: parserOptions.stringNumbers,
        returnBuffers: !parserOptions.dropBufferSupport,
        returnError: (err) => {
          this.returnError(err);
        },
        returnFatalError: (err) => {
          this.returnFatalError(err);
        },
        returnReply: (reply) => {
          this.returnReply(reply);
        }
      });
      redis.stream.on("data", (data) => {
        parser.execute(data);
      });
    }
    returnFatalError(err) {
      err.message += ". Please report this.";
      this.redis.recoverFromFatalError(err, err, { offlineQueue: false });
    }
    returnError(err) {
      const item = this.shiftCommand(err);
      if (!item) {
        return;
      }
      err.command = {
        name: item.command.name,
        args: item.command.args
      };
      this.redis.handleReconnection(err, item);
    }
    returnReply(reply) {
      if (this.handleMonitorReply(reply)) {
        return;
      }
      if (this.handleSubscriberReply(reply)) {
        return;
      }
      const item = this.shiftCommand(reply);
      if (!item) {
        return;
      }
      if (command_1.default.checkFlag("ENTER_SUBSCRIBER_MODE", item.command.name)) {
        this.redis.condition.subscriber = new SubscriptionSet_1.default;
        this.redis.condition.subscriber.add(item.command.name, reply[1].toString());
        if (!fillSubCommand(item.command, reply[2])) {
          this.redis.commandQueue.unshift(item);
        }
      } else if (command_1.default.checkFlag("EXIT_SUBSCRIBER_MODE", item.command.name)) {
        if (!fillUnsubCommand(item.command, reply[2])) {
          this.redis.commandQueue.unshift(item);
        }
      } else {
        item.command.resolve(reply);
      }
    }
    handleSubscriberReply(reply) {
      if (!this.redis.condition.subscriber) {
        return false;
      }
      const replyType = Array.isArray(reply) ? reply[0].toString() : null;
      debug('receive reply "%s" in subscriber mode', replyType);
      switch (replyType) {
        case "message":
          if (this.redis.listeners("message").length > 0) {
            this.redis.emit("message", reply[1].toString(), reply[2] ? reply[2].toString() : "");
          }
          this.redis.emit("messageBuffer", reply[1], reply[2]);
          break;
        case "pmessage": {
          const pattern = reply[1].toString();
          if (this.redis.listeners("pmessage").length > 0) {
            this.redis.emit("pmessage", pattern, reply[2].toString(), reply[3].toString());
          }
          this.redis.emit("pmessageBuffer", pattern, reply[2], reply[3]);
          break;
        }
        case "subscribe":
        case "psubscribe": {
          const channel = reply[1].toString();
          this.redis.condition.subscriber.add(replyType, channel);
          const item = this.shiftCommand(reply);
          if (!item) {
            return;
          }
          if (!fillSubCommand(item.command, reply[2])) {
            this.redis.commandQueue.unshift(item);
          }
          break;
        }
        case "unsubscribe":
        case "punsubscribe": {
          const channel = reply[1] ? reply[1].toString() : null;
          if (channel) {
            this.redis.condition.subscriber.del(replyType, channel);
          }
          const count = reply[2];
          if (count === 0) {
            this.redis.condition.subscriber = false;
          }
          const item = this.shiftCommand(reply);
          if (!item) {
            return;
          }
          if (!fillUnsubCommand(item.command, count)) {
            this.redis.commandQueue.unshift(item);
          }
          break;
        }
        default: {
          const item = this.shiftCommand(reply);
          if (!item) {
            return;
          }
          item.command.resolve(reply);
        }
      }
      return true;
    }
    handleMonitorReply(reply) {
      if (this.redis.status !== "monitoring") {
        return false;
      }
      const replyStr = reply.toString();
      if (replyStr === "OK") {
        return false;
      }
      const len = replyStr.indexOf(" ");
      const timestamp = replyStr.slice(0, len);
      const argindex = replyStr.indexOf('"');
      const args = replyStr.slice(argindex + 1, -1).split('" "').map((elem) => elem.replace(/\\"/g, '"'));
      const dbAndSource = replyStr.slice(len + 2, argindex - 2).split(" ");
      this.redis.emit("monitor", timestamp, args, dbAndSource[1], dbAndSource[0]);
      return true;
    }
    shiftCommand(reply) {
      const item = this.redis.commandQueue.shift();
      if (!item) {
        const message2 = "Command queue state error. If you can reproduce this, please report it.";
        const error = new Error(message2 + (reply instanceof Error ? ` Last error: ${reply.message}` : ` Last reply: ${reply.toString()}`));
        this.redis.emit("error", error);
        return null;
      }
      return item;
    }
  }
  exports.default = DataHandler;
});

// node_modules/ioredis/built/redis/event_handler.js
var require_event_handler = __commonJS((exports) => {
  var connectHandler = function(self2) {
    return function() {
      self2.setStatus("connect");
      self2.resetCommandQueue();
      let flushed = false;
      const { connectionEpoch } = self2;
      if (self2.condition.auth) {
        self2.auth(self2.condition.auth, function(err) {
          if (connectionEpoch !== self2.connectionEpoch) {
            return;
          }
          if (err) {
            if (err.message.indexOf("no password is set") !== -1) {
              console.warn("[WARN] Redis server does not require a password, but a password was supplied.");
            } else if (err.message.indexOf("without any password configured for the default user") !== -1) {
              console.warn("[WARN] This Redis server's `default` user does not require a password, but a password was supplied");
            } else if (err.message.indexOf("wrong number of arguments for 'auth' command") !== -1) {
              console.warn(`[ERROR] The server returned "wrong number of arguments for 'auth' command". You are probably passing both username and password to Redis version 5 or below. You should only pass the 'password' option for Redis version 5 and under.`);
            } else {
              flushed = true;
              self2.recoverFromFatalError(err, err);
            }
          }
        });
      }
      if (self2.condition.select) {
        self2.select(self2.condition.select).catch((err) => {
          self2.silentEmit("error", err);
        });
      }
      if (!self2.options.enableReadyCheck) {
        exports.readyHandler(self2)();
      }
      new DataHandler_1.default(self2, {
        stringNumbers: self2.options.stringNumbers,
        dropBufferSupport: self2.options.dropBufferSupport
      });
      if (self2.options.enableReadyCheck) {
        self2._readyCheck(function(err, info) {
          if (connectionEpoch !== self2.connectionEpoch) {
            return;
          }
          if (err) {
            if (!flushed) {
              self2.recoverFromFatalError(new Error("Ready check failed: " + err.message), err);
            }
          } else {
            self2.serverInfo = info;
            if (self2.connector.check(info)) {
              exports.readyHandler(self2)();
            } else {
              self2.disconnect(true);
            }
          }
        });
      }
    };
  };
  var abortError = function(command) {
    const err = new redis_errors_1.AbortError("Command aborted due to connection close");
    err.command = {
      name: command.name,
      args: command.args
    };
    return err;
  };
  var abortIncompletePipelines = function(commandQueue) {
    let expectedIndex = 0;
    for (let i = 0;i < commandQueue.length; ) {
      const command = commandQueue.peekAt(i).command;
      const pipelineIndex = command.pipelineIndex;
      if (pipelineIndex === undefined || pipelineIndex === 0) {
        expectedIndex = 0;
      }
      if (pipelineIndex !== undefined && pipelineIndex !== expectedIndex++) {
        commandQueue.remove(i, 1);
        command.reject(abortError(command));
        continue;
      }
      i++;
    }
  };
  var abortTransactionFragments = function(commandQueue) {
    for (let i = 0;i < commandQueue.length; ) {
      const command = commandQueue.peekAt(i).command;
      if (command.name === "multi") {
        break;
      }
      if (command.name === "exec") {
        commandQueue.remove(i, 1);
        command.reject(abortError(command));
        break;
      }
      if (command.inTransaction) {
        commandQueue.remove(i, 1);
        command.reject(abortError(command));
      } else {
        i++;
      }
    }
  };
  var closeHandler = function(self2) {
    return function() {
      self2.setStatus("close");
      if (!self2.prevCondition) {
        self2.prevCondition = self2.condition;
      }
      if (self2.commandQueue.length) {
        abortIncompletePipelines(self2.commandQueue);
        self2.prevCommandQueue = self2.commandQueue;
      }
      if (self2.offlineQueue.length) {
        abortTransactionFragments(self2.offlineQueue);
      }
      self2.clearAddedScriptHashesCleanInterval();
      if (self2.manuallyClosing) {
        self2.manuallyClosing = false;
        debug("skip reconnecting since the connection is manually closed.");
        return close();
      }
      if (typeof self2.options.retryStrategy !== "function") {
        debug("skip reconnecting because `retryStrategy` is not a function");
        return close();
      }
      const retryDelay = self2.options.retryStrategy(++self2.retryAttempts);
      if (typeof retryDelay !== "number") {
        debug("skip reconnecting because `retryStrategy` doesn't return a number");
        return close();
      }
      debug("reconnect in %sms", retryDelay);
      self2.setStatus("reconnecting", retryDelay);
      self2.reconnectTimeout = setTimeout(function() {
        self2.reconnectTimeout = null;
        self2.connect().catch(utils_1.noop);
      }, retryDelay);
      const { maxRetriesPerRequest } = self2.options;
      if (typeof maxRetriesPerRequest === "number") {
        if (maxRetriesPerRequest < 0) {
          debug("maxRetriesPerRequest is negative, ignoring...");
        } else {
          const remainder = self2.retryAttempts % (maxRetriesPerRequest + 1);
          if (remainder === 0) {
            debug("reach maxRetriesPerRequest limitation, flushing command queue...");
            self2.flushQueue(new errors_1.MaxRetriesPerRequestError(maxRetriesPerRequest));
          }
        }
      }
    };
    function close() {
      self2.setStatus("end");
      self2.flushQueue(new Error(utils_1.CONNECTION_CLOSED_ERROR_MSG));
    }
  };
  var errorHandler2 = function(self2) {
    return function(error) {
      debug("error: %s", error);
      self2.silentEmit("error", error);
    };
  };
  var readyHandler = function(self2) {
    return function() {
      self2.setStatus("ready");
      self2.retryAttempts = 0;
      if (self2.options.monitor) {
        self2.call("monitor");
        const { sendCommand } = self2;
        self2.sendCommand = function(command) {
          if (command_1.default.checkFlag("VALID_IN_MONITOR_MODE", command.name)) {
            return sendCommand.call(self2, command);
          }
          command.reject(new Error("Connection is in monitoring mode, can't process commands."));
          return command.promise;
        };
        self2.once("close", function() {
          delete self2.sendCommand;
        });
        self2.setStatus("monitoring");
        return;
      }
      const finalSelect = self2.prevCondition ? self2.prevCondition.select : self2.condition.select;
      if (self2.options.connectionName) {
        debug("set the connection name [%s]", self2.options.connectionName);
        self2.client("setname", self2.options.connectionName).catch(utils_1.noop);
      }
      if (self2.options.readOnly) {
        debug("set the connection to readonly mode");
        self2.readonly().catch(utils_1.noop);
      }
      if (self2.prevCondition) {
        const condition = self2.prevCondition;
        self2.prevCondition = null;
        if (condition.subscriber && self2.options.autoResubscribe) {
          if (self2.condition.select !== finalSelect) {
            debug("connect to db [%d]", finalSelect);
            self2.select(finalSelect);
          }
          const subscribeChannels = condition.subscriber.channels("subscribe");
          if (subscribeChannels.length) {
            debug("subscribe %d channels", subscribeChannels.length);
            self2.subscribe(subscribeChannels);
          }
          const psubscribeChannels = condition.subscriber.channels("psubscribe");
          if (psubscribeChannels.length) {
            debug("psubscribe %d channels", psubscribeChannels.length);
            self2.psubscribe(psubscribeChannels);
          }
        }
      }
      if (self2.prevCommandQueue) {
        if (self2.options.autoResendUnfulfilledCommands) {
          debug("resend %d unfulfilled commands", self2.prevCommandQueue.length);
          while (self2.prevCommandQueue.length > 0) {
            const item = self2.prevCommandQueue.shift();
            if (item.select !== self2.condition.select && item.command.name !== "select") {
              self2.select(item.select);
            }
            self2.sendCommand(item.command, item.stream);
          }
        } else {
          self2.prevCommandQueue = null;
        }
      }
      if (self2.offlineQueue.length) {
        debug("send %d commands in offline queue", self2.offlineQueue.length);
        const offlineQueue = self2.offlineQueue;
        self2.resetOfflineQueue();
        while (offlineQueue.length > 0) {
          const item = offlineQueue.shift();
          if (item.select !== self2.condition.select && item.command.name !== "select") {
            self2.select(item.select);
          }
          self2.sendCommand(item.command, item.stream);
        }
      }
      if (self2.condition.select !== finalSelect) {
        debug("connect to db [%d]", finalSelect);
        self2.select(finalSelect);
      }
    };
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  var redis_errors_1 = require_redis_errors();
  var command_1 = require_command();
  var errors_1 = require_errors();
  var utils_1 = require_utils2();
  var DataHandler_1 = require_DataHandler();
  var debug = utils_1.Debug("connection");
  exports.connectHandler = connectHandler;
  exports.closeHandler = closeHandler;
  exports.errorHandler = errorHandler2;
  exports.readyHandler = readyHandler;
});

// node_modules/ioredis/built/connectors/AbstractConnector.js
var require_AbstractConnector = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  var utils_1 = require_utils2();
  var debug = utils_1.Debug("AbstractConnector");

  class AbstractConnector {
    constructor(disconnectTimeout) {
      this.connecting = false;
      this.disconnectTimeout = disconnectTimeout;
    }
    check(info) {
      return true;
    }
    disconnect() {
      this.connecting = false;
      if (this.stream) {
        const stream = this.stream;
        const timeout = setTimeout(() => {
          debug("stream %s:%s still open, destroying it", stream.remoteAddress, stream.remotePort);
          stream.destroy();
        }, this.disconnectTimeout);
        stream.on("close", () => clearTimeout(timeout));
        stream.end();
      }
    }
  }
  exports.default = AbstractConnector;
});

// node_modules/ioredis/built/connectors/StandaloneConnector.js
var require_StandaloneConnector = __commonJS((exports) => {
  var isIIpcConnectionOptions = function(value) {
    return value.path;
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  var net_1 = __require("net");
  var tls_1 = __require("tls");
  var utils_1 = require_utils2();
  var AbstractConnector_1 = require_AbstractConnector();
  exports.isIIpcConnectionOptions = isIIpcConnectionOptions;

  class StandaloneConnector extends AbstractConnector_1.default {
    constructor(options) {
      super(options.disconnectTimeout);
      this.options = options;
    }
    connect(_) {
      const { options } = this;
      this.connecting = true;
      let connectionOptions;
      if (isIIpcConnectionOptions(options)) {
        connectionOptions = {
          path: options.path
        };
      } else {
        connectionOptions = {};
        if (options.port != null) {
          connectionOptions.port = options.port;
        }
        if (options.host != null) {
          connectionOptions.host = options.host;
        }
        if (options.family != null) {
          connectionOptions.family = options.family;
        }
      }
      if (options.tls) {
        Object.assign(connectionOptions, options.tls);
      }
      return new Promise((resolve, reject) => {
        process.nextTick(() => {
          if (!this.connecting) {
            reject(new Error(utils_1.CONNECTION_CLOSED_ERROR_MSG));
            return;
          }
          try {
            if (options.tls) {
              this.stream = tls_1.connect(connectionOptions);
            } else {
              this.stream = net_1.createConnection(connectionOptions);
            }
          } catch (err) {
            reject(err);
            return;
          }
          this.stream.once("error", (err) => {
            this.firstError = err;
          });
          resolve(this.stream);
        });
      });
    }
  }
  exports.default = StandaloneConnector;
});

// node_modules/ioredis/built/connectors/SentinelConnector/SentinelIterator.js
var require_SentinelIterator = __commonJS((exports) => {
  var isSentinelEql = function(a, b2) {
    return (a.host || "127.0.0.1") === (b2.host || "127.0.0.1") && (a.port || 26379) === (b2.port || 26379);
  };
  Object.defineProperty(exports, "__esModule", { value: true });

  class SentinelIterator {
    constructor(sentinels) {
      this.cursor = 0;
      this.sentinels = sentinels.slice(0);
    }
    next() {
      const done = this.cursor >= this.sentinels.length;
      return { done, value: done ? undefined : this.sentinels[this.cursor++] };
    }
    reset(moveCurrentEndpointToFirst) {
      if (moveCurrentEndpointToFirst && this.sentinels.length > 1 && this.cursor !== 1) {
        this.sentinels.unshift(...this.sentinels.splice(this.cursor - 1));
      }
      this.cursor = 0;
    }
    add(sentinel) {
      for (let i = 0;i < this.sentinels.length; i++) {
        if (isSentinelEql(sentinel, this.sentinels[i])) {
          return false;
        }
      }
      this.sentinels.push(sentinel);
      return true;
    }
    toString() {
      return `${JSON.stringify(this.sentinels)} @${this.cursor}`;
    }
  }
  exports.default = SentinelIterator;
});

// node_modules/ioredis/built/connectors/SentinelConnector/FailoverDetector.js
var require_FailoverDetector = __commonJS((exports) => {
  var __awaiter = exports && exports.__awaiter || function(thisArg, _arguments, P, generator) {
    function adopt(value) {
      return value instanceof P ? value : new P(function(resolve) {
        resolve(value);
      });
    }
    return new (P || (P = Promise))(function(resolve, reject) {
      function fulfilled(value) {
        try {
          step(generator.next(value));
        } catch (e) {
          reject(e);
        }
      }
      function rejected(value) {
        try {
          step(generator["throw"](value));
        } catch (e) {
          reject(e);
        }
      }
      function step(result2) {
        result2.done ? resolve(result2.value) : adopt(result2.value).then(fulfilled, rejected);
      }
      step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  var utils_1 = require_utils2();
  var debug = utils_1.Debug("FailoverDetector");
  var CHANNEL_NAME = "+switch-master";

  class FailoverDetector {
    constructor(connector, sentinels) {
      this.isDisconnected = false;
      this.connector = connector;
      this.sentinels = sentinels;
    }
    cleanup() {
      this.isDisconnected = true;
      for (const sentinel of this.sentinels) {
        sentinel.client.disconnect();
      }
    }
    subscribe() {
      return __awaiter(this, undefined, undefined, function* () {
        debug("Starting FailoverDetector");
        const promises = [];
        for (const sentinel of this.sentinels) {
          const promise = sentinel.client.subscribe(CHANNEL_NAME).catch((err) => {
            debug("Failed to subscribe to failover messages on sentinel %s:%s (%s)", sentinel.address.host || "127.0.0.1", sentinel.address.port || 26739, err.message);
          });
          promises.push(promise);
          sentinel.client.on("message", (channel) => {
            if (!this.isDisconnected && channel === CHANNEL_NAME) {
              this.disconnect();
            }
          });
        }
        yield Promise.all(promises);
      });
    }
    disconnect() {
      this.isDisconnected = true;
      debug("Failover detected, disconnecting");
      this.connector.disconnect();
    }
  }
  exports.FailoverDetector = FailoverDetector;
});

// node_modules/ioredis/built/connectors/SentinelConnector/index.js
var require_SentinelConnector = __commonJS((exports) => {
  var selectPreferredSentinel = function(availableSlaves, preferredSlaves) {
    if (availableSlaves.length === 0) {
      return null;
    }
    let selectedSlave;
    if (typeof preferredSlaves === "function") {
      selectedSlave = preferredSlaves(availableSlaves);
    } else if (preferredSlaves !== null && typeof preferredSlaves === "object") {
      const preferredSlavesArray = Array.isArray(preferredSlaves) ? preferredSlaves : [preferredSlaves];
      preferredSlavesArray.sort((a, b2) => {
        if (!a.prio) {
          a.prio = 1;
        }
        if (!b2.prio) {
          b2.prio = 1;
        }
        if (a.prio < b2.prio) {
          return -1;
        }
        if (a.prio > b2.prio) {
          return 1;
        }
        return 0;
      });
      for (let p = 0;p < preferredSlavesArray.length; p++) {
        for (let a = 0;a < availableSlaves.length; a++) {
          const slave = availableSlaves[a];
          if (slave.ip === preferredSlavesArray[p].ip) {
            if (slave.port === preferredSlavesArray[p].port) {
              selectedSlave = slave;
              break;
            }
          }
        }
        if (selectedSlave) {
          break;
        }
      }
    }
    if (!selectedSlave) {
      selectedSlave = utils_1.sample(availableSlaves);
    }
    return addressResponseToAddress(selectedSlave);
  };
  var addressResponseToAddress = function(input) {
    return { host: input.ip, port: Number(input.port) };
  };
  var noop3 = function() {
  };
  var __awaiter = exports && exports.__awaiter || function(thisArg, _arguments, P, generator) {
    function adopt(value) {
      return value instanceof P ? value : new P(function(resolve) {
        resolve(value);
      });
    }
    return new (P || (P = Promise))(function(resolve, reject) {
      function fulfilled(value) {
        try {
          step(generator.next(value));
        } catch (e) {
          reject(e);
        }
      }
      function rejected(value) {
        try {
          step(generator["throw"](value));
        } catch (e) {
          reject(e);
        }
      }
      function step(result2) {
        result2.done ? resolve(result2.value) : adopt(result2.value).then(fulfilled, rejected);
      }
      step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  var net_1 = __require("net");
  var utils_1 = require_utils2();
  var tls_1 = __require("tls");
  var StandaloneConnector_1 = require_StandaloneConnector();
  var SentinelIterator_1 = require_SentinelIterator();
  exports.SentinelIterator = SentinelIterator_1.default;
  var AbstractConnector_1 = require_AbstractConnector();
  var redis_1 = require_redis();
  var FailoverDetector_1 = require_FailoverDetector();
  var debug = utils_1.Debug("SentinelConnector");

  class SentinelConnector extends AbstractConnector_1.default {
    constructor(options) {
      super(options.disconnectTimeout);
      this.options = options;
      this.failoverDetector = null;
      this.emitter = null;
      if (!this.options.sentinels.length) {
        throw new Error("Requires at least one sentinel to connect to.");
      }
      if (!this.options.name) {
        throw new Error("Requires the name of master.");
      }
      this.sentinelIterator = new SentinelIterator_1.default(this.options.sentinels);
    }
    check(info) {
      const roleMatches = !info.role || this.options.role === info.role;
      if (!roleMatches) {
        debug("role invalid, expected %s, but got %s", this.options.role, info.role);
        this.sentinelIterator.next();
        this.sentinelIterator.next();
        this.sentinelIterator.reset(true);
      }
      return roleMatches;
    }
    disconnect() {
      super.disconnect();
      if (this.failoverDetector) {
        this.failoverDetector.cleanup();
      }
    }
    connect(eventEmitter) {
      this.connecting = true;
      this.retryAttempts = 0;
      let lastError;
      const connectToNext = () => __awaiter(this, undefined, undefined, function* () {
        const endpoint = this.sentinelIterator.next();
        if (endpoint.done) {
          this.sentinelIterator.reset(false);
          const retryDelay = typeof this.options.sentinelRetryStrategy === "function" ? this.options.sentinelRetryStrategy(++this.retryAttempts) : null;
          let errorMsg = typeof retryDelay !== "number" ? "All sentinels are unreachable and retry is disabled." : `All sentinels are unreachable. Retrying from scratch after ${retryDelay}ms.`;
          if (lastError) {
            errorMsg += ` Last error: ${lastError.message}`;
          }
          debug(errorMsg);
          const error = new Error(errorMsg);
          if (typeof retryDelay === "number") {
            eventEmitter("error", error);
            yield new Promise((resolve) => setTimeout(resolve, retryDelay));
            return connectToNext();
          } else {
            throw error;
          }
        }
        let resolved = null;
        let err = null;
        try {
          resolved = yield this.resolve(endpoint.value);
        } catch (error) {
          err = error;
        }
        if (!this.connecting) {
          throw new Error(utils_1.CONNECTION_CLOSED_ERROR_MSG);
        }
        const endpointAddress = endpoint.value.host + ":" + endpoint.value.port;
        if (resolved) {
          debug("resolved: %s:%s from sentinel %s", resolved.host, resolved.port, endpointAddress);
          if (this.options.enableTLSForSentinelMode && this.options.tls) {
            Object.assign(resolved, this.options.tls);
            this.stream = tls_1.connect(resolved);
          } else {
            this.stream = net_1.createConnection(resolved);
          }
          this.stream.once("connect", () => this.initFailoverDetector());
          this.stream.once("error", (err2) => {
            this.firstError = err2;
          });
          return this.stream;
        } else {
          const errorMsg = err ? "failed to connect to sentinel " + endpointAddress + " because " + err.message : "connected to sentinel " + endpointAddress + " successfully, but got an invalid reply: " + resolved;
          debug(errorMsg);
          eventEmitter("sentinelError", new Error(errorMsg));
          if (err) {
            lastError = err;
          }
          return connectToNext();
        }
      });
      return connectToNext();
    }
    updateSentinels(client) {
      return __awaiter(this, undefined, undefined, function* () {
        if (!this.options.updateSentinels) {
          return;
        }
        const result2 = yield client.sentinel("sentinels", this.options.name);
        if (!Array.isArray(result2)) {
          return;
        }
        result2.map(utils_1.packObject).forEach((sentinel) => {
          const flags3 = sentinel.flags ? sentinel.flags.split(",") : [];
          if (flags3.indexOf("disconnected") === -1 && sentinel.ip && sentinel.port) {
            const endpoint = this.sentinelNatResolve(addressResponseToAddress(sentinel));
            if (this.sentinelIterator.add(endpoint)) {
              debug("adding sentinel %s:%s", endpoint.host, endpoint.port);
            }
          }
        });
        debug("Updated internal sentinels: %s", this.sentinelIterator);
      });
    }
    resolveMaster(client) {
      return __awaiter(this, undefined, undefined, function* () {
        const result2 = yield client.sentinel("get-master-addr-by-name", this.options.name);
        yield this.updateSentinels(client);
        return this.sentinelNatResolve(Array.isArray(result2) ? { host: result2[0], port: Number(result2[1]) } : null);
      });
    }
    resolveSlave(client) {
      return __awaiter(this, undefined, undefined, function* () {
        const result2 = yield client.sentinel("slaves", this.options.name);
        if (!Array.isArray(result2)) {
          return null;
        }
        const availableSlaves = result2.map(utils_1.packObject).filter((slave) => slave.flags && !slave.flags.match(/(disconnected|s_down|o_down)/));
        return this.sentinelNatResolve(selectPreferredSentinel(availableSlaves, this.options.preferredSlaves));
      });
    }
    sentinelNatResolve(item) {
      if (!item || !this.options.natMap)
        return item;
      return this.options.natMap[`${item.host}:${item.port}`] || item;
    }
    connectToSentinel(endpoint, options) {
      return new redis_1.default(Object.assign({ port: endpoint.port || 26379, host: endpoint.host, username: this.options.sentinelUsername || null, password: this.options.sentinelPassword || null, family: endpoint.family || (StandaloneConnector_1.isIIpcConnectionOptions(this.options) ? undefined : this.options.family), tls: this.options.sentinelTLS, retryStrategy: null, enableReadyCheck: false, connectTimeout: this.options.connectTimeout, commandTimeout: this.options.sentinelCommandTimeout, dropBufferSupport: true }, options));
    }
    resolve(endpoint) {
      return __awaiter(this, undefined, undefined, function* () {
        const client = this.connectToSentinel(endpoint);
        client.on("error", noop3);
        try {
          if (this.options.role === "slave") {
            return yield this.resolveSlave(client);
          } else {
            return yield this.resolveMaster(client);
          }
        } finally {
          client.disconnect();
        }
      });
    }
    initFailoverDetector() {
      var _a;
      return __awaiter(this, undefined, undefined, function* () {
        if (!this.options.failoverDetector) {
          return;
        }
        this.sentinelIterator.reset(true);
        const sentinels = [];
        while (sentinels.length < this.options.sentinelMaxConnections) {
          const { done, value } = this.sentinelIterator.next();
          if (done) {
            break;
          }
          const client = this.connectToSentinel(value, {
            lazyConnect: true,
            retryStrategy: this.options.sentinelReconnectStrategy
          });
          client.on("reconnecting", () => {
            var _a2;
            (_a2 = this.emitter) === null || _a2 === undefined || _a2.emit("sentinelReconnecting");
          });
          sentinels.push({ address: value, client });
        }
        this.sentinelIterator.reset(false);
        if (this.failoverDetector) {
          this.failoverDetector.cleanup();
        }
        this.failoverDetector = new FailoverDetector_1.FailoverDetector(this, sentinels);
        yield this.failoverDetector.subscribe();
        (_a = this.emitter) === null || _a === undefined || _a.emit("failoverSubscribed");
      });
    }
  }
  exports.default = SentinelConnector;
});

// node_modules/ioredis/built/connectors/index.js
var require_connectors = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  var StandaloneConnector_1 = require_StandaloneConnector();
  exports.StandaloneConnector = StandaloneConnector_1.default;
  var SentinelConnector_1 = require_SentinelConnector();
  exports.SentinelConnector = SentinelConnector_1.default;
});

// node_modules/ioredis/built/ScanStream.js
var require_ScanStream = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  var stream_1 = __require("stream");

  class ScanStream extends stream_1.Readable {
    constructor(opt) {
      super(opt);
      this.opt = opt;
      this._redisCursor = "0";
      this._redisDrained = false;
    }
    _read() {
      if (this._redisDrained) {
        this.push(null);
        return;
      }
      const args = [this._redisCursor];
      if (this.opt.key) {
        args.unshift(this.opt.key);
      }
      if (this.opt.match) {
        args.push("MATCH", this.opt.match);
      }
      if (this.opt.type) {
        args.push("TYPE", this.opt.type);
      }
      if (this.opt.count) {
        args.push("COUNT", String(this.opt.count));
      }
      this.opt.redis[this.opt.command](args, (err, res) => {
        if (err) {
          this.emit("error", err);
          return;
        }
        this._redisCursor = res[0] instanceof Buffer ? res[0].toString() : res[0];
        if (this._redisCursor === "0") {
          this._redisDrained = true;
        }
        this.push(res[1]);
      });
    }
    close() {
      this._redisDrained = true;
    }
  }
  exports.default = ScanStream;
});

// node_modules/p-map/index.js
var require_p_map = __commonJS((exports, module) => {
  var pMap = (iterable, mapper, options) => new Promise((resolve, reject) => {
    options = Object.assign({
      concurrency: Infinity
    }, options);
    if (typeof mapper !== "function") {
      throw new TypeError("Mapper function is required");
    }
    const { concurrency } = options;
    if (!(typeof concurrency === "number" && concurrency >= 1)) {
      throw new TypeError(`Expected \`concurrency\` to be a number from 1 and up, got \`${concurrency}\` (${typeof concurrency})`);
    }
    const ret = [];
    const iterator = iterable[Symbol.iterator]();
    let isRejected = false;
    let isIterableDone = false;
    let resolvingCount = 0;
    let currentIndex = 0;
    const next = () => {
      if (isRejected) {
        return;
      }
      const nextItem = iterator.next();
      const i = currentIndex;
      currentIndex++;
      if (nextItem.done) {
        isIterableDone = true;
        if (resolvingCount === 0) {
          resolve(ret);
        }
        return;
      }
      resolvingCount++;
      Promise.resolve(nextItem.value).then((element) => mapper(element, i)).then((value) => {
        ret[i] = value;
        resolvingCount--;
        next();
      }, (error) => {
        isRejected = true;
        reject(error);
      });
    };
    for (let i = 0;i < concurrency; i++) {
      next();
      if (isIterableDone) {
        break;
      }
    }
  });
  module.exports = pMap;
  module.exports.default = pMap;
});

// node_modules/ioredis/built/pipeline.js
var require_pipeline = __commonJS((exports) => {
  var generateMultiWithNodes = function(redis, keys) {
    const slot = calculateSlot(keys[0]);
    const target = redis._groupsBySlot[slot];
    for (let i = 1;i < keys.length; i++) {
      if (redis._groupsBySlot[calculateSlot(keys[i])] !== target) {
        return -1;
      }
    }
    return slot;
  };
  var Pipeline = function(redis) {
    commander_1.default.call(this);
    this.redis = redis;
    this.isCluster = this.redis.constructor.name === "Cluster" || this.redis.isCluster;
    this.isPipeline = true;
    this.options = redis.options;
    this._queue = [];
    this._result = [];
    this._transactions = 0;
    this._shaToScript = {};
    Object.keys(redis.scriptsSet).forEach((name) => {
      const script = redis.scriptsSet[name];
      this._shaToScript[script.sha] = script;
      this[name] = redis[name];
      this[name + "Buffer"] = redis[name + "Buffer"];
    });
    redis.addedBuiltinSet.forEach((name) => {
      this[name] = redis[name];
      this[name + "Buffer"] = redis[name + "Buffer"];
    });
    const Promise2 = PromiseContainer.get();
    this.promise = new Promise2((resolve, reject) => {
      this.resolve = resolve;
      this.reject = reject;
    });
    const _this = this;
    Object.defineProperty(this, "length", {
      get: function() {
        return _this._queue.length;
      }
    });
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  var command_1 = require_command();
  var util_1 = __require("util");
  var standard_as_callback_1 = require_built();
  var redis_commands_1 = require_redis_commands();
  var calculateSlot = require_lib();
  var pMap = require_p_map();
  var PromiseContainer = require_promiseContainer();
  var commander_1 = require_commander();
  var utils_1 = require_utils2();
  exports.default = Pipeline;
  Object.assign(Pipeline.prototype, commander_1.default.prototype);
  Pipeline.prototype.fillResult = function(value, position) {
    if (this._queue[position].name === "exec" && Array.isArray(value[1])) {
      const execLength = value[1].length;
      for (let i = 0;i < execLength; i++) {
        if (value[1][i] instanceof Error) {
          continue;
        }
        const cmd = this._queue[position - (execLength - i)];
        try {
          value[1][i] = cmd.transformReply(value[1][i]);
        } catch (err) {
          value[1][i] = err;
        }
      }
    }
    this._result[position] = value;
    if (--this.replyPending) {
      return;
    }
    if (this.isCluster) {
      let retriable = true;
      let commonError;
      for (let i = 0;i < this._result.length; ++i) {
        const error = this._result[i][0];
        const command = this._queue[i];
        if (error) {
          if (command.name === "exec" && error.message === "EXECABORT Transaction discarded because of previous errors.") {
            continue;
          }
          if (!commonError) {
            commonError = {
              name: error.name,
              message: error.message
            };
          } else if (commonError.name !== error.name || commonError.message !== error.message) {
            retriable = false;
            break;
          }
        } else if (!command.inTransaction) {
          const isReadOnly = redis_commands_1.exists(command.name) && redis_commands_1.hasFlag(command.name, "readonly");
          if (!isReadOnly) {
            retriable = false;
            break;
          }
        }
      }
      if (commonError && retriable) {
        const _this = this;
        const errv = commonError.message.split(" ");
        const queue3 = this._queue;
        let inTransaction = false;
        this._queue = [];
        for (let i = 0;i < queue3.length; ++i) {
          if (errv[0] === "ASK" && !inTransaction && queue3[i].name !== "asking" && (!queue3[i - 1] || queue3[i - 1].name !== "asking")) {
            const asking = new command_1.default("asking");
            asking.ignore = true;
            this.sendCommand(asking);
          }
          queue3[i].initPromise();
          this.sendCommand(queue3[i]);
          inTransaction = queue3[i].inTransaction;
        }
        let matched = true;
        if (typeof this.leftRedirections === "undefined") {
          this.leftRedirections = {};
        }
        const exec2 = function() {
          _this.exec();
        };
        this.redis.handleError(commonError, this.leftRedirections, {
          moved: function(slot, key) {
            _this.preferKey = key;
            _this.redis.slots[errv[1]] = [key];
            _this.redis._groupsBySlot[errv[1]] = _this.redis._groupsIds[_this.redis.slots[errv[1]].join(";")];
            _this.redis.refreshSlotsCache();
            _this.exec();
          },
          ask: function(slot, key) {
            _this.preferKey = key;
            _this.exec();
          },
          tryagain: exec2,
          clusterDown: exec2,
          connectionClosed: exec2,
          maxRedirections: () => {
            matched = false;
          },
          defaults: () => {
            matched = false;
          }
        });
        if (matched) {
          return;
        }
      }
    }
    let ignoredCount = 0;
    for (let i = 0;i < this._queue.length - ignoredCount; ++i) {
      if (this._queue[i + ignoredCount].ignore) {
        ignoredCount += 1;
      }
      this._result[i] = this._result[i + ignoredCount];
    }
    this.resolve(this._result.slice(0, this._result.length - ignoredCount));
  };
  Pipeline.prototype.sendCommand = function(command) {
    if (this._transactions > 0) {
      command.inTransaction = true;
    }
    const position = this._queue.length;
    command.pipelineIndex = position;
    command.promise.then((result2) => {
      this.fillResult([null, result2], position);
    }).catch((error) => {
      this.fillResult([error], position);
    });
    this._queue.push(command);
    return this;
  };
  Pipeline.prototype.addBatch = function(commands) {
    let command, commandName, args;
    for (let i = 0;i < commands.length; ++i) {
      command = commands[i];
      commandName = command[0];
      args = command.slice(1);
      this[commandName].apply(this, args);
    }
    return this;
  };
  var multi = Pipeline.prototype.multi;
  Pipeline.prototype.multi = function() {
    this._transactions += 1;
    return multi.apply(this, arguments);
  };
  var execBuffer = Pipeline.prototype.execBuffer;
  var exec = Pipeline.prototype.exec;
  Pipeline.prototype.execBuffer = util_1.deprecate(function() {
    if (this._transactions > 0) {
      this._transactions -= 1;
    }
    return execBuffer.apply(this, arguments);
  }, "Pipeline#execBuffer: Use Pipeline#exec instead");
  Pipeline.prototype.exec = function(callback) {
    if (this.isCluster && !this.redis.slots.length) {
      if (this.redis.status === "wait")
        this.redis.connect().catch(utils_1.noop);
      this.redis.delayUntilReady((err) => {
        if (err) {
          callback(err);
          return;
        }
        this.exec(callback);
      });
      return this.promise;
    }
    if (this._transactions > 0) {
      this._transactions -= 1;
      return (this.options.dropBufferSupport ? exec : execBuffer).apply(this, arguments);
    }
    if (!this.nodeifiedPromise) {
      this.nodeifiedPromise = true;
      standard_as_callback_1.default(this.promise, callback);
    }
    if (!this._queue.length) {
      this.resolve([]);
    }
    let pipelineSlot;
    if (this.isCluster) {
      const sampleKeys = [];
      for (let i = 0;i < this._queue.length; i++) {
        const keys = this._queue[i].getKeys();
        if (keys.length) {
          sampleKeys.push(keys[0]);
        }
        if (keys.length && calculateSlot.generateMulti(keys) < 0) {
          this.reject(new Error("All the keys in a pipeline command should belong to the same slot"));
          return this.promise;
        }
      }
      if (sampleKeys.length) {
        pipelineSlot = generateMultiWithNodes(this.redis, sampleKeys);
        if (pipelineSlot < 0) {
          this.reject(new Error("All keys in the pipeline should belong to the same slots allocation group"));
          return this.promise;
        }
      } else {
        pipelineSlot = Math.random() * 16384 | 0;
      }
    }
    const scripts = [];
    for (let i = 0;i < this._queue.length; ++i) {
      const item = this._queue[i];
      if (item.name !== "evalsha") {
        continue;
      }
      const script = this._shaToScript[item.args[0]];
      if (!script || this.redis._addedScriptHashes[script.sha] || scripts.includes(script)) {
        continue;
      }
      scripts.push(script);
    }
    const _this = this;
    if (!scripts.length) {
      return execPipeline();
    }
    if (this.isCluster) {
      pMap(scripts, (script) => _this.redis.script("load", script.lua), {
        concurrency: 10
      }).then(function() {
        for (let i = 0;i < scripts.length; i++) {
          _this.redis._addedScriptHashes[scripts[i].sha] = true;
        }
      }).then(execPipeline, this.reject);
      return this.promise;
    }
    this.redis.script("exists", scripts.map(({ sha }) => sha)).then(function(results) {
      const pending = [];
      for (let i = 0;i < results.length; ++i) {
        if (!results[i]) {
          pending.push(scripts[i]);
        }
      }
      const Promise2 = PromiseContainer.get();
      return Promise2.all(pending.map(function(script) {
        return _this.redis.script("load", script.lua);
      }));
    }).then(function() {
      for (let i = 0;i < scripts.length; i++) {
        _this.redis._addedScriptHashes[scripts[i].sha] = true;
      }
    }).then(execPipeline, this.reject);
    return this.promise;
    function execPipeline() {
      let data = "";
      let buffers;
      let writePending = _this.replyPending = _this._queue.length;
      let node4;
      if (_this.isCluster) {
        node4 = {
          slot: pipelineSlot,
          redis: _this.redis.connectionPool.nodes.all[_this.preferKey]
        };
      }
      let bufferMode = false;
      const stream = {
        write: function(writable) {
          if (writable instanceof Buffer) {
            bufferMode = true;
          }
          if (bufferMode) {
            if (!buffers) {
              buffers = [];
            }
            if (typeof data === "string") {
              buffers.push(Buffer.from(data, "utf8"));
              data = undefined;
            }
            buffers.push(typeof writable === "string" ? Buffer.from(writable, "utf8") : writable);
          } else {
            data += writable;
          }
          if (!--writePending) {
            let sendData;
            if (buffers) {
              sendData = Buffer.concat(buffers);
            } else {
              sendData = data;
            }
            if (_this.isCluster) {
              node4.redis.stream.write(sendData);
            } else {
              _this.redis.stream.write(sendData);
            }
            writePending = _this._queue.length;
            data = "";
            buffers = undefined;
            bufferMode = false;
          }
        }
      };
      for (let i = 0;i < _this._queue.length; ++i) {
        _this.redis.sendCommand(_this._queue[i], stream, node4);
      }
      return _this.promise;
    }
  };
});

// node_modules/ioredis/built/transaction.js
var require_transaction = __commonJS((exports) => {
  var addTransactionSupport = function(redis) {
    redis.pipeline = function(commands) {
      const pipeline = new pipeline_1.default(this);
      if (Array.isArray(commands)) {
        pipeline.addBatch(commands);
      }
      return pipeline;
    };
    const { multi } = redis;
    redis.multi = function(commands, options) {
      if (typeof options === "undefined" && !Array.isArray(commands)) {
        options = commands;
        commands = null;
      }
      if (options && options.pipeline === false) {
        return multi.call(this);
      }
      const pipeline = new pipeline_1.default(this);
      pipeline.multi();
      if (Array.isArray(commands)) {
        pipeline.addBatch(commands);
      }
      const exec2 = pipeline.exec;
      pipeline.exec = function(callback) {
        if (this.isCluster && !this.redis.slots.length) {
          if (this.redis.status === "wait")
            this.redis.connect().catch(utils_1.noop);
          return standard_as_callback_1.default(new Promise((resolve, reject) => {
            this.redis.delayUntilReady((err) => {
              if (err) {
                reject(err);
                return;
              }
              this.exec(pipeline).then(resolve, reject);
            });
          }), callback);
        }
        if (this._transactions > 0) {
          exec2.call(pipeline);
        }
        if (this.nodeifiedPromise) {
          return exec2.call(pipeline);
        }
        const promise = exec2.call(pipeline);
        return standard_as_callback_1.default(promise.then(function(result2) {
          const execResult = result2[result2.length - 1];
          if (typeof execResult === "undefined") {
            throw new Error("Pipeline cannot be used to send any commands when the `exec()` has been called on it.");
          }
          if (execResult[0]) {
            execResult[0].previousErrors = [];
            for (let i = 0;i < result2.length - 1; ++i) {
              if (result2[i][0]) {
                execResult[0].previousErrors.push(result2[i][0]);
              }
            }
            throw execResult[0];
          }
          return utils_1.wrapMultiResult(execResult[1]);
        }), callback);
      };
      const { execBuffer } = pipeline;
      pipeline.execBuffer = function(callback) {
        if (this._transactions > 0) {
          execBuffer.call(pipeline);
        }
        return pipeline.exec(callback);
      };
      return pipeline;
    };
    const { exec } = redis;
    redis.exec = function(callback) {
      return standard_as_callback_1.default(exec.call(this).then(function(results) {
        if (Array.isArray(results)) {
          results = utils_1.wrapMultiResult(results);
        }
        return results;
      }), callback);
    };
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  var utils_1 = require_utils2();
  var standard_as_callback_1 = require_built();
  var pipeline_1 = require_pipeline();
  exports.addTransactionSupport = addTransactionSupport;
});

// node_modules/ioredis/built/redis/RedisOptions.js
var require_RedisOptions = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.DEFAULT_REDIS_OPTIONS = {
    port: 6379,
    host: "localhost",
    family: 4,
    connectTimeout: 1e4,
    disconnectTimeout: 2000,
    retryStrategy: function(times) {
      return Math.min(times * 50, 2000);
    },
    keepAlive: 0,
    noDelay: true,
    connectionName: null,
    sentinels: null,
    name: null,
    role: "master",
    sentinelRetryStrategy: function(times) {
      return Math.min(times * 10, 1000);
    },
    sentinelReconnectStrategy: function() {
      return 60000;
    },
    natMap: null,
    enableTLSForSentinelMode: false,
    updateSentinels: true,
    failoverDetector: false,
    username: null,
    password: null,
    db: 0,
    dropBufferSupport: false,
    enableOfflineQueue: true,
    enableReadyCheck: true,
    autoResubscribe: true,
    autoResendUnfulfilledCommands: true,
    lazyConnect: false,
    keyPrefix: "",
    reconnectOnError: null,
    readOnly: false,
    stringNumbers: false,
    maxRetriesPerRequest: 20,
    maxLoadingRetryTime: 1e4,
    enableAutoPipelining: false,
    autoPipeliningIgnoredCommands: [],
    maxScriptsCachingTime: 60000,
    sentinelMaxConnections: 10
  };
});

// node_modules/ioredis/built/redis/index.js
var require_redis = __commonJS((exports) => {
  var Redis = function() {
    if (!(this instanceof Redis)) {
      console.error(new Error("Calling `Redis()` like a function is deprecated. Using `new Redis()` instead.").stack.replace("Error", "Warning"));
      return new Redis(arguments[0], arguments[1], arguments[2]);
    }
    this.parseOptions(arguments[0], arguments[1], arguments[2]);
    events_1.EventEmitter.call(this);
    commander_1.default.call(this);
    this.resetCommandQueue();
    this.resetOfflineQueue();
    this.connectionEpoch = 0;
    if (this.options.Connector) {
      this.connector = new this.options.Connector(this.options);
    } else if (this.options.sentinels) {
      const sentinelConnector = new connectors_1.SentinelConnector(this.options);
      sentinelConnector.emitter = this;
      this.connector = sentinelConnector;
    } else {
      this.connector = new connectors_1.StandaloneConnector(this.options);
    }
    this.retryAttempts = 0;
    this._addedScriptHashes = {};
    this._autoPipelines = new Map;
    this._runningAutoPipelines = new Set;
    Object.defineProperty(this, "autoPipelineQueueSize", {
      get() {
        let queued = 0;
        for (const pipeline of this._autoPipelines.values()) {
          queued += pipeline.length;
        }
        return queued;
      }
    });
    if (this.options.lazyConnect) {
      this.setStatus("wait");
    } else {
      this.connect().catch(lodash_1.noop);
    }
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  var lodash_1 = require_lodash4();
  var util_1 = __require("util");
  var events_1 = __require("events");
  var Deque = require_denque();
  var command_1 = require_command();
  var commander_1 = require_commander();
  var utils_1 = require_utils2();
  var standard_as_callback_1 = require_built();
  var eventHandler = require_event_handler();
  var connectors_1 = require_connectors();
  var ScanStream_1 = require_ScanStream();
  var commands = require_redis_commands();
  var PromiseContainer = require_promiseContainer();
  var transaction_1 = require_transaction();
  var RedisOptions_1 = require_RedisOptions();
  var debug = utils_1.Debug("redis");
  exports.default = Redis;
  util_1.inherits(Redis, events_1.EventEmitter);
  Object.assign(Redis.prototype, commander_1.default.prototype);
  Redis.createClient = function(...args) {
    return new Redis(...args);
  };
  Redis.defaultOptions = RedisOptions_1.DEFAULT_REDIS_OPTIONS;
  Redis.prototype.resetCommandQueue = function() {
    this.commandQueue = new Deque;
  };
  Redis.prototype.resetOfflineQueue = function() {
    this.offlineQueue = new Deque;
  };
  Redis.prototype.parseOptions = function() {
    this.options = {};
    let isTls = false;
    for (let i = 0;i < arguments.length; ++i) {
      const arg = arguments[i];
      if (arg === null || typeof arg === "undefined") {
        continue;
      }
      if (typeof arg === "object") {
        lodash_1.defaults(this.options, arg);
      } else if (typeof arg === "string") {
        lodash_1.defaults(this.options, utils_1.parseURL(arg));
        if (arg.startsWith("rediss://")) {
          isTls = true;
        }
      } else if (typeof arg === "number") {
        this.options.port = arg;
      } else {
        throw new Error("Invalid argument " + arg);
      }
    }
    if (isTls) {
      lodash_1.defaults(this.options, { tls: true });
    }
    lodash_1.defaults(this.options, Redis.defaultOptions);
    if (typeof this.options.port === "string") {
      this.options.port = parseInt(this.options.port, 10);
    }
    if (typeof this.options.db === "string") {
      this.options.db = parseInt(this.options.db, 10);
    }
    if (this.options.parser === "hiredis") {
      console.warn("Hiredis parser is abandoned since ioredis v3.0, and JavaScript parser will be used");
    }
    this.options = utils_1.resolveTLSProfile(this.options);
  };
  Redis.prototype.setStatus = function(status, arg) {
    if (debug.enabled) {
      debug("status[%s]: %s -> %s", this._getDescription(), this.status || "[empty]", status);
    }
    this.status = status;
    process.nextTick(this.emit.bind(this, status, arg));
  };
  Redis.prototype.clearAddedScriptHashesCleanInterval = function() {
    if (this._addedScriptHashesCleanInterval) {
      clearInterval(this._addedScriptHashesCleanInterval);
      this._addedScriptHashesCleanInterval = null;
    }
  };
  Redis.prototype.connect = function(callback) {
    const _Promise = PromiseContainer.get();
    const promise = new _Promise((resolve, reject) => {
      if (this.status === "connecting" || this.status === "connect" || this.status === "ready") {
        reject(new Error("Redis is already connecting/connected"));
        return;
      }
      this.clearAddedScriptHashesCleanInterval();
      this._addedScriptHashes = {};
      this._addedScriptHashesCleanInterval = setInterval(() => {
        this._addedScriptHashes = {};
      }, this.options.maxScriptsCachingTime);
      this.connectionEpoch += 1;
      this.setStatus("connecting");
      const { options } = this;
      this.condition = {
        select: options.db,
        auth: options.username ? [options.username, options.password] : options.password,
        subscriber: false
      };
      const _this = this;
      standard_as_callback_1.default(this.connector.connect(function(type, err) {
        _this.silentEmit(type, err);
      }), function(err, stream) {
        if (err) {
          _this.flushQueue(err);
          _this.silentEmit("error", err);
          reject(err);
          _this.setStatus("end");
          return;
        }
        let CONNECT_EVENT = options.tls ? "secureConnect" : "connect";
        if (options.sentinels && !options.enableTLSForSentinelMode) {
          CONNECT_EVENT = "connect";
        }
        _this.stream = stream;
        if (typeof options.keepAlive === "number") {
          stream.setKeepAlive(true, options.keepAlive);
        }
        if (stream.connecting) {
          stream.once(CONNECT_EVENT, eventHandler.connectHandler(_this));
          if (options.connectTimeout) {
            let connectTimeoutCleared = false;
            stream.setTimeout(options.connectTimeout, function() {
              if (connectTimeoutCleared) {
                return;
              }
              stream.setTimeout(0);
              stream.destroy();
              const err2 = new Error("connect ETIMEDOUT");
              err2.errorno = "ETIMEDOUT";
              err2.code = "ETIMEDOUT";
              err2.syscall = "connect";
              eventHandler.errorHandler(_this)(err2);
            });
            stream.once(CONNECT_EVENT, function() {
              connectTimeoutCleared = true;
              stream.setTimeout(0);
            });
          }
        } else if (stream.destroyed) {
          const firstError = _this.connector.firstError;
          if (firstError) {
            process.nextTick(() => {
              eventHandler.errorHandler(_this)(firstError);
            });
          }
          process.nextTick(eventHandler.closeHandler(_this));
        } else {
          process.nextTick(eventHandler.connectHandler(_this));
        }
        if (!stream.destroyed) {
          stream.once("error", eventHandler.errorHandler(_this));
          stream.once("close", eventHandler.closeHandler(_this));
        }
        if (options.noDelay) {
          stream.setNoDelay(true);
        }
        const connectionReadyHandler = function() {
          _this.removeListener("close", connectionCloseHandler);
          resolve();
        };
        var connectionCloseHandler = function() {
          _this.removeListener("ready", connectionReadyHandler);
          reject(new Error(utils_1.CONNECTION_CLOSED_ERROR_MSG));
        };
        _this.once("ready", connectionReadyHandler);
        _this.once("close", connectionCloseHandler);
      });
    });
    return standard_as_callback_1.default(promise, callback);
  };
  Redis.prototype.disconnect = function(reconnect) {
    this.clearAddedScriptHashesCleanInterval();
    if (!reconnect) {
      this.manuallyClosing = true;
    }
    if (this.reconnectTimeout && !reconnect) {
      clearTimeout(this.reconnectTimeout);
      this.reconnectTimeout = null;
    }
    if (this.status === "wait") {
      eventHandler.closeHandler(this)();
    } else {
      this.connector.disconnect();
    }
  };
  Redis.prototype.end = function() {
    this.disconnect();
  };
  Redis.prototype.duplicate = function(override) {
    return new Redis(Object.assign({}, this.options, override || {}));
  };
  Redis.prototype.recoverFromFatalError = function(commandError, err, options) {
    this.flushQueue(err, options);
    this.silentEmit("error", err);
    this.disconnect(true);
  };
  Redis.prototype.handleReconnection = function handleReconnection(err, item) {
    let needReconnect = false;
    if (this.options.reconnectOnError) {
      needReconnect = this.options.reconnectOnError(err);
    }
    switch (needReconnect) {
      case 1:
      case true:
        if (this.status !== "reconnecting") {
          this.disconnect(true);
        }
        item.command.reject(err);
        break;
      case 2:
        if (this.status !== "reconnecting") {
          this.disconnect(true);
        }
        if (this.condition.select !== item.select && item.command.name !== "select") {
          this.select(item.select);
        }
        this.sendCommand(item.command);
        break;
      default:
        item.command.reject(err);
    }
  };
  Redis.prototype.flushQueue = function(error, options) {
    options = lodash_1.defaults({}, options, {
      offlineQueue: true,
      commandQueue: true
    });
    let item;
    if (options.offlineQueue) {
      while (this.offlineQueue.length > 0) {
        item = this.offlineQueue.shift();
        item.command.reject(error);
      }
    }
    if (options.commandQueue) {
      if (this.commandQueue.length > 0) {
        if (this.stream) {
          this.stream.removeAllListeners("data");
        }
        while (this.commandQueue.length > 0) {
          item = this.commandQueue.shift();
          item.command.reject(error);
        }
      }
    }
  };
  Redis.prototype._readyCheck = function(callback) {
    const _this = this;
    this.info(function(err, res) {
      if (err) {
        return callback(err);
      }
      if (typeof res !== "string") {
        return callback(null, res);
      }
      const info = {};
      const lines = res.split("\r\n");
      for (let i = 0;i < lines.length; ++i) {
        const [fieldName, ...fieldValueParts] = lines[i].split(":");
        const fieldValue = fieldValueParts.join(":");
        if (fieldValue) {
          info[fieldName] = fieldValue;
        }
      }
      if (!info.loading || info.loading === "0") {
        callback(null, info);
      } else {
        const loadingEtaMs = (info.loading_eta_seconds || 1) * 1000;
        const retryTime = _this.options.maxLoadingRetryTime && _this.options.maxLoadingRetryTime < loadingEtaMs ? _this.options.maxLoadingRetryTime : loadingEtaMs;
        debug("Redis server still loading, trying again in " + retryTime + "ms");
        setTimeout(function() {
          _this._readyCheck(callback);
        }, retryTime);
      }
    });
  };
  Redis.prototype.silentEmit = function(eventName) {
    let error;
    if (eventName === "error") {
      error = arguments[1];
      if (this.status === "end") {
        return;
      }
      if (this.manuallyClosing) {
        if (error instanceof Error && (error.message === utils_1.CONNECTION_CLOSED_ERROR_MSG || error.syscall === "connect" || error.syscall === "read")) {
          return;
        }
      }
    }
    if (this.listeners(eventName).length > 0) {
      return this.emit.apply(this, arguments);
    }
    if (error && error instanceof Error) {
      console.error("[ioredis] Unhandled error event:", error.stack);
    }
    return false;
  };
  Redis.prototype.monitor = function(callback) {
    const monitorInstance = this.duplicate({
      monitor: true,
      lazyConnect: false
    });
    const Promise2 = PromiseContainer.get();
    return standard_as_callback_1.default(new Promise2(function(resolve) {
      monitorInstance.once("monitoring", function() {
        resolve(monitorInstance);
      });
    }), callback);
  };
  transaction_1.addTransactionSupport(Redis.prototype);
  Redis.prototype.sendCommand = function(command, stream) {
    if (this.status === "wait") {
      this.connect().catch(lodash_1.noop);
    }
    if (this.status === "end") {
      command.reject(new Error(utils_1.CONNECTION_CLOSED_ERROR_MSG));
      return command.promise;
    }
    if (this.condition.subscriber && !command_1.default.checkFlag("VALID_IN_SUBSCRIBER_MODE", command.name)) {
      command.reject(new Error("Connection in subscriber mode, only subscriber commands may be used"));
      return command.promise;
    }
    if (typeof this.options.commandTimeout === "number") {
      command.setTimeout(this.options.commandTimeout);
    }
    if (command.name === "quit") {
      this.clearAddedScriptHashesCleanInterval();
    }
    let writable = this.status === "ready" || !stream && this.status === "connect" && commands.exists(command.name) && commands.hasFlag(command.name, "loading");
    if (!this.stream) {
      writable = false;
    } else if (!this.stream.writable) {
      writable = false;
    } else if (this.stream._writableState && this.stream._writableState.ended) {
      writable = false;
    }
    if (!writable && !this.options.enableOfflineQueue) {
      command.reject(new Error("Stream isn't writeable and enableOfflineQueue options is false"));
      return command.promise;
    }
    if (!writable && command.name === "quit" && this.offlineQueue.length === 0) {
      this.disconnect();
      command.resolve(Buffer.from("OK"));
      return command.promise;
    }
    if (writable) {
      if (debug.enabled) {
        debug("write command[%s]: %d -> %s(%o)", this._getDescription(), this.condition.select, command.name, command.args);
      }
      (stream || this.stream).write(command.toWritable());
      this.commandQueue.push({
        command,
        stream,
        select: this.condition.select
      });
      if (command_1.default.checkFlag("WILL_DISCONNECT", command.name)) {
        this.manuallyClosing = true;
      }
    } else if (this.options.enableOfflineQueue) {
      if (debug.enabled) {
        debug("queue command[%s]: %d -> %s(%o)", this._getDescription(), this.condition.select, command.name, command.args);
      }
      this.offlineQueue.push({
        command,
        stream,
        select: this.condition.select
      });
    }
    if (command.name === "select" && utils_1.isInt(command.args[0])) {
      const db2 = parseInt(command.args[0], 10);
      if (this.condition.select !== db2) {
        this.condition.select = db2;
        this.emit("select", db2);
        debug("switch to db [%d]", this.condition.select);
      }
    }
    return command.promise;
  };
  Redis.prototype._getDescription = function() {
    let description;
    if (this.options.path) {
      description = this.options.path;
    } else if (this.stream && this.stream.remoteAddress && this.stream.remotePort) {
      description = this.stream.remoteAddress + ":" + this.stream.remotePort;
    } else {
      description = this.options.host + ":" + this.options.port;
    }
    if (this.options.connectionName) {
      description += ` (${this.options.connectionName})`;
    }
    return description;
  };
  [
    "scan",
    "sscan",
    "hscan",
    "zscan",
    "scanBuffer",
    "sscanBuffer",
    "hscanBuffer",
    "zscanBuffer"
  ].forEach(function(command) {
    Redis.prototype[command + "Stream"] = function(key, options) {
      if (command === "scan" || command === "scanBuffer") {
        options = key;
        key = null;
      }
      return new ScanStream_1.default(lodash_1.defaults({
        objectMode: true,
        key,
        redis: this,
        command
      }, options));
    };
  });
});

// node_modules/ioredis/built/errors/ClusterAllFailedError.js
var require_ClusterAllFailedError = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  var redis_errors_1 = require_redis_errors();

  class ClusterAllFailedError extends redis_errors_1.RedisError {
    constructor(message2, lastNodeError) {
      super(message2);
      this.lastNodeError = lastNodeError;
      Error.captureStackTrace(this, this.constructor);
    }
    get name() {
      return this.constructor.name;
    }
  }
  exports.default = ClusterAllFailedError;
});

// node_modules/ioredis/built/cluster/util.js
var require_util = __commonJS((exports) => {
  var getNodeKey = function(node4) {
    node4.port = node4.port || 6379;
    node4.host = node4.host || "127.0.0.1";
    return node4.host + ":" + node4.port;
  };
  var nodeKeyToRedisOptions = function(nodeKey) {
    const portIndex = nodeKey.lastIndexOf(":");
    if (portIndex === -1) {
      throw new Error(`Invalid node key ${nodeKey}`);
    }
    return {
      host: nodeKey.slice(0, portIndex),
      port: Number(nodeKey.slice(portIndex + 1))
    };
  };
  var normalizeNodeOptions = function(nodes) {
    return nodes.map((node4) => {
      const options = {};
      if (typeof node4 === "object") {
        Object.assign(options, node4);
      } else if (typeof node4 === "string") {
        Object.assign(options, utils_1.parseURL(node4));
      } else if (typeof node4 === "number") {
        options.port = node4;
      } else {
        throw new Error("Invalid argument " + node4);
      }
      if (typeof options.port === "string") {
        options.port = parseInt(options.port, 10);
      }
      delete options.db;
      if (!options.port) {
        options.port = 6379;
      }
      if (!options.host) {
        options.host = "127.0.0.1";
      }
      return utils_1.resolveTLSProfile(options);
    });
  };
  var getUniqueHostnamesFromOptions = function(nodes) {
    const uniqueHostsMap = {};
    nodes.forEach((node4) => {
      uniqueHostsMap[node4.host] = true;
    });
    return Object.keys(uniqueHostsMap).filter((host) => !net_1.isIP(host));
  };
  var groupSrvRecords = function(records) {
    const recordsByPriority = {};
    for (const record of records) {
      if (!recordsByPriority.hasOwnProperty(record.priority)) {
        recordsByPriority[record.priority] = {
          totalWeight: record.weight,
          records: [record]
        };
      } else {
        recordsByPriority[record.priority].totalWeight += record.weight;
        recordsByPriority[record.priority].records.push(record);
      }
    }
    return recordsByPriority;
  };
  var weightSrvRecords = function(recordsGroup) {
    if (recordsGroup.records.length === 1) {
      recordsGroup.totalWeight = 0;
      return recordsGroup.records.shift();
    }
    const random = Math.floor(Math.random() * (recordsGroup.totalWeight + recordsGroup.records.length));
    let total = 0;
    for (const [i, record] of recordsGroup.records.entries()) {
      total += 1 + record.weight;
      if (total > random) {
        recordsGroup.totalWeight -= record.weight;
        recordsGroup.records.splice(i, 1);
        return record;
      }
    }
  };
  var getConnectionName = function(component, nodeConnectionName) {
    const prefix = `ioredis-cluster(${component})`;
    return nodeConnectionName ? `${prefix}:${nodeConnectionName}` : prefix;
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  var utils_1 = require_utils2();
  var net_1 = __require("net");
  exports.getNodeKey = getNodeKey;
  exports.nodeKeyToRedisOptions = nodeKeyToRedisOptions;
  exports.normalizeNodeOptions = normalizeNodeOptions;
  exports.getUniqueHostnamesFromOptions = getUniqueHostnamesFromOptions;
  exports.groupSrvRecords = groupSrvRecords;
  exports.weightSrvRecords = weightSrvRecords;
  exports.getConnectionName = getConnectionName;
});

// node_modules/ioredis/built/cluster/ConnectionPool.js
var require_ConnectionPool = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  var events_1 = __require("events");
  var utils_1 = require_utils2();
  var util_1 = require_util();
  var redis_1 = require_redis();
  var debug = utils_1.Debug("cluster:connectionPool");

  class ConnectionPool extends events_1.EventEmitter {
    constructor(redisOptions) {
      super();
      this.redisOptions = redisOptions;
      this.nodes = {
        all: {},
        master: {},
        slave: {}
      };
      this.specifiedOptions = {};
    }
    getNodes(role = "all") {
      const nodes = this.nodes[role];
      return Object.keys(nodes).map((key) => nodes[key]);
    }
    getInstanceByKey(key) {
      return this.nodes.all[key];
    }
    getSampleInstance(role) {
      const keys = Object.keys(this.nodes[role]);
      const sampleKey = utils_1.sample(keys);
      return this.nodes[role][sampleKey];
    }
    findOrCreate(node4, readOnly = false) {
      const key = util_1.getNodeKey(node4);
      readOnly = Boolean(readOnly);
      if (this.specifiedOptions[key]) {
        Object.assign(node4, this.specifiedOptions[key]);
      } else {
        this.specifiedOptions[key] = node4;
      }
      let redis;
      if (this.nodes.all[key]) {
        redis = this.nodes.all[key];
        if (redis.options.readOnly !== readOnly) {
          redis.options.readOnly = readOnly;
          debug("Change role of %s to %s", key, readOnly ? "slave" : "master");
          redis[readOnly ? "readonly" : "readwrite"]().catch(utils_1.noop);
          if (readOnly) {
            delete this.nodes.master[key];
            this.nodes.slave[key] = redis;
          } else {
            delete this.nodes.slave[key];
            this.nodes.master[key] = redis;
          }
        }
      } else {
        debug("Connecting to %s as %s", key, readOnly ? "slave" : "master");
        redis = new redis_1.default(utils_1.defaults({
          retryStrategy: null,
          enableOfflineQueue: true,
          readOnly
        }, node4, this.redisOptions, { lazyConnect: true }));
        this.nodes.all[key] = redis;
        this.nodes[readOnly ? "slave" : "master"][key] = redis;
        redis.once("end", () => {
          this.removeNode(key);
          this.emit("-node", redis, key);
          if (!Object.keys(this.nodes.all).length) {
            this.emit("drain");
          }
        });
        this.emit("+node", redis, key);
        redis.on("error", function(error) {
          this.emit("nodeError", error, key);
        });
      }
      return redis;
    }
    removeNode(key) {
      const { nodes } = this;
      if (nodes.all[key]) {
        debug("Remove %s from the pool", key);
        delete nodes.all[key];
      }
      delete nodes.master[key];
      delete nodes.slave[key];
    }
    reset(nodes) {
      debug("Reset with %O", nodes);
      const newNodes = {};
      nodes.forEach((node4) => {
        const key = util_1.getNodeKey(node4);
        if (!(node4.readOnly && newNodes[key])) {
          newNodes[key] = node4;
        }
      });
      Object.keys(this.nodes.all).forEach((key) => {
        if (!newNodes[key]) {
          debug("Disconnect %s because the node does not hold any slot", key);
          this.nodes.all[key].disconnect();
          this.removeNode(key);
        }
      });
      Object.keys(newNodes).forEach((key) => {
        const node4 = newNodes[key];
        this.findOrCreate(node4, node4.readOnly);
      });
    }
  }
  exports.default = ConnectionPool;
});

// node_modules/ioredis/built/cluster/ClusterSubscriber.js
var require_ClusterSubscriber = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  var util_1 = require_util();
  var utils_1 = require_utils2();
  var redis_1 = require_redis();
  var debug = utils_1.Debug("cluster:subscriber");

  class ClusterSubscriber {
    constructor(connectionPool, emitter) {
      this.connectionPool = connectionPool;
      this.emitter = emitter;
      this.started = false;
      this.subscriber = null;
      this.connectionPool.on("-node", (_, key) => {
        if (!this.started || !this.subscriber) {
          return;
        }
        if (util_1.getNodeKey(this.subscriber.options) === key) {
          debug("subscriber has left, selecting a new one...");
          this.selectSubscriber();
        }
      });
      this.connectionPool.on("+node", () => {
        if (!this.started || this.subscriber) {
          return;
        }
        debug("a new node is discovered and there is no subscriber, selecting a new one...");
        this.selectSubscriber();
      });
    }
    getInstance() {
      return this.subscriber;
    }
    selectSubscriber() {
      const lastActiveSubscriber = this.lastActiveSubscriber;
      if (lastActiveSubscriber) {
        lastActiveSubscriber.disconnect();
      }
      if (this.subscriber) {
        this.subscriber.disconnect();
      }
      const sampleNode = utils_1.sample(this.connectionPool.getNodes());
      if (!sampleNode) {
        debug("selecting subscriber failed since there is no node discovered in the cluster yet");
        this.subscriber = null;
        return;
      }
      const { options } = sampleNode;
      debug("selected a subscriber %s:%s", options.host, options.port);
      this.subscriber = new redis_1.default({
        port: options.port,
        host: options.host,
        username: options.username,
        password: options.password,
        enableReadyCheck: true,
        connectionName: util_1.getConnectionName("subscriber", options.connectionName),
        lazyConnect: true,
        tls: options.tls
      });
      this.subscriber.on("error", utils_1.noop);
      const previousChannels = { subscribe: [], psubscribe: [] };
      if (lastActiveSubscriber) {
        const condition = lastActiveSubscriber.condition || lastActiveSubscriber.prevCondition;
        if (condition && condition.subscriber) {
          previousChannels.subscribe = condition.subscriber.channels("subscribe");
          previousChannels.psubscribe = condition.subscriber.channels("psubscribe");
        }
      }
      if (previousChannels.subscribe.length || previousChannels.psubscribe.length) {
        let pending = 0;
        for (const type of ["subscribe", "psubscribe"]) {
          const channels = previousChannels[type];
          if (channels.length) {
            pending += 1;
            debug("%s %d channels", type, channels.length);
            this.subscriber[type](channels).then(() => {
              if (!--pending) {
                this.lastActiveSubscriber = this.subscriber;
              }
            }).catch(() => {
              debug("failed to %s %d channels", type, channels.length);
            });
          }
        }
      } else {
        this.lastActiveSubscriber = this.subscriber;
      }
      for (const event of ["message", "messageBuffer"]) {
        this.subscriber.on(event, (arg1, arg2) => {
          this.emitter.emit(event, arg1, arg2);
        });
      }
      for (const event of ["pmessage", "pmessageBuffer"]) {
        this.subscriber.on(event, (arg1, arg2, arg3) => {
          this.emitter.emit(event, arg1, arg2, arg3);
        });
      }
    }
    start() {
      this.started = true;
      this.selectSubscriber();
      debug("started");
    }
    stop() {
      this.started = false;
      if (this.subscriber) {
        this.subscriber.disconnect();
        this.subscriber = null;
      }
      debug("stopped");
    }
  }
  exports.default = ClusterSubscriber;
});

// node_modules/ioredis/built/cluster/DelayQueue.js
var require_DelayQueue = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  var utils_1 = require_utils2();
  var Deque = require_denque();
  var debug = utils_1.Debug("delayqueue");

  class DelayQueue {
    constructor() {
      this.queues = {};
      this.timeouts = {};
    }
    push(bucket, item, options) {
      const callback = options.callback || process.nextTick;
      if (!this.queues[bucket]) {
        this.queues[bucket] = new Deque;
      }
      const queue3 = this.queues[bucket];
      queue3.push(item);
      if (!this.timeouts[bucket]) {
        this.timeouts[bucket] = setTimeout(() => {
          callback(() => {
            this.timeouts[bucket] = null;
            this.execute(bucket);
          });
        }, options.timeout);
      }
    }
    execute(bucket) {
      const queue3 = this.queues[bucket];
      if (!queue3) {
        return;
      }
      const { length } = queue3;
      if (!length) {
        return;
      }
      debug("send %d commands in %s queue", length, bucket);
      this.queues[bucket] = null;
      while (queue3.length > 0) {
        queue3.shift()();
      }
    }
  }
  exports.default = DelayQueue;
});

// node_modules/ioredis/built/cluster/ClusterOptions.js
var require_ClusterOptions = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  var dns_1 = __require("dns");
  exports.DEFAULT_CLUSTER_OPTIONS = {
    clusterRetryStrategy: (times) => Math.min(100 + times * 2, 2000),
    enableOfflineQueue: true,
    enableReadyCheck: true,
    scaleReads: "master",
    maxRedirections: 16,
    retryDelayOnMoved: 0,
    retryDelayOnFailover: 100,
    retryDelayOnClusterDown: 100,
    retryDelayOnTryAgain: 100,
    slotsRefreshTimeout: 1000,
    slotsRefreshInterval: 5000,
    useSRVRecords: false,
    resolveSrv: dns_1.resolveSrv,
    dnsLookup: dns_1.lookup,
    enableAutoPipelining: false,
    autoPipeliningIgnoredCommands: [],
    maxScriptsCachingTime: 60000
  };
});

// node_modules/ioredis/built/cluster/index.js
var require_cluster = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  var events_1 = __require("events");
  var ClusterAllFailedError_1 = require_ClusterAllFailedError();
  var utils_1 = require_utils2();
  var ConnectionPool_1 = require_ConnectionPool();
  var util_1 = require_util();
  var ClusterSubscriber_1 = require_ClusterSubscriber();
  var DelayQueue_1 = require_DelayQueue();
  var ScanStream_1 = require_ScanStream();
  var redis_errors_1 = require_redis_errors();
  var standard_as_callback_1 = require_built();
  var PromiseContainer = require_promiseContainer();
  var ClusterOptions_1 = require_ClusterOptions();
  var utils_2 = require_utils2();
  var commands = require_redis_commands();
  var command_1 = require_command();
  var redis_1 = require_redis();
  var commander_1 = require_commander();
  var Deque = require_denque();
  var debug = utils_1.Debug("cluster");

  class Cluster extends events_1.EventEmitter {
    constructor(startupNodes, options = {}) {
      super();
      this.slots = [];
      this.retryAttempts = 0;
      this.delayQueue = new DelayQueue_1.default;
      this.offlineQueue = new Deque;
      this.isRefreshing = false;
      this.isCluster = true;
      this._autoPipelines = new Map;
      this._groupsIds = {};
      this._groupsBySlot = Array(16384);
      this._runningAutoPipelines = new Set;
      this._readyDelayedCallbacks = [];
      this._addedScriptHashes = {};
      this.connectionEpoch = 0;
      commander_1.default.call(this);
      this.startupNodes = startupNodes;
      this.options = utils_1.defaults({}, options, ClusterOptions_1.DEFAULT_CLUSTER_OPTIONS, this.options);
      if (typeof this.options.scaleReads !== "function" && ["all", "master", "slave"].indexOf(this.options.scaleReads) === -1) {
        throw new Error('Invalid option scaleReads "' + this.options.scaleReads + '". Expected "all", "master", "slave" or a custom function');
      }
      this.connectionPool = new ConnectionPool_1.default(this.options.redisOptions);
      this.connectionPool.on("-node", (redis, key) => {
        this.emit("-node", redis);
      });
      this.connectionPool.on("+node", (redis) => {
        this.emit("+node", redis);
      });
      this.connectionPool.on("drain", () => {
        this.setStatus("close");
      });
      this.connectionPool.on("nodeError", (error, key) => {
        this.emit("node error", error, key);
      });
      this.subscriber = new ClusterSubscriber_1.default(this.connectionPool, this);
      if (this.options.lazyConnect) {
        this.setStatus("wait");
      } else {
        this.connect().catch((err) => {
          debug("connecting failed: %s", err);
        });
      }
    }
    resetOfflineQueue() {
      this.offlineQueue = new Deque;
    }
    clearNodesRefreshInterval() {
      if (this.slotsTimer) {
        clearTimeout(this.slotsTimer);
        this.slotsTimer = null;
      }
    }
    clearAddedScriptHashesCleanInterval() {
      if (this._addedScriptHashesCleanInterval) {
        clearInterval(this._addedScriptHashesCleanInterval);
        this._addedScriptHashesCleanInterval = null;
      }
    }
    resetNodesRefreshInterval() {
      if (this.slotsTimer) {
        return;
      }
      const nextRound = () => {
        this.slotsTimer = setTimeout(() => {
          debug('refreshing slot caches... (triggered by "slotsRefreshInterval" option)');
          this.refreshSlotsCache(() => {
            nextRound();
          });
        }, this.options.slotsRefreshInterval);
      };
      nextRound();
    }
    connect() {
      const Promise2 = PromiseContainer.get();
      return new Promise2((resolve, reject) => {
        if (this.status === "connecting" || this.status === "connect" || this.status === "ready") {
          reject(new Error("Redis is already connecting/connected"));
          return;
        }
        this.clearAddedScriptHashesCleanInterval();
        this._addedScriptHashesCleanInterval = setInterval(() => {
          this._addedScriptHashes = {};
        }, this.options.maxScriptsCachingTime);
        const epoch3 = ++this.connectionEpoch;
        this.setStatus("connecting");
        this.resolveStartupNodeHostnames().then((nodes) => {
          if (this.connectionEpoch !== epoch3) {
            debug("discard connecting after resolving startup nodes because epoch not match: %d != %d", epoch3, this.connectionEpoch);
            reject(new redis_errors_1.RedisError("Connection is discarded because a new connection is made"));
            return;
          }
          if (this.status !== "connecting") {
            debug("discard connecting after resolving startup nodes because the status changed to %s", this.status);
            reject(new redis_errors_1.RedisError("Connection is aborted"));
            return;
          }
          this.connectionPool.reset(nodes);
          function readyHandler() {
            this.setStatus("ready");
            this.retryAttempts = 0;
            this.executeOfflineCommands();
            this.resetNodesRefreshInterval();
            resolve();
          }
          let closeListener = undefined;
          const refreshListener = () => {
            this.invokeReadyDelayedCallbacks(undefined);
            this.removeListener("close", closeListener);
            this.manuallyClosing = false;
            this.setStatus("connect");
            if (this.options.enableReadyCheck) {
              this.readyCheck((err, fail) => {
                if (err || fail) {
                  debug("Ready check failed (%s). Reconnecting...", err || fail);
                  if (this.status === "connect") {
                    this.disconnect(true);
                  }
                } else {
                  readyHandler.call(this);
                }
              });
            } else {
              readyHandler.call(this);
            }
          };
          closeListener = function() {
            const error = new Error("None of startup nodes is available");
            this.removeListener("refresh", refreshListener);
            this.invokeReadyDelayedCallbacks(error);
            reject(error);
          };
          this.once("refresh", refreshListener);
          this.once("close", closeListener);
          this.once("close", this.handleCloseEvent.bind(this));
          this.refreshSlotsCache(function(err) {
            if (err && err.message === "Failed to refresh slots cache.") {
              redis_1.default.prototype.silentEmit.call(this, "error", err);
              this.connectionPool.reset([]);
            }
          }.bind(this));
          this.subscriber.start();
        }).catch((err) => {
          this.setStatus("close");
          this.handleCloseEvent(err);
          this.invokeReadyDelayedCallbacks(err);
          reject(err);
        });
      });
    }
    handleCloseEvent(reason) {
      if (reason) {
        debug("closed because %s", reason);
      }
      this.clearAddedScriptHashesCleanInterval();
      let retryDelay;
      if (!this.manuallyClosing && typeof this.options.clusterRetryStrategy === "function") {
        retryDelay = this.options.clusterRetryStrategy.call(this, ++this.retryAttempts, reason);
      }
      if (typeof retryDelay === "number") {
        this.setStatus("reconnecting");
        this.reconnectTimeout = setTimeout(function() {
          this.reconnectTimeout = null;
          debug("Cluster is disconnected. Retrying after %dms", retryDelay);
          this.connect().catch(function(err) {
            debug("Got error %s when reconnecting. Ignoring...", err);
          });
        }.bind(this), retryDelay);
      } else {
        this.setStatus("end");
        this.flushQueue(new Error("None of startup nodes is available"));
      }
    }
    disconnect(reconnect = false) {
      const status = this.status;
      this.setStatus("disconnecting");
      this.clearAddedScriptHashesCleanInterval();
      if (!reconnect) {
        this.manuallyClosing = true;
      }
      if (this.reconnectTimeout && !reconnect) {
        clearTimeout(this.reconnectTimeout);
        this.reconnectTimeout = null;
        debug("Canceled reconnecting attempts");
      }
      this.clearNodesRefreshInterval();
      this.subscriber.stop();
      if (status === "wait") {
        this.setStatus("close");
        this.handleCloseEvent();
      } else {
        this.connectionPool.reset([]);
      }
    }
    quit(callback) {
      const status = this.status;
      this.setStatus("disconnecting");
      this.clearAddedScriptHashesCleanInterval();
      this.manuallyClosing = true;
      if (this.reconnectTimeout) {
        clearTimeout(this.reconnectTimeout);
        this.reconnectTimeout = null;
      }
      this.clearNodesRefreshInterval();
      this.subscriber.stop();
      const Promise2 = PromiseContainer.get();
      if (status === "wait") {
        const ret = standard_as_callback_1.default(Promise2.resolve("OK"), callback);
        setImmediate(function() {
          this.setStatus("close");
          this.handleCloseEvent();
        }.bind(this));
        return ret;
      }
      return standard_as_callback_1.default(Promise2.all(this.nodes().map((node4) => node4.quit().catch((err) => {
        if (err.message === utils_2.CONNECTION_CLOSED_ERROR_MSG) {
          return "OK";
        }
        throw err;
      }))).then(() => "OK"), callback);
    }
    duplicate(overrideStartupNodes = [], overrideOptions = {}) {
      const startupNodes = overrideStartupNodes.length > 0 ? overrideStartupNodes : this.startupNodes.slice(0);
      const options = Object.assign({}, this.options, overrideOptions);
      return new Cluster(startupNodes, options);
    }
    nodes(role = "all") {
      if (role !== "all" && role !== "master" && role !== "slave") {
        throw new Error('Invalid role "' + role + '". Expected "all", "master" or "slave"');
      }
      return this.connectionPool.getNodes(role);
    }
    delayUntilReady(callback) {
      this._readyDelayedCallbacks.push(callback);
    }
    get autoPipelineQueueSize() {
      let queued = 0;
      for (const pipeline of this._autoPipelines.values()) {
        queued += pipeline.length;
      }
      return queued;
    }
    setStatus(status) {
      debug("status: %s -> %s", this.status || "[empty]", status);
      this.status = status;
      process.nextTick(() => {
        this.emit(status);
      });
    }
    refreshSlotsCache(callback) {
      if (this.isRefreshing) {
        if (typeof callback === "function") {
          process.nextTick(callback);
        }
        return;
      }
      this.isRefreshing = true;
      const _this = this;
      const wrapper = function(error) {
        _this.isRefreshing = false;
        if (typeof callback === "function") {
          callback(error);
        }
      };
      const nodes = utils_2.shuffle(this.connectionPool.getNodes());
      let lastNodeError = null;
      function tryNode(index) {
        if (index === nodes.length) {
          const error = new ClusterAllFailedError_1.default("Failed to refresh slots cache.", lastNodeError);
          return wrapper(error);
        }
        const node4 = nodes[index];
        const key = `${node4.options.host}:${node4.options.port}`;
        debug("getting slot cache from %s", key);
        _this.getInfoFromNode(node4, function(err) {
          switch (_this.status) {
            case "close":
            case "end":
              return wrapper(new Error("Cluster is disconnected."));
            case "disconnecting":
              return wrapper(new Error("Cluster is disconnecting."));
          }
          if (err) {
            _this.emit("node error", err, key);
            lastNodeError = err;
            tryNode(index + 1);
          } else {
            _this.emit("refresh");
            wrapper();
          }
        });
      }
      tryNode(0);
    }
    flushQueue(error) {
      let item;
      while (this.offlineQueue.length > 0) {
        item = this.offlineQueue.shift();
        item.command.reject(error);
      }
    }
    executeOfflineCommands() {
      if (this.offlineQueue.length) {
        debug("send %d commands in offline queue", this.offlineQueue.length);
        const offlineQueue = this.offlineQueue;
        this.resetOfflineQueue();
        while (offlineQueue.length > 0) {
          const item = offlineQueue.shift();
          this.sendCommand(item.command, item.stream, item.node);
        }
      }
    }
    natMapper(nodeKey) {
      if (this.options.natMap && typeof this.options.natMap === "object") {
        const key = typeof nodeKey === "string" ? nodeKey : `${nodeKey.host}:${nodeKey.port}`;
        const mapped = this.options.natMap[key];
        if (mapped) {
          debug("NAT mapping %s -> %O", key, mapped);
          return Object.assign({}, mapped);
        }
      }
      return typeof nodeKey === "string" ? util_1.nodeKeyToRedisOptions(nodeKey) : nodeKey;
    }
    sendCommand(command, stream, node4) {
      if (this.status === "wait") {
        this.connect().catch(utils_1.noop);
      }
      if (this.status === "end") {
        command.reject(new Error(utils_2.CONNECTION_CLOSED_ERROR_MSG));
        return command.promise;
      }
      let to = this.options.scaleReads;
      if (to !== "master") {
        const isCommandReadOnly = command.isReadOnly || commands.exists(command.name) && commands.hasFlag(command.name, "readonly");
        if (!isCommandReadOnly) {
          to = "master";
        }
      }
      let targetSlot = node4 ? node4.slot : command.getSlot();
      const ttl = {};
      const _this = this;
      if (!node4 && !command.__is_reject_overwritten) {
        command.__is_reject_overwritten = true;
        const reject = command.reject;
        command.reject = function(err) {
          const partialTry = tryConnection.bind(null, true);
          _this.handleError(err, ttl, {
            moved: function(slot, key) {
              debug("command %s is moved to %s", command.name, key);
              targetSlot = Number(slot);
              if (_this.slots[slot]) {
                _this.slots[slot][0] = key;
              } else {
                _this.slots[slot] = [key];
              }
              _this._groupsBySlot[slot] = _this._groupsIds[_this.slots[slot].join(";")];
              _this.connectionPool.findOrCreate(_this.natMapper(key));
              tryConnection();
              debug("refreshing slot caches... (triggered by MOVED error)");
              _this.refreshSlotsCache();
            },
            ask: function(slot, key) {
              debug("command %s is required to ask %s:%s", command.name, key);
              const mapped = _this.natMapper(key);
              _this.connectionPool.findOrCreate(mapped);
              tryConnection(false, `${mapped.host}:${mapped.port}`);
            },
            tryagain: partialTry,
            clusterDown: partialTry,
            connectionClosed: partialTry,
            maxRedirections: function(redirectionError) {
              reject.call(command, redirectionError);
            },
            defaults: function() {
              reject.call(command, err);
            }
          });
        };
      }
      tryConnection();
      function tryConnection(random, asking) {
        if (_this.status === "end") {
          command.reject(new redis_errors_1.AbortError("Cluster is ended."));
          return;
        }
        let redis;
        if (_this.status === "ready" || command.name === "cluster") {
          if (node4 && node4.redis) {
            redis = node4.redis;
          } else if (command_1.default.checkFlag("ENTER_SUBSCRIBER_MODE", command.name) || command_1.default.checkFlag("EXIT_SUBSCRIBER_MODE", command.name)) {
            redis = _this.subscriber.getInstance();
            if (!redis) {
              command.reject(new redis_errors_1.AbortError("No subscriber for the cluster"));
              return;
            }
          } else {
            if (!random) {
              if (typeof targetSlot === "number" && _this.slots[targetSlot]) {
                const nodeKeys = _this.slots[targetSlot];
                if (typeof to === "function") {
                  const nodes = nodeKeys.map(function(key) {
                    return _this.connectionPool.getInstanceByKey(key);
                  });
                  redis = to(nodes, command);
                  if (Array.isArray(redis)) {
                    redis = utils_2.sample(redis);
                  }
                  if (!redis) {
                    redis = nodes[0];
                  }
                } else {
                  let key;
                  if (to === "all") {
                    key = utils_2.sample(nodeKeys);
                  } else if (to === "slave" && nodeKeys.length > 1) {
                    key = utils_2.sample(nodeKeys, 1);
                  } else {
                    key = nodeKeys[0];
                  }
                  redis = _this.connectionPool.getInstanceByKey(key);
                }
              }
              if (asking) {
                redis = _this.connectionPool.getInstanceByKey(asking);
                redis.asking();
              }
            }
            if (!redis) {
              redis = (typeof to === "function" ? null : _this.connectionPool.getSampleInstance(to)) || _this.connectionPool.getSampleInstance("all");
            }
          }
          if (node4 && !node4.redis) {
            node4.redis = redis;
          }
        }
        if (redis) {
          redis.sendCommand(command, stream);
        } else if (_this.options.enableOfflineQueue) {
          _this.offlineQueue.push({
            command,
            stream,
            node: node4
          });
        } else {
          command.reject(new Error("Cluster isn't ready and enableOfflineQueue options is false"));
        }
      }
      return command.promise;
    }
    handleError(error, ttl, handlers) {
      if (typeof ttl.value === "undefined") {
        ttl.value = this.options.maxRedirections;
      } else {
        ttl.value -= 1;
      }
      if (ttl.value <= 0) {
        handlers.maxRedirections(new Error("Too many Cluster redirections. Last error: " + error));
        return;
      }
      const errv = error.message.split(" ");
      if (errv[0] === "MOVED") {
        const timeout = this.options.retryDelayOnMoved;
        if (timeout && typeof timeout === "number") {
          this.delayQueue.push("moved", handlers.moved.bind(null, errv[1], errv[2]), { timeout });
        } else {
          handlers.moved(errv[1], errv[2]);
        }
      } else if (errv[0] === "ASK") {
        handlers.ask(errv[1], errv[2]);
      } else if (errv[0] === "TRYAGAIN") {
        this.delayQueue.push("tryagain", handlers.tryagain, {
          timeout: this.options.retryDelayOnTryAgain
        });
      } else if (errv[0] === "CLUSTERDOWN" && this.options.retryDelayOnClusterDown > 0) {
        this.delayQueue.push("clusterdown", handlers.connectionClosed, {
          timeout: this.options.retryDelayOnClusterDown,
          callback: this.refreshSlotsCache.bind(this)
        });
      } else if (error.message === utils_2.CONNECTION_CLOSED_ERROR_MSG && this.options.retryDelayOnFailover > 0 && this.status === "ready") {
        this.delayQueue.push("failover", handlers.connectionClosed, {
          timeout: this.options.retryDelayOnFailover,
          callback: this.refreshSlotsCache.bind(this)
        });
      } else {
        handlers.defaults();
      }
    }
    getInfoFromNode(redis, callback) {
      if (!redis) {
        return callback(new Error("Node is disconnected"));
      }
      const duplicatedConnection = redis.duplicate({
        enableOfflineQueue: true,
        enableReadyCheck: false,
        retryStrategy: null,
        connectionName: util_1.getConnectionName("refresher", this.options.redisOptions && this.options.redisOptions.connectionName)
      });
      duplicatedConnection.on("error", utils_1.noop);
      duplicatedConnection.cluster("slots", utils_2.timeout((err, result2) => {
        duplicatedConnection.disconnect();
        if (err) {
          return callback(err);
        }
        if (this.status === "disconnecting" || this.status === "close" || this.status === "end") {
          debug("ignore CLUSTER.SLOTS results (count: %d) since cluster status is %s", result2.length, this.status);
          callback();
          return;
        }
        const nodes = [];
        debug("cluster slots result count: %d", result2.length);
        for (let i = 0;i < result2.length; ++i) {
          const items = result2[i];
          const slotRangeStart = items[0];
          const slotRangeEnd = items[1];
          const keys = [];
          for (let j2 = 2;j2 < items.length; j2++) {
            if (!items[j2][0]) {
              continue;
            }
            items[j2] = this.natMapper({ host: items[j2][0], port: items[j2][1] });
            items[j2].readOnly = j2 !== 2;
            nodes.push(items[j2]);
            keys.push(items[j2].host + ":" + items[j2].port);
          }
          debug("cluster slots result [%d]: slots %d~%d served by %s", i, slotRangeStart, slotRangeEnd, keys);
          for (let slot = slotRangeStart;slot <= slotRangeEnd; slot++) {
            this.slots[slot] = keys;
          }
        }
        this._groupsIds = Object.create(null);
        let j = 0;
        for (let i = 0;i < 16384; i++) {
          const target = (this.slots[i] || []).join(";");
          if (!target.length) {
            this._groupsBySlot[i] = undefined;
            continue;
          }
          if (!this._groupsIds[target]) {
            this._groupsIds[target] = ++j;
          }
          this._groupsBySlot[i] = this._groupsIds[target];
        }
        this.connectionPool.reset(nodes);
        callback();
      }, this.options.slotsRefreshTimeout));
    }
    invokeReadyDelayedCallbacks(err) {
      for (const c of this._readyDelayedCallbacks) {
        process.nextTick(c, err);
      }
      this._readyDelayedCallbacks = [];
    }
    readyCheck(callback) {
      this.cluster("info", function(err, res) {
        if (err) {
          return callback(err);
        }
        if (typeof res !== "string") {
          return callback();
        }
        let state;
        const lines = res.split("\r\n");
        for (let i = 0;i < lines.length; ++i) {
          const parts = lines[i].split(":");
          if (parts[0] === "cluster_state") {
            state = parts[1];
            break;
          }
        }
        if (state === "fail") {
          debug("cluster state not ok (%s)", state);
          callback(null, state);
        } else {
          callback();
        }
      });
    }
    resolveSrv(hostname) {
      return new Promise((resolve, reject) => {
        this.options.resolveSrv(hostname, (err, records) => {
          if (err) {
            return reject(err);
          }
          const self2 = this, groupedRecords = util_1.groupSrvRecords(records), sortedKeys = Object.keys(groupedRecords).sort((a, b2) => parseInt(a) - parseInt(b2));
          function tryFirstOne(err2) {
            if (!sortedKeys.length) {
              return reject(err2);
            }
            const key = sortedKeys[0], group = groupedRecords[key], record = util_1.weightSrvRecords(group);
            if (!group.records.length) {
              sortedKeys.shift();
            }
            self2.dnsLookup(record.name).then((host) => resolve({
              host,
              port: record.port
            }), tryFirstOne);
          }
          tryFirstOne();
        });
      });
    }
    dnsLookup(hostname) {
      return new Promise((resolve, reject) => {
        this.options.dnsLookup(hostname, (err, address) => {
          if (err) {
            debug("failed to resolve hostname %s to IP: %s", hostname, err.message);
            reject(err);
          } else {
            debug("resolved hostname %s to IP %s", hostname, address);
            resolve(address);
          }
        });
      });
    }
    resolveStartupNodeHostnames() {
      if (!Array.isArray(this.startupNodes) || this.startupNodes.length === 0) {
        return Promise.reject(new Error("`startupNodes` should contain at least one node."));
      }
      const startupNodes = util_1.normalizeNodeOptions(this.startupNodes);
      const hostnames = util_1.getUniqueHostnamesFromOptions(startupNodes);
      if (hostnames.length === 0) {
        return Promise.resolve(startupNodes);
      }
      return Promise.all(hostnames.map((this.options.useSRVRecords ? this.resolveSrv : this.dnsLookup).bind(this))).then((configs) => {
        const hostnameToConfig = utils_2.zipMap(hostnames, configs);
        return startupNodes.map((node4) => {
          const config = hostnameToConfig.get(node4.host);
          if (!config) {
            return node4;
          } else if (this.options.useSRVRecords) {
            return Object.assign({}, node4, config);
          } else {
            return Object.assign({}, node4, { host: config });
          }
        });
      });
    }
  }
  Object.getOwnPropertyNames(commander_1.default.prototype).forEach((name) => {
    if (!Cluster.prototype.hasOwnProperty(name)) {
      Cluster.prototype[name] = commander_1.default.prototype[name];
    }
  });
  var scanCommands = [
    "sscan",
    "hscan",
    "zscan",
    "sscanBuffer",
    "hscanBuffer",
    "zscanBuffer"
  ];
  scanCommands.forEach((command) => {
    Cluster.prototype[command + "Stream"] = function(key, options) {
      return new ScanStream_1.default(utils_1.defaults({
        objectMode: true,
        key,
        redis: this,
        command
      }, options));
    };
  });
  require_transaction().addTransactionSupport(Cluster.prototype);
  exports.default = Cluster;
});

// node_modules/ioredis/built/index.js
var require_built2 = __commonJS((exports, module) => {
  var print = function(err, reply) {
    if (err) {
      console.log("Error: " + err);
    } else {
      console.log("Reply: " + reply);
    }
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports = module.exports = require_redis().default;
  var redis_1 = require_redis();
  exports.default = redis_1.default;
  var cluster_1 = require_cluster();
  exports.Cluster = cluster_1.default;
  var command_1 = require_command();
  exports.Command = command_1.default;
  var ScanStream_1 = require_ScanStream();
  exports.ScanStream = ScanStream_1.default;
  var pipeline_1 = require_pipeline();
  exports.Pipeline = pipeline_1.default;
  var AbstractConnector_1 = require_AbstractConnector();
  exports.AbstractConnector = AbstractConnector_1.default;
  var SentinelConnector_1 = require_SentinelConnector();
  exports.SentinelConnector = SentinelConnector_1.default;
  exports.SentinelIterator = SentinelConnector_1.SentinelIterator;
  exports.ReplyError = require_redis_errors().ReplyError;
  var PromiseContainer = require_promiseContainer();
  Object.defineProperty(exports, "Promise", {
    get() {
      return PromiseContainer.get();
    },
    set(lib) {
      PromiseContainer.set(lib);
    }
  });
  exports.print = print;
});

// node_modules/celery-node/dist/kombu/message.js
var require_message = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.Message = undefined;

  class Message {
    constructor(body2, contentType, contentEncoding, properties, headers) {
      this.body = body2;
      this.contentType = contentType;
      this.contentEncoding = contentEncoding;
      this.properties = properties;
      this.headers = headers;
    }
    decode() {
      if (!this._decode) {
        this._decode = JSON.parse(this.body.toString("utf-8"));
      }
      return this._decode;
    }
  }
  exports.Message = Message;
});

// node_modules/celery-node/dist/kombu/brokers/redis.js
var require_redis2 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  var Redis = require_built2();
  var uuid_1 = require_uuid();
  var message_1 = require_message();

  class RedisMessage extends message_1.Message {
    constructor(payload) {
      super(Buffer.from(payload["body"], "base64"), payload["content-type"], payload["content-encoding"], payload["properties"], payload["headers"]);
      this.raw = payload;
    }
  }

  class RedisBroker {
    constructor(url7, opts) {
      this.channels = [];
      this.closing = false;
      this.redis = new Redis(url7, Object.assign({}, opts));
    }
    isReady() {
      return new Promise((resolve, reject) => {
        if (this.redis.status === "ready") {
          resolve();
        } else {
          let handleError;
          const handleReady = () => {
            this.redis.removeListener("error", handleError);
            resolve();
          };
          handleError = (err) => {
            this.redis.removeListener("ready", handleReady);
            reject(err);
          };
          this.redis.once("ready", handleReady);
          this.redis.once("error", handleError);
        }
      });
    }
    disconnect() {
      this.closing = true;
      return Promise.all(this.channels).then(() => this.redis.quit());
    }
    publish(body2, exchange, routingKey, headers, properties) {
      const messageBody = JSON.stringify(body2);
      const contentType = "application/json";
      const contentEncoding = "utf-8";
      const message2 = {
        body: Buffer.from(messageBody).toString("base64"),
        "content-type": contentType,
        "content-encoding": contentEncoding,
        headers,
        properties: Object.assign({ body_encoding: "base64", delivery_info: {
          exchange,
          routing_key: routingKey
        }, delivery_mode: 2, delivery_tag: uuid_1.v4() }, properties)
      };
      return this.redis.lpush(routingKey, JSON.stringify(message2));
    }
    subscribe(queue3, callback) {
      const promiseCount = 1;
      return this.isReady().then(() => {
        for (let index = 0;index < promiseCount; index += 1) {
          this.channels.push(new Promise((resolve) => this.receive(index, resolve, queue3, callback)));
        }
        return Promise.all(this.channels);
      });
    }
    receive(index, resolve, queue3, callback) {
      process.nextTick(() => this.recieveOneOnNextTick(index, resolve, queue3, callback));
    }
    recieveOneOnNextTick(index, resolve, queue3, callback) {
      if (this.closing) {
        resolve();
        return;
      }
      return this.receiveOne(queue3).then((body2) => {
        if (body2) {
          callback(body2);
        }
        Promise.resolve();
      }).then(() => this.receive(index, resolve, queue3, callback)).catch((err) => console.log(err));
    }
    receiveOne(queue3) {
      return this.redis.brpop(queue3, "5").then((result2) => {
        if (!result2) {
          return null;
        }
        const [queue4, item] = result2;
        const rawMsg = JSON.parse(item);
        if (rawMsg["content-type"] !== "application/json") {
          throw new Error(`queue ${queue4} item: unsupported content type ${rawMsg["content-type"]}`);
        }
        if (rawMsg.properties.body_encoding !== "base64") {
          throw new Error(`queue ${queue4} item: unsupported body encoding ${rawMsg.properties.body_encoding}`);
        }
        if (rawMsg["content-encoding"] !== "utf-8") {
          throw new Error(`queue ${queue4} item: unsupported content encoding ${rawMsg["content-encoding"]}`);
        }
        return new RedisMessage(rawMsg);
      });
    }
  }
  exports.default = RedisBroker;
});

// node_modules/requires-port/index.js
var require_requires_port = __commonJS((exports, module) => {
  module.exports = function required(port, protocol) {
    protocol = protocol.split(":")[0];
    port = +port;
    if (!port)
      return false;
    switch (protocol) {
      case "http":
      case "ws":
        return port !== 80;
      case "https":
      case "wss":
        return port !== 443;
      case "ftp":
        return port !== 21;
      case "gopher":
        return port !== 70;
      case "file":
        return false;
    }
    return port !== 0;
  };
});

// node_modules/querystringify/index.js
var require_querystringify = __commonJS((exports) => {
  var decode2 = function(input) {
    try {
      return decodeURIComponent(input.replace(/\+/g, " "));
    } catch (e) {
      return null;
    }
  };
  var encode2 = function(input) {
    try {
      return encodeURIComponent(input);
    } catch (e) {
      return null;
    }
  };
  var querystring = function(query4) {
    var parser = /([^=?#&]+)=?([^&]*)/g, result2 = {}, part;
    while (part = parser.exec(query4)) {
      var key = decode2(part[1]), value = decode2(part[2]);
      if (key === null || value === null || (key in result2))
        continue;
      result2[key] = value;
    }
    return result2;
  };
  var querystringify = function(obj, prefix) {
    prefix = prefix || "";
    var pairs = [], value, key;
    if (typeof prefix !== "string")
      prefix = "?";
    for (key in obj) {
      if (has.call(obj, key)) {
        value = obj[key];
        if (!value && (value === null || value === undef || isNaN(value))) {
          value = "";
        }
        key = encode2(key);
        value = encode2(value);
        if (key === null || value === null)
          continue;
        pairs.push(key + "=" + value);
      }
    }
    return pairs.length ? prefix + pairs.join("&") : "";
  };
  var has = Object.prototype.hasOwnProperty;
  var undef;
  exports.stringify = querystringify;
  exports.parse = querystring;
});

// node_modules/url-parse/index.js
var require_url_parse = __commonJS((exports, module) => {
  var trimLeft = function(str) {
    return (str ? str : "").toString().replace(controlOrWhitespace, "");
  };
  var lolcation = function(loc) {
    var globalVar;
    if (typeof window !== "undefined")
      globalVar = window;
    else if (typeof global !== "undefined")
      globalVar = global;
    else if (typeof self !== "undefined")
      globalVar = self;
    else
      globalVar = {};
    var location = globalVar.location || {};
    loc = loc || location;
    var finaldestination = {}, type = typeof loc, key;
    if (loc.protocol === "blob:") {
      finaldestination = new Url(unescape(loc.pathname), {});
    } else if (type === "string") {
      finaldestination = new Url(loc, {});
      for (key in ignore)
        delete finaldestination[key];
    } else if (type === "object") {
      for (key in loc) {
        if (key in ignore)
          continue;
        finaldestination[key] = loc[key];
      }
      if (finaldestination.slashes === undefined) {
        finaldestination.slashes = slashes.test(loc.href);
      }
    }
    return finaldestination;
  };
  var isSpecial = function(scheme) {
    return scheme === "file:" || scheme === "ftp:" || scheme === "http:" || scheme === "https:" || scheme === "ws:" || scheme === "wss:";
  };
  var extractProtocol = function(address, location) {
    address = trimLeft(address);
    address = address.replace(CRHTLF, "");
    location = location || {};
    var match = protocolre.exec(address);
    var protocol = match[1] ? match[1].toLowerCase() : "";
    var forwardSlashes = !!match[2];
    var otherSlashes = !!match[3];
    var slashesCount = 0;
    var rest;
    if (forwardSlashes) {
      if (otherSlashes) {
        rest = match[2] + match[3] + match[4];
        slashesCount = match[2].length + match[3].length;
      } else {
        rest = match[2] + match[4];
        slashesCount = match[2].length;
      }
    } else {
      if (otherSlashes) {
        rest = match[3] + match[4];
        slashesCount = match[3].length;
      } else {
        rest = match[4];
      }
    }
    if (protocol === "file:") {
      if (slashesCount >= 2) {
        rest = rest.slice(2);
      }
    } else if (isSpecial(protocol)) {
      rest = match[4];
    } else if (protocol) {
      if (forwardSlashes) {
        rest = rest.slice(2);
      }
    } else if (slashesCount >= 2 && isSpecial(location.protocol)) {
      rest = match[4];
    }
    return {
      protocol,
      slashes: forwardSlashes || isSpecial(protocol),
      slashesCount,
      rest
    };
  };
  var resolve = function(relative, base) {
    if (relative === "")
      return base;
    var path = (base || "/").split("/").slice(0, -1).concat(relative.split("/")), i = path.length, last = path[i - 1], unshift = false, up = 0;
    while (i--) {
      if (path[i] === ".") {
        path.splice(i, 1);
      } else if (path[i] === "..") {
        path.splice(i, 1);
        up++;
      } else if (up) {
        if (i === 0)
          unshift = true;
        path.splice(i, 1);
        up--;
      }
    }
    if (unshift)
      path.unshift("");
    if (last === "." || last === "..")
      path.push("");
    return path.join("/");
  };
  var Url = function(address, location, parser) {
    address = trimLeft(address);
    address = address.replace(CRHTLF, "");
    if (!(this instanceof Url)) {
      return new Url(address, location, parser);
    }
    var relative, extracted, parse4, instruction, index, key, instructions = rules.slice(), type = typeof location, url7 = this, i = 0;
    if (type !== "object" && type !== "string") {
      parser = location;
      location = null;
    }
    if (parser && typeof parser !== "function")
      parser = qs.parse;
    location = lolcation(location);
    extracted = extractProtocol(address || "", location);
    relative = !extracted.protocol && !extracted.slashes;
    url7.slashes = extracted.slashes || relative && location.slashes;
    url7.protocol = extracted.protocol || location.protocol || "";
    address = extracted.rest;
    if (extracted.protocol === "file:" && (extracted.slashesCount !== 2 || windowsDriveLetter.test(address)) || !extracted.slashes && (extracted.protocol || extracted.slashesCount < 2 || !isSpecial(url7.protocol))) {
      instructions[3] = [/(.*)/, "pathname"];
    }
    for (;i < instructions.length; i++) {
      instruction = instructions[i];
      if (typeof instruction === "function") {
        address = instruction(address, url7);
        continue;
      }
      parse4 = instruction[0];
      key = instruction[1];
      if (parse4 !== parse4) {
        url7[key] = address;
      } else if (typeof parse4 === "string") {
        index = parse4 === "@" ? address.lastIndexOf(parse4) : address.indexOf(parse4);
        if (~index) {
          if (typeof instruction[2] === "number") {
            url7[key] = address.slice(0, index);
            address = address.slice(index + instruction[2]);
          } else {
            url7[key] = address.slice(index);
            address = address.slice(0, index);
          }
        }
      } else if (index = parse4.exec(address)) {
        url7[key] = index[1];
        address = address.slice(0, index.index);
      }
      url7[key] = url7[key] || (relative && instruction[3] ? location[key] || "" : "");
      if (instruction[4])
        url7[key] = url7[key].toLowerCase();
    }
    if (parser)
      url7.query = parser(url7.query);
    if (relative && location.slashes && url7.pathname.charAt(0) !== "/" && (url7.pathname !== "" || location.pathname !== "")) {
      url7.pathname = resolve(url7.pathname, location.pathname);
    }
    if (url7.pathname.charAt(0) !== "/" && isSpecial(url7.protocol)) {
      url7.pathname = "/" + url7.pathname;
    }
    if (!required(url7.port, url7.protocol)) {
      url7.host = url7.hostname;
      url7.port = "";
    }
    url7.username = url7.password = "";
    if (url7.auth) {
      index = url7.auth.indexOf(":");
      if (~index) {
        url7.username = url7.auth.slice(0, index);
        url7.username = encodeURIComponent(decodeURIComponent(url7.username));
        url7.password = url7.auth.slice(index + 1);
        url7.password = encodeURIComponent(decodeURIComponent(url7.password));
      } else {
        url7.username = encodeURIComponent(decodeURIComponent(url7.auth));
      }
      url7.auth = url7.password ? url7.username + ":" + url7.password : url7.username;
    }
    url7.origin = url7.protocol !== "file:" && isSpecial(url7.protocol) && url7.host ? url7.protocol + "//" + url7.host : "null";
    url7.href = url7.toString();
  };
  var set = function(part, value, fn) {
    var url7 = this;
    switch (part) {
      case "query":
        if (typeof value === "string" && value.length) {
          value = (fn || qs.parse)(value);
        }
        url7[part] = value;
        break;
      case "port":
        url7[part] = value;
        if (!required(value, url7.protocol)) {
          url7.host = url7.hostname;
          url7[part] = "";
        } else if (value) {
          url7.host = url7.hostname + ":" + value;
        }
        break;
      case "hostname":
        url7[part] = value;
        if (url7.port)
          value += ":" + url7.port;
        url7.host = value;
        break;
      case "host":
        url7[part] = value;
        if (port.test(value)) {
          value = value.split(":");
          url7.port = value.pop();
          url7.hostname = value.join(":");
        } else {
          url7.hostname = value;
          url7.port = "";
        }
        break;
      case "protocol":
        url7.protocol = value.toLowerCase();
        url7.slashes = !fn;
        break;
      case "pathname":
      case "hash":
        if (value) {
          var char = part === "pathname" ? "/" : "#";
          url7[part] = value.charAt(0) !== char ? char + value : value;
        } else {
          url7[part] = value;
        }
        break;
      case "username":
      case "password":
        url7[part] = encodeURIComponent(value);
        break;
      case "auth":
        var index = value.indexOf(":");
        if (~index) {
          url7.username = value.slice(0, index);
          url7.username = encodeURIComponent(decodeURIComponent(url7.username));
          url7.password = value.slice(index + 1);
          url7.password = encodeURIComponent(decodeURIComponent(url7.password));
        } else {
          url7.username = encodeURIComponent(decodeURIComponent(value));
        }
    }
    for (var i = 0;i < rules.length; i++) {
      var ins = rules[i];
      if (ins[4])
        url7[ins[1]] = url7[ins[1]].toLowerCase();
    }
    url7.auth = url7.password ? url7.username + ":" + url7.password : url7.username;
    url7.origin = url7.protocol !== "file:" && isSpecial(url7.protocol) && url7.host ? url7.protocol + "//" + url7.host : "null";
    url7.href = url7.toString();
    return url7;
  };
  var toString = function(stringify3) {
    if (!stringify3 || typeof stringify3 !== "function")
      stringify3 = qs.stringify;
    var query4, url7 = this, host = url7.host, protocol = url7.protocol;
    if (protocol && protocol.charAt(protocol.length - 1) !== ":")
      protocol += ":";
    var result2 = protocol + (url7.protocol && url7.slashes || isSpecial(url7.protocol) ? "//" : "");
    if (url7.username) {
      result2 += url7.username;
      if (url7.password)
        result2 += ":" + url7.password;
      result2 += "@";
    } else if (url7.password) {
      result2 += ":" + url7.password;
      result2 += "@";
    } else if (url7.protocol !== "file:" && isSpecial(url7.protocol) && !host && url7.pathname !== "/") {
      result2 += "@";
    }
    if (host[host.length - 1] === ":" || port.test(url7.hostname) && !url7.port) {
      host += ":";
    }
    result2 += host + url7.pathname;
    query4 = typeof url7.query === "object" ? stringify3(url7.query) : url7.query;
    if (query4)
      result2 += query4.charAt(0) !== "?" ? "?" + query4 : query4;
    if (url7.hash)
      result2 += url7.hash;
    return result2;
  };
  var required = require_requires_port();
  var qs = require_querystringify();
  var controlOrWhitespace = /^[\x00-\x20\u00a0\u1680\u2000-\u200a\u2028\u2029\u202f\u205f\u3000\ufeff]+/;
  var CRHTLF = /[\n\r\t]/g;
  var slashes = /^[A-Za-z][A-Za-z0-9+-.]*:\/\//;
  var port = /:\d+$/;
  var protocolre = /^([a-z][a-z0-9.+-]*:)?(\/\/)?([\\/]+)?([\S\s]*)/i;
  var windowsDriveLetter = /^[a-zA-Z]:/;
  var rules = [
    ["#", "hash"],
    ["?", "query"],
    function sanitize(address, url7) {
      return isSpecial(url7.protocol) ? address.replace(/\\/g, "/") : address;
    },
    ["/", "pathname"],
    ["@", "auth", 1],
    [NaN, "host", undefined, 1, 1],
    [/:(\d*)$/, "port", undefined, 1],
    [NaN, "hostname", undefined, 1, 1]
  ];
  var ignore = { hash: 1, query: 1 };
  Url.prototype = { set, toString };
  Url.extractProtocol = extractProtocol;
  Url.location = lolcation;
  Url.trimLeft = trimLeft;
  Url.qs = qs;
  module.exports = Url;
});

// node_modules/safe-buffer/index.js
var require_safe_buffer = __commonJS((exports, module) => {
  var copyProps = function(src, dst) {
    for (var key in src) {
      dst[key] = src[key];
    }
  };
  var SafeBuffer = function(arg, encodingOrOffset, length) {
    return Buffer4(arg, encodingOrOffset, length);
  };
  /*! safe-buffer. MIT License. Feross Aboukhadijeh <https://feross.org/opensource> */
  var buffer2 = __require("buffer");
  var Buffer4 = buffer2.Buffer;
  if (Buffer4.from && Buffer4.alloc && Buffer4.allocUnsafe && Buffer4.allocUnsafeSlow) {
    module.exports = buffer2;
  } else {
    copyProps(buffer2, exports);
    exports.Buffer = SafeBuffer;
  }
  SafeBuffer.prototype = Object.create(Buffer4.prototype);
  copyProps(Buffer4, SafeBuffer);
  SafeBuffer.from = function(arg, encodingOrOffset, length) {
    if (typeof arg === "number") {
      throw new TypeError("Argument must not be a number");
    }
    return Buffer4(arg, encodingOrOffset, length);
  };
  SafeBuffer.alloc = function(size2, fill, encoding) {
    if (typeof size2 !== "number") {
      throw new TypeError("Argument must be a number");
    }
    var buf = Buffer4(size2);
    if (fill !== undefined) {
      if (typeof encoding === "string") {
        buf.fill(fill, encoding);
      } else {
        buf.fill(fill);
      }
    } else {
      buf.fill(0);
    }
    return buf;
  };
  SafeBuffer.allocUnsafe = function(size2) {
    if (typeof size2 !== "number") {
      throw new TypeError("Argument must be a number");
    }
    return Buffer4(size2);
  };
  SafeBuffer.allocUnsafeSlow = function(size2) {
    if (typeof size2 !== "number") {
      throw new TypeError("Argument must be a number");
    }
    return buffer2.SlowBuffer(size2);
  };
});

// node_modules/buffer-more-ints/buffer-more-ints.js
var require_buffer_more_ints = __commonJS((exports, module) => {
  var isContiguousInt = function(val) {
    return val <= MAX_INT && val >= -MAX_INT;
  };
  var assertContiguousInt = function(val) {
    if (!isContiguousInt(val)) {
      throw new TypeError("number cannot be represented as a contiguous integer");
    }
  };
  var check_value = function(val, min, max) {
    val = +val;
    if (typeof val != "number" || val < min || val > max || Math.floor(val) !== val) {
      throw new TypeError("\"value\" argument is out of bounds");
    }
    return val;
  };
  var check_bounds = function(buf, offset, len) {
    if (offset < 0 || offset + len > buf.length) {
      throw new RangeError("Index out of range");
    }
  };
  var readUInt24BE = function(buf, offset) {
    return buf.readUInt8(offset) << 16 | buf.readUInt16BE(offset + 1);
  };
  var writeUInt24BE = function(buf, val, offset) {
    val = check_value(val, 0, 16777215);
    check_bounds(buf, offset, 3);
    buf.writeUInt8(val >>> 16, offset);
    buf.writeUInt16BE(val & 65535, offset + 1);
  };
  var readUInt40BE = function(buf, offset) {
    return (buf.readUInt8(offset) || 0) * SHIFT_LEFT_32 + buf.readUInt32BE(offset + 1);
  };
  var writeUInt40BE = function(buf, val, offset) {
    val = check_value(val, 0, 1099511627775);
    check_bounds(buf, offset, 5);
    buf.writeUInt8(Math.floor(val * SHIFT_RIGHT_32), offset);
    buf.writeInt32BE(val & -1, offset + 1);
  };
  var readUInt48BE = function(buf, offset) {
    return buf.readUInt16BE(offset) * SHIFT_LEFT_32 + buf.readUInt32BE(offset + 2);
  };
  var writeUInt48BE = function(buf, val, offset) {
    val = check_value(val, 0, 281474976710655);
    check_bounds(buf, offset, 6);
    buf.writeUInt16BE(Math.floor(val * SHIFT_RIGHT_32), offset);
    buf.writeInt32BE(val & -1, offset + 2);
  };
  var readUInt56BE = function(buf, offset) {
    return ((buf.readUInt8(offset) || 0) << 16 | buf.readUInt16BE(offset + 1)) * SHIFT_LEFT_32 + buf.readUInt32BE(offset + 3);
  };
  var writeUInt56BE = function(buf, val, offset) {
    val = check_value(val, 0, 72057594037927940);
    check_bounds(buf, offset, 7);
    if (val < 72057594037927940) {
      var hi = Math.floor(val * SHIFT_RIGHT_32);
      buf.writeUInt8(hi >>> 16, offset);
      buf.writeUInt16BE(hi & 65535, offset + 1);
      buf.writeInt32BE(val & -1, offset + 3);
    } else {
      buf[offset] = 255;
      buf[offset + 1] = 255;
      buf[offset + 2] = 255;
      buf[offset + 3] = 255;
      buf[offset + 4] = 255;
      buf[offset + 5] = 255;
      buf[offset + 6] = 255;
    }
  };
  var readUInt64BE = function(buf, offset) {
    return buf.readUInt32BE(offset) * SHIFT_LEFT_32 + buf.readUInt32BE(offset + 4);
  };
  var writeUInt64BE = function(buf, val, offset) {
    val = check_value(val, 0, 18446744073709550000);
    check_bounds(buf, offset, 8);
    if (val < 18446744073709550000) {
      buf.writeUInt32BE(Math.floor(val * SHIFT_RIGHT_32), offset);
      buf.writeInt32BE(val & -1, offset + 4);
    } else {
      buf[offset] = 255;
      buf[offset + 1] = 255;
      buf[offset + 2] = 255;
      buf[offset + 3] = 255;
      buf[offset + 4] = 255;
      buf[offset + 5] = 255;
      buf[offset + 6] = 255;
      buf[offset + 7] = 255;
    }
  };
  var readUInt24LE = function(buf, offset) {
    return buf.readUInt8(offset + 2) << 16 | buf.readUInt16LE(offset);
  };
  var writeUInt24LE = function(buf, val, offset) {
    val = check_value(val, 0, 16777215);
    check_bounds(buf, offset, 3);
    buf.writeUInt16LE(val & 65535, offset);
    buf.writeUInt8(val >>> 16, offset + 2);
  };
  var readUInt40LE = function(buf, offset) {
    return (buf.readUInt8(offset + 4) || 0) * SHIFT_LEFT_32 + buf.readUInt32LE(offset);
  };
  var writeUInt40LE = function(buf, val, offset) {
    val = check_value(val, 0, 1099511627775);
    check_bounds(buf, offset, 5);
    buf.writeInt32LE(val & -1, offset);
    buf.writeUInt8(Math.floor(val * SHIFT_RIGHT_32), offset + 4);
  };
  var readUInt48LE = function(buf, offset) {
    return buf.readUInt16LE(offset + 4) * SHIFT_LEFT_32 + buf.readUInt32LE(offset);
  };
  var writeUInt48LE = function(buf, val, offset) {
    val = check_value(val, 0, 281474976710655);
    check_bounds(buf, offset, 6);
    buf.writeInt32LE(val & -1, offset);
    buf.writeUInt16LE(Math.floor(val * SHIFT_RIGHT_32), offset + 4);
  };
  var readUInt56LE = function(buf, offset) {
    return ((buf.readUInt8(offset + 6) || 0) << 16 | buf.readUInt16LE(offset + 4)) * SHIFT_LEFT_32 + buf.readUInt32LE(offset);
  };
  var writeUInt56LE = function(buf, val, offset) {
    val = check_value(val, 0, 72057594037927940);
    check_bounds(buf, offset, 7);
    if (val < 72057594037927940) {
      buf.writeInt32LE(val & -1, offset);
      var hi = Math.floor(val * SHIFT_RIGHT_32);
      buf.writeUInt16LE(hi & 65535, offset + 4);
      buf.writeUInt8(hi >>> 16, offset + 6);
    } else {
      buf[offset] = 255;
      buf[offset + 1] = 255;
      buf[offset + 2] = 255;
      buf[offset + 3] = 255;
      buf[offset + 4] = 255;
      buf[offset + 5] = 255;
      buf[offset + 6] = 255;
    }
  };
  var readUInt64LE = function(buf, offset) {
    return buf.readUInt32LE(offset + 4) * SHIFT_LEFT_32 + buf.readUInt32LE(offset);
  };
  var writeUInt64LE = function(buf, val, offset) {
    val = check_value(val, 0, 18446744073709550000);
    check_bounds(buf, offset, 8);
    if (val < 18446744073709550000) {
      buf.writeInt32LE(val & -1, offset);
      buf.writeUInt32LE(Math.floor(val * SHIFT_RIGHT_32), offset + 4);
    } else {
      buf[offset] = 255;
      buf[offset + 1] = 255;
      buf[offset + 2] = 255;
      buf[offset + 3] = 255;
      buf[offset + 4] = 255;
      buf[offset + 5] = 255;
      buf[offset + 6] = 255;
      buf[offset + 7] = 255;
    }
  };
  var readInt24BE = function(buf, offset) {
    return (buf.readInt8(offset) << 16) + buf.readUInt16BE(offset + 1);
  };
  var writeInt24BE = function(buf, val, offset) {
    val = check_value(val, -8388608, 8388607);
    check_bounds(buf, offset, 3);
    buf.writeInt8(val >> 16, offset);
    buf.writeUInt16BE(val & 65535, offset + 1);
  };
  var readInt40BE = function(buf, offset) {
    return (buf.readInt8(offset) || 0) * SHIFT_LEFT_32 + buf.readUInt32BE(offset + 1);
  };
  var writeInt40BE = function(buf, val, offset) {
    val = check_value(val, -549755813888, 549755813887);
    check_bounds(buf, offset, 5);
    buf.writeInt8(Math.floor(val * SHIFT_RIGHT_32), offset);
    buf.writeInt32BE(val & -1, offset + 1);
  };
  var readInt48BE = function(buf, offset) {
    return buf.readInt16BE(offset) * SHIFT_LEFT_32 + buf.readUInt32BE(offset + 2);
  };
  var writeInt48BE = function(buf, val, offset) {
    val = check_value(val, -140737488355328, 140737488355327);
    check_bounds(buf, offset, 6);
    buf.writeInt16BE(Math.floor(val * SHIFT_RIGHT_32), offset);
    buf.writeInt32BE(val & -1, offset + 2);
  };
  var readInt56BE = function(buf, offset) {
    return (((buf.readInt8(offset) || 0) << 16) + buf.readUInt16BE(offset + 1)) * SHIFT_LEFT_32 + buf.readUInt32BE(offset + 3);
  };
  var writeInt56BE = function(buf, val, offset) {
    val = check_value(val, -576460752303423500, 36028797018963970);
    check_bounds(buf, offset, 7);
    if (val < 36028797018963970) {
      var hi = Math.floor(val * SHIFT_RIGHT_32);
      buf.writeInt8(hi >> 16, offset);
      buf.writeUInt16BE(hi & 65535, offset + 1);
      buf.writeInt32BE(val & -1, offset + 3);
    } else {
      buf[offset] = 127;
      buf[offset + 1] = 255;
      buf[offset + 2] = 255;
      buf[offset + 3] = 255;
      buf[offset + 4] = 255;
      buf[offset + 5] = 255;
      buf[offset + 6] = 255;
    }
  };
  var readInt64BE = function(buf, offset) {
    return buf.readInt32BE(offset) * SHIFT_LEFT_32 + buf.readUInt32BE(offset + 4);
  };
  var writeInt64BE = function(buf, val, offset) {
    val = check_value(val, -2361183241434822600000, 9223372036854776000);
    check_bounds(buf, offset, 8);
    if (val < 9223372036854776000) {
      buf.writeInt32BE(Math.floor(val * SHIFT_RIGHT_32), offset);
      buf.writeInt32BE(val & -1, offset + 4);
    } else {
      buf[offset] = 127;
      buf[offset + 1] = 255;
      buf[offset + 2] = 255;
      buf[offset + 3] = 255;
      buf[offset + 4] = 255;
      buf[offset + 5] = 255;
      buf[offset + 6] = 255;
      buf[offset + 7] = 255;
    }
  };
  var readInt24LE = function(buf, offset) {
    return (buf.readInt8(offset + 2) << 16) + buf.readUInt16LE(offset);
  };
  var writeInt24LE = function(buf, val, offset) {
    val = check_value(val, -8388608, 8388607);
    check_bounds(buf, offset, 3);
    buf.writeUInt16LE(val & 65535, offset);
    buf.writeInt8(val >> 16, offset + 2);
  };
  var readInt40LE = function(buf, offset) {
    return (buf.readInt8(offset + 4) || 0) * SHIFT_LEFT_32 + buf.readUInt32LE(offset);
  };
  var writeInt40LE = function(buf, val, offset) {
    val = check_value(val, -549755813888, 549755813887);
    check_bounds(buf, offset, 5);
    buf.writeInt32LE(val & -1, offset);
    buf.writeInt8(Math.floor(val * SHIFT_RIGHT_32), offset + 4);
  };
  var readInt48LE = function(buf, offset) {
    return buf.readInt16LE(offset + 4) * SHIFT_LEFT_32 + buf.readUInt32LE(offset);
  };
  var writeInt48LE = function(buf, val, offset) {
    val = check_value(val, -140737488355328, 140737488355327);
    check_bounds(buf, offset, 6);
    buf.writeInt32LE(val & -1, offset);
    buf.writeInt16LE(Math.floor(val * SHIFT_RIGHT_32), offset + 4);
  };
  var readInt56LE = function(buf, offset) {
    return (((buf.readInt8(offset + 6) || 0) << 16) + buf.readUInt16LE(offset + 4)) * SHIFT_LEFT_32 + buf.readUInt32LE(offset);
  };
  var writeInt56LE = function(buf, val, offset) {
    val = check_value(val, -36028797018963970, 36028797018963970);
    check_bounds(buf, offset, 7);
    if (val < 36028797018963970) {
      buf.writeInt32LE(val & -1, offset);
      var hi = Math.floor(val * SHIFT_RIGHT_32);
      buf.writeUInt16LE(hi & 65535, offset + 4);
      buf.writeInt8(hi >> 16, offset + 6);
    } else {
      buf[offset] = 255;
      buf[offset + 1] = 255;
      buf[offset + 2] = 255;
      buf[offset + 3] = 255;
      buf[offset + 4] = 255;
      buf[offset + 5] = 255;
      buf[offset + 6] = 127;
    }
  };
  var readInt64LE = function(buf, offset) {
    return buf.readInt32LE(offset + 4) * SHIFT_LEFT_32 + buf.readUInt32LE(offset);
  };
  var writeInt64LE = function(buf, val, offset) {
    val = check_value(val, -9223372036854776000, 9223372036854776000);
    check_bounds(buf, offset, 8);
    if (val < 9223372036854776000) {
      buf.writeInt32LE(val & -1, offset);
      buf.writeInt32LE(Math.floor(val * SHIFT_RIGHT_32), offset + 4);
    } else {
      buf[offset] = 255;
      buf[offset + 1] = 255;
      buf[offset + 2] = 255;
      buf[offset + 3] = 255;
      buf[offset + 4] = 255;
      buf[offset + 5] = 255;
      buf[offset + 6] = 255;
      buf[offset + 7] = 127;
    }
  };
  var SHIFT_LEFT_32 = (1 << 16) * (1 << 16);
  var SHIFT_RIGHT_32 = 1 / SHIFT_LEFT_32;
  var MAX_INT = 9007199254740991;
  exports.isContiguousInt = isContiguousInt;
  exports.assertContiguousInt = assertContiguousInt;
  ["UInt", "Int"].forEach(function(sign7) {
    var suffix = sign7 + "8";
    exports["read" + suffix] = Buffer.prototype["read" + suffix].call;
    exports["write" + suffix] = Buffer.prototype["write" + suffix].call;
    ["16", "32"].forEach(function(size2) {
      ["LE", "BE"].forEach(function(endian) {
        var suffix2 = sign7 + size2 + endian;
        var read = Buffer.prototype["read" + suffix2];
        exports["read" + suffix2] = function(buf, offset) {
          return read.call(buf, offset);
        };
        var write = Buffer.prototype["write" + suffix2];
        exports["write" + suffix2] = function(buf, val, offset) {
          return write.call(buf, val, offset);
        };
      });
    });
  });
  exports.readUInt24BE = readUInt24BE;
  exports.writeUInt24BE = writeUInt24BE;
  exports.readUInt40BE = readUInt40BE;
  exports.writeUInt40BE = writeUInt40BE;
  exports.readUInt48BE = readUInt48BE;
  exports.writeUInt48BE = writeUInt48BE;
  exports.readUInt56BE = readUInt56BE;
  exports.writeUInt56BE = writeUInt56BE;
  exports.readUInt64BE = readUInt64BE;
  exports.writeUInt64BE = writeUInt64BE;
  exports.readUInt24LE = readUInt24LE;
  exports.writeUInt24LE = writeUInt24LE;
  exports.readUInt40LE = readUInt40LE;
  exports.writeUInt40LE = writeUInt40LE;
  exports.readUInt48LE = readUInt48LE;
  exports.writeUInt48LE = writeUInt48LE;
  exports.readUInt56LE = readUInt56LE;
  exports.writeUInt56LE = writeUInt56LE;
  exports.readUInt64LE = readUInt64LE;
  exports.writeUInt64LE = writeUInt64LE;
  exports.readInt24BE = readInt24BE;
  exports.writeInt24BE = writeInt24BE;
  exports.readInt40BE = readInt40BE;
  exports.writeInt40BE = writeInt40BE;
  exports.readInt48BE = readInt48BE;
  exports.writeInt48BE = writeInt48BE;
  exports.readInt56BE = readInt56BE;
  exports.writeInt56BE = writeInt56BE;
  exports.readInt64BE = readInt64BE;
  exports.writeInt64BE = writeInt64BE;
  exports.readInt24LE = readInt24LE;
  exports.writeInt24LE = writeInt24LE;
  exports.readInt40LE = readInt40LE;
  exports.writeInt40LE = writeInt40LE;
  exports.readInt48LE = readInt48LE;
  exports.writeInt48LE = writeInt48LE;
  exports.readInt56LE = readInt56LE;
  exports.writeInt56LE = writeInt56LE;
  exports.readInt64LE = readInt64LE;
  exports.writeInt64LE = writeInt64LE;
});

// node_modules/amqplib/lib/codec.js
var require_codec = __commonJS((exports, module) => {
  var isFloatingPoint = function(n) {
    return n >= 9223372036854776000 || Math.abs(n) < 1125899906842624 && Math.floor(n) !== n;
  };
  var encodeTable = function(buffer2, val, offset) {
    var start = offset;
    offset += 4;
    for (var key in val) {
      if (val[key] !== undefined) {
        var len = Buffer.byteLength(key);
        buffer2.writeUInt8(len, offset);
        offset++;
        buffer2.write(key, offset, "utf8");
        offset += len;
        offset += encodeFieldValue(buffer2, val[key], offset);
      }
    }
    var size2 = offset - start;
    buffer2.writeUInt32BE(size2 - 4, start);
    return size2;
  };
  var encodeArray = function(buffer2, val, offset) {
    var start = offset;
    offset += 4;
    for (var i = 0, num = val.length;i < num; i++) {
      offset += encodeFieldValue(buffer2, val[i], offset);
    }
    var size2 = offset - start;
    buffer2.writeUInt32BE(size2 - 4, start);
    return size2;
  };
  var encodeFieldValue = function(buffer2, value, offset) {
    var start = offset;
    var type = typeof value, val = value;
    if (value && type === "object" && value.hasOwnProperty("!")) {
      val = value.value;
      type = value["!"];
    }
    if (type == "number") {
      if (isFloatingPoint(val)) {
        type = "double";
      } else {
        if (val < 128 && val >= -128) {
          type = "byte";
        } else if (val >= -32768 && val < 32768) {
          type = "short";
        } else if (val >= -2147483648 && val < 2147483648) {
          type = "int";
        } else {
          type = "long";
        }
      }
    }
    function tag(t) {
      buffer2.write(t, offset);
      offset++;
    }
    switch (type) {
      case "string":
        var len = Buffer.byteLength(val, "utf8");
        tag("S");
        buffer2.writeUInt32BE(len, offset);
        offset += 4;
        buffer2.write(val, offset, "utf8");
        offset += len;
        break;
      case "object":
        if (val === null) {
          tag("V");
        } else if (Array.isArray(val)) {
          tag("A");
          offset += encodeArray(buffer2, val, offset);
        } else if (Buffer.isBuffer(val)) {
          tag("x");
          buffer2.writeUInt32BE(val.length, offset);
          offset += 4;
          val.copy(buffer2, offset);
          offset += val.length;
        } else {
          tag("F");
          offset += encodeTable(buffer2, val, offset);
        }
        break;
      case "boolean":
        tag("t");
        buffer2.writeUInt8(val ? 1 : 0, offset);
        offset++;
        break;
      case "double":
      case "float64":
        tag("d");
        buffer2.writeDoubleBE(val, offset);
        offset += 8;
        break;
      case "byte":
      case "int8":
        tag("b");
        buffer2.writeInt8(val, offset);
        offset++;
        break;
      case "short":
      case "int16":
        tag("s");
        buffer2.writeInt16BE(val, offset);
        offset += 2;
        break;
      case "int":
      case "int32":
        tag("I");
        buffer2.writeInt32BE(val, offset);
        offset += 4;
        break;
      case "long":
      case "int64":
        tag("l");
        ints.writeInt64BE(buffer2, val, offset);
        offset += 8;
        break;
      case "timestamp":
        tag("T");
        ints.writeUInt64BE(buffer2, val, offset);
        offset += 8;
        break;
      case "float":
        tag("f");
        buffer2.writeFloatBE(val, offset);
        offset += 4;
        break;
      case "decimal":
        tag("D");
        if (val.hasOwnProperty("places") && val.hasOwnProperty("digits") && val.places >= 0 && val.places < 256) {
          buffer2[offset] = val.places;
          offset++;
          buffer2.writeUInt32BE(val.digits, offset);
          offset += 4;
        } else
          throw new TypeError("Decimal value must be {'places': 0..255, 'digits': uint32}, got " + JSON.stringify(val));
        break;
      default:
        throw new TypeError("Unknown type to encode: " + type);
    }
    return offset - start;
  };
  var decodeFields = function(slice) {
    var fields = {}, offset = 0, size2 = slice.length;
    var len, key, val;
    function decodeFieldValue() {
      var tag = String.fromCharCode(slice[offset]);
      offset++;
      switch (tag) {
        case "b":
          val = slice.readInt8(offset);
          offset++;
          break;
        case "S":
          len = slice.readUInt32BE(offset);
          offset += 4;
          val = slice.toString("utf8", offset, offset + len);
          offset += len;
          break;
        case "I":
          val = slice.readInt32BE(offset);
          offset += 4;
          break;
        case "D":
          var places = slice[offset];
          offset++;
          var digits = slice.readUInt32BE(offset);
          offset += 4;
          val = { "!": "decimal", value: { places, digits } };
          break;
        case "T":
          val = ints.readUInt64BE(slice, offset);
          offset += 8;
          val = { "!": "timestamp", value: val };
          break;
        case "F":
          len = slice.readUInt32BE(offset);
          offset += 4;
          val = decodeFields(slice.slice(offset, offset + len));
          offset += len;
          break;
        case "A":
          len = slice.readUInt32BE(offset);
          offset += 4;
          decodeArray(offset + len);
          break;
        case "d":
          val = slice.readDoubleBE(offset);
          offset += 8;
          break;
        case "f":
          val = slice.readFloatBE(offset);
          offset += 4;
          break;
        case "l":
          val = ints.readInt64BE(slice, offset);
          offset += 8;
          break;
        case "s":
          val = slice.readInt16BE(offset);
          offset += 2;
          break;
        case "t":
          val = slice[offset] != 0;
          offset++;
          break;
        case "V":
          val = null;
          break;
        case "x":
          len = slice.readUInt32BE(offset);
          offset += 4;
          val = slice.slice(offset, offset + len);
          offset += len;
          break;
        default:
          throw new TypeError('Unexpected type tag "' + tag + '"');
      }
    }
    function decodeArray(until) {
      var vals = [];
      while (offset < until) {
        decodeFieldValue();
        vals.push(val);
      }
      val = vals;
    }
    while (offset < size2) {
      len = slice.readUInt8(offset);
      offset++;
      key = slice.toString("utf8", offset, offset + len);
      offset += len;
      decodeFieldValue();
      fields[key] = val;
    }
    return fields;
  };
  var ints = require_buffer_more_ints();
  exports.encodeTable = encodeTable;
  exports.decodeFields = decodeFields;
});

// node_modules/amqplib/lib/defs.js
var require_defs = __commonJS((exports, module) => {
  var decodeConnectionStart = function(buffer2) {
    var val, len, offset = 0, fields = {
      versionMajor: undefined,
      versionMinor: undefined,
      serverProperties: undefined,
      mechanisms: undefined,
      locales: undefined
    };
    val = buffer2[offset];
    offset++;
    fields.versionMajor = val;
    val = buffer2[offset];
    offset++;
    fields.versionMinor = val;
    len = buffer2.readUInt32BE(offset);
    offset += 4;
    val = decodeFields(buffer2.slice(offset, offset + len));
    offset += len;
    fields.serverProperties = val;
    len = buffer2.readUInt32BE(offset);
    offset += 4;
    val = buffer2.slice(offset, offset + len);
    offset += len;
    fields.mechanisms = val;
    len = buffer2.readUInt32BE(offset);
    offset += 4;
    val = buffer2.slice(offset, offset + len);
    offset += len;
    fields.locales = val;
    return fields;
  };
  var encodeConnectionStart = function(channel, fields) {
    var len, offset = 0, val = null, varyingSize = 0, scratchOffset = 0;
    val = fields.serverProperties;
    if (val === undefined)
      throw new Error("Missing value for mandatory field 'serverProperties'");
    if (typeof val != "object")
      throw new TypeError("Field 'serverProperties' is the wrong type; must be an object");
    len = encodeTable(SCRATCH, val, scratchOffset);
    var serverProperties_encoded = SCRATCH.slice(scratchOffset, scratchOffset + len);
    scratchOffset += len;
    varyingSize += serverProperties_encoded.length;
    val = fields.mechanisms;
    if (val === undefined)
      val = Buffer4.from("PLAIN");
    else if (!Buffer4.isBuffer(val))
      throw new TypeError("Field 'mechanisms' is the wrong type; must be a Buffer");
    varyingSize += val.length;
    val = fields.locales;
    if (val === undefined)
      val = Buffer4.from("en_US");
    else if (!Buffer4.isBuffer(val))
      throw new TypeError("Field 'locales' is the wrong type; must be a Buffer");
    varyingSize += val.length;
    var buffer2 = Buffer4.alloc(22 + varyingSize);
    buffer2[0] = 1;
    buffer2.writeUInt16BE(channel, 1);
    buffer2.writeUInt32BE(655370, 7);
    offset = 11;
    val = fields.versionMajor;
    if (val === undefined)
      val = 0;
    else if (typeof val != "number" || isNaN(val))
      throw new TypeError("Field 'versionMajor' is the wrong type; must be a number (but not NaN)");
    buffer2.writeUInt8(val, offset);
    offset++;
    val = fields.versionMinor;
    if (val === undefined)
      val = 9;
    else if (typeof val != "number" || isNaN(val))
      throw new TypeError("Field 'versionMinor' is the wrong type; must be a number (but not NaN)");
    buffer2.writeUInt8(val, offset);
    offset++;
    offset += serverProperties_encoded.copy(buffer2, offset);
    val = fields.mechanisms;
    val === undefined && (val = Buffer4.from("PLAIN"));
    len = val.length;
    buffer2.writeUInt32BE(len, offset);
    offset += 4;
    val.copy(buffer2, offset);
    offset += len;
    val = fields.locales;
    val === undefined && (val = Buffer4.from("en_US"));
    len = val.length;
    buffer2.writeUInt32BE(len, offset);
    offset += 4;
    val.copy(buffer2, offset);
    offset += len;
    buffer2[offset] = 206;
    buffer2.writeUInt32BE(offset - 7, 3);
    return buffer2;
  };
  var decodeConnectionStartOk = function(buffer2) {
    var val, len, offset = 0, fields = {
      clientProperties: undefined,
      mechanism: undefined,
      response: undefined,
      locale: undefined
    };
    len = buffer2.readUInt32BE(offset);
    offset += 4;
    val = decodeFields(buffer2.slice(offset, offset + len));
    offset += len;
    fields.clientProperties = val;
    len = buffer2.readUInt8(offset);
    offset++;
    val = buffer2.toString("utf8", offset, offset + len);
    offset += len;
    fields.mechanism = val;
    len = buffer2.readUInt32BE(offset);
    offset += 4;
    val = buffer2.slice(offset, offset + len);
    offset += len;
    fields.response = val;
    len = buffer2.readUInt8(offset);
    offset++;
    val = buffer2.toString("utf8", offset, offset + len);
    offset += len;
    fields.locale = val;
    return fields;
  };
  var encodeConnectionStartOk = function(channel, fields) {
    var len, offset = 0, val = null, varyingSize = 0, scratchOffset = 0;
    val = fields.clientProperties;
    if (val === undefined)
      throw new Error("Missing value for mandatory field 'clientProperties'");
    if (typeof val != "object")
      throw new TypeError("Field 'clientProperties' is the wrong type; must be an object");
    len = encodeTable(SCRATCH, val, scratchOffset);
    var clientProperties_encoded = SCRATCH.slice(scratchOffset, scratchOffset + len);
    scratchOffset += len;
    varyingSize += clientProperties_encoded.length;
    val = fields.mechanism;
    if (val === undefined)
      val = "PLAIN";
    else if (!(typeof val == "string" && Buffer4.byteLength(val) < 256))
      throw new TypeError("Field 'mechanism' is the wrong type; must be a string (up to 255 chars)");
    var mechanism_len = Buffer4.byteLength(val, "utf8");
    varyingSize += mechanism_len;
    val = fields.response;
    if (val === undefined)
      throw new Error("Missing value for mandatory field 'response'");
    if (!Buffer4.isBuffer(val))
      throw new TypeError("Field 'response' is the wrong type; must be a Buffer");
    varyingSize += val.length;
    val = fields.locale;
    if (val === undefined)
      val = "en_US";
    else if (!(typeof val == "string" && Buffer4.byteLength(val) < 256))
      throw new TypeError("Field 'locale' is the wrong type; must be a string (up to 255 chars)");
    var locale_len = Buffer4.byteLength(val, "utf8");
    varyingSize += locale_len;
    var buffer2 = Buffer4.alloc(18 + varyingSize);
    buffer2[0] = 1;
    buffer2.writeUInt16BE(channel, 1);
    buffer2.writeUInt32BE(655371, 7);
    offset = 11;
    offset += clientProperties_encoded.copy(buffer2, offset);
    val = fields.mechanism;
    val === undefined && (val = "PLAIN");
    buffer2[offset] = mechanism_len;
    offset++;
    buffer2.write(val, offset, "utf8");
    offset += mechanism_len;
    val = fields.response;
    val === undefined && (val = Buffer4.from(undefined));
    len = val.length;
    buffer2.writeUInt32BE(len, offset);
    offset += 4;
    val.copy(buffer2, offset);
    offset += len;
    val = fields.locale;
    val === undefined && (val = "en_US");
    buffer2[offset] = locale_len;
    offset++;
    buffer2.write(val, offset, "utf8");
    offset += locale_len;
    buffer2[offset] = 206;
    buffer2.writeUInt32BE(offset - 7, 3);
    return buffer2;
  };
  var decodeConnectionSecure = function(buffer2) {
    var val, len, offset = 0, fields = {
      challenge: undefined
    };
    len = buffer2.readUInt32BE(offset);
    offset += 4;
    val = buffer2.slice(offset, offset + len);
    offset += len;
    fields.challenge = val;
    return fields;
  };
  var encodeConnectionSecure = function(channel, fields) {
    var len, offset = 0, val = null, varyingSize = 0;
    val = fields.challenge;
    if (val === undefined)
      throw new Error("Missing value for mandatory field 'challenge'");
    if (!Buffer4.isBuffer(val))
      throw new TypeError("Field 'challenge' is the wrong type; must be a Buffer");
    varyingSize += val.length;
    var buffer2 = Buffer4.alloc(16 + varyingSize);
    buffer2[0] = 1;
    buffer2.writeUInt16BE(channel, 1);
    buffer2.writeUInt32BE(655380, 7);
    offset = 11;
    val = fields.challenge;
    val === undefined && (val = Buffer4.from(undefined));
    len = val.length;
    buffer2.writeUInt32BE(len, offset);
    offset += 4;
    val.copy(buffer2, offset);
    offset += len;
    buffer2[offset] = 206;
    buffer2.writeUInt32BE(offset - 7, 3);
    return buffer2;
  };
  var decodeConnectionSecureOk = function(buffer2) {
    var val, len, offset = 0, fields = {
      response: undefined
    };
    len = buffer2.readUInt32BE(offset);
    offset += 4;
    val = buffer2.slice(offset, offset + len);
    offset += len;
    fields.response = val;
    return fields;
  };
  var encodeConnectionSecureOk = function(channel, fields) {
    var len, offset = 0, val = null, varyingSize = 0;
    val = fields.response;
    if (val === undefined)
      throw new Error("Missing value for mandatory field 'response'");
    if (!Buffer4.isBuffer(val))
      throw new TypeError("Field 'response' is the wrong type; must be a Buffer");
    varyingSize += val.length;
    var buffer2 = Buffer4.alloc(16 + varyingSize);
    buffer2[0] = 1;
    buffer2.writeUInt16BE(channel, 1);
    buffer2.writeUInt32BE(655381, 7);
    offset = 11;
    val = fields.response;
    val === undefined && (val = Buffer4.from(undefined));
    len = val.length;
    buffer2.writeUInt32BE(len, offset);
    offset += 4;
    val.copy(buffer2, offset);
    offset += len;
    buffer2[offset] = 206;
    buffer2.writeUInt32BE(offset - 7, 3);
    return buffer2;
  };
  var decodeConnectionTune = function(buffer2) {
    var val, offset = 0, fields = {
      channelMax: undefined,
      frameMax: undefined,
      heartbeat: undefined
    };
    val = buffer2.readUInt16BE(offset);
    offset += 2;
    fields.channelMax = val;
    val = buffer2.readUInt32BE(offset);
    offset += 4;
    fields.frameMax = val;
    val = buffer2.readUInt16BE(offset);
    offset += 2;
    fields.heartbeat = val;
    return fields;
  };
  var encodeConnectionTune = function(channel, fields) {
    var offset = 0, val = null, buffer2 = Buffer4.alloc(20);
    buffer2[0] = 1;
    buffer2.writeUInt16BE(channel, 1);
    buffer2.writeUInt32BE(655390, 7);
    offset = 11;
    val = fields.channelMax;
    if (val === undefined)
      val = 0;
    else if (typeof val != "number" || isNaN(val))
      throw new TypeError("Field 'channelMax' is the wrong type; must be a number (but not NaN)");
    buffer2.writeUInt16BE(val, offset);
    offset += 2;
    val = fields.frameMax;
    if (val === undefined)
      val = 0;
    else if (typeof val != "number" || isNaN(val))
      throw new TypeError("Field 'frameMax' is the wrong type; must be a number (but not NaN)");
    buffer2.writeUInt32BE(val, offset);
    offset += 4;
    val = fields.heartbeat;
    if (val === undefined)
      val = 0;
    else if (typeof val != "number" || isNaN(val))
      throw new TypeError("Field 'heartbeat' is the wrong type; must be a number (but not NaN)");
    buffer2.writeUInt16BE(val, offset);
    offset += 2;
    buffer2[offset] = 206;
    buffer2.writeUInt32BE(offset - 7, 3);
    return buffer2;
  };
  var decodeConnectionTuneOk = function(buffer2) {
    var val, offset = 0, fields = {
      channelMax: undefined,
      frameMax: undefined,
      heartbeat: undefined
    };
    val = buffer2.readUInt16BE(offset);
    offset += 2;
    fields.channelMax = val;
    val = buffer2.readUInt32BE(offset);
    offset += 4;
    fields.frameMax = val;
    val = buffer2.readUInt16BE(offset);
    offset += 2;
    fields.heartbeat = val;
    return fields;
  };
  var encodeConnectionTuneOk = function(channel, fields) {
    var offset = 0, val = null, buffer2 = Buffer4.alloc(20);
    buffer2[0] = 1;
    buffer2.writeUInt16BE(channel, 1);
    buffer2.writeUInt32BE(655391, 7);
    offset = 11;
    val = fields.channelMax;
    if (val === undefined)
      val = 0;
    else if (typeof val != "number" || isNaN(val))
      throw new TypeError("Field 'channelMax' is the wrong type; must be a number (but not NaN)");
    buffer2.writeUInt16BE(val, offset);
    offset += 2;
    val = fields.frameMax;
    if (val === undefined)
      val = 0;
    else if (typeof val != "number" || isNaN(val))
      throw new TypeError("Field 'frameMax' is the wrong type; must be a number (but not NaN)");
    buffer2.writeUInt32BE(val, offset);
    offset += 4;
    val = fields.heartbeat;
    if (val === undefined)
      val = 0;
    else if (typeof val != "number" || isNaN(val))
      throw new TypeError("Field 'heartbeat' is the wrong type; must be a number (but not NaN)");
    buffer2.writeUInt16BE(val, offset);
    offset += 2;
    buffer2[offset] = 206;
    buffer2.writeUInt32BE(offset - 7, 3);
    return buffer2;
  };
  var decodeConnectionOpen = function(buffer2) {
    var val, len, offset = 0, fields = {
      virtualHost: undefined,
      capabilities: undefined,
      insist: undefined
    };
    len = buffer2.readUInt8(offset);
    offset++;
    val = buffer2.toString("utf8", offset, offset + len);
    offset += len;
    fields.virtualHost = val;
    len = buffer2.readUInt8(offset);
    offset++;
    val = buffer2.toString("utf8", offset, offset + len);
    offset += len;
    fields.capabilities = val;
    val = !!(1 & buffer2[offset]);
    fields.insist = val;
    return fields;
  };
  var encodeConnectionOpen = function(channel, fields) {
    var offset = 0, val = null, bits = 0, varyingSize = 0;
    val = fields.virtualHost;
    if (val === undefined)
      val = "/";
    else if (!(typeof val == "string" && Buffer4.byteLength(val) < 256))
      throw new TypeError("Field 'virtualHost' is the wrong type; must be a string (up to 255 chars)");
    var virtualHost_len = Buffer4.byteLength(val, "utf8");
    varyingSize += virtualHost_len;
    val = fields.capabilities;
    if (val === undefined)
      val = "";
    else if (!(typeof val == "string" && Buffer4.byteLength(val) < 256))
      throw new TypeError("Field 'capabilities' is the wrong type; must be a string (up to 255 chars)");
    var capabilities_len = Buffer4.byteLength(val, "utf8");
    varyingSize += capabilities_len;
    var buffer2 = Buffer4.alloc(15 + varyingSize);
    buffer2[0] = 1;
    buffer2.writeUInt16BE(channel, 1);
    buffer2.writeUInt32BE(655400, 7);
    offset = 11;
    val = fields.virtualHost;
    val === undefined && (val = "/");
    buffer2[offset] = virtualHost_len;
    offset++;
    buffer2.write(val, offset, "utf8");
    offset += virtualHost_len;
    val = fields.capabilities;
    val === undefined && (val = "");
    buffer2[offset] = capabilities_len;
    offset++;
    buffer2.write(val, offset, "utf8");
    offset += capabilities_len;
    val = fields.insist;
    val === undefined && (val = false);
    val && (bits += 1);
    buffer2[offset] = bits;
    offset++;
    buffer2[offset] = 206;
    buffer2.writeUInt32BE(offset - 7, 3);
    return buffer2;
  };
  var decodeConnectionOpenOk = function(buffer2) {
    var val, len, offset = 0, fields = {
      knownHosts: undefined
    };
    len = buffer2.readUInt8(offset);
    offset++;
    val = buffer2.toString("utf8", offset, offset + len);
    offset += len;
    fields.knownHosts = val;
    return fields;
  };
  var encodeConnectionOpenOk = function(channel, fields) {
    var offset = 0, val = null, varyingSize = 0;
    val = fields.knownHosts;
    if (val === undefined)
      val = "";
    else if (!(typeof val == "string" && Buffer4.byteLength(val) < 256))
      throw new TypeError("Field 'knownHosts' is the wrong type; must be a string (up to 255 chars)");
    var knownHosts_len = Buffer4.byteLength(val, "utf8");
    varyingSize += knownHosts_len;
    var buffer2 = Buffer4.alloc(13 + varyingSize);
    buffer2[0] = 1;
    buffer2.writeUInt16BE(channel, 1);
    buffer2.writeUInt32BE(655401, 7);
    offset = 11;
    val = fields.knownHosts;
    val === undefined && (val = "");
    buffer2[offset] = knownHosts_len;
    offset++;
    buffer2.write(val, offset, "utf8");
    offset += knownHosts_len;
    buffer2[offset] = 206;
    buffer2.writeUInt32BE(offset - 7, 3);
    return buffer2;
  };
  var decodeConnectionClose = function(buffer2) {
    var val, len, offset = 0, fields = {
      replyCode: undefined,
      replyText: undefined,
      classId: undefined,
      methodId: undefined
    };
    val = buffer2.readUInt16BE(offset);
    offset += 2;
    fields.replyCode = val;
    len = buffer2.readUInt8(offset);
    offset++;
    val = buffer2.toString("utf8", offset, offset + len);
    offset += len;
    fields.replyText = val;
    val = buffer2.readUInt16BE(offset);
    offset += 2;
    fields.classId = val;
    val = buffer2.readUInt16BE(offset);
    offset += 2;
    fields.methodId = val;
    return fields;
  };
  var encodeConnectionClose = function(channel, fields) {
    var offset = 0, val = null, varyingSize = 0;
    val = fields.replyText;
    if (val === undefined)
      val = "";
    else if (!(typeof val == "string" && Buffer4.byteLength(val) < 256))
      throw new TypeError("Field 'replyText' is the wrong type; must be a string (up to 255 chars)");
    var replyText_len = Buffer4.byteLength(val, "utf8");
    varyingSize += replyText_len;
    var buffer2 = Buffer4.alloc(19 + varyingSize);
    buffer2[0] = 1;
    buffer2.writeUInt16BE(channel, 1);
    buffer2.writeUInt32BE(655410, 7);
    offset = 11;
    val = fields.replyCode;
    if (val === undefined)
      throw new Error("Missing value for mandatory field 'replyCode'");
    if (typeof val != "number" || isNaN(val))
      throw new TypeError("Field 'replyCode' is the wrong type; must be a number (but not NaN)");
    buffer2.writeUInt16BE(val, offset);
    offset += 2;
    val = fields.replyText;
    val === undefined && (val = "");
    buffer2[offset] = replyText_len;
    offset++;
    buffer2.write(val, offset, "utf8");
    offset += replyText_len;
    val = fields.classId;
    if (val === undefined)
      throw new Error("Missing value for mandatory field 'classId'");
    if (typeof val != "number" || isNaN(val))
      throw new TypeError("Field 'classId' is the wrong type; must be a number (but not NaN)");
    buffer2.writeUInt16BE(val, offset);
    offset += 2;
    val = fields.methodId;
    if (val === undefined)
      throw new Error("Missing value for mandatory field 'methodId'");
    if (typeof val != "number" || isNaN(val))
      throw new TypeError("Field 'methodId' is the wrong type; must be a number (but not NaN)");
    buffer2.writeUInt16BE(val, offset);
    offset += 2;
    buffer2[offset] = 206;
    buffer2.writeUInt32BE(offset - 7, 3);
    return buffer2;
  };
  var decodeConnectionCloseOk = function(buffer2) {
    return {};
  };
  var encodeConnectionCloseOk = function(channel, fields) {
    var offset = 0, buffer2 = Buffer4.alloc(12);
    buffer2[0] = 1;
    buffer2.writeUInt16BE(channel, 1);
    buffer2.writeUInt32BE(655411, 7);
    offset = 11;
    buffer2[offset] = 206;
    buffer2.writeUInt32BE(offset - 7, 3);
    return buffer2;
  };
  var decodeConnectionBlocked = function(buffer2) {
    var val, len, offset = 0, fields = {
      reason: undefined
    };
    len = buffer2.readUInt8(offset);
    offset++;
    val = buffer2.toString("utf8", offset, offset + len);
    offset += len;
    fields.reason = val;
    return fields;
  };
  var encodeConnectionBlocked = function(channel, fields) {
    var offset = 0, val = null, varyingSize = 0;
    val = fields.reason;
    if (val === undefined)
      val = "";
    else if (!(typeof val == "string" && Buffer4.byteLength(val) < 256))
      throw new TypeError("Field 'reason' is the wrong type; must be a string (up to 255 chars)");
    var reason_len = Buffer4.byteLength(val, "utf8");
    varyingSize += reason_len;
    var buffer2 = Buffer4.alloc(13 + varyingSize);
    buffer2[0] = 1;
    buffer2.writeUInt16BE(channel, 1);
    buffer2.writeUInt32BE(655420, 7);
    offset = 11;
    val = fields.reason;
    val === undefined && (val = "");
    buffer2[offset] = reason_len;
    offset++;
    buffer2.write(val, offset, "utf8");
    offset += reason_len;
    buffer2[offset] = 206;
    buffer2.writeUInt32BE(offset - 7, 3);
    return buffer2;
  };
  var decodeConnectionUnblocked = function(buffer2) {
    return {};
  };
  var encodeConnectionUnblocked = function(channel, fields) {
    var offset = 0, buffer2 = Buffer4.alloc(12);
    buffer2[0] = 1;
    buffer2.writeUInt16BE(channel, 1);
    buffer2.writeUInt32BE(655421, 7);
    offset = 11;
    buffer2[offset] = 206;
    buffer2.writeUInt32BE(offset - 7, 3);
    return buffer2;
  };
  var decodeChannelOpen = function(buffer2) {
    var val, len, offset = 0, fields = {
      outOfBand: undefined
    };
    len = buffer2.readUInt8(offset);
    offset++;
    val = buffer2.toString("utf8", offset, offset + len);
    offset += len;
    fields.outOfBand = val;
    return fields;
  };
  var encodeChannelOpen = function(channel, fields) {
    var offset = 0, val = null, varyingSize = 0;
    val = fields.outOfBand;
    if (val === undefined)
      val = "";
    else if (!(typeof val == "string" && Buffer4.byteLength(val) < 256))
      throw new TypeError("Field 'outOfBand' is the wrong type; must be a string (up to 255 chars)");
    var outOfBand_len = Buffer4.byteLength(val, "utf8");
    varyingSize += outOfBand_len;
    var buffer2 = Buffer4.alloc(13 + varyingSize);
    buffer2[0] = 1;
    buffer2.writeUInt16BE(channel, 1);
    buffer2.writeUInt32BE(1310730, 7);
    offset = 11;
    val = fields.outOfBand;
    val === undefined && (val = "");
    buffer2[offset] = outOfBand_len;
    offset++;
    buffer2.write(val, offset, "utf8");
    offset += outOfBand_len;
    buffer2[offset] = 206;
    buffer2.writeUInt32BE(offset - 7, 3);
    return buffer2;
  };
  var decodeChannelOpenOk = function(buffer2) {
    var val, len, offset = 0, fields = {
      channelId: undefined
    };
    len = buffer2.readUInt32BE(offset);
    offset += 4;
    val = buffer2.slice(offset, offset + len);
    offset += len;
    fields.channelId = val;
    return fields;
  };
  var encodeChannelOpenOk = function(channel, fields) {
    var len, offset = 0, val = null, varyingSize = 0;
    val = fields.channelId;
    if (val === undefined)
      val = Buffer4.from("");
    else if (!Buffer4.isBuffer(val))
      throw new TypeError("Field 'channelId' is the wrong type; must be a Buffer");
    varyingSize += val.length;
    var buffer2 = Buffer4.alloc(16 + varyingSize);
    buffer2[0] = 1;
    buffer2.writeUInt16BE(channel, 1);
    buffer2.writeUInt32BE(1310731, 7);
    offset = 11;
    val = fields.channelId;
    val === undefined && (val = Buffer4.from(""));
    len = val.length;
    buffer2.writeUInt32BE(len, offset);
    offset += 4;
    val.copy(buffer2, offset);
    offset += len;
    buffer2[offset] = 206;
    buffer2.writeUInt32BE(offset - 7, 3);
    return buffer2;
  };
  var decodeChannelFlow = function(buffer2) {
    var val, fields = {
      active: undefined
    };
    val = !!(1 & buffer2[0]);
    fields.active = val;
    return fields;
  };
  var encodeChannelFlow = function(channel, fields) {
    var offset = 0, val = null, bits = 0, buffer2 = Buffer4.alloc(13);
    buffer2[0] = 1;
    buffer2.writeUInt16BE(channel, 1);
    buffer2.writeUInt32BE(1310740, 7);
    offset = 11;
    val = fields.active;
    if (val === undefined)
      throw new Error("Missing value for mandatory field 'active'");
    val && (bits += 1);
    buffer2[offset] = bits;
    offset++;
    buffer2[offset] = 206;
    buffer2.writeUInt32BE(offset - 7, 3);
    return buffer2;
  };
  var decodeChannelFlowOk = function(buffer2) {
    var val, fields = {
      active: undefined
    };
    val = !!(1 & buffer2[0]);
    fields.active = val;
    return fields;
  };
  var encodeChannelFlowOk = function(channel, fields) {
    var offset = 0, val = null, bits = 0, buffer2 = Buffer4.alloc(13);
    buffer2[0] = 1;
    buffer2.writeUInt16BE(channel, 1);
    buffer2.writeUInt32BE(1310741, 7);
    offset = 11;
    val = fields.active;
    if (val === undefined)
      throw new Error("Missing value for mandatory field 'active'");
    val && (bits += 1);
    buffer2[offset] = bits;
    offset++;
    buffer2[offset] = 206;
    buffer2.writeUInt32BE(offset - 7, 3);
    return buffer2;
  };
  var decodeChannelClose = function(buffer2) {
    var val, len, offset = 0, fields = {
      replyCode: undefined,
      replyText: undefined,
      classId: undefined,
      methodId: undefined
    };
    val = buffer2.readUInt16BE(offset);
    offset += 2;
    fields.replyCode = val;
    len = buffer2.readUInt8(offset);
    offset++;
    val = buffer2.toString("utf8", offset, offset + len);
    offset += len;
    fields.replyText = val;
    val = buffer2.readUInt16BE(offset);
    offset += 2;
    fields.classId = val;
    val = buffer2.readUInt16BE(offset);
    offset += 2;
    fields.methodId = val;
    return fields;
  };
  var encodeChannelClose = function(channel, fields) {
    var offset = 0, val = null, varyingSize = 0;
    val = fields.replyText;
    if (val === undefined)
      val = "";
    else if (!(typeof val == "string" && Buffer4.byteLength(val) < 256))
      throw new TypeError("Field 'replyText' is the wrong type; must be a string (up to 255 chars)");
    var replyText_len = Buffer4.byteLength(val, "utf8");
    varyingSize += replyText_len;
    var buffer2 = Buffer4.alloc(19 + varyingSize);
    buffer2[0] = 1;
    buffer2.writeUInt16BE(channel, 1);
    buffer2.writeUInt32BE(1310760, 7);
    offset = 11;
    val = fields.replyCode;
    if (val === undefined)
      throw new Error("Missing value for mandatory field 'replyCode'");
    if (typeof val != "number" || isNaN(val))
      throw new TypeError("Field 'replyCode' is the wrong type; must be a number (but not NaN)");
    buffer2.writeUInt16BE(val, offset);
    offset += 2;
    val = fields.replyText;
    val === undefined && (val = "");
    buffer2[offset] = replyText_len;
    offset++;
    buffer2.write(val, offset, "utf8");
    offset += replyText_len;
    val = fields.classId;
    if (val === undefined)
      throw new Error("Missing value for mandatory field 'classId'");
    if (typeof val != "number" || isNaN(val))
      throw new TypeError("Field 'classId' is the wrong type; must be a number (but not NaN)");
    buffer2.writeUInt16BE(val, offset);
    offset += 2;
    val = fields.methodId;
    if (val === undefined)
      throw new Error("Missing value for mandatory field 'methodId'");
    if (typeof val != "number" || isNaN(val))
      throw new TypeError("Field 'methodId' is the wrong type; must be a number (but not NaN)");
    buffer2.writeUInt16BE(val, offset);
    offset += 2;
    buffer2[offset] = 206;
    buffer2.writeUInt32BE(offset - 7, 3);
    return buffer2;
  };
  var decodeChannelCloseOk = function(buffer2) {
    return {};
  };
  var encodeChannelCloseOk = function(channel, fields) {
    var offset = 0, buffer2 = Buffer4.alloc(12);
    buffer2[0] = 1;
    buffer2.writeUInt16BE(channel, 1);
    buffer2.writeUInt32BE(1310761, 7);
    offset = 11;
    buffer2[offset] = 206;
    buffer2.writeUInt32BE(offset - 7, 3);
    return buffer2;
  };
  var decodeAccessRequest = function(buffer2) {
    var val, len, offset = 0, fields = {
      realm: undefined,
      exclusive: undefined,
      passive: undefined,
      active: undefined,
      write: undefined,
      read: undefined
    };
    len = buffer2.readUInt8(offset);
    offset++;
    val = buffer2.toString("utf8", offset, offset + len);
    offset += len;
    fields.realm = val;
    val = !!(1 & buffer2[offset]);
    fields.exclusive = val;
    val = !!(2 & buffer2[offset]);
    fields.passive = val;
    val = !!(4 & buffer2[offset]);
    fields.active = val;
    val = !!(8 & buffer2[offset]);
    fields.write = val;
    val = !!(16 & buffer2[offset]);
    fields.read = val;
    return fields;
  };
  var encodeAccessRequest = function(channel, fields) {
    var offset = 0, val = null, bits = 0, varyingSize = 0;
    val = fields.realm;
    if (val === undefined)
      val = "/data";
    else if (!(typeof val == "string" && Buffer4.byteLength(val) < 256))
      throw new TypeError("Field 'realm' is the wrong type; must be a string (up to 255 chars)");
    var realm_len = Buffer4.byteLength(val, "utf8");
    varyingSize += realm_len;
    var buffer2 = Buffer4.alloc(14 + varyingSize);
    buffer2[0] = 1;
    buffer2.writeUInt16BE(channel, 1);
    buffer2.writeUInt32BE(1966090, 7);
    offset = 11;
    val = fields.realm;
    val === undefined && (val = "/data");
    buffer2[offset] = realm_len;
    offset++;
    buffer2.write(val, offset, "utf8");
    offset += realm_len;
    val = fields.exclusive;
    val === undefined && (val = false);
    val && (bits += 1);
    val = fields.passive;
    val === undefined && (val = true);
    val && (bits += 2);
    val = fields.active;
    val === undefined && (val = true);
    val && (bits += 4);
    val = fields.write;
    val === undefined && (val = true);
    val && (bits += 8);
    val = fields.read;
    val === undefined && (val = true);
    val && (bits += 16);
    buffer2[offset] = bits;
    offset++;
    buffer2[offset] = 206;
    buffer2.writeUInt32BE(offset - 7, 3);
    return buffer2;
  };
  var decodeAccessRequestOk = function(buffer2) {
    var val, offset = 0, fields = {
      ticket: undefined
    };
    val = buffer2.readUInt16BE(offset);
    offset += 2;
    fields.ticket = val;
    return fields;
  };
  var encodeAccessRequestOk = function(channel, fields) {
    var offset = 0, val = null, buffer2 = Buffer4.alloc(14);
    buffer2[0] = 1;
    buffer2.writeUInt16BE(channel, 1);
    buffer2.writeUInt32BE(1966091, 7);
    offset = 11;
    val = fields.ticket;
    if (val === undefined)
      val = 1;
    else if (typeof val != "number" || isNaN(val))
      throw new TypeError("Field 'ticket' is the wrong type; must be a number (but not NaN)");
    buffer2.writeUInt16BE(val, offset);
    offset += 2;
    buffer2[offset] = 206;
    buffer2.writeUInt32BE(offset - 7, 3);
    return buffer2;
  };
  var decodeExchangeDeclare = function(buffer2) {
    var val, len, offset = 0, fields = {
      ticket: undefined,
      exchange: undefined,
      type: undefined,
      passive: undefined,
      durable: undefined,
      autoDelete: undefined,
      internal: undefined,
      nowait: undefined,
      arguments: undefined
    };
    val = buffer2.readUInt16BE(offset);
    offset += 2;
    fields.ticket = val;
    len = buffer2.readUInt8(offset);
    offset++;
    val = buffer2.toString("utf8", offset, offset + len);
    offset += len;
    fields.exchange = val;
    len = buffer2.readUInt8(offset);
    offset++;
    val = buffer2.toString("utf8", offset, offset + len);
    offset += len;
    fields.type = val;
    val = !!(1 & buffer2[offset]);
    fields.passive = val;
    val = !!(2 & buffer2[offset]);
    fields.durable = val;
    val = !!(4 & buffer2[offset]);
    fields.autoDelete = val;
    val = !!(8 & buffer2[offset]);
    fields.internal = val;
    val = !!(16 & buffer2[offset]);
    fields.nowait = val;
    offset++;
    len = buffer2.readUInt32BE(offset);
    offset += 4;
    val = decodeFields(buffer2.slice(offset, offset + len));
    offset += len;
    fields.arguments = val;
    return fields;
  };
  var encodeExchangeDeclare = function(channel, fields) {
    var len, offset = 0, val = null, bits = 0, varyingSize = 0, scratchOffset = 0;
    val = fields.exchange;
    if (val === undefined)
      throw new Error("Missing value for mandatory field 'exchange'");
    if (!(typeof val == "string" && Buffer4.byteLength(val) < 256))
      throw new TypeError("Field 'exchange' is the wrong type; must be a string (up to 255 chars)");
    var exchange_len = Buffer4.byteLength(val, "utf8");
    varyingSize += exchange_len;
    val = fields.type;
    if (val === undefined)
      val = "direct";
    else if (!(typeof val == "string" && Buffer4.byteLength(val) < 256))
      throw new TypeError("Field 'type' is the wrong type; must be a string (up to 255 chars)");
    var type_len = Buffer4.byteLength(val, "utf8");
    varyingSize += type_len;
    val = fields.arguments;
    if (val === undefined)
      val = {};
    else if (typeof val != "object")
      throw new TypeError("Field 'arguments' is the wrong type; must be an object");
    len = encodeTable(SCRATCH, val, scratchOffset);
    var arguments_encoded = SCRATCH.slice(scratchOffset, scratchOffset + len);
    scratchOffset += len;
    varyingSize += arguments_encoded.length;
    var buffer2 = Buffer4.alloc(17 + varyingSize);
    buffer2[0] = 1;
    buffer2.writeUInt16BE(channel, 1);
    buffer2.writeUInt32BE(2621450, 7);
    offset = 11;
    val = fields.ticket;
    if (val === undefined)
      val = 0;
    else if (typeof val != "number" || isNaN(val))
      throw new TypeError("Field 'ticket' is the wrong type; must be a number (but not NaN)");
    buffer2.writeUInt16BE(val, offset);
    offset += 2;
    val = fields.exchange;
    val === undefined && (val = undefined);
    buffer2[offset] = exchange_len;
    offset++;
    buffer2.write(val, offset, "utf8");
    offset += exchange_len;
    val = fields.type;
    val === undefined && (val = "direct");
    buffer2[offset] = type_len;
    offset++;
    buffer2.write(val, offset, "utf8");
    offset += type_len;
    val = fields.passive;
    val === undefined && (val = false);
    val && (bits += 1);
    val = fields.durable;
    val === undefined && (val = false);
    val && (bits += 2);
    val = fields.autoDelete;
    val === undefined && (val = false);
    val && (bits += 4);
    val = fields.internal;
    val === undefined && (val = false);
    val && (bits += 8);
    val = fields.nowait;
    val === undefined && (val = false);
    val && (bits += 16);
    buffer2[offset] = bits;
    offset++;
    bits = 0;
    offset += arguments_encoded.copy(buffer2, offset);
    buffer2[offset] = 206;
    buffer2.writeUInt32BE(offset - 7, 3);
    return buffer2;
  };
  var decodeExchangeDeclareOk = function(buffer2) {
    return {};
  };
  var encodeExchangeDeclareOk = function(channel, fields) {
    var offset = 0, buffer2 = Buffer4.alloc(12);
    buffer2[0] = 1;
    buffer2.writeUInt16BE(channel, 1);
    buffer2.writeUInt32BE(2621451, 7);
    offset = 11;
    buffer2[offset] = 206;
    buffer2.writeUInt32BE(offset - 7, 3);
    return buffer2;
  };
  var decodeExchangeDelete = function(buffer2) {
    var val, len, offset = 0, fields = {
      ticket: undefined,
      exchange: undefined,
      ifUnused: undefined,
      nowait: undefined
    };
    val = buffer2.readUInt16BE(offset);
    offset += 2;
    fields.ticket = val;
    len = buffer2.readUInt8(offset);
    offset++;
    val = buffer2.toString("utf8", offset, offset + len);
    offset += len;
    fields.exchange = val;
    val = !!(1 & buffer2[offset]);
    fields.ifUnused = val;
    val = !!(2 & buffer2[offset]);
    fields.nowait = val;
    return fields;
  };
  var encodeExchangeDelete = function(channel, fields) {
    var offset = 0, val = null, bits = 0, varyingSize = 0;
    val = fields.exchange;
    if (val === undefined)
      throw new Error("Missing value for mandatory field 'exchange'");
    if (!(typeof val == "string" && Buffer4.byteLength(val) < 256))
      throw new TypeError("Field 'exchange' is the wrong type; must be a string (up to 255 chars)");
    var exchange_len = Buffer4.byteLength(val, "utf8");
    varyingSize += exchange_len;
    var buffer2 = Buffer4.alloc(16 + varyingSize);
    buffer2[0] = 1;
    buffer2.writeUInt16BE(channel, 1);
    buffer2.writeUInt32BE(2621460, 7);
    offset = 11;
    val = fields.ticket;
    if (val === undefined)
      val = 0;
    else if (typeof val != "number" || isNaN(val))
      throw new TypeError("Field 'ticket' is the wrong type; must be a number (but not NaN)");
    buffer2.writeUInt16BE(val, offset);
    offset += 2;
    val = fields.exchange;
    val === undefined && (val = undefined);
    buffer2[offset] = exchange_len;
    offset++;
    buffer2.write(val, offset, "utf8");
    offset += exchange_len;
    val = fields.ifUnused;
    val === undefined && (val = false);
    val && (bits += 1);
    val = fields.nowait;
    val === undefined && (val = false);
    val && (bits += 2);
    buffer2[offset] = bits;
    offset++;
    buffer2[offset] = 206;
    buffer2.writeUInt32BE(offset - 7, 3);
    return buffer2;
  };
  var decodeExchangeDeleteOk = function(buffer2) {
    return {};
  };
  var encodeExchangeDeleteOk = function(channel, fields) {
    var offset = 0, buffer2 = Buffer4.alloc(12);
    buffer2[0] = 1;
    buffer2.writeUInt16BE(channel, 1);
    buffer2.writeUInt32BE(2621461, 7);
    offset = 11;
    buffer2[offset] = 206;
    buffer2.writeUInt32BE(offset - 7, 3);
    return buffer2;
  };
  var decodeExchangeBind = function(buffer2) {
    var val, len, offset = 0, fields = {
      ticket: undefined,
      destination: undefined,
      source: undefined,
      routingKey: undefined,
      nowait: undefined,
      arguments: undefined
    };
    val = buffer2.readUInt16BE(offset);
    offset += 2;
    fields.ticket = val;
    len = buffer2.readUInt8(offset);
    offset++;
    val = buffer2.toString("utf8", offset, offset + len);
    offset += len;
    fields.destination = val;
    len = buffer2.readUInt8(offset);
    offset++;
    val = buffer2.toString("utf8", offset, offset + len);
    offset += len;
    fields.source = val;
    len = buffer2.readUInt8(offset);
    offset++;
    val = buffer2.toString("utf8", offset, offset + len);
    offset += len;
    fields.routingKey = val;
    val = !!(1 & buffer2[offset]);
    fields.nowait = val;
    offset++;
    len = buffer2.readUInt32BE(offset);
    offset += 4;
    val = decodeFields(buffer2.slice(offset, offset + len));
    offset += len;
    fields.arguments = val;
    return fields;
  };
  var encodeExchangeBind = function(channel, fields) {
    var len, offset = 0, val = null, bits = 0, varyingSize = 0, scratchOffset = 0;
    val = fields.destination;
    if (val === undefined)
      throw new Error("Missing value for mandatory field 'destination'");
    if (!(typeof val == "string" && Buffer4.byteLength(val) < 256))
      throw new TypeError("Field 'destination' is the wrong type; must be a string (up to 255 chars)");
    var destination_len = Buffer4.byteLength(val, "utf8");
    varyingSize += destination_len;
    val = fields.source;
    if (val === undefined)
      throw new Error("Missing value for mandatory field 'source'");
    if (!(typeof val == "string" && Buffer4.byteLength(val) < 256))
      throw new TypeError("Field 'source' is the wrong type; must be a string (up to 255 chars)");
    var source_len = Buffer4.byteLength(val, "utf8");
    varyingSize += source_len;
    val = fields.routingKey;
    if (val === undefined)
      val = "";
    else if (!(typeof val == "string" && Buffer4.byteLength(val) < 256))
      throw new TypeError("Field 'routingKey' is the wrong type; must be a string (up to 255 chars)");
    var routingKey_len = Buffer4.byteLength(val, "utf8");
    varyingSize += routingKey_len;
    val = fields.arguments;
    if (val === undefined)
      val = {};
    else if (typeof val != "object")
      throw new TypeError("Field 'arguments' is the wrong type; must be an object");
    len = encodeTable(SCRATCH, val, scratchOffset);
    var arguments_encoded = SCRATCH.slice(scratchOffset, scratchOffset + len);
    scratchOffset += len;
    varyingSize += arguments_encoded.length;
    var buffer2 = Buffer4.alloc(18 + varyingSize);
    buffer2[0] = 1;
    buffer2.writeUInt16BE(channel, 1);
    buffer2.writeUInt32BE(2621470, 7);
    offset = 11;
    val = fields.ticket;
    if (val === undefined)
      val = 0;
    else if (typeof val != "number" || isNaN(val))
      throw new TypeError("Field 'ticket' is the wrong type; must be a number (but not NaN)");
    buffer2.writeUInt16BE(val, offset);
    offset += 2;
    val = fields.destination;
    val === undefined && (val = undefined);
    buffer2[offset] = destination_len;
    offset++;
    buffer2.write(val, offset, "utf8");
    offset += destination_len;
    val = fields.source;
    val === undefined && (val = undefined);
    buffer2[offset] = source_len;
    offset++;
    buffer2.write(val, offset, "utf8");
    offset += source_len;
    val = fields.routingKey;
    val === undefined && (val = "");
    buffer2[offset] = routingKey_len;
    offset++;
    buffer2.write(val, offset, "utf8");
    offset += routingKey_len;
    val = fields.nowait;
    val === undefined && (val = false);
    val && (bits += 1);
    buffer2[offset] = bits;
    offset++;
    bits = 0;
    offset += arguments_encoded.copy(buffer2, offset);
    buffer2[offset] = 206;
    buffer2.writeUInt32BE(offset - 7, 3);
    return buffer2;
  };
  var decodeExchangeBindOk = function(buffer2) {
    return {};
  };
  var encodeExchangeBindOk = function(channel, fields) {
    var offset = 0, buffer2 = Buffer4.alloc(12);
    buffer2[0] = 1;
    buffer2.writeUInt16BE(channel, 1);
    buffer2.writeUInt32BE(2621471, 7);
    offset = 11;
    buffer2[offset] = 206;
    buffer2.writeUInt32BE(offset - 7, 3);
    return buffer2;
  };
  var decodeExchangeUnbind = function(buffer2) {
    var val, len, offset = 0, fields = {
      ticket: undefined,
      destination: undefined,
      source: undefined,
      routingKey: undefined,
      nowait: undefined,
      arguments: undefined
    };
    val = buffer2.readUInt16BE(offset);
    offset += 2;
    fields.ticket = val;
    len = buffer2.readUInt8(offset);
    offset++;
    val = buffer2.toString("utf8", offset, offset + len);
    offset += len;
    fields.destination = val;
    len = buffer2.readUInt8(offset);
    offset++;
    val = buffer2.toString("utf8", offset, offset + len);
    offset += len;
    fields.source = val;
    len = buffer2.readUInt8(offset);
    offset++;
    val = buffer2.toString("utf8", offset, offset + len);
    offset += len;
    fields.routingKey = val;
    val = !!(1 & buffer2[offset]);
    fields.nowait = val;
    offset++;
    len = buffer2.readUInt32BE(offset);
    offset += 4;
    val = decodeFields(buffer2.slice(offset, offset + len));
    offset += len;
    fields.arguments = val;
    return fields;
  };
  var encodeExchangeUnbind = function(channel, fields) {
    var len, offset = 0, val = null, bits = 0, varyingSize = 0, scratchOffset = 0;
    val = fields.destination;
    if (val === undefined)
      throw new Error("Missing value for mandatory field 'destination'");
    if (!(typeof val == "string" && Buffer4.byteLength(val) < 256))
      throw new TypeError("Field 'destination' is the wrong type; must be a string (up to 255 chars)");
    var destination_len = Buffer4.byteLength(val, "utf8");
    varyingSize += destination_len;
    val = fields.source;
    if (val === undefined)
      throw new Error("Missing value for mandatory field 'source'");
    if (!(typeof val == "string" && Buffer4.byteLength(val) < 256))
      throw new TypeError("Field 'source' is the wrong type; must be a string (up to 255 chars)");
    var source_len = Buffer4.byteLength(val, "utf8");
    varyingSize += source_len;
    val = fields.routingKey;
    if (val === undefined)
      val = "";
    else if (!(typeof val == "string" && Buffer4.byteLength(val) < 256))
      throw new TypeError("Field 'routingKey' is the wrong type; must be a string (up to 255 chars)");
    var routingKey_len = Buffer4.byteLength(val, "utf8");
    varyingSize += routingKey_len;
    val = fields.arguments;
    if (val === undefined)
      val = {};
    else if (typeof val != "object")
      throw new TypeError("Field 'arguments' is the wrong type; must be an object");
    len = encodeTable(SCRATCH, val, scratchOffset);
    var arguments_encoded = SCRATCH.slice(scratchOffset, scratchOffset + len);
    scratchOffset += len;
    varyingSize += arguments_encoded.length;
    var buffer2 = Buffer4.alloc(18 + varyingSize);
    buffer2[0] = 1;
    buffer2.writeUInt16BE(channel, 1);
    buffer2.writeUInt32BE(2621480, 7);
    offset = 11;
    val = fields.ticket;
    if (val === undefined)
      val = 0;
    else if (typeof val != "number" || isNaN(val))
      throw new TypeError("Field 'ticket' is the wrong type; must be a number (but not NaN)");
    buffer2.writeUInt16BE(val, offset);
    offset += 2;
    val = fields.destination;
    val === undefined && (val = undefined);
    buffer2[offset] = destination_len;
    offset++;
    buffer2.write(val, offset, "utf8");
    offset += destination_len;
    val = fields.source;
    val === undefined && (val = undefined);
    buffer2[offset] = source_len;
    offset++;
    buffer2.write(val, offset, "utf8");
    offset += source_len;
    val = fields.routingKey;
    val === undefined && (val = "");
    buffer2[offset] = routingKey_len;
    offset++;
    buffer2.write(val, offset, "utf8");
    offset += routingKey_len;
    val = fields.nowait;
    val === undefined && (val = false);
    val && (bits += 1);
    buffer2[offset] = bits;
    offset++;
    bits = 0;
    offset += arguments_encoded.copy(buffer2, offset);
    buffer2[offset] = 206;
    buffer2.writeUInt32BE(offset - 7, 3);
    return buffer2;
  };
  var decodeExchangeUnbindOk = function(buffer2) {
    return {};
  };
  var encodeExchangeUnbindOk = function(channel, fields) {
    var offset = 0, buffer2 = Buffer4.alloc(12);
    buffer2[0] = 1;
    buffer2.writeUInt16BE(channel, 1);
    buffer2.writeUInt32BE(2621491, 7);
    offset = 11;
    buffer2[offset] = 206;
    buffer2.writeUInt32BE(offset - 7, 3);
    return buffer2;
  };
  var decodeQueueDeclare = function(buffer2) {
    var val, len, offset = 0, fields = {
      ticket: undefined,
      queue: undefined,
      passive: undefined,
      durable: undefined,
      exclusive: undefined,
      autoDelete: undefined,
      nowait: undefined,
      arguments: undefined
    };
    val = buffer2.readUInt16BE(offset);
    offset += 2;
    fields.ticket = val;
    len = buffer2.readUInt8(offset);
    offset++;
    val = buffer2.toString("utf8", offset, offset + len);
    offset += len;
    fields.queue = val;
    val = !!(1 & buffer2[offset]);
    fields.passive = val;
    val = !!(2 & buffer2[offset]);
    fields.durable = val;
    val = !!(4 & buffer2[offset]);
    fields.exclusive = val;
    val = !!(8 & buffer2[offset]);
    fields.autoDelete = val;
    val = !!(16 & buffer2[offset]);
    fields.nowait = val;
    offset++;
    len = buffer2.readUInt32BE(offset);
    offset += 4;
    val = decodeFields(buffer2.slice(offset, offset + len));
    offset += len;
    fields.arguments = val;
    return fields;
  };
  var encodeQueueDeclare = function(channel, fields) {
    var len, offset = 0, val = null, bits = 0, varyingSize = 0, scratchOffset = 0;
    val = fields.queue;
    if (val === undefined)
      val = "";
    else if (!(typeof val == "string" && Buffer4.byteLength(val) < 256))
      throw new TypeError("Field 'queue' is the wrong type; must be a string (up to 255 chars)");
    var queue_len = Buffer4.byteLength(val, "utf8");
    varyingSize += queue_len;
    val = fields.arguments;
    if (val === undefined)
      val = {};
    else if (typeof val != "object")
      throw new TypeError("Field 'arguments' is the wrong type; must be an object");
    len = encodeTable(SCRATCH, val, scratchOffset);
    var arguments_encoded = SCRATCH.slice(scratchOffset, scratchOffset + len);
    scratchOffset += len;
    varyingSize += arguments_encoded.length;
    var buffer2 = Buffer4.alloc(16 + varyingSize);
    buffer2[0] = 1;
    buffer2.writeUInt16BE(channel, 1);
    buffer2.writeUInt32BE(3276810, 7);
    offset = 11;
    val = fields.ticket;
    if (val === undefined)
      val = 0;
    else if (typeof val != "number" || isNaN(val))
      throw new TypeError("Field 'ticket' is the wrong type; must be a number (but not NaN)");
    buffer2.writeUInt16BE(val, offset);
    offset += 2;
    val = fields.queue;
    val === undefined && (val = "");
    buffer2[offset] = queue_len;
    offset++;
    buffer2.write(val, offset, "utf8");
    offset += queue_len;
    val = fields.passive;
    val === undefined && (val = false);
    val && (bits += 1);
    val = fields.durable;
    val === undefined && (val = false);
    val && (bits += 2);
    val = fields.exclusive;
    val === undefined && (val = false);
    val && (bits += 4);
    val = fields.autoDelete;
    val === undefined && (val = false);
    val && (bits += 8);
    val = fields.nowait;
    val === undefined && (val = false);
    val && (bits += 16);
    buffer2[offset] = bits;
    offset++;
    bits = 0;
    offset += arguments_encoded.copy(buffer2, offset);
    buffer2[offset] = 206;
    buffer2.writeUInt32BE(offset - 7, 3);
    return buffer2;
  };
  var decodeQueueDeclareOk = function(buffer2) {
    var val, len, offset = 0, fields = {
      queue: undefined,
      messageCount: undefined,
      consumerCount: undefined
    };
    len = buffer2.readUInt8(offset);
    offset++;
    val = buffer2.toString("utf8", offset, offset + len);
    offset += len;
    fields.queue = val;
    val = buffer2.readUInt32BE(offset);
    offset += 4;
    fields.messageCount = val;
    val = buffer2.readUInt32BE(offset);
    offset += 4;
    fields.consumerCount = val;
    return fields;
  };
  var encodeQueueDeclareOk = function(channel, fields) {
    var offset = 0, val = null, varyingSize = 0;
    val = fields.queue;
    if (val === undefined)
      throw new Error("Missing value for mandatory field 'queue'");
    if (!(typeof val == "string" && Buffer4.byteLength(val) < 256))
      throw new TypeError("Field 'queue' is the wrong type; must be a string (up to 255 chars)");
    var queue_len = Buffer4.byteLength(val, "utf8");
    varyingSize += queue_len;
    var buffer2 = Buffer4.alloc(21 + varyingSize);
    buffer2[0] = 1;
    buffer2.writeUInt16BE(channel, 1);
    buffer2.writeUInt32BE(3276811, 7);
    offset = 11;
    val = fields.queue;
    val === undefined && (val = undefined);
    buffer2[offset] = queue_len;
    offset++;
    buffer2.write(val, offset, "utf8");
    offset += queue_len;
    val = fields.messageCount;
    if (val === undefined)
      throw new Error("Missing value for mandatory field 'messageCount'");
    if (typeof val != "number" || isNaN(val))
      throw new TypeError("Field 'messageCount' is the wrong type; must be a number (but not NaN)");
    buffer2.writeUInt32BE(val, offset);
    offset += 4;
    val = fields.consumerCount;
    if (val === undefined)
      throw new Error("Missing value for mandatory field 'consumerCount'");
    if (typeof val != "number" || isNaN(val))
      throw new TypeError("Field 'consumerCount' is the wrong type; must be a number (but not NaN)");
    buffer2.writeUInt32BE(val, offset);
    offset += 4;
    buffer2[offset] = 206;
    buffer2.writeUInt32BE(offset - 7, 3);
    return buffer2;
  };
  var decodeQueueBind = function(buffer2) {
    var val, len, offset = 0, fields = {
      ticket: undefined,
      queue: undefined,
      exchange: undefined,
      routingKey: undefined,
      nowait: undefined,
      arguments: undefined
    };
    val = buffer2.readUInt16BE(offset);
    offset += 2;
    fields.ticket = val;
    len = buffer2.readUInt8(offset);
    offset++;
    val = buffer2.toString("utf8", offset, offset + len);
    offset += len;
    fields.queue = val;
    len = buffer2.readUInt8(offset);
    offset++;
    val = buffer2.toString("utf8", offset, offset + len);
    offset += len;
    fields.exchange = val;
    len = buffer2.readUInt8(offset);
    offset++;
    val = buffer2.toString("utf8", offset, offset + len);
    offset += len;
    fields.routingKey = val;
    val = !!(1 & buffer2[offset]);
    fields.nowait = val;
    offset++;
    len = buffer2.readUInt32BE(offset);
    offset += 4;
    val = decodeFields(buffer2.slice(offset, offset + len));
    offset += len;
    fields.arguments = val;
    return fields;
  };
  var encodeQueueBind = function(channel, fields) {
    var len, offset = 0, val = null, bits = 0, varyingSize = 0, scratchOffset = 0;
    val = fields.queue;
    if (val === undefined)
      val = "";
    else if (!(typeof val == "string" && Buffer4.byteLength(val) < 256))
      throw new TypeError("Field 'queue' is the wrong type; must be a string (up to 255 chars)");
    var queue_len = Buffer4.byteLength(val, "utf8");
    varyingSize += queue_len;
    val = fields.exchange;
    if (val === undefined)
      throw new Error("Missing value for mandatory field 'exchange'");
    if (!(typeof val == "string" && Buffer4.byteLength(val) < 256))
      throw new TypeError("Field 'exchange' is the wrong type; must be a string (up to 255 chars)");
    var exchange_len = Buffer4.byteLength(val, "utf8");
    varyingSize += exchange_len;
    val = fields.routingKey;
    if (val === undefined)
      val = "";
    else if (!(typeof val == "string" && Buffer4.byteLength(val) < 256))
      throw new TypeError("Field 'routingKey' is the wrong type; must be a string (up to 255 chars)");
    var routingKey_len = Buffer4.byteLength(val, "utf8");
    varyingSize += routingKey_len;
    val = fields.arguments;
    if (val === undefined)
      val = {};
    else if (typeof val != "object")
      throw new TypeError("Field 'arguments' is the wrong type; must be an object");
    len = encodeTable(SCRATCH, val, scratchOffset);
    var arguments_encoded = SCRATCH.slice(scratchOffset, scratchOffset + len);
    scratchOffset += len;
    varyingSize += arguments_encoded.length;
    var buffer2 = Buffer4.alloc(18 + varyingSize);
    buffer2[0] = 1;
    buffer2.writeUInt16BE(channel, 1);
    buffer2.writeUInt32BE(3276820, 7);
    offset = 11;
    val = fields.ticket;
    if (val === undefined)
      val = 0;
    else if (typeof val != "number" || isNaN(val))
      throw new TypeError("Field 'ticket' is the wrong type; must be a number (but not NaN)");
    buffer2.writeUInt16BE(val, offset);
    offset += 2;
    val = fields.queue;
    val === undefined && (val = "");
    buffer2[offset] = queue_len;
    offset++;
    buffer2.write(val, offset, "utf8");
    offset += queue_len;
    val = fields.exchange;
    val === undefined && (val = undefined);
    buffer2[offset] = exchange_len;
    offset++;
    buffer2.write(val, offset, "utf8");
    offset += exchange_len;
    val = fields.routingKey;
    val === undefined && (val = "");
    buffer2[offset] = routingKey_len;
    offset++;
    buffer2.write(val, offset, "utf8");
    offset += routingKey_len;
    val = fields.nowait;
    val === undefined && (val = false);
    val && (bits += 1);
    buffer2[offset] = bits;
    offset++;
    bits = 0;
    offset += arguments_encoded.copy(buffer2, offset);
    buffer2[offset] = 206;
    buffer2.writeUInt32BE(offset - 7, 3);
    return buffer2;
  };
  var decodeQueueBindOk = function(buffer2) {
    return {};
  };
  var encodeQueueBindOk = function(channel, fields) {
    var offset = 0, buffer2 = Buffer4.alloc(12);
    buffer2[0] = 1;
    buffer2.writeUInt16BE(channel, 1);
    buffer2.writeUInt32BE(3276821, 7);
    offset = 11;
    buffer2[offset] = 206;
    buffer2.writeUInt32BE(offset - 7, 3);
    return buffer2;
  };
  var decodeQueuePurge = function(buffer2) {
    var val, len, offset = 0, fields = {
      ticket: undefined,
      queue: undefined,
      nowait: undefined
    };
    val = buffer2.readUInt16BE(offset);
    offset += 2;
    fields.ticket = val;
    len = buffer2.readUInt8(offset);
    offset++;
    val = buffer2.toString("utf8", offset, offset + len);
    offset += len;
    fields.queue = val;
    val = !!(1 & buffer2[offset]);
    fields.nowait = val;
    return fields;
  };
  var encodeQueuePurge = function(channel, fields) {
    var offset = 0, val = null, bits = 0, varyingSize = 0;
    val = fields.queue;
    if (val === undefined)
      val = "";
    else if (!(typeof val == "string" && Buffer4.byteLength(val) < 256))
      throw new TypeError("Field 'queue' is the wrong type; must be a string (up to 255 chars)");
    var queue_len = Buffer4.byteLength(val, "utf8");
    varyingSize += queue_len;
    var buffer2 = Buffer4.alloc(16 + varyingSize);
    buffer2[0] = 1;
    buffer2.writeUInt16BE(channel, 1);
    buffer2.writeUInt32BE(3276830, 7);
    offset = 11;
    val = fields.ticket;
    if (val === undefined)
      val = 0;
    else if (typeof val != "number" || isNaN(val))
      throw new TypeError("Field 'ticket' is the wrong type; must be a number (but not NaN)");
    buffer2.writeUInt16BE(val, offset);
    offset += 2;
    val = fields.queue;
    val === undefined && (val = "");
    buffer2[offset] = queue_len;
    offset++;
    buffer2.write(val, offset, "utf8");
    offset += queue_len;
    val = fields.nowait;
    val === undefined && (val = false);
    val && (bits += 1);
    buffer2[offset] = bits;
    offset++;
    buffer2[offset] = 206;
    buffer2.writeUInt32BE(offset - 7, 3);
    return buffer2;
  };
  var decodeQueuePurgeOk = function(buffer2) {
    var val, offset = 0, fields = {
      messageCount: undefined
    };
    val = buffer2.readUInt32BE(offset);
    offset += 4;
    fields.messageCount = val;
    return fields;
  };
  var encodeQueuePurgeOk = function(channel, fields) {
    var offset = 0, val = null, buffer2 = Buffer4.alloc(16);
    buffer2[0] = 1;
    buffer2.writeUInt16BE(channel, 1);
    buffer2.writeUInt32BE(3276831, 7);
    offset = 11;
    val = fields.messageCount;
    if (val === undefined)
      throw new Error("Missing value for mandatory field 'messageCount'");
    if (typeof val != "number" || isNaN(val))
      throw new TypeError("Field 'messageCount' is the wrong type; must be a number (but not NaN)");
    buffer2.writeUInt32BE(val, offset);
    offset += 4;
    buffer2[offset] = 206;
    buffer2.writeUInt32BE(offset - 7, 3);
    return buffer2;
  };
  var decodeQueueDelete = function(buffer2) {
    var val, len, offset = 0, fields = {
      ticket: undefined,
      queue: undefined,
      ifUnused: undefined,
      ifEmpty: undefined,
      nowait: undefined
    };
    val = buffer2.readUInt16BE(offset);
    offset += 2;
    fields.ticket = val;
    len = buffer2.readUInt8(offset);
    offset++;
    val = buffer2.toString("utf8", offset, offset + len);
    offset += len;
    fields.queue = val;
    val = !!(1 & buffer2[offset]);
    fields.ifUnused = val;
    val = !!(2 & buffer2[offset]);
    fields.ifEmpty = val;
    val = !!(4 & buffer2[offset]);
    fields.nowait = val;
    return fields;
  };
  var encodeQueueDelete = function(channel, fields) {
    var offset = 0, val = null, bits = 0, varyingSize = 0;
    val = fields.queue;
    if (val === undefined)
      val = "";
    else if (!(typeof val == "string" && Buffer4.byteLength(val) < 256))
      throw new TypeError("Field 'queue' is the wrong type; must be a string (up to 255 chars)");
    var queue_len = Buffer4.byteLength(val, "utf8");
    varyingSize += queue_len;
    var buffer2 = Buffer4.alloc(16 + varyingSize);
    buffer2[0] = 1;
    buffer2.writeUInt16BE(channel, 1);
    buffer2.writeUInt32BE(3276840, 7);
    offset = 11;
    val = fields.ticket;
    if (val === undefined)
      val = 0;
    else if (typeof val != "number" || isNaN(val))
      throw new TypeError("Field 'ticket' is the wrong type; must be a number (but not NaN)");
    buffer2.writeUInt16BE(val, offset);
    offset += 2;
    val = fields.queue;
    val === undefined && (val = "");
    buffer2[offset] = queue_len;
    offset++;
    buffer2.write(val, offset, "utf8");
    offset += queue_len;
    val = fields.ifUnused;
    val === undefined && (val = false);
    val && (bits += 1);
    val = fields.ifEmpty;
    val === undefined && (val = false);
    val && (bits += 2);
    val = fields.nowait;
    val === undefined && (val = false);
    val && (bits += 4);
    buffer2[offset] = bits;
    offset++;
    buffer2[offset] = 206;
    buffer2.writeUInt32BE(offset - 7, 3);
    return buffer2;
  };
  var decodeQueueDeleteOk = function(buffer2) {
    var val, offset = 0, fields = {
      messageCount: undefined
    };
    val = buffer2.readUInt32BE(offset);
    offset += 4;
    fields.messageCount = val;
    return fields;
  };
  var encodeQueueDeleteOk = function(channel, fields) {
    var offset = 0, val = null, buffer2 = Buffer4.alloc(16);
    buffer2[0] = 1;
    buffer2.writeUInt16BE(channel, 1);
    buffer2.writeUInt32BE(3276841, 7);
    offset = 11;
    val = fields.messageCount;
    if (val === undefined)
      throw new Error("Missing value for mandatory field 'messageCount'");
    if (typeof val != "number" || isNaN(val))
      throw new TypeError("Field 'messageCount' is the wrong type; must be a number (but not NaN)");
    buffer2.writeUInt32BE(val, offset);
    offset += 4;
    buffer2[offset] = 206;
    buffer2.writeUInt32BE(offset - 7, 3);
    return buffer2;
  };
  var decodeQueueUnbind = function(buffer2) {
    var val, len, offset = 0, fields = {
      ticket: undefined,
      queue: undefined,
      exchange: undefined,
      routingKey: undefined,
      arguments: undefined
    };
    val = buffer2.readUInt16BE(offset);
    offset += 2;
    fields.ticket = val;
    len = buffer2.readUInt8(offset);
    offset++;
    val = buffer2.toString("utf8", offset, offset + len);
    offset += len;
    fields.queue = val;
    len = buffer2.readUInt8(offset);
    offset++;
    val = buffer2.toString("utf8", offset, offset + len);
    offset += len;
    fields.exchange = val;
    len = buffer2.readUInt8(offset);
    offset++;
    val = buffer2.toString("utf8", offset, offset + len);
    offset += len;
    fields.routingKey = val;
    len = buffer2.readUInt32BE(offset);
    offset += 4;
    val = decodeFields(buffer2.slice(offset, offset + len));
    offset += len;
    fields.arguments = val;
    return fields;
  };
  var encodeQueueUnbind = function(channel, fields) {
    var len, offset = 0, val = null, varyingSize = 0, scratchOffset = 0;
    val = fields.queue;
    if (val === undefined)
      val = "";
    else if (!(typeof val == "string" && Buffer4.byteLength(val) < 256))
      throw new TypeError("Field 'queue' is the wrong type; must be a string (up to 255 chars)");
    var queue_len = Buffer4.byteLength(val, "utf8");
    varyingSize += queue_len;
    val = fields.exchange;
    if (val === undefined)
      throw new Error("Missing value for mandatory field 'exchange'");
    if (!(typeof val == "string" && Buffer4.byteLength(val) < 256))
      throw new TypeError("Field 'exchange' is the wrong type; must be a string (up to 255 chars)");
    var exchange_len = Buffer4.byteLength(val, "utf8");
    varyingSize += exchange_len;
    val = fields.routingKey;
    if (val === undefined)
      val = "";
    else if (!(typeof val == "string" && Buffer4.byteLength(val) < 256))
      throw new TypeError("Field 'routingKey' is the wrong type; must be a string (up to 255 chars)");
    var routingKey_len = Buffer4.byteLength(val, "utf8");
    varyingSize += routingKey_len;
    val = fields.arguments;
    if (val === undefined)
      val = {};
    else if (typeof val != "object")
      throw new TypeError("Field 'arguments' is the wrong type; must be an object");
    len = encodeTable(SCRATCH, val, scratchOffset);
    var arguments_encoded = SCRATCH.slice(scratchOffset, scratchOffset + len);
    scratchOffset += len;
    varyingSize += arguments_encoded.length;
    var buffer2 = Buffer4.alloc(17 + varyingSize);
    buffer2[0] = 1;
    buffer2.writeUInt16BE(channel, 1);
    buffer2.writeUInt32BE(3276850, 7);
    offset = 11;
    val = fields.ticket;
    if (val === undefined)
      val = 0;
    else if (typeof val != "number" || isNaN(val))
      throw new TypeError("Field 'ticket' is the wrong type; must be a number (but not NaN)");
    buffer2.writeUInt16BE(val, offset);
    offset += 2;
    val = fields.queue;
    val === undefined && (val = "");
    buffer2[offset] = queue_len;
    offset++;
    buffer2.write(val, offset, "utf8");
    offset += queue_len;
    val = fields.exchange;
    val === undefined && (val = undefined);
    buffer2[offset] = exchange_len;
    offset++;
    buffer2.write(val, offset, "utf8");
    offset += exchange_len;
    val = fields.routingKey;
    val === undefined && (val = "");
    buffer2[offset] = routingKey_len;
    offset++;
    buffer2.write(val, offset, "utf8");
    offset += routingKey_len;
    offset += arguments_encoded.copy(buffer2, offset);
    buffer2[offset] = 206;
    buffer2.writeUInt32BE(offset - 7, 3);
    return buffer2;
  };
  var decodeQueueUnbindOk = function(buffer2) {
    return {};
  };
  var encodeQueueUnbindOk = function(channel, fields) {
    var offset = 0, buffer2 = Buffer4.alloc(12);
    buffer2[0] = 1;
    buffer2.writeUInt16BE(channel, 1);
    buffer2.writeUInt32BE(3276851, 7);
    offset = 11;
    buffer2[offset] = 206;
    buffer2.writeUInt32BE(offset - 7, 3);
    return buffer2;
  };
  var decodeBasicQos = function(buffer2) {
    var val, offset = 0, fields = {
      prefetchSize: undefined,
      prefetchCount: undefined,
      global: undefined
    };
    val = buffer2.readUInt32BE(offset);
    offset += 4;
    fields.prefetchSize = val;
    val = buffer2.readUInt16BE(offset);
    offset += 2;
    fields.prefetchCount = val;
    val = !!(1 & buffer2[offset]);
    fields.global = val;
    return fields;
  };
  var encodeBasicQos = function(channel, fields) {
    var offset = 0, val = null, bits = 0, buffer2 = Buffer4.alloc(19);
    buffer2[0] = 1;
    buffer2.writeUInt16BE(channel, 1);
    buffer2.writeUInt32BE(3932170, 7);
    offset = 11;
    val = fields.prefetchSize;
    if (val === undefined)
      val = 0;
    else if (typeof val != "number" || isNaN(val))
      throw new TypeError("Field 'prefetchSize' is the wrong type; must be a number (but not NaN)");
    buffer2.writeUInt32BE(val, offset);
    offset += 4;
    val = fields.prefetchCount;
    if (val === undefined)
      val = 0;
    else if (typeof val != "number" || isNaN(val))
      throw new TypeError("Field 'prefetchCount' is the wrong type; must be a number (but not NaN)");
    buffer2.writeUInt16BE(val, offset);
    offset += 2;
    val = fields.global;
    val === undefined && (val = false);
    val && (bits += 1);
    buffer2[offset] = bits;
    offset++;
    buffer2[offset] = 206;
    buffer2.writeUInt32BE(offset - 7, 3);
    return buffer2;
  };
  var decodeBasicQosOk = function(buffer2) {
    return {};
  };
  var encodeBasicQosOk = function(channel, fields) {
    var offset = 0, buffer2 = Buffer4.alloc(12);
    buffer2[0] = 1;
    buffer2.writeUInt16BE(channel, 1);
    buffer2.writeUInt32BE(3932171, 7);
    offset = 11;
    buffer2[offset] = 206;
    buffer2.writeUInt32BE(offset - 7, 3);
    return buffer2;
  };
  var decodeBasicConsume = function(buffer2) {
    var val, len, offset = 0, fields = {
      ticket: undefined,
      queue: undefined,
      consumerTag: undefined,
      noLocal: undefined,
      noAck: undefined,
      exclusive: undefined,
      nowait: undefined,
      arguments: undefined
    };
    val = buffer2.readUInt16BE(offset);
    offset += 2;
    fields.ticket = val;
    len = buffer2.readUInt8(offset);
    offset++;
    val = buffer2.toString("utf8", offset, offset + len);
    offset += len;
    fields.queue = val;
    len = buffer2.readUInt8(offset);
    offset++;
    val = buffer2.toString("utf8", offset, offset + len);
    offset += len;
    fields.consumerTag = val;
    val = !!(1 & buffer2[offset]);
    fields.noLocal = val;
    val = !!(2 & buffer2[offset]);
    fields.noAck = val;
    val = !!(4 & buffer2[offset]);
    fields.exclusive = val;
    val = !!(8 & buffer2[offset]);
    fields.nowait = val;
    offset++;
    len = buffer2.readUInt32BE(offset);
    offset += 4;
    val = decodeFields(buffer2.slice(offset, offset + len));
    offset += len;
    fields.arguments = val;
    return fields;
  };
  var encodeBasicConsume = function(channel, fields) {
    var len, offset = 0, val = null, bits = 0, varyingSize = 0, scratchOffset = 0;
    val = fields.queue;
    if (val === undefined)
      val = "";
    else if (!(typeof val == "string" && Buffer4.byteLength(val) < 256))
      throw new TypeError("Field 'queue' is the wrong type; must be a string (up to 255 chars)");
    var queue_len = Buffer4.byteLength(val, "utf8");
    varyingSize += queue_len;
    val = fields.consumerTag;
    if (val === undefined)
      val = "";
    else if (!(typeof val == "string" && Buffer4.byteLength(val) < 256))
      throw new TypeError("Field 'consumerTag' is the wrong type; must be a string (up to 255 chars)");
    var consumerTag_len = Buffer4.byteLength(val, "utf8");
    varyingSize += consumerTag_len;
    val = fields.arguments;
    if (val === undefined)
      val = {};
    else if (typeof val != "object")
      throw new TypeError("Field 'arguments' is the wrong type; must be an object");
    len = encodeTable(SCRATCH, val, scratchOffset);
    var arguments_encoded = SCRATCH.slice(scratchOffset, scratchOffset + len);
    scratchOffset += len;
    varyingSize += arguments_encoded.length;
    var buffer2 = Buffer4.alloc(17 + varyingSize);
    buffer2[0] = 1;
    buffer2.writeUInt16BE(channel, 1);
    buffer2.writeUInt32BE(3932180, 7);
    offset = 11;
    val = fields.ticket;
    if (val === undefined)
      val = 0;
    else if (typeof val != "number" || isNaN(val))
      throw new TypeError("Field 'ticket' is the wrong type; must be a number (but not NaN)");
    buffer2.writeUInt16BE(val, offset);
    offset += 2;
    val = fields.queue;
    val === undefined && (val = "");
    buffer2[offset] = queue_len;
    offset++;
    buffer2.write(val, offset, "utf8");
    offset += queue_len;
    val = fields.consumerTag;
    val === undefined && (val = "");
    buffer2[offset] = consumerTag_len;
    offset++;
    buffer2.write(val, offset, "utf8");
    offset += consumerTag_len;
    val = fields.noLocal;
    val === undefined && (val = false);
    val && (bits += 1);
    val = fields.noAck;
    val === undefined && (val = false);
    val && (bits += 2);
    val = fields.exclusive;
    val === undefined && (val = false);
    val && (bits += 4);
    val = fields.nowait;
    val === undefined && (val = false);
    val && (bits += 8);
    buffer2[offset] = bits;
    offset++;
    bits = 0;
    offset += arguments_encoded.copy(buffer2, offset);
    buffer2[offset] = 206;
    buffer2.writeUInt32BE(offset - 7, 3);
    return buffer2;
  };
  var decodeBasicConsumeOk = function(buffer2) {
    var val, len, offset = 0, fields = {
      consumerTag: undefined
    };
    len = buffer2.readUInt8(offset);
    offset++;
    val = buffer2.toString("utf8", offset, offset + len);
    offset += len;
    fields.consumerTag = val;
    return fields;
  };
  var encodeBasicConsumeOk = function(channel, fields) {
    var offset = 0, val = null, varyingSize = 0;
    val = fields.consumerTag;
    if (val === undefined)
      throw new Error("Missing value for mandatory field 'consumerTag'");
    if (!(typeof val == "string" && Buffer4.byteLength(val) < 256))
      throw new TypeError("Field 'consumerTag' is the wrong type; must be a string (up to 255 chars)");
    var consumerTag_len = Buffer4.byteLength(val, "utf8");
    varyingSize += consumerTag_len;
    var buffer2 = Buffer4.alloc(13 + varyingSize);
    buffer2[0] = 1;
    buffer2.writeUInt16BE(channel, 1);
    buffer2.writeUInt32BE(3932181, 7);
    offset = 11;
    val = fields.consumerTag;
    val === undefined && (val = undefined);
    buffer2[offset] = consumerTag_len;
    offset++;
    buffer2.write(val, offset, "utf8");
    offset += consumerTag_len;
    buffer2[offset] = 206;
    buffer2.writeUInt32BE(offset - 7, 3);
    return buffer2;
  };
  var decodeBasicCancel = function(buffer2) {
    var val, len, offset = 0, fields = {
      consumerTag: undefined,
      nowait: undefined
    };
    len = buffer2.readUInt8(offset);
    offset++;
    val = buffer2.toString("utf8", offset, offset + len);
    offset += len;
    fields.consumerTag = val;
    val = !!(1 & buffer2[offset]);
    fields.nowait = val;
    return fields;
  };
  var encodeBasicCancel = function(channel, fields) {
    var offset = 0, val = null, bits = 0, varyingSize = 0;
    val = fields.consumerTag;
    if (val === undefined)
      throw new Error("Missing value for mandatory field 'consumerTag'");
    if (!(typeof val == "string" && Buffer4.byteLength(val) < 256))
      throw new TypeError("Field 'consumerTag' is the wrong type; must be a string (up to 255 chars)");
    var consumerTag_len = Buffer4.byteLength(val, "utf8");
    varyingSize += consumerTag_len;
    var buffer2 = Buffer4.alloc(14 + varyingSize);
    buffer2[0] = 1;
    buffer2.writeUInt16BE(channel, 1);
    buffer2.writeUInt32BE(3932190, 7);
    offset = 11;
    val = fields.consumerTag;
    val === undefined && (val = undefined);
    buffer2[offset] = consumerTag_len;
    offset++;
    buffer2.write(val, offset, "utf8");
    offset += consumerTag_len;
    val = fields.nowait;
    val === undefined && (val = false);
    val && (bits += 1);
    buffer2[offset] = bits;
    offset++;
    buffer2[offset] = 206;
    buffer2.writeUInt32BE(offset - 7, 3);
    return buffer2;
  };
  var decodeBasicCancelOk = function(buffer2) {
    var val, len, offset = 0, fields = {
      consumerTag: undefined
    };
    len = buffer2.readUInt8(offset);
    offset++;
    val = buffer2.toString("utf8", offset, offset + len);
    offset += len;
    fields.consumerTag = val;
    return fields;
  };
  var encodeBasicCancelOk = function(channel, fields) {
    var offset = 0, val = null, varyingSize = 0;
    val = fields.consumerTag;
    if (val === undefined)
      throw new Error("Missing value for mandatory field 'consumerTag'");
    if (!(typeof val == "string" && Buffer4.byteLength(val) < 256))
      throw new TypeError("Field 'consumerTag' is the wrong type; must be a string (up to 255 chars)");
    var consumerTag_len = Buffer4.byteLength(val, "utf8");
    varyingSize += consumerTag_len;
    var buffer2 = Buffer4.alloc(13 + varyingSize);
    buffer2[0] = 1;
    buffer2.writeUInt16BE(channel, 1);
    buffer2.writeUInt32BE(3932191, 7);
    offset = 11;
    val = fields.consumerTag;
    val === undefined && (val = undefined);
    buffer2[offset] = consumerTag_len;
    offset++;
    buffer2.write(val, offset, "utf8");
    offset += consumerTag_len;
    buffer2[offset] = 206;
    buffer2.writeUInt32BE(offset - 7, 3);
    return buffer2;
  };
  var decodeBasicPublish = function(buffer2) {
    var val, len, offset = 0, fields = {
      ticket: undefined,
      exchange: undefined,
      routingKey: undefined,
      mandatory: undefined,
      immediate: undefined
    };
    val = buffer2.readUInt16BE(offset);
    offset += 2;
    fields.ticket = val;
    len = buffer2.readUInt8(offset);
    offset++;
    val = buffer2.toString("utf8", offset, offset + len);
    offset += len;
    fields.exchange = val;
    len = buffer2.readUInt8(offset);
    offset++;
    val = buffer2.toString("utf8", offset, offset + len);
    offset += len;
    fields.routingKey = val;
    val = !!(1 & buffer2[offset]);
    fields.mandatory = val;
    val = !!(2 & buffer2[offset]);
    fields.immediate = val;
    return fields;
  };
  var encodeBasicPublish = function(channel, fields) {
    var offset = 0, val = null, bits = 0, varyingSize = 0;
    val = fields.exchange;
    if (val === undefined)
      val = "";
    else if (!(typeof val == "string" && Buffer4.byteLength(val) < 256))
      throw new TypeError("Field 'exchange' is the wrong type; must be a string (up to 255 chars)");
    var exchange_len = Buffer4.byteLength(val, "utf8");
    varyingSize += exchange_len;
    val = fields.routingKey;
    if (val === undefined)
      val = "";
    else if (!(typeof val == "string" && Buffer4.byteLength(val) < 256))
      throw new TypeError("Field 'routingKey' is the wrong type; must be a string (up to 255 chars)");
    var routingKey_len = Buffer4.byteLength(val, "utf8");
    varyingSize += routingKey_len;
    var buffer2 = Buffer4.alloc(17 + varyingSize);
    buffer2[0] = 1;
    buffer2.writeUInt16BE(channel, 1);
    buffer2.writeUInt32BE(3932200, 7);
    offset = 11;
    val = fields.ticket;
    if (val === undefined)
      val = 0;
    else if (typeof val != "number" || isNaN(val))
      throw new TypeError("Field 'ticket' is the wrong type; must be a number (but not NaN)");
    buffer2.writeUInt16BE(val, offset);
    offset += 2;
    val = fields.exchange;
    val === undefined && (val = "");
    buffer2[offset] = exchange_len;
    offset++;
    buffer2.write(val, offset, "utf8");
    offset += exchange_len;
    val = fields.routingKey;
    val === undefined && (val = "");
    buffer2[offset] = routingKey_len;
    offset++;
    buffer2.write(val, offset, "utf8");
    offset += routingKey_len;
    val = fields.mandatory;
    val === undefined && (val = false);
    val && (bits += 1);
    val = fields.immediate;
    val === undefined && (val = false);
    val && (bits += 2);
    buffer2[offset] = bits;
    offset++;
    buffer2[offset] = 206;
    buffer2.writeUInt32BE(offset - 7, 3);
    return buffer2;
  };
  var decodeBasicReturn = function(buffer2) {
    var val, len, offset = 0, fields = {
      replyCode: undefined,
      replyText: undefined,
      exchange: undefined,
      routingKey: undefined
    };
    val = buffer2.readUInt16BE(offset);
    offset += 2;
    fields.replyCode = val;
    len = buffer2.readUInt8(offset);
    offset++;
    val = buffer2.toString("utf8", offset, offset + len);
    offset += len;
    fields.replyText = val;
    len = buffer2.readUInt8(offset);
    offset++;
    val = buffer2.toString("utf8", offset, offset + len);
    offset += len;
    fields.exchange = val;
    len = buffer2.readUInt8(offset);
    offset++;
    val = buffer2.toString("utf8", offset, offset + len);
    offset += len;
    fields.routingKey = val;
    return fields;
  };
  var encodeBasicReturn = function(channel, fields) {
    var offset = 0, val = null, varyingSize = 0;
    val = fields.replyText;
    if (val === undefined)
      val = "";
    else if (!(typeof val == "string" && Buffer4.byteLength(val) < 256))
      throw new TypeError("Field 'replyText' is the wrong type; must be a string (up to 255 chars)");
    var replyText_len = Buffer4.byteLength(val, "utf8");
    varyingSize += replyText_len;
    val = fields.exchange;
    if (val === undefined)
      throw new Error("Missing value for mandatory field 'exchange'");
    if (!(typeof val == "string" && Buffer4.byteLength(val) < 256))
      throw new TypeError("Field 'exchange' is the wrong type; must be a string (up to 255 chars)");
    var exchange_len = Buffer4.byteLength(val, "utf8");
    varyingSize += exchange_len;
    val = fields.routingKey;
    if (val === undefined)
      throw new Error("Missing value for mandatory field 'routingKey'");
    if (!(typeof val == "string" && Buffer4.byteLength(val) < 256))
      throw new TypeError("Field 'routingKey' is the wrong type; must be a string (up to 255 chars)");
    var routingKey_len = Buffer4.byteLength(val, "utf8");
    varyingSize += routingKey_len;
    var buffer2 = Buffer4.alloc(17 + varyingSize);
    buffer2[0] = 1;
    buffer2.writeUInt16BE(channel, 1);
    buffer2.writeUInt32BE(3932210, 7);
    offset = 11;
    val = fields.replyCode;
    if (val === undefined)
      throw new Error("Missing value for mandatory field 'replyCode'");
    if (typeof val != "number" || isNaN(val))
      throw new TypeError("Field 'replyCode' is the wrong type; must be a number (but not NaN)");
    buffer2.writeUInt16BE(val, offset);
    offset += 2;
    val = fields.replyText;
    val === undefined && (val = "");
    buffer2[offset] = replyText_len;
    offset++;
    buffer2.write(val, offset, "utf8");
    offset += replyText_len;
    val = fields.exchange;
    val === undefined && (val = undefined);
    buffer2[offset] = exchange_len;
    offset++;
    buffer2.write(val, offset, "utf8");
    offset += exchange_len;
    val = fields.routingKey;
    val === undefined && (val = undefined);
    buffer2[offset] = routingKey_len;
    offset++;
    buffer2.write(val, offset, "utf8");
    offset += routingKey_len;
    buffer2[offset] = 206;
    buffer2.writeUInt32BE(offset - 7, 3);
    return buffer2;
  };
  var decodeBasicDeliver = function(buffer2) {
    var val, len, offset = 0, fields = {
      consumerTag: undefined,
      deliveryTag: undefined,
      redelivered: undefined,
      exchange: undefined,
      routingKey: undefined
    };
    len = buffer2.readUInt8(offset);
    offset++;
    val = buffer2.toString("utf8", offset, offset + len);
    offset += len;
    fields.consumerTag = val;
    val = ints.readUInt64BE(buffer2, offset);
    offset += 8;
    fields.deliveryTag = val;
    val = !!(1 & buffer2[offset]);
    fields.redelivered = val;
    offset++;
    len = buffer2.readUInt8(offset);
    offset++;
    val = buffer2.toString("utf8", offset, offset + len);
    offset += len;
    fields.exchange = val;
    len = buffer2.readUInt8(offset);
    offset++;
    val = buffer2.toString("utf8", offset, offset + len);
    offset += len;
    fields.routingKey = val;
    return fields;
  };
  var encodeBasicDeliver = function(channel, fields) {
    var offset = 0, val = null, bits = 0, varyingSize = 0;
    val = fields.consumerTag;
    if (val === undefined)
      throw new Error("Missing value for mandatory field 'consumerTag'");
    if (!(typeof val == "string" && Buffer4.byteLength(val) < 256))
      throw new TypeError("Field 'consumerTag' is the wrong type; must be a string (up to 255 chars)");
    var consumerTag_len = Buffer4.byteLength(val, "utf8");
    varyingSize += consumerTag_len;
    val = fields.exchange;
    if (val === undefined)
      throw new Error("Missing value for mandatory field 'exchange'");
    if (!(typeof val == "string" && Buffer4.byteLength(val) < 256))
      throw new TypeError("Field 'exchange' is the wrong type; must be a string (up to 255 chars)");
    var exchange_len = Buffer4.byteLength(val, "utf8");
    varyingSize += exchange_len;
    val = fields.routingKey;
    if (val === undefined)
      throw new Error("Missing value for mandatory field 'routingKey'");
    if (!(typeof val == "string" && Buffer4.byteLength(val) < 256))
      throw new TypeError("Field 'routingKey' is the wrong type; must be a string (up to 255 chars)");
    var routingKey_len = Buffer4.byteLength(val, "utf8");
    varyingSize += routingKey_len;
    var buffer2 = Buffer4.alloc(24 + varyingSize);
    buffer2[0] = 1;
    buffer2.writeUInt16BE(channel, 1);
    buffer2.writeUInt32BE(3932220, 7);
    offset = 11;
    val = fields.consumerTag;
    val === undefined && (val = undefined);
    buffer2[offset] = consumerTag_len;
    offset++;
    buffer2.write(val, offset, "utf8");
    offset += consumerTag_len;
    val = fields.deliveryTag;
    if (val === undefined)
      throw new Error("Missing value for mandatory field 'deliveryTag'");
    if (typeof val != "number" || isNaN(val))
      throw new TypeError("Field 'deliveryTag' is the wrong type; must be a number (but not NaN)");
    ints.writeUInt64BE(buffer2, val, offset);
    offset += 8;
    val = fields.redelivered;
    val === undefined && (val = false);
    val && (bits += 1);
    buffer2[offset] = bits;
    offset++;
    bits = 0;
    val = fields.exchange;
    val === undefined && (val = undefined);
    buffer2[offset] = exchange_len;
    offset++;
    buffer2.write(val, offset, "utf8");
    offset += exchange_len;
    val = fields.routingKey;
    val === undefined && (val = undefined);
    buffer2[offset] = routingKey_len;
    offset++;
    buffer2.write(val, offset, "utf8");
    offset += routingKey_len;
    buffer2[offset] = 206;
    buffer2.writeUInt32BE(offset - 7, 3);
    return buffer2;
  };
  var decodeBasicGet = function(buffer2) {
    var val, len, offset = 0, fields = {
      ticket: undefined,
      queue: undefined,
      noAck: undefined
    };
    val = buffer2.readUInt16BE(offset);
    offset += 2;
    fields.ticket = val;
    len = buffer2.readUInt8(offset);
    offset++;
    val = buffer2.toString("utf8", offset, offset + len);
    offset += len;
    fields.queue = val;
    val = !!(1 & buffer2[offset]);
    fields.noAck = val;
    return fields;
  };
  var encodeBasicGet = function(channel, fields) {
    var offset = 0, val = null, bits = 0, varyingSize = 0;
    val = fields.queue;
    if (val === undefined)
      val = "";
    else if (!(typeof val == "string" && Buffer4.byteLength(val) < 256))
      throw new TypeError("Field 'queue' is the wrong type; must be a string (up to 255 chars)");
    var queue_len = Buffer4.byteLength(val, "utf8");
    varyingSize += queue_len;
    var buffer2 = Buffer4.alloc(16 + varyingSize);
    buffer2[0] = 1;
    buffer2.writeUInt16BE(channel, 1);
    buffer2.writeUInt32BE(3932230, 7);
    offset = 11;
    val = fields.ticket;
    if (val === undefined)
      val = 0;
    else if (typeof val != "number" || isNaN(val))
      throw new TypeError("Field 'ticket' is the wrong type; must be a number (but not NaN)");
    buffer2.writeUInt16BE(val, offset);
    offset += 2;
    val = fields.queue;
    val === undefined && (val = "");
    buffer2[offset] = queue_len;
    offset++;
    buffer2.write(val, offset, "utf8");
    offset += queue_len;
    val = fields.noAck;
    val === undefined && (val = false);
    val && (bits += 1);
    buffer2[offset] = bits;
    offset++;
    buffer2[offset] = 206;
    buffer2.writeUInt32BE(offset - 7, 3);
    return buffer2;
  };
  var decodeBasicGetOk = function(buffer2) {
    var val, len, offset = 0, fields = {
      deliveryTag: undefined,
      redelivered: undefined,
      exchange: undefined,
      routingKey: undefined,
      messageCount: undefined
    };
    val = ints.readUInt64BE(buffer2, offset);
    offset += 8;
    fields.deliveryTag = val;
    val = !!(1 & buffer2[offset]);
    fields.redelivered = val;
    offset++;
    len = buffer2.readUInt8(offset);
    offset++;
    val = buffer2.toString("utf8", offset, offset + len);
    offset += len;
    fields.exchange = val;
    len = buffer2.readUInt8(offset);
    offset++;
    val = buffer2.toString("utf8", offset, offset + len);
    offset += len;
    fields.routingKey = val;
    val = buffer2.readUInt32BE(offset);
    offset += 4;
    fields.messageCount = val;
    return fields;
  };
  var encodeBasicGetOk = function(channel, fields) {
    var offset = 0, val = null, bits = 0, varyingSize = 0;
    val = fields.exchange;
    if (val === undefined)
      throw new Error("Missing value for mandatory field 'exchange'");
    if (!(typeof val == "string" && Buffer4.byteLength(val) < 256))
      throw new TypeError("Field 'exchange' is the wrong type; must be a string (up to 255 chars)");
    var exchange_len = Buffer4.byteLength(val, "utf8");
    varyingSize += exchange_len;
    val = fields.routingKey;
    if (val === undefined)
      throw new Error("Missing value for mandatory field 'routingKey'");
    if (!(typeof val == "string" && Buffer4.byteLength(val) < 256))
      throw new TypeError("Field 'routingKey' is the wrong type; must be a string (up to 255 chars)");
    var routingKey_len = Buffer4.byteLength(val, "utf8");
    varyingSize += routingKey_len;
    var buffer2 = Buffer4.alloc(27 + varyingSize);
    buffer2[0] = 1;
    buffer2.writeUInt16BE(channel, 1);
    buffer2.writeUInt32BE(3932231, 7);
    offset = 11;
    val = fields.deliveryTag;
    if (val === undefined)
      throw new Error("Missing value for mandatory field 'deliveryTag'");
    if (typeof val != "number" || isNaN(val))
      throw new TypeError("Field 'deliveryTag' is the wrong type; must be a number (but not NaN)");
    ints.writeUInt64BE(buffer2, val, offset);
    offset += 8;
    val = fields.redelivered;
    val === undefined && (val = false);
    val && (bits += 1);
    buffer2[offset] = bits;
    offset++;
    bits = 0;
    val = fields.exchange;
    val === undefined && (val = undefined);
    buffer2[offset] = exchange_len;
    offset++;
    buffer2.write(val, offset, "utf8");
    offset += exchange_len;
    val = fields.routingKey;
    val === undefined && (val = undefined);
    buffer2[offset] = routingKey_len;
    offset++;
    buffer2.write(val, offset, "utf8");
    offset += routingKey_len;
    val = fields.messageCount;
    if (val === undefined)
      throw new Error("Missing value for mandatory field 'messageCount'");
    if (typeof val != "number" || isNaN(val))
      throw new TypeError("Field 'messageCount' is the wrong type; must be a number (but not NaN)");
    buffer2.writeUInt32BE(val, offset);
    offset += 4;
    buffer2[offset] = 206;
    buffer2.writeUInt32BE(offset - 7, 3);
    return buffer2;
  };
  var decodeBasicGetEmpty = function(buffer2) {
    var val, len, offset = 0, fields = {
      clusterId: undefined
    };
    len = buffer2.readUInt8(offset);
    offset++;
    val = buffer2.toString("utf8", offset, offset + len);
    offset += len;
    fields.clusterId = val;
    return fields;
  };
  var encodeBasicGetEmpty = function(channel, fields) {
    var offset = 0, val = null, varyingSize = 0;
    val = fields.clusterId;
    if (val === undefined)
      val = "";
    else if (!(typeof val == "string" && Buffer4.byteLength(val) < 256))
      throw new TypeError("Field 'clusterId' is the wrong type; must be a string (up to 255 chars)");
    var clusterId_len = Buffer4.byteLength(val, "utf8");
    varyingSize += clusterId_len;
    var buffer2 = Buffer4.alloc(13 + varyingSize);
    buffer2[0] = 1;
    buffer2.writeUInt16BE(channel, 1);
    buffer2.writeUInt32BE(3932232, 7);
    offset = 11;
    val = fields.clusterId;
    val === undefined && (val = "");
    buffer2[offset] = clusterId_len;
    offset++;
    buffer2.write(val, offset, "utf8");
    offset += clusterId_len;
    buffer2[offset] = 206;
    buffer2.writeUInt32BE(offset - 7, 3);
    return buffer2;
  };
  var decodeBasicAck = function(buffer2) {
    var val, offset = 0, fields = {
      deliveryTag: undefined,
      multiple: undefined
    };
    val = ints.readUInt64BE(buffer2, offset);
    offset += 8;
    fields.deliveryTag = val;
    val = !!(1 & buffer2[offset]);
    fields.multiple = val;
    return fields;
  };
  var encodeBasicAck = function(channel, fields) {
    var offset = 0, val = null, bits = 0, buffer2 = Buffer4.alloc(21);
    buffer2[0] = 1;
    buffer2.writeUInt16BE(channel, 1);
    buffer2.writeUInt32BE(3932240, 7);
    offset = 11;
    val = fields.deliveryTag;
    if (val === undefined)
      val = 0;
    else if (typeof val != "number" || isNaN(val))
      throw new TypeError("Field 'deliveryTag' is the wrong type; must be a number (but not NaN)");
    ints.writeUInt64BE(buffer2, val, offset);
    offset += 8;
    val = fields.multiple;
    val === undefined && (val = false);
    val && (bits += 1);
    buffer2[offset] = bits;
    offset++;
    buffer2[offset] = 206;
    buffer2.writeUInt32BE(offset - 7, 3);
    return buffer2;
  };
  var decodeBasicReject = function(buffer2) {
    var val, offset = 0, fields = {
      deliveryTag: undefined,
      requeue: undefined
    };
    val = ints.readUInt64BE(buffer2, offset);
    offset += 8;
    fields.deliveryTag = val;
    val = !!(1 & buffer2[offset]);
    fields.requeue = val;
    return fields;
  };
  var encodeBasicReject = function(channel, fields) {
    var offset = 0, val = null, bits = 0, buffer2 = Buffer4.alloc(21);
    buffer2[0] = 1;
    buffer2.writeUInt16BE(channel, 1);
    buffer2.writeUInt32BE(3932250, 7);
    offset = 11;
    val = fields.deliveryTag;
    if (val === undefined)
      throw new Error("Missing value for mandatory field 'deliveryTag'");
    if (typeof val != "number" || isNaN(val))
      throw new TypeError("Field 'deliveryTag' is the wrong type; must be a number (but not NaN)");
    ints.writeUInt64BE(buffer2, val, offset);
    offset += 8;
    val = fields.requeue;
    val === undefined && (val = true);
    val && (bits += 1);
    buffer2[offset] = bits;
    offset++;
    buffer2[offset] = 206;
    buffer2.writeUInt32BE(offset - 7, 3);
    return buffer2;
  };
  var decodeBasicRecoverAsync = function(buffer2) {
    var val, fields = {
      requeue: undefined
    };
    val = !!(1 & buffer2[0]);
    fields.requeue = val;
    return fields;
  };
  var encodeBasicRecoverAsync = function(channel, fields) {
    var offset = 0, val = null, bits = 0, buffer2 = Buffer4.alloc(13);
    buffer2[0] = 1;
    buffer2.writeUInt16BE(channel, 1);
    buffer2.writeUInt32BE(3932260, 7);
    offset = 11;
    val = fields.requeue;
    val === undefined && (val = false);
    val && (bits += 1);
    buffer2[offset] = bits;
    offset++;
    buffer2[offset] = 206;
    buffer2.writeUInt32BE(offset - 7, 3);
    return buffer2;
  };
  var decodeBasicRecover = function(buffer2) {
    var val, fields = {
      requeue: undefined
    };
    val = !!(1 & buffer2[0]);
    fields.requeue = val;
    return fields;
  };
  var encodeBasicRecover = function(channel, fields) {
    var offset = 0, val = null, bits = 0, buffer2 = Buffer4.alloc(13);
    buffer2[0] = 1;
    buffer2.writeUInt16BE(channel, 1);
    buffer2.writeUInt32BE(3932270, 7);
    offset = 11;
    val = fields.requeue;
    val === undefined && (val = false);
    val && (bits += 1);
    buffer2[offset] = bits;
    offset++;
    buffer2[offset] = 206;
    buffer2.writeUInt32BE(offset - 7, 3);
    return buffer2;
  };
  var decodeBasicRecoverOk = function(buffer2) {
    return {};
  };
  var encodeBasicRecoverOk = function(channel, fields) {
    var offset = 0, buffer2 = Buffer4.alloc(12);
    buffer2[0] = 1;
    buffer2.writeUInt16BE(channel, 1);
    buffer2.writeUInt32BE(3932271, 7);
    offset = 11;
    buffer2[offset] = 206;
    buffer2.writeUInt32BE(offset - 7, 3);
    return buffer2;
  };
  var decodeBasicNack = function(buffer2) {
    var val, offset = 0, fields = {
      deliveryTag: undefined,
      multiple: undefined,
      requeue: undefined
    };
    val = ints.readUInt64BE(buffer2, offset);
    offset += 8;
    fields.deliveryTag = val;
    val = !!(1 & buffer2[offset]);
    fields.multiple = val;
    val = !!(2 & buffer2[offset]);
    fields.requeue = val;
    return fields;
  };
  var encodeBasicNack = function(channel, fields) {
    var offset = 0, val = null, bits = 0, buffer2 = Buffer4.alloc(21);
    buffer2[0] = 1;
    buffer2.writeUInt16BE(channel, 1);
    buffer2.writeUInt32BE(3932280, 7);
    offset = 11;
    val = fields.deliveryTag;
    if (val === undefined)
      val = 0;
    else if (typeof val != "number" || isNaN(val))
      throw new TypeError("Field 'deliveryTag' is the wrong type; must be a number (but not NaN)");
    ints.writeUInt64BE(buffer2, val, offset);
    offset += 8;
    val = fields.multiple;
    val === undefined && (val = false);
    val && (bits += 1);
    val = fields.requeue;
    val === undefined && (val = true);
    val && (bits += 2);
    buffer2[offset] = bits;
    offset++;
    buffer2[offset] = 206;
    buffer2.writeUInt32BE(offset - 7, 3);
    return buffer2;
  };
  var decodeTxSelect = function(buffer2) {
    return {};
  };
  var encodeTxSelect = function(channel, fields) {
    var offset = 0, buffer2 = Buffer4.alloc(12);
    buffer2[0] = 1;
    buffer2.writeUInt16BE(channel, 1);
    buffer2.writeUInt32BE(5898250, 7);
    offset = 11;
    buffer2[offset] = 206;
    buffer2.writeUInt32BE(offset - 7, 3);
    return buffer2;
  };
  var decodeTxSelectOk = function(buffer2) {
    return {};
  };
  var encodeTxSelectOk = function(channel, fields) {
    var offset = 0, buffer2 = Buffer4.alloc(12);
    buffer2[0] = 1;
    buffer2.writeUInt16BE(channel, 1);
    buffer2.writeUInt32BE(5898251, 7);
    offset = 11;
    buffer2[offset] = 206;
    buffer2.writeUInt32BE(offset - 7, 3);
    return buffer2;
  };
  var decodeTxCommit = function(buffer2) {
    return {};
  };
  var encodeTxCommit = function(channel, fields) {
    var offset = 0, buffer2 = Buffer4.alloc(12);
    buffer2[0] = 1;
    buffer2.writeUInt16BE(channel, 1);
    buffer2.writeUInt32BE(5898260, 7);
    offset = 11;
    buffer2[offset] = 206;
    buffer2.writeUInt32BE(offset - 7, 3);
    return buffer2;
  };
  var decodeTxCommitOk = function(buffer2) {
    return {};
  };
  var encodeTxCommitOk = function(channel, fields) {
    var offset = 0, buffer2 = Buffer4.alloc(12);
    buffer2[0] = 1;
    buffer2.writeUInt16BE(channel, 1);
    buffer2.writeUInt32BE(5898261, 7);
    offset = 11;
    buffer2[offset] = 206;
    buffer2.writeUInt32BE(offset - 7, 3);
    return buffer2;
  };
  var decodeTxRollback = function(buffer2) {
    return {};
  };
  var encodeTxRollback = function(channel, fields) {
    var offset = 0, buffer2 = Buffer4.alloc(12);
    buffer2[0] = 1;
    buffer2.writeUInt16BE(channel, 1);
    buffer2.writeUInt32BE(5898270, 7);
    offset = 11;
    buffer2[offset] = 206;
    buffer2.writeUInt32BE(offset - 7, 3);
    return buffer2;
  };
  var decodeTxRollbackOk = function(buffer2) {
    return {};
  };
  var encodeTxRollbackOk = function(channel, fields) {
    var offset = 0, buffer2 = Buffer4.alloc(12);
    buffer2[0] = 1;
    buffer2.writeUInt16BE(channel, 1);
    buffer2.writeUInt32BE(5898271, 7);
    offset = 11;
    buffer2[offset] = 206;
    buffer2.writeUInt32BE(offset - 7, 3);
    return buffer2;
  };
  var decodeConfirmSelect = function(buffer2) {
    var val, fields = {
      nowait: undefined
    };
    val = !!(1 & buffer2[0]);
    fields.nowait = val;
    return fields;
  };
  var encodeConfirmSelect = function(channel, fields) {
    var offset = 0, val = null, bits = 0, buffer2 = Buffer4.alloc(13);
    buffer2[0] = 1;
    buffer2.writeUInt16BE(channel, 1);
    buffer2.writeUInt32BE(5570570, 7);
    offset = 11;
    val = fields.nowait;
    val === undefined && (val = false);
    val && (bits += 1);
    buffer2[offset] = bits;
    offset++;
    buffer2[offset] = 206;
    buffer2.writeUInt32BE(offset - 7, 3);
    return buffer2;
  };
  var decodeConfirmSelectOk = function(buffer2) {
    return {};
  };
  var encodeConfirmSelectOk = function(channel, fields) {
    var offset = 0, buffer2 = Buffer4.alloc(12);
    buffer2[0] = 1;
    buffer2.writeUInt16BE(channel, 1);
    buffer2.writeUInt32BE(5570571, 7);
    offset = 11;
    buffer2[offset] = 206;
    buffer2.writeUInt32BE(offset - 7, 3);
    return buffer2;
  };
  var encodeBasicProperties = function(channel, size2, fields) {
    var val, len, offset = 0, flags3 = 0, scratchOffset = 0, varyingSize = 0;
    val = fields.contentType;
    if (val != null) {
      if (!(typeof val == "string" && Buffer4.byteLength(val) < 256))
        throw new TypeError("Field 'contentType' is the wrong type; must be a string (up to 255 chars)");
      var contentType_len = Buffer4.byteLength(val, "utf8");
      varyingSize += 1;
      varyingSize += contentType_len;
    }
    val = fields.contentEncoding;
    if (val != null) {
      if (!(typeof val == "string" && Buffer4.byteLength(val) < 256))
        throw new TypeError("Field 'contentEncoding' is the wrong type; must be a string (up to 255 chars)");
      var contentEncoding_len = Buffer4.byteLength(val, "utf8");
      varyingSize += 1;
      varyingSize += contentEncoding_len;
    }
    val = fields.headers;
    if (val != null) {
      if (typeof val != "object")
        throw new TypeError("Field 'headers' is the wrong type; must be an object");
      len = encodeTable(SCRATCH, val, scratchOffset);
      var headers_encoded = SCRATCH.slice(scratchOffset, scratchOffset + len);
      scratchOffset += len;
      varyingSize += headers_encoded.length;
    }
    val = fields.deliveryMode;
    if (val != null) {
      if (typeof val != "number" || isNaN(val))
        throw new TypeError("Field 'deliveryMode' is the wrong type; must be a number (but not NaN)");
      varyingSize += 1;
    }
    val = fields.priority;
    if (val != null) {
      if (typeof val != "number" || isNaN(val))
        throw new TypeError("Field 'priority' is the wrong type; must be a number (but not NaN)");
      varyingSize += 1;
    }
    val = fields.correlationId;
    if (val != null) {
      if (!(typeof val == "string" && Buffer4.byteLength(val) < 256))
        throw new TypeError("Field 'correlationId' is the wrong type; must be a string (up to 255 chars)");
      var correlationId_len = Buffer4.byteLength(val, "utf8");
      varyingSize += 1;
      varyingSize += correlationId_len;
    }
    val = fields.replyTo;
    if (val != null) {
      if (!(typeof val == "string" && Buffer4.byteLength(val) < 256))
        throw new TypeError("Field 'replyTo' is the wrong type; must be a string (up to 255 chars)");
      var replyTo_len = Buffer4.byteLength(val, "utf8");
      varyingSize += 1;
      varyingSize += replyTo_len;
    }
    val = fields.expiration;
    if (val != null) {
      if (!(typeof val == "string" && Buffer4.byteLength(val) < 256))
        throw new TypeError("Field 'expiration' is the wrong type; must be a string (up to 255 chars)");
      var expiration_len = Buffer4.byteLength(val, "utf8");
      varyingSize += 1;
      varyingSize += expiration_len;
    }
    val = fields.messageId;
    if (val != null) {
      if (!(typeof val == "string" && Buffer4.byteLength(val) < 256))
        throw new TypeError("Field 'messageId' is the wrong type; must be a string (up to 255 chars)");
      var messageId_len = Buffer4.byteLength(val, "utf8");
      varyingSize += 1;
      varyingSize += messageId_len;
    }
    val = fields.timestamp;
    if (val != null) {
      if (typeof val != "number" || isNaN(val))
        throw new TypeError("Field 'timestamp' is the wrong type; must be a number (but not NaN)");
      varyingSize += 8;
    }
    val = fields.type;
    if (val != null) {
      if (!(typeof val == "string" && Buffer4.byteLength(val) < 256))
        throw new TypeError("Field 'type' is the wrong type; must be a string (up to 255 chars)");
      var type_len = Buffer4.byteLength(val, "utf8");
      varyingSize += 1;
      varyingSize += type_len;
    }
    val = fields.userId;
    if (val != null) {
      if (!(typeof val == "string" && Buffer4.byteLength(val) < 256))
        throw new TypeError("Field 'userId' is the wrong type; must be a string (up to 255 chars)");
      var userId_len = Buffer4.byteLength(val, "utf8");
      varyingSize += 1;
      varyingSize += userId_len;
    }
    val = fields.appId;
    if (val != null) {
      if (!(typeof val == "string" && Buffer4.byteLength(val) < 256))
        throw new TypeError("Field 'appId' is the wrong type; must be a string (up to 255 chars)");
      var appId_len = Buffer4.byteLength(val, "utf8");
      varyingSize += 1;
      varyingSize += appId_len;
    }
    val = fields.clusterId;
    if (val != null) {
      if (!(typeof val == "string" && Buffer4.byteLength(val) < 256))
        throw new TypeError("Field 'clusterId' is the wrong type; must be a string (up to 255 chars)");
      var clusterId_len = Buffer4.byteLength(val, "utf8");
      varyingSize += 1;
      varyingSize += clusterId_len;
    }
    var buffer2 = Buffer4.alloc(22 + varyingSize);
    buffer2[0] = 2;
    buffer2.writeUInt16BE(channel, 1);
    buffer2.writeUInt32BE(3932160, 7);
    ints.writeUInt64BE(buffer2, size2, 11);
    flags3 = 0;
    offset = 21;
    val = fields.contentType;
    if (val != null) {
      flags3 += 32768;
      buffer2[offset] = contentType_len;
      offset++;
      buffer2.write(val, offset, "utf8");
      offset += contentType_len;
    }
    val = fields.contentEncoding;
    if (val != null) {
      flags3 += 16384;
      buffer2[offset] = contentEncoding_len;
      offset++;
      buffer2.write(val, offset, "utf8");
      offset += contentEncoding_len;
    }
    val = fields.headers;
    if (val != null) {
      flags3 += 8192;
      offset += headers_encoded.copy(buffer2, offset);
    }
    val = fields.deliveryMode;
    if (val != null) {
      flags3 += 4096;
      buffer2.writeUInt8(val, offset);
      offset++;
    }
    val = fields.priority;
    if (val != null) {
      flags3 += 2048;
      buffer2.writeUInt8(val, offset);
      offset++;
    }
    val = fields.correlationId;
    if (val != null) {
      flags3 += 1024;
      buffer2[offset] = correlationId_len;
      offset++;
      buffer2.write(val, offset, "utf8");
      offset += correlationId_len;
    }
    val = fields.replyTo;
    if (val != null) {
      flags3 += 512;
      buffer2[offset] = replyTo_len;
      offset++;
      buffer2.write(val, offset, "utf8");
      offset += replyTo_len;
    }
    val = fields.expiration;
    if (val != null) {
      flags3 += 256;
      buffer2[offset] = expiration_len;
      offset++;
      buffer2.write(val, offset, "utf8");
      offset += expiration_len;
    }
    val = fields.messageId;
    if (val != null) {
      flags3 += 128;
      buffer2[offset] = messageId_len;
      offset++;
      buffer2.write(val, offset, "utf8");
      offset += messageId_len;
    }
    val = fields.timestamp;
    if (val != null) {
      flags3 += 64;
      ints.writeUInt64BE(buffer2, val, offset);
      offset += 8;
    }
    val = fields.type;
    if (val != null) {
      flags3 += 32;
      buffer2[offset] = type_len;
      offset++;
      buffer2.write(val, offset, "utf8");
      offset += type_len;
    }
    val = fields.userId;
    if (val != null) {
      flags3 += 16;
      buffer2[offset] = userId_len;
      offset++;
      buffer2.write(val, offset, "utf8");
      offset += userId_len;
    }
    val = fields.appId;
    if (val != null) {
      flags3 += 8;
      buffer2[offset] = appId_len;
      offset++;
      buffer2.write(val, offset, "utf8");
      offset += appId_len;
    }
    val = fields.clusterId;
    if (val != null) {
      flags3 += 4;
      buffer2[offset] = clusterId_len;
      offset++;
      buffer2.write(val, offset, "utf8");
      offset += clusterId_len;
    }
    buffer2[offset] = 206;
    buffer2.writeUInt32BE(offset - 7, 3);
    buffer2.writeUInt16BE(flags3, 19);
    return buffer2.slice(0, offset + 1);
  };
  var decodeBasicProperties = function(buffer2) {
    var flags3, val, len, offset = 2;
    flags3 = buffer2.readUInt16BE(0);
    if (flags3 === 0)
      return {};
    var fields = {
      contentType: undefined,
      contentEncoding: undefined,
      headers: undefined,
      deliveryMode: undefined,
      priority: undefined,
      correlationId: undefined,
      replyTo: undefined,
      expiration: undefined,
      messageId: undefined,
      timestamp: undefined,
      type: undefined,
      userId: undefined,
      appId: undefined,
      clusterId: undefined
    };
    if (32768 & flags3) {
      len = buffer2.readUInt8(offset);
      offset++;
      val = buffer2.toString("utf8", offset, offset + len);
      offset += len;
      fields.contentType = val;
    }
    if (16384 & flags3) {
      len = buffer2.readUInt8(offset);
      offset++;
      val = buffer2.toString("utf8", offset, offset + len);
      offset += len;
      fields.contentEncoding = val;
    }
    if (8192 & flags3) {
      len = buffer2.readUInt32BE(offset);
      offset += 4;
      val = decodeFields(buffer2.slice(offset, offset + len));
      offset += len;
      fields.headers = val;
    }
    if (4096 & flags3) {
      val = buffer2[offset];
      offset++;
      fields.deliveryMode = val;
    }
    if (2048 & flags3) {
      val = buffer2[offset];
      offset++;
      fields.priority = val;
    }
    if (1024 & flags3) {
      len = buffer2.readUInt8(offset);
      offset++;
      val = buffer2.toString("utf8", offset, offset + len);
      offset += len;
      fields.correlationId = val;
    }
    if (512 & flags3) {
      len = buffer2.readUInt8(offset);
      offset++;
      val = buffer2.toString("utf8", offset, offset + len);
      offset += len;
      fields.replyTo = val;
    }
    if (256 & flags3) {
      len = buffer2.readUInt8(offset);
      offset++;
      val = buffer2.toString("utf8", offset, offset + len);
      offset += len;
      fields.expiration = val;
    }
    if (128 & flags3) {
      len = buffer2.readUInt8(offset);
      offset++;
      val = buffer2.toString("utf8", offset, offset + len);
      offset += len;
      fields.messageId = val;
    }
    if (64 & flags3) {
      val = ints.readUInt64BE(buffer2, offset);
      offset += 8;
      fields.timestamp = val;
    }
    if (32 & flags3) {
      len = buffer2.readUInt8(offset);
      offset++;
      val = buffer2.toString("utf8", offset, offset + len);
      offset += len;
      fields.type = val;
    }
    if (16 & flags3) {
      len = buffer2.readUInt8(offset);
      offset++;
      val = buffer2.toString("utf8", offset, offset + len);
      offset += len;
      fields.userId = val;
    }
    if (8 & flags3) {
      len = buffer2.readUInt8(offset);
      offset++;
      val = buffer2.toString("utf8", offset, offset + len);
      offset += len;
      fields.appId = val;
    }
    if (4 & flags3) {
      len = buffer2.readUInt8(offset);
      offset++;
      val = buffer2.toString("utf8", offset, offset + len);
      offset += len;
      fields.clusterId = val;
    }
    return fields;
  };
  var Buffer4 = require_safe_buffer().Buffer;
  var codec = require_codec();
  var ints = require_buffer_more_ints();
  var encodeTable = codec.encodeTable;
  var decodeFields = codec.decodeFields;
  var SCRATCH = Buffer4.alloc(65536);
  var EMPTY_OBJECT = Object.freeze({});
  exports.constants = {
    FRAME_METHOD: 1,
    FRAME_HEADER: 2,
    FRAME_BODY: 3,
    FRAME_HEARTBEAT: 8,
    FRAME_MIN_SIZE: 4096,
    FRAME_END: 206,
    REPLY_SUCCESS: 200,
    CONTENT_TOO_LARGE: 311,
    NO_ROUTE: 312,
    NO_CONSUMERS: 313,
    ACCESS_REFUSED: 403,
    NOT_FOUND: 404,
    RESOURCE_LOCKED: 405,
    PRECONDITION_FAILED: 406,
    CONNECTION_FORCED: 320,
    INVALID_PATH: 402,
    FRAME_ERROR: 501,
    SYNTAX_ERROR: 502,
    COMMAND_INVALID: 503,
    CHANNEL_ERROR: 504,
    UNEXPECTED_FRAME: 505,
    RESOURCE_ERROR: 506,
    NOT_ALLOWED: 530,
    NOT_IMPLEMENTED: 540,
    INTERNAL_ERROR: 541
  };
  exports.constant_strs = {
    "1": "FRAME-METHOD",
    "2": "FRAME-HEADER",
    "3": "FRAME-BODY",
    "8": "FRAME-HEARTBEAT",
    "200": "REPLY-SUCCESS",
    "206": "FRAME-END",
    "311": "CONTENT-TOO-LARGE",
    "312": "NO-ROUTE",
    "313": "NO-CONSUMERS",
    "320": "CONNECTION-FORCED",
    "402": "INVALID-PATH",
    "403": "ACCESS-REFUSED",
    "404": "NOT-FOUND",
    "405": "RESOURCE-LOCKED",
    "406": "PRECONDITION-FAILED",
    "501": "FRAME-ERROR",
    "502": "SYNTAX-ERROR",
    "503": "COMMAND-INVALID",
    "504": "CHANNEL-ERROR",
    "505": "UNEXPECTED-FRAME",
    "506": "RESOURCE-ERROR",
    "530": "NOT-ALLOWED",
    "540": "NOT-IMPLEMENTED",
    "541": "INTERNAL-ERROR",
    "4096": "FRAME-MIN-SIZE"
  };
  exports.FRAME_OVERHEAD = 8;
  exports.decode = function(id, buf) {
    switch (id) {
      case 655370:
        return decodeConnectionStart(buf);
      case 655371:
        return decodeConnectionStartOk(buf);
      case 655380:
        return decodeConnectionSecure(buf);
      case 655381:
        return decodeConnectionSecureOk(buf);
      case 655390:
        return decodeConnectionTune(buf);
      case 655391:
        return decodeConnectionTuneOk(buf);
      case 655400:
        return decodeConnectionOpen(buf);
      case 655401:
        return decodeConnectionOpenOk(buf);
      case 655410:
        return decodeConnectionClose(buf);
      case 655411:
        return decodeConnectionCloseOk(buf);
      case 655420:
        return decodeConnectionBlocked(buf);
      case 655421:
        return decodeConnectionUnblocked(buf);
      case 1310730:
        return decodeChannelOpen(buf);
      case 1310731:
        return decodeChannelOpenOk(buf);
      case 1310740:
        return decodeChannelFlow(buf);
      case 1310741:
        return decodeChannelFlowOk(buf);
      case 1310760:
        return decodeChannelClose(buf);
      case 1310761:
        return decodeChannelCloseOk(buf);
      case 1966090:
        return decodeAccessRequest(buf);
      case 1966091:
        return decodeAccessRequestOk(buf);
      case 2621450:
        return decodeExchangeDeclare(buf);
      case 2621451:
        return decodeExchangeDeclareOk(buf);
      case 2621460:
        return decodeExchangeDelete(buf);
      case 2621461:
        return decodeExchangeDeleteOk(buf);
      case 2621470:
        return decodeExchangeBind(buf);
      case 2621471:
        return decodeExchangeBindOk(buf);
      case 2621480:
        return decodeExchangeUnbind(buf);
      case 2621491:
        return decodeExchangeUnbindOk(buf);
      case 3276810:
        return decodeQueueDeclare(buf);
      case 3276811:
        return decodeQueueDeclareOk(buf);
      case 3276820:
        return decodeQueueBind(buf);
      case 3276821:
        return decodeQueueBindOk(buf);
      case 3276830:
        return decodeQueuePurge(buf);
      case 3276831:
        return decodeQueuePurgeOk(buf);
      case 3276840:
        return decodeQueueDelete(buf);
      case 3276841:
        return decodeQueueDeleteOk(buf);
      case 3276850:
        return decodeQueueUnbind(buf);
      case 3276851:
        return decodeQueueUnbindOk(buf);
      case 3932170:
        return decodeBasicQos(buf);
      case 3932171:
        return decodeBasicQosOk(buf);
      case 3932180:
        return decodeBasicConsume(buf);
      case 3932181:
        return decodeBasicConsumeOk(buf);
      case 3932190:
        return decodeBasicCancel(buf);
      case 3932191:
        return decodeBasicCancelOk(buf);
      case 3932200:
        return decodeBasicPublish(buf);
      case 3932210:
        return decodeBasicReturn(buf);
      case 3932220:
        return decodeBasicDeliver(buf);
      case 3932230:
        return decodeBasicGet(buf);
      case 3932231:
        return decodeBasicGetOk(buf);
      case 3932232:
        return decodeBasicGetEmpty(buf);
      case 3932240:
        return decodeBasicAck(buf);
      case 3932250:
        return decodeBasicReject(buf);
      case 3932260:
        return decodeBasicRecoverAsync(buf);
      case 3932270:
        return decodeBasicRecover(buf);
      case 3932271:
        return decodeBasicRecoverOk(buf);
      case 3932280:
        return decodeBasicNack(buf);
      case 5898250:
        return decodeTxSelect(buf);
      case 5898251:
        return decodeTxSelectOk(buf);
      case 5898260:
        return decodeTxCommit(buf);
      case 5898261:
        return decodeTxCommitOk(buf);
      case 5898270:
        return decodeTxRollback(buf);
      case 5898271:
        return decodeTxRollbackOk(buf);
      case 5570570:
        return decodeConfirmSelect(buf);
      case 5570571:
        return decodeConfirmSelectOk(buf);
      case 60:
        return decodeBasicProperties(buf);
      default:
        throw new Error("Unknown class/method ID");
    }
  };
  exports.encodeMethod = function(id, channel, fields) {
    switch (id) {
      case 655370:
        return encodeConnectionStart(channel, fields);
      case 655371:
        return encodeConnectionStartOk(channel, fields);
      case 655380:
        return encodeConnectionSecure(channel, fields);
      case 655381:
        return encodeConnectionSecureOk(channel, fields);
      case 655390:
        return encodeConnectionTune(channel, fields);
      case 655391:
        return encodeConnectionTuneOk(channel, fields);
      case 655400:
        return encodeConnectionOpen(channel, fields);
      case 655401:
        return encodeConnectionOpenOk(channel, fields);
      case 655410:
        return encodeConnectionClose(channel, fields);
      case 655411:
        return encodeConnectionCloseOk(channel, fields);
      case 655420:
        return encodeConnectionBlocked(channel, fields);
      case 655421:
        return encodeConnectionUnblocked(channel, fields);
      case 1310730:
        return encodeChannelOpen(channel, fields);
      case 1310731:
        return encodeChannelOpenOk(channel, fields);
      case 1310740:
        return encodeChannelFlow(channel, fields);
      case 1310741:
        return encodeChannelFlowOk(channel, fields);
      case 1310760:
        return encodeChannelClose(channel, fields);
      case 1310761:
        return encodeChannelCloseOk(channel, fields);
      case 1966090:
        return encodeAccessRequest(channel, fields);
      case 1966091:
        return encodeAccessRequestOk(channel, fields);
      case 2621450:
        return encodeExchangeDeclare(channel, fields);
      case 2621451:
        return encodeExchangeDeclareOk(channel, fields);
      case 2621460:
        return encodeExchangeDelete(channel, fields);
      case 2621461:
        return encodeExchangeDeleteOk(channel, fields);
      case 2621470:
        return encodeExchangeBind(channel, fields);
      case 2621471:
        return encodeExchangeBindOk(channel, fields);
      case 2621480:
        return encodeExchangeUnbind(channel, fields);
      case 2621491:
        return encodeExchangeUnbindOk(channel, fields);
      case 3276810:
        return encodeQueueDeclare(channel, fields);
      case 3276811:
        return encodeQueueDeclareOk(channel, fields);
      case 3276820:
        return encodeQueueBind(channel, fields);
      case 3276821:
        return encodeQueueBindOk(channel, fields);
      case 3276830:
        return encodeQueuePurge(channel, fields);
      case 3276831:
        return encodeQueuePurgeOk(channel, fields);
      case 3276840:
        return encodeQueueDelete(channel, fields);
      case 3276841:
        return encodeQueueDeleteOk(channel, fields);
      case 3276850:
        return encodeQueueUnbind(channel, fields);
      case 3276851:
        return encodeQueueUnbindOk(channel, fields);
      case 3932170:
        return encodeBasicQos(channel, fields);
      case 3932171:
        return encodeBasicQosOk(channel, fields);
      case 3932180:
        return encodeBasicConsume(channel, fields);
      case 3932181:
        return encodeBasicConsumeOk(channel, fields);
      case 3932190:
        return encodeBasicCancel(channel, fields);
      case 3932191:
        return encodeBasicCancelOk(channel, fields);
      case 3932200:
        return encodeBasicPublish(channel, fields);
      case 3932210:
        return encodeBasicReturn(channel, fields);
      case 3932220:
        return encodeBasicDeliver(channel, fields);
      case 3932230:
        return encodeBasicGet(channel, fields);
      case 3932231:
        return encodeBasicGetOk(channel, fields);
      case 3932232:
        return encodeBasicGetEmpty(channel, fields);
      case 3932240:
        return encodeBasicAck(channel, fields);
      case 3932250:
        return encodeBasicReject(channel, fields);
      case 3932260:
        return encodeBasicRecoverAsync(channel, fields);
      case 3932270:
        return encodeBasicRecover(channel, fields);
      case 3932271:
        return encodeBasicRecoverOk(channel, fields);
      case 3932280:
        return encodeBasicNack(channel, fields);
      case 5898250:
        return encodeTxSelect(channel, fields);
      case 5898251:
        return encodeTxSelectOk(channel, fields);
      case 5898260:
        return encodeTxCommit(channel, fields);
      case 5898261:
        return encodeTxCommitOk(channel, fields);
      case 5898270:
        return encodeTxRollback(channel, fields);
      case 5898271:
        return encodeTxRollbackOk(channel, fields);
      case 5570570:
        return encodeConfirmSelect(channel, fields);
      case 5570571:
        return encodeConfirmSelectOk(channel, fields);
      default:
        throw new Error("Unknown class/method ID");
    }
  };
  exports.encodeProperties = function(id, channel, size2, fields) {
    switch (id) {
      case 60:
        return encodeBasicProperties(channel, size2, fields);
      default:
        throw new Error("Unknown class/properties ID");
    }
  };
  exports.info = function(id) {
    switch (id) {
      case 655370:
        return methodInfoConnectionStart;
      case 655371:
        return methodInfoConnectionStartOk;
      case 655380:
        return methodInfoConnectionSecure;
      case 655381:
        return methodInfoConnectionSecureOk;
      case 655390:
        return methodInfoConnectionTune;
      case 655391:
        return methodInfoConnectionTuneOk;
      case 655400:
        return methodInfoConnectionOpen;
      case 655401:
        return methodInfoConnectionOpenOk;
      case 655410:
        return methodInfoConnectionClose;
      case 655411:
        return methodInfoConnectionCloseOk;
      case 655420:
        return methodInfoConnectionBlocked;
      case 655421:
        return methodInfoConnectionUnblocked;
      case 1310730:
        return methodInfoChannelOpen;
      case 1310731:
        return methodInfoChannelOpenOk;
      case 1310740:
        return methodInfoChannelFlow;
      case 1310741:
        return methodInfoChannelFlowOk;
      case 1310760:
        return methodInfoChannelClose;
      case 1310761:
        return methodInfoChannelCloseOk;
      case 1966090:
        return methodInfoAccessRequest;
      case 1966091:
        return methodInfoAccessRequestOk;
      case 2621450:
        return methodInfoExchangeDeclare;
      case 2621451:
        return methodInfoExchangeDeclareOk;
      case 2621460:
        return methodInfoExchangeDelete;
      case 2621461:
        return methodInfoExchangeDeleteOk;
      case 2621470:
        return methodInfoExchangeBind;
      case 2621471:
        return methodInfoExchangeBindOk;
      case 2621480:
        return methodInfoExchangeUnbind;
      case 2621491:
        return methodInfoExchangeUnbindOk;
      case 3276810:
        return methodInfoQueueDeclare;
      case 3276811:
        return methodInfoQueueDeclareOk;
      case 3276820:
        return methodInfoQueueBind;
      case 3276821:
        return methodInfoQueueBindOk;
      case 3276830:
        return methodInfoQueuePurge;
      case 3276831:
        return methodInfoQueuePurgeOk;
      case 3276840:
        return methodInfoQueueDelete;
      case 3276841:
        return methodInfoQueueDeleteOk;
      case 3276850:
        return methodInfoQueueUnbind;
      case 3276851:
        return methodInfoQueueUnbindOk;
      case 3932170:
        return methodInfoBasicQos;
      case 3932171:
        return methodInfoBasicQosOk;
      case 3932180:
        return methodInfoBasicConsume;
      case 3932181:
        return methodInfoBasicConsumeOk;
      case 3932190:
        return methodInfoBasicCancel;
      case 3932191:
        return methodInfoBasicCancelOk;
      case 3932200:
        return methodInfoBasicPublish;
      case 3932210:
        return methodInfoBasicReturn;
      case 3932220:
        return methodInfoBasicDeliver;
      case 3932230:
        return methodInfoBasicGet;
      case 3932231:
        return methodInfoBasicGetOk;
      case 3932232:
        return methodInfoBasicGetEmpty;
      case 3932240:
        return methodInfoBasicAck;
      case 3932250:
        return methodInfoBasicReject;
      case 3932260:
        return methodInfoBasicRecoverAsync;
      case 3932270:
        return methodInfoBasicRecover;
      case 3932271:
        return methodInfoBasicRecoverOk;
      case 3932280:
        return methodInfoBasicNack;
      case 5898250:
        return methodInfoTxSelect;
      case 5898251:
        return methodInfoTxSelectOk;
      case 5898260:
        return methodInfoTxCommit;
      case 5898261:
        return methodInfoTxCommitOk;
      case 5898270:
        return methodInfoTxRollback;
      case 5898271:
        return methodInfoTxRollbackOk;
      case 5570570:
        return methodInfoConfirmSelect;
      case 5570571:
        return methodInfoConfirmSelectOk;
      case 60:
        return propertiesInfoBasicProperties;
      default:
        throw new Error("Unknown class/method ID");
    }
  };
  exports.ConnectionStart = 655370;
  var methodInfoConnectionStart = exports.methodInfoConnectionStart = {
    id: 655370,
    classId: 10,
    methodId: 10,
    name: "ConnectionStart",
    args: [{
      type: "octet",
      name: "versionMajor",
      default: 0
    }, {
      type: "octet",
      name: "versionMinor",
      default: 9
    }, {
      type: "table",
      name: "serverProperties"
    }, {
      type: "longstr",
      name: "mechanisms",
      default: "PLAIN"
    }, {
      type: "longstr",
      name: "locales",
      default: "en_US"
    }]
  };
  exports.ConnectionStartOk = 655371;
  var methodInfoConnectionStartOk = exports.methodInfoConnectionStartOk = {
    id: 655371,
    classId: 10,
    methodId: 11,
    name: "ConnectionStartOk",
    args: [{
      type: "table",
      name: "clientProperties"
    }, {
      type: "shortstr",
      name: "mechanism",
      default: "PLAIN"
    }, {
      type: "longstr",
      name: "response"
    }, {
      type: "shortstr",
      name: "locale",
      default: "en_US"
    }]
  };
  exports.ConnectionSecure = 655380;
  var methodInfoConnectionSecure = exports.methodInfoConnectionSecure = {
    id: 655380,
    classId: 10,
    methodId: 20,
    name: "ConnectionSecure",
    args: [{
      type: "longstr",
      name: "challenge"
    }]
  };
  exports.ConnectionSecureOk = 655381;
  var methodInfoConnectionSecureOk = exports.methodInfoConnectionSecureOk = {
    id: 655381,
    classId: 10,
    methodId: 21,
    name: "ConnectionSecureOk",
    args: [{
      type: "longstr",
      name: "response"
    }]
  };
  exports.ConnectionTune = 655390;
  var methodInfoConnectionTune = exports.methodInfoConnectionTune = {
    id: 655390,
    classId: 10,
    methodId: 30,
    name: "ConnectionTune",
    args: [{
      type: "short",
      name: "channelMax",
      default: 0
    }, {
      type: "long",
      name: "frameMax",
      default: 0
    }, {
      type: "short",
      name: "heartbeat",
      default: 0
    }]
  };
  exports.ConnectionTuneOk = 655391;
  var methodInfoConnectionTuneOk = exports.methodInfoConnectionTuneOk = {
    id: 655391,
    classId: 10,
    methodId: 31,
    name: "ConnectionTuneOk",
    args: [{
      type: "short",
      name: "channelMax",
      default: 0
    }, {
      type: "long",
      name: "frameMax",
      default: 0
    }, {
      type: "short",
      name: "heartbeat",
      default: 0
    }]
  };
  exports.ConnectionOpen = 655400;
  var methodInfoConnectionOpen = exports.methodInfoConnectionOpen = {
    id: 655400,
    classId: 10,
    methodId: 40,
    name: "ConnectionOpen",
    args: [{
      type: "shortstr",
      name: "virtualHost",
      default: "/"
    }, {
      type: "shortstr",
      name: "capabilities",
      default: ""
    }, {
      type: "bit",
      name: "insist",
      default: false
    }]
  };
  exports.ConnectionOpenOk = 655401;
  var methodInfoConnectionOpenOk = exports.methodInfoConnectionOpenOk = {
    id: 655401,
    classId: 10,
    methodId: 41,
    name: "ConnectionOpenOk",
    args: [{
      type: "shortstr",
      name: "knownHosts",
      default: ""
    }]
  };
  exports.ConnectionClose = 655410;
  var methodInfoConnectionClose = exports.methodInfoConnectionClose = {
    id: 655410,
    classId: 10,
    methodId: 50,
    name: "ConnectionClose",
    args: [{
      type: "short",
      name: "replyCode"
    }, {
      type: "shortstr",
      name: "replyText",
      default: ""
    }, {
      type: "short",
      name: "classId"
    }, {
      type: "short",
      name: "methodId"
    }]
  };
  exports.ConnectionCloseOk = 655411;
  var methodInfoConnectionCloseOk = exports.methodInfoConnectionCloseOk = {
    id: 655411,
    classId: 10,
    methodId: 51,
    name: "ConnectionCloseOk",
    args: []
  };
  exports.ConnectionBlocked = 655420;
  var methodInfoConnectionBlocked = exports.methodInfoConnectionBlocked = {
    id: 655420,
    classId: 10,
    methodId: 60,
    name: "ConnectionBlocked",
    args: [{
      type: "shortstr",
      name: "reason",
      default: ""
    }]
  };
  exports.ConnectionUnblocked = 655421;
  var methodInfoConnectionUnblocked = exports.methodInfoConnectionUnblocked = {
    id: 655421,
    classId: 10,
    methodId: 61,
    name: "ConnectionUnblocked",
    args: []
  };
  exports.ChannelOpen = 1310730;
  var methodInfoChannelOpen = exports.methodInfoChannelOpen = {
    id: 1310730,
    classId: 20,
    methodId: 10,
    name: "ChannelOpen",
    args: [{
      type: "shortstr",
      name: "outOfBand",
      default: ""
    }]
  };
  exports.ChannelOpenOk = 1310731;
  var methodInfoChannelOpenOk = exports.methodInfoChannelOpenOk = {
    id: 1310731,
    classId: 20,
    methodId: 11,
    name: "ChannelOpenOk",
    args: [{
      type: "longstr",
      name: "channelId",
      default: ""
    }]
  };
  exports.ChannelFlow = 1310740;
  var methodInfoChannelFlow = exports.methodInfoChannelFlow = {
    id: 1310740,
    classId: 20,
    methodId: 20,
    name: "ChannelFlow",
    args: [{
      type: "bit",
      name: "active"
    }]
  };
  exports.ChannelFlowOk = 1310741;
  var methodInfoChannelFlowOk = exports.methodInfoChannelFlowOk = {
    id: 1310741,
    classId: 20,
    methodId: 21,
    name: "ChannelFlowOk",
    args: [{
      type: "bit",
      name: "active"
    }]
  };
  exports.ChannelClose = 1310760;
  var methodInfoChannelClose = exports.methodInfoChannelClose = {
    id: 1310760,
    classId: 20,
    methodId: 40,
    name: "ChannelClose",
    args: [{
      type: "short",
      name: "replyCode"
    }, {
      type: "shortstr",
      name: "replyText",
      default: ""
    }, {
      type: "short",
      name: "classId"
    }, {
      type: "short",
      name: "methodId"
    }]
  };
  exports.ChannelCloseOk = 1310761;
  var methodInfoChannelCloseOk = exports.methodInfoChannelCloseOk = {
    id: 1310761,
    classId: 20,
    methodId: 41,
    name: "ChannelCloseOk",
    args: []
  };
  exports.AccessRequest = 1966090;
  var methodInfoAccessRequest = exports.methodInfoAccessRequest = {
    id: 1966090,
    classId: 30,
    methodId: 10,
    name: "AccessRequest",
    args: [{
      type: "shortstr",
      name: "realm",
      default: "/data"
    }, {
      type: "bit",
      name: "exclusive",
      default: false
    }, {
      type: "bit",
      name: "passive",
      default: true
    }, {
      type: "bit",
      name: "active",
      default: true
    }, {
      type: "bit",
      name: "write",
      default: true
    }, {
      type: "bit",
      name: "read",
      default: true
    }]
  };
  exports.AccessRequestOk = 1966091;
  var methodInfoAccessRequestOk = exports.methodInfoAccessRequestOk = {
    id: 1966091,
    classId: 30,
    methodId: 11,
    name: "AccessRequestOk",
    args: [{
      type: "short",
      name: "ticket",
      default: 1
    }]
  };
  exports.ExchangeDeclare = 2621450;
  var methodInfoExchangeDeclare = exports.methodInfoExchangeDeclare = {
    id: 2621450,
    classId: 40,
    methodId: 10,
    name: "ExchangeDeclare",
    args: [{
      type: "short",
      name: "ticket",
      default: 0
    }, {
      type: "shortstr",
      name: "exchange"
    }, {
      type: "shortstr",
      name: "type",
      default: "direct"
    }, {
      type: "bit",
      name: "passive",
      default: false
    }, {
      type: "bit",
      name: "durable",
      default: false
    }, {
      type: "bit",
      name: "autoDelete",
      default: false
    }, {
      type: "bit",
      name: "internal",
      default: false
    }, {
      type: "bit",
      name: "nowait",
      default: false
    }, {
      type: "table",
      name: "arguments",
      default: {}
    }]
  };
  exports.ExchangeDeclareOk = 2621451;
  var methodInfoExchangeDeclareOk = exports.methodInfoExchangeDeclareOk = {
    id: 2621451,
    classId: 40,
    methodId: 11,
    name: "ExchangeDeclareOk",
    args: []
  };
  exports.ExchangeDelete = 2621460;
  var methodInfoExchangeDelete = exports.methodInfoExchangeDelete = {
    id: 2621460,
    classId: 40,
    methodId: 20,
    name: "ExchangeDelete",
    args: [{
      type: "short",
      name: "ticket",
      default: 0
    }, {
      type: "shortstr",
      name: "exchange"
    }, {
      type: "bit",
      name: "ifUnused",
      default: false
    }, {
      type: "bit",
      name: "nowait",
      default: false
    }]
  };
  exports.ExchangeDeleteOk = 2621461;
  var methodInfoExchangeDeleteOk = exports.methodInfoExchangeDeleteOk = {
    id: 2621461,
    classId: 40,
    methodId: 21,
    name: "ExchangeDeleteOk",
    args: []
  };
  exports.ExchangeBind = 2621470;
  var methodInfoExchangeBind = exports.methodInfoExchangeBind = {
    id: 2621470,
    classId: 40,
    methodId: 30,
    name: "ExchangeBind",
    args: [{
      type: "short",
      name: "ticket",
      default: 0
    }, {
      type: "shortstr",
      name: "destination"
    }, {
      type: "shortstr",
      name: "source"
    }, {
      type: "shortstr",
      name: "routingKey",
      default: ""
    }, {
      type: "bit",
      name: "nowait",
      default: false
    }, {
      type: "table",
      name: "arguments",
      default: {}
    }]
  };
  exports.ExchangeBindOk = 2621471;
  var methodInfoExchangeBindOk = exports.methodInfoExchangeBindOk = {
    id: 2621471,
    classId: 40,
    methodId: 31,
    name: "ExchangeBindOk",
    args: []
  };
  exports.ExchangeUnbind = 2621480;
  var methodInfoExchangeUnbind = exports.methodInfoExchangeUnbind = {
    id: 2621480,
    classId: 40,
    methodId: 40,
    name: "ExchangeUnbind",
    args: [{
      type: "short",
      name: "ticket",
      default: 0
    }, {
      type: "shortstr",
      name: "destination"
    }, {
      type: "shortstr",
      name: "source"
    }, {
      type: "shortstr",
      name: "routingKey",
      default: ""
    }, {
      type: "bit",
      name: "nowait",
      default: false
    }, {
      type: "table",
      name: "arguments",
      default: {}
    }]
  };
  exports.ExchangeUnbindOk = 2621491;
  var methodInfoExchangeUnbindOk = exports.methodInfoExchangeUnbindOk = {
    id: 2621491,
    classId: 40,
    methodId: 51,
    name: "ExchangeUnbindOk",
    args: []
  };
  exports.QueueDeclare = 3276810;
  var methodInfoQueueDeclare = exports.methodInfoQueueDeclare = {
    id: 3276810,
    classId: 50,
    methodId: 10,
    name: "QueueDeclare",
    args: [{
      type: "short",
      name: "ticket",
      default: 0
    }, {
      type: "shortstr",
      name: "queue",
      default: ""
    }, {
      type: "bit",
      name: "passive",
      default: false
    }, {
      type: "bit",
      name: "durable",
      default: false
    }, {
      type: "bit",
      name: "exclusive",
      default: false
    }, {
      type: "bit",
      name: "autoDelete",
      default: false
    }, {
      type: "bit",
      name: "nowait",
      default: false
    }, {
      type: "table",
      name: "arguments",
      default: {}
    }]
  };
  exports.QueueDeclareOk = 3276811;
  var methodInfoQueueDeclareOk = exports.methodInfoQueueDeclareOk = {
    id: 3276811,
    classId: 50,
    methodId: 11,
    name: "QueueDeclareOk",
    args: [{
      type: "shortstr",
      name: "queue"
    }, {
      type: "long",
      name: "messageCount"
    }, {
      type: "long",
      name: "consumerCount"
    }]
  };
  exports.QueueBind = 3276820;
  var methodInfoQueueBind = exports.methodInfoQueueBind = {
    id: 3276820,
    classId: 50,
    methodId: 20,
    name: "QueueBind",
    args: [{
      type: "short",
      name: "ticket",
      default: 0
    }, {
      type: "shortstr",
      name: "queue",
      default: ""
    }, {
      type: "shortstr",
      name: "exchange"
    }, {
      type: "shortstr",
      name: "routingKey",
      default: ""
    }, {
      type: "bit",
      name: "nowait",
      default: false
    }, {
      type: "table",
      name: "arguments",
      default: {}
    }]
  };
  exports.QueueBindOk = 3276821;
  var methodInfoQueueBindOk = exports.methodInfoQueueBindOk = {
    id: 3276821,
    classId: 50,
    methodId: 21,
    name: "QueueBindOk",
    args: []
  };
  exports.QueuePurge = 3276830;
  var methodInfoQueuePurge = exports.methodInfoQueuePurge = {
    id: 3276830,
    classId: 50,
    methodId: 30,
    name: "QueuePurge",
    args: [{
      type: "short",
      name: "ticket",
      default: 0
    }, {
      type: "shortstr",
      name: "queue",
      default: ""
    }, {
      type: "bit",
      name: "nowait",
      default: false
    }]
  };
  exports.QueuePurgeOk = 3276831;
  var methodInfoQueuePurgeOk = exports.methodInfoQueuePurgeOk = {
    id: 3276831,
    classId: 50,
    methodId: 31,
    name: "QueuePurgeOk",
    args: [{
      type: "long",
      name: "messageCount"
    }]
  };
  exports.QueueDelete = 3276840;
  var methodInfoQueueDelete = exports.methodInfoQueueDelete = {
    id: 3276840,
    classId: 50,
    methodId: 40,
    name: "QueueDelete",
    args: [{
      type: "short",
      name: "ticket",
      default: 0
    }, {
      type: "shortstr",
      name: "queue",
      default: ""
    }, {
      type: "bit",
      name: "ifUnused",
      default: false
    }, {
      type: "bit",
      name: "ifEmpty",
      default: false
    }, {
      type: "bit",
      name: "nowait",
      default: false
    }]
  };
  exports.QueueDeleteOk = 3276841;
  var methodInfoQueueDeleteOk = exports.methodInfoQueueDeleteOk = {
    id: 3276841,
    classId: 50,
    methodId: 41,
    name: "QueueDeleteOk",
    args: [{
      type: "long",
      name: "messageCount"
    }]
  };
  exports.QueueUnbind = 3276850;
  var methodInfoQueueUnbind = exports.methodInfoQueueUnbind = {
    id: 3276850,
    classId: 50,
    methodId: 50,
    name: "QueueUnbind",
    args: [{
      type: "short",
      name: "ticket",
      default: 0
    }, {
      type: "shortstr",
      name: "queue",
      default: ""
    }, {
      type: "shortstr",
      name: "exchange"
    }, {
      type: "shortstr",
      name: "routingKey",
      default: ""
    }, {
      type: "table",
      name: "arguments",
      default: {}
    }]
  };
  exports.QueueUnbindOk = 3276851;
  var methodInfoQueueUnbindOk = exports.methodInfoQueueUnbindOk = {
    id: 3276851,
    classId: 50,
    methodId: 51,
    name: "QueueUnbindOk",
    args: []
  };
  exports.BasicQos = 3932170;
  var methodInfoBasicQos = exports.methodInfoBasicQos = {
    id: 3932170,
    classId: 60,
    methodId: 10,
    name: "BasicQos",
    args: [{
      type: "long",
      name: "prefetchSize",
      default: 0
    }, {
      type: "short",
      name: "prefetchCount",
      default: 0
    }, {
      type: "bit",
      name: "global",
      default: false
    }]
  };
  exports.BasicQosOk = 3932171;
  var methodInfoBasicQosOk = exports.methodInfoBasicQosOk = {
    id: 3932171,
    classId: 60,
    methodId: 11,
    name: "BasicQosOk",
    args: []
  };
  exports.BasicConsume = 3932180;
  var methodInfoBasicConsume = exports.methodInfoBasicConsume = {
    id: 3932180,
    classId: 60,
    methodId: 20,
    name: "BasicConsume",
    args: [{
      type: "short",
      name: "ticket",
      default: 0
    }, {
      type: "shortstr",
      name: "queue",
      default: ""
    }, {
      type: "shortstr",
      name: "consumerTag",
      default: ""
    }, {
      type: "bit",
      name: "noLocal",
      default: false
    }, {
      type: "bit",
      name: "noAck",
      default: false
    }, {
      type: "bit",
      name: "exclusive",
      default: false
    }, {
      type: "bit",
      name: "nowait",
      default: false
    }, {
      type: "table",
      name: "arguments",
      default: {}
    }]
  };
  exports.BasicConsumeOk = 3932181;
  var methodInfoBasicConsumeOk = exports.methodInfoBasicConsumeOk = {
    id: 3932181,
    classId: 60,
    methodId: 21,
    name: "BasicConsumeOk",
    args: [{
      type: "shortstr",
      name: "consumerTag"
    }]
  };
  exports.BasicCancel = 3932190;
  var methodInfoBasicCancel = exports.methodInfoBasicCancel = {
    id: 3932190,
    classId: 60,
    methodId: 30,
    name: "BasicCancel",
    args: [{
      type: "shortstr",
      name: "consumerTag"
    }, {
      type: "bit",
      name: "nowait",
      default: false
    }]
  };
  exports.BasicCancelOk = 3932191;
  var methodInfoBasicCancelOk = exports.methodInfoBasicCancelOk = {
    id: 3932191,
    classId: 60,
    methodId: 31,
    name: "BasicCancelOk",
    args: [{
      type: "shortstr",
      name: "consumerTag"
    }]
  };
  exports.BasicPublish = 3932200;
  var methodInfoBasicPublish = exports.methodInfoBasicPublish = {
    id: 3932200,
    classId: 60,
    methodId: 40,
    name: "BasicPublish",
    args: [{
      type: "short",
      name: "ticket",
      default: 0
    }, {
      type: "shortstr",
      name: "exchange",
      default: ""
    }, {
      type: "shortstr",
      name: "routingKey",
      default: ""
    }, {
      type: "bit",
      name: "mandatory",
      default: false
    }, {
      type: "bit",
      name: "immediate",
      default: false
    }]
  };
  exports.BasicReturn = 3932210;
  var methodInfoBasicReturn = exports.methodInfoBasicReturn = {
    id: 3932210,
    classId: 60,
    methodId: 50,
    name: "BasicReturn",
    args: [{
      type: "short",
      name: "replyCode"
    }, {
      type: "shortstr",
      name: "replyText",
      default: ""
    }, {
      type: "shortstr",
      name: "exchange"
    }, {
      type: "shortstr",
      name: "routingKey"
    }]
  };
  exports.BasicDeliver = 3932220;
  var methodInfoBasicDeliver = exports.methodInfoBasicDeliver = {
    id: 3932220,
    classId: 60,
    methodId: 60,
    name: "BasicDeliver",
    args: [{
      type: "shortstr",
      name: "consumerTag"
    }, {
      type: "longlong",
      name: "deliveryTag"
    }, {
      type: "bit",
      name: "redelivered",
      default: false
    }, {
      type: "shortstr",
      name: "exchange"
    }, {
      type: "shortstr",
      name: "routingKey"
    }]
  };
  exports.BasicGet = 3932230;
  var methodInfoBasicGet = exports.methodInfoBasicGet = {
    id: 3932230,
    classId: 60,
    methodId: 70,
    name: "BasicGet",
    args: [{
      type: "short",
      name: "ticket",
      default: 0
    }, {
      type: "shortstr",
      name: "queue",
      default: ""
    }, {
      type: "bit",
      name: "noAck",
      default: false
    }]
  };
  exports.BasicGetOk = 3932231;
  var methodInfoBasicGetOk = exports.methodInfoBasicGetOk = {
    id: 3932231,
    classId: 60,
    methodId: 71,
    name: "BasicGetOk",
    args: [{
      type: "longlong",
      name: "deliveryTag"
    }, {
      type: "bit",
      name: "redelivered",
      default: false
    }, {
      type: "shortstr",
      name: "exchange"
    }, {
      type: "shortstr",
      name: "routingKey"
    }, {
      type: "long",
      name: "messageCount"
    }]
  };
  exports.BasicGetEmpty = 3932232;
  var methodInfoBasicGetEmpty = exports.methodInfoBasicGetEmpty = {
    id: 3932232,
    classId: 60,
    methodId: 72,
    name: "BasicGetEmpty",
    args: [{
      type: "shortstr",
      name: "clusterId",
      default: ""
    }]
  };
  exports.BasicAck = 3932240;
  var methodInfoBasicAck = exports.methodInfoBasicAck = {
    id: 3932240,
    classId: 60,
    methodId: 80,
    name: "BasicAck",
    args: [{
      type: "longlong",
      name: "deliveryTag",
      default: 0
    }, {
      type: "bit",
      name: "multiple",
      default: false
    }]
  };
  exports.BasicReject = 3932250;
  var methodInfoBasicReject = exports.methodInfoBasicReject = {
    id: 3932250,
    classId: 60,
    methodId: 90,
    name: "BasicReject",
    args: [{
      type: "longlong",
      name: "deliveryTag"
    }, {
      type: "bit",
      name: "requeue",
      default: true
    }]
  };
  exports.BasicRecoverAsync = 3932260;
  var methodInfoBasicRecoverAsync = exports.methodInfoBasicRecoverAsync = {
    id: 3932260,
    classId: 60,
    methodId: 100,
    name: "BasicRecoverAsync",
    args: [{
      type: "bit",
      name: "requeue",
      default: false
    }]
  };
  exports.BasicRecover = 3932270;
  var methodInfoBasicRecover = exports.methodInfoBasicRecover = {
    id: 3932270,
    classId: 60,
    methodId: 110,
    name: "BasicRecover",
    args: [{
      type: "bit",
      name: "requeue",
      default: false
    }]
  };
  exports.BasicRecoverOk = 3932271;
  var methodInfoBasicRecoverOk = exports.methodInfoBasicRecoverOk = {
    id: 3932271,
    classId: 60,
    methodId: 111,
    name: "BasicRecoverOk",
    args: []
  };
  exports.BasicNack = 3932280;
  var methodInfoBasicNack = exports.methodInfoBasicNack = {
    id: 3932280,
    classId: 60,
    methodId: 120,
    name: "BasicNack",
    args: [{
      type: "longlong",
      name: "deliveryTag",
      default: 0
    }, {
      type: "bit",
      name: "multiple",
      default: false
    }, {
      type: "bit",
      name: "requeue",
      default: true
    }]
  };
  exports.TxSelect = 5898250;
  var methodInfoTxSelect = exports.methodInfoTxSelect = {
    id: 5898250,
    classId: 90,
    methodId: 10,
    name: "TxSelect",
    args: []
  };
  exports.TxSelectOk = 5898251;
  var methodInfoTxSelectOk = exports.methodInfoTxSelectOk = {
    id: 5898251,
    classId: 90,
    methodId: 11,
    name: "TxSelectOk",
    args: []
  };
  exports.TxCommit = 5898260;
  var methodInfoTxCommit = exports.methodInfoTxCommit = {
    id: 5898260,
    classId: 90,
    methodId: 20,
    name: "TxCommit",
    args: []
  };
  exports.TxCommitOk = 5898261;
  var methodInfoTxCommitOk = exports.methodInfoTxCommitOk = {
    id: 5898261,
    classId: 90,
    methodId: 21,
    name: "TxCommitOk",
    args: []
  };
  exports.TxRollback = 5898270;
  var methodInfoTxRollback = exports.methodInfoTxRollback = {
    id: 5898270,
    classId: 90,
    methodId: 30,
    name: "TxRollback",
    args: []
  };
  exports.TxRollbackOk = 5898271;
  var methodInfoTxRollbackOk = exports.methodInfoTxRollbackOk = {
    id: 5898271,
    classId: 90,
    methodId: 31,
    name: "TxRollbackOk",
    args: []
  };
  exports.ConfirmSelect = 5570570;
  var methodInfoConfirmSelect = exports.methodInfoConfirmSelect = {
    id: 5570570,
    classId: 85,
    methodId: 10,
    name: "ConfirmSelect",
    args: [{
      type: "bit",
      name: "nowait",
      default: false
    }]
  };
  exports.ConfirmSelectOk = 5570571;
  var methodInfoConfirmSelectOk = exports.methodInfoConfirmSelectOk = {
    id: 5570571,
    classId: 85,
    methodId: 11,
    name: "ConfirmSelectOk",
    args: []
  };
  exports.BasicProperties = 60;
  var propertiesInfoBasicProperties = exports.propertiesInfoBasicProperties = {
    id: 60,
    name: "BasicProperties",
    args: [{
      type: "shortstr",
      name: "contentType"
    }, {
      type: "shortstr",
      name: "contentEncoding"
    }, {
      type: "table",
      name: "headers"
    }, {
      type: "octet",
      name: "deliveryMode"
    }, {
      type: "octet",
      name: "priority"
    }, {
      type: "shortstr",
      name: "correlationId"
    }, {
      type: "shortstr",
      name: "replyTo"
    }, {
      type: "shortstr",
      name: "expiration"
    }, {
      type: "shortstr",
      name: "messageId"
    }, {
      type: "timestamp",
      name: "timestamp"
    }, {
      type: "shortstr",
      name: "type"
    }, {
      type: "shortstr",
      name: "userId"
    }, {
      type: "shortstr",
      name: "appId"
    }, {
      type: "shortstr",
      name: "clusterId"
    }]
  };
});

// node_modules/bitsyntax/lib/pattern.js
var require_pattern = __commonJS((exports, module) => {
  var set = function(values2) {
    var s = {};
    for (var i in values2) {
      s[values2[i]] = 1;
    }
    return s;
  };
  var variable = function(name, size2, specifiers0) {
    var specifiers = set(specifiers0);
    var segment = { name };
    segment.type = type_in(specifiers);
    specs(segment, segment.type, specifiers);
    segment.size = size_of(segment, segment.type, size2, segment.unit);
    return segment;
  };
  var value = function(val, size2, specifiers0) {
    var specifiers = set(specifiers0);
    var segment = { value: val };
    segment.type = type_in(specifiers);
    specs(segment, segment.type, specifiers);
    segment.size = size_of(segment, segment.type, size2, segment.unit);
    return segment;
  };
  var string = function(val) {
    return { value: val, type: "string" };
  };
  var type_in = function(specifiers) {
    for (var t in specifiers) {
      if (TYPES[t]) {
        return t;
      }
    }
    return "integer";
  };
  var specs = function(segment, type, specifiers) {
    switch (type) {
      case "integer":
        segment.signed = signed_in(specifiers);
      case "float":
        segment.bigendian = endian_in(specifiers);
      default:
        segment.unit = unit_in(specifiers, segment.type);
    }
    return segment;
  };
  var endian_in = function(specifiers) {
    return !specifiers["little"];
  };
  var signed_in = function(specifiers) {
    return specifiers["signed"];
  };
  var unit_in = function(specifiers, type) {
    for (var s in specifiers) {
      if (s.substr(0, 5) == "unit:") {
        var unit = parseInt(s.substr(5));
        return unit;
      }
    }
    switch (type) {
      case "binary":
        return 8;
      case "integer":
      case "float":
        return 1;
    }
  };
  var size_of = function(segment, type, size2, unit) {
    if (size2 !== undefined && size2 !== "") {
      return size2;
    } else {
      switch (type) {
        case "integer":
          return 8;
        case "float":
          return 64;
        case "binary":
          return true;
      }
    }
  };
  exports.variable = variable;
  exports.rest = function() {
    return variable("_", true, ["binary"]);
  };
  exports.value = value;
  exports.string = string;
  var TYPES = { integer: 1, binary: 1, float: 1 };
});

// node_modules/bitsyntax/lib/parser.js
var require_parser2 = __commonJS((exports, module) => {
  module.exports = function() {
    function quote(s) {
      return '"' + s.replace(/\\/g, "\\\\").replace(/"/g, '\\"').replace(/\x08/g, "\\b").replace(/\t/g, "\\t").replace(/\n/g, "\\n").replace(/\f/g, "\\f").replace(/\r/g, "\\r").replace(/[\x00-\x07\x0B\x0E-\x1F\x80-\uFFFF]/g, escape) + '"';
    }
    var result2 = {
      parse: function(input, startRule) {
        var parseFunctions = {
          start: parse_start,
          segmentTail: parse_segmentTail,
          segment: parse_segment,
          string: parse_string,
          chars: parse_chars,
          char: parse_char,
          hexDigit: parse_hexDigit,
          identifier: parse_identifier,
          number: parse_number,
          size: parse_size,
          specifierList: parse_specifierList,
          specifierTail: parse_specifierTail,
          specifier: parse_specifier,
          unit: parse_unit,
          ws: parse_ws
        };
        if (startRule !== undefined) {
          if (parseFunctions[startRule] === undefined) {
            throw new Error("Invalid rule name: " + quote(startRule) + ".");
          }
        } else {
          startRule = "start";
        }
        var pos = 0;
        var reportFailures = 0;
        var rightmostFailuresPos = 0;
        var rightmostFailuresExpected = [];
        function padLeft(input2, padding, length) {
          var result4 = input2;
          var padLength = length - input2.length;
          for (var i = 0;i < padLength; i++) {
            result4 = padding + result4;
          }
          return result4;
        }
        function escape3(ch) {
          var charCode = ch.charCodeAt(0);
          var escapeChar;
          var length;
          if (charCode <= 255) {
            escapeChar = "x";
            length = 2;
          } else {
            escapeChar = "u";
            length = 4;
          }
          return "\\" + escapeChar + padLeft(charCode.toString(16).toUpperCase(), "0", length);
        }
        function matchFailed(failure) {
          if (pos < rightmostFailuresPos) {
            return;
          }
          if (pos > rightmostFailuresPos) {
            rightmostFailuresPos = pos;
            rightmostFailuresExpected = [];
          }
          rightmostFailuresExpected.push(failure);
        }
        function parse_start() {
          var result0, result1, result22, result32;
          var pos0, pos1;
          pos0 = pos;
          pos1 = pos;
          result0 = parse_ws();
          if (result0 !== null) {
            result1 = parse_segment();
            if (result1 !== null) {
              result22 = [];
              result32 = parse_segmentTail();
              while (result32 !== null) {
                result22.push(result32);
                result32 = parse_segmentTail();
              }
              if (result22 !== null) {
                result0 = [result0, result1, result22];
              } else {
                result0 = null;
                pos = pos1;
              }
            } else {
              result0 = null;
              pos = pos1;
            }
          } else {
            result0 = null;
            pos = pos1;
          }
          if (result0 !== null) {
            result0 = function(offset2, head, tail) {
              tail.unshift(head);
              return tail;
            }(pos0, result0[1], result0[2]);
          }
          if (result0 === null) {
            pos = pos0;
          }
          return result0;
        }
        function parse_segmentTail() {
          var result0, result1, result22, result32;
          var pos0, pos1;
          pos0 = pos;
          pos1 = pos;
          result0 = parse_ws();
          if (result0 !== null) {
            if (input.charCodeAt(pos) === 44) {
              result1 = ",";
              pos++;
            } else {
              result1 = null;
              if (reportFailures === 0) {
                matchFailed("\",\"");
              }
            }
            if (result1 !== null) {
              result22 = parse_ws();
              if (result22 !== null) {
                result32 = parse_segment();
                if (result32 !== null) {
                  result0 = [result0, result1, result22, result32];
                } else {
                  result0 = null;
                  pos = pos1;
                }
              } else {
                result0 = null;
                pos = pos1;
              }
            } else {
              result0 = null;
              pos = pos1;
            }
          } else {
            result0 = null;
            pos = pos1;
          }
          if (result0 !== null) {
            result0 = function(offset2, seg) {
              return seg;
            }(pos0, result0[3]);
          }
          if (result0 === null) {
            pos = pos0;
          }
          return result0;
        }
        function parse_segment() {
          var result0, result1, result22;
          var pos0, pos1;
          pos0 = pos;
          result0 = parse_string();
          if (result0 !== null) {
            result0 = function(offset2, str) {
              return { string: str };
            }(pos0, result0);
          }
          if (result0 === null) {
            pos = pos0;
          }
          if (result0 === null) {
            pos0 = pos;
            pos1 = pos;
            result0 = parse_identifier();
            if (result0 !== null) {
              result1 = parse_size();
              result1 = result1 !== null ? result1 : "";
              if (result1 !== null) {
                result22 = parse_specifierList();
                result22 = result22 !== null ? result22 : "";
                if (result22 !== null) {
                  result0 = [result0, result1, result22];
                } else {
                  result0 = null;
                  pos = pos1;
                }
              } else {
                result0 = null;
                pos = pos1;
              }
            } else {
              result0 = null;
              pos = pos1;
            }
            if (result0 !== null) {
              result0 = function(offset2, v, size2, specs) {
                return { name: v, size: size2, specifiers: specs };
              }(pos0, result0[0], result0[1], result0[2]);
            }
            if (result0 === null) {
              pos = pos0;
            }
            if (result0 === null) {
              pos0 = pos;
              pos1 = pos;
              result0 = parse_number();
              if (result0 !== null) {
                result1 = parse_size();
                result1 = result1 !== null ? result1 : "";
                if (result1 !== null) {
                  result22 = parse_specifierList();
                  result22 = result22 !== null ? result22 : "";
                  if (result22 !== null) {
                    result0 = [result0, result1, result22];
                  } else {
                    result0 = null;
                    pos = pos1;
                  }
                } else {
                  result0 = null;
                  pos = pos1;
                }
              } else {
                result0 = null;
                pos = pos1;
              }
              if (result0 !== null) {
                result0 = function(offset2, v, size2, specs) {
                  return { value: v, size: size2, specifiers: specs };
                }(pos0, result0[0], result0[1], result0[2]);
              }
              if (result0 === null) {
                pos = pos0;
              }
            }
          }
          return result0;
        }
        function parse_string() {
          var result0, result1, result22;
          var pos0, pos1;
          pos0 = pos;
          pos1 = pos;
          if (input.charCodeAt(pos) === 34) {
            result0 = "\"";
            pos++;
          } else {
            result0 = null;
            if (reportFailures === 0) {
              matchFailed("\"\\\"\"");
            }
          }
          if (result0 !== null) {
            if (input.charCodeAt(pos) === 34) {
              result1 = "\"";
              pos++;
            } else {
              result1 = null;
              if (reportFailures === 0) {
                matchFailed("\"\\\"\"");
              }
            }
            if (result1 !== null) {
              result0 = [result0, result1];
            } else {
              result0 = null;
              pos = pos1;
            }
          } else {
            result0 = null;
            pos = pos1;
          }
          if (result0 !== null) {
            result0 = function(offset2) {
              return "";
            }(pos0);
          }
          if (result0 === null) {
            pos = pos0;
          }
          if (result0 === null) {
            pos0 = pos;
            pos1 = pos;
            if (input.charCodeAt(pos) === 34) {
              result0 = "\"";
              pos++;
            } else {
              result0 = null;
              if (reportFailures === 0) {
                matchFailed("\"\\\"\"");
              }
            }
            if (result0 !== null) {
              result1 = parse_chars();
              if (result1 !== null) {
                if (input.charCodeAt(pos) === 34) {
                  result22 = "\"";
                  pos++;
                } else {
                  result22 = null;
                  if (reportFailures === 0) {
                    matchFailed("\"\\\"\"");
                  }
                }
                if (result22 !== null) {
                  result0 = [result0, result1, result22];
                } else {
                  result0 = null;
                  pos = pos1;
                }
              } else {
                result0 = null;
                pos = pos1;
              }
            } else {
              result0 = null;
              pos = pos1;
            }
            if (result0 !== null) {
              result0 = function(offset2, chars) {
                return chars;
              }(pos0, result0[1]);
            }
            if (result0 === null) {
              pos = pos0;
            }
          }
          return result0;
        }
        function parse_chars() {
          var result0, result1;
          var pos0;
          pos0 = pos;
          result1 = parse_char();
          if (result1 !== null) {
            result0 = [];
            while (result1 !== null) {
              result0.push(result1);
              result1 = parse_char();
            }
          } else {
            result0 = null;
          }
          if (result0 !== null) {
            result0 = function(offset2, chars) {
              return chars.join("");
            }(pos0, result0);
          }
          if (result0 === null) {
            pos = pos0;
          }
          return result0;
        }
        function parse_char() {
          var result0, result1, result22, result32, result4;
          var pos0, pos1;
          if (/^[^"\\\0-\x1F]/.test(input.charAt(pos))) {
            result0 = input.charAt(pos);
            pos++;
          } else {
            result0 = null;
            if (reportFailures === 0) {
              matchFailed("[^\"\\\\\\0-\\x1F]");
            }
          }
          if (result0 === null) {
            pos0 = pos;
            if (input.substr(pos, 2) === "\\\"") {
              result0 = "\\\"";
              pos += 2;
            } else {
              result0 = null;
              if (reportFailures === 0) {
                matchFailed("\"\\\\\\\"\"");
              }
            }
            if (result0 !== null) {
              result0 = function(offset2) {
                return '"';
              }(pos0);
            }
            if (result0 === null) {
              pos = pos0;
            }
            if (result0 === null) {
              pos0 = pos;
              if (input.substr(pos, 2) === "\\\\") {
                result0 = "\\\\";
                pos += 2;
              } else {
                result0 = null;
                if (reportFailures === 0) {
                  matchFailed("\"\\\\\\\\\"");
                }
              }
              if (result0 !== null) {
                result0 = function(offset2) {
                  return "\\";
                }(pos0);
              }
              if (result0 === null) {
                pos = pos0;
              }
              if (result0 === null) {
                pos0 = pos;
                if (input.substr(pos, 2) === "\\/") {
                  result0 = "\\/";
                  pos += 2;
                } else {
                  result0 = null;
                  if (reportFailures === 0) {
                    matchFailed("\"\\\\/\"");
                  }
                }
                if (result0 !== null) {
                  result0 = function(offset2) {
                    return "/";
                  }(pos0);
                }
                if (result0 === null) {
                  pos = pos0;
                }
                if (result0 === null) {
                  pos0 = pos;
                  if (input.substr(pos, 2) === "\\b") {
                    result0 = "\\b";
                    pos += 2;
                  } else {
                    result0 = null;
                    if (reportFailures === 0) {
                      matchFailed("\"\\\\b\"");
                    }
                  }
                  if (result0 !== null) {
                    result0 = function(offset2) {
                      return "\b";
                    }(pos0);
                  }
                  if (result0 === null) {
                    pos = pos0;
                  }
                  if (result0 === null) {
                    pos0 = pos;
                    if (input.substr(pos, 2) === "\\f") {
                      result0 = "\\f";
                      pos += 2;
                    } else {
                      result0 = null;
                      if (reportFailures === 0) {
                        matchFailed("\"\\\\f\"");
                      }
                    }
                    if (result0 !== null) {
                      result0 = function(offset2) {
                        return "\f";
                      }(pos0);
                    }
                    if (result0 === null) {
                      pos = pos0;
                    }
                    if (result0 === null) {
                      pos0 = pos;
                      if (input.substr(pos, 2) === "\\n") {
                        result0 = "\\n";
                        pos += 2;
                      } else {
                        result0 = null;
                        if (reportFailures === 0) {
                          matchFailed("\"\\\\n\"");
                        }
                      }
                      if (result0 !== null) {
                        result0 = function(offset2) {
                          return "\n";
                        }(pos0);
                      }
                      if (result0 === null) {
                        pos = pos0;
                      }
                      if (result0 === null) {
                        pos0 = pos;
                        if (input.substr(pos, 2) === "\\r") {
                          result0 = "\\r";
                          pos += 2;
                        } else {
                          result0 = null;
                          if (reportFailures === 0) {
                            matchFailed("\"\\\\r\"");
                          }
                        }
                        if (result0 !== null) {
                          result0 = function(offset2) {
                            return "\r";
                          }(pos0);
                        }
                        if (result0 === null) {
                          pos = pos0;
                        }
                        if (result0 === null) {
                          pos0 = pos;
                          if (input.substr(pos, 2) === "\\t") {
                            result0 = "\\t";
                            pos += 2;
                          } else {
                            result0 = null;
                            if (reportFailures === 0) {
                              matchFailed("\"\\\\t\"");
                            }
                          }
                          if (result0 !== null) {
                            result0 = function(offset2) {
                              return "\t";
                            }(pos0);
                          }
                          if (result0 === null) {
                            pos = pos0;
                          }
                          if (result0 === null) {
                            pos0 = pos;
                            pos1 = pos;
                            if (input.substr(pos, 2) === "\\u") {
                              result0 = "\\u";
                              pos += 2;
                            } else {
                              result0 = null;
                              if (reportFailures === 0) {
                                matchFailed("\"\\\\u\"");
                              }
                            }
                            if (result0 !== null) {
                              result1 = parse_hexDigit();
                              if (result1 !== null) {
                                result22 = parse_hexDigit();
                                if (result22 !== null) {
                                  result32 = parse_hexDigit();
                                  if (result32 !== null) {
                                    result4 = parse_hexDigit();
                                    if (result4 !== null) {
                                      result0 = [result0, result1, result22, result32, result4];
                                    } else {
                                      result0 = null;
                                      pos = pos1;
                                    }
                                  } else {
                                    result0 = null;
                                    pos = pos1;
                                  }
                                } else {
                                  result0 = null;
                                  pos = pos1;
                                }
                              } else {
                                result0 = null;
                                pos = pos1;
                              }
                            } else {
                              result0 = null;
                              pos = pos1;
                            }
                            if (result0 !== null) {
                              result0 = function(offset2, h1, h2, h3, h4) {
                                return String.fromCharCode(parseInt("0x" + h1 + h2 + h3 + h4));
                              }(pos0, result0[1], result0[2], result0[3], result0[4]);
                            }
                            if (result0 === null) {
                              pos = pos0;
                            }
                          }
                        }
                      }
                    }
                  }
                }
              }
            }
          }
          return result0;
        }
        function parse_hexDigit() {
          var result0;
          if (/^[0-9a-fA-F]/.test(input.charAt(pos))) {
            result0 = input.charAt(pos);
            pos++;
          } else {
            result0 = null;
            if (reportFailures === 0) {
              matchFailed("[0-9a-fA-F]");
            }
          }
          return result0;
        }
        function parse_identifier() {
          var result0, result1, result22;
          var pos0, pos1;
          pos0 = pos;
          pos1 = pos;
          if (/^[_a-zA-Z]/.test(input.charAt(pos))) {
            result0 = input.charAt(pos);
            pos++;
          } else {
            result0 = null;
            if (reportFailures === 0) {
              matchFailed("[_a-zA-Z]");
            }
          }
          if (result0 !== null) {
            result1 = [];
            if (/^[_a-zA-Z0-9]/.test(input.charAt(pos))) {
              result22 = input.charAt(pos);
              pos++;
            } else {
              result22 = null;
              if (reportFailures === 0) {
                matchFailed("[_a-zA-Z0-9]");
              }
            }
            while (result22 !== null) {
              result1.push(result22);
              if (/^[_a-zA-Z0-9]/.test(input.charAt(pos))) {
                result22 = input.charAt(pos);
                pos++;
              } else {
                result22 = null;
                if (reportFailures === 0) {
                  matchFailed("[_a-zA-Z0-9]");
                }
              }
            }
            if (result1 !== null) {
              result0 = [result0, result1];
            } else {
              result0 = null;
              pos = pos1;
            }
          } else {
            result0 = null;
            pos = pos1;
          }
          if (result0 !== null) {
            result0 = function(offset2, head, tail) {
              return head + tail.join("");
            }(pos0, result0[0], result0[1]);
          }
          if (result0 === null) {
            pos = pos0;
          }
          return result0;
        }
        function parse_number() {
          var result0, result1, result22;
          var pos0, pos1;
          pos0 = pos;
          if (input.charCodeAt(pos) === 48) {
            result0 = "0";
            pos++;
          } else {
            result0 = null;
            if (reportFailures === 0) {
              matchFailed("\"0\"");
            }
          }
          if (result0 !== null) {
            result0 = function(offset2) {
              return 0;
            }(pos0);
          }
          if (result0 === null) {
            pos = pos0;
          }
          if (result0 === null) {
            pos0 = pos;
            pos1 = pos;
            if (/^[1-9]/.test(input.charAt(pos))) {
              result0 = input.charAt(pos);
              pos++;
            } else {
              result0 = null;
              if (reportFailures === 0) {
                matchFailed("[1-9]");
              }
            }
            if (result0 !== null) {
              result1 = [];
              if (/^[0-9]/.test(input.charAt(pos))) {
                result22 = input.charAt(pos);
                pos++;
              } else {
                result22 = null;
                if (reportFailures === 0) {
                  matchFailed("[0-9]");
                }
              }
              while (result22 !== null) {
                result1.push(result22);
                if (/^[0-9]/.test(input.charAt(pos))) {
                  result22 = input.charAt(pos);
                  pos++;
                } else {
                  result22 = null;
                  if (reportFailures === 0) {
                    matchFailed("[0-9]");
                  }
                }
              }
              if (result1 !== null) {
                result0 = [result0, result1];
              } else {
                result0 = null;
                pos = pos1;
              }
            } else {
              result0 = null;
              pos = pos1;
            }
            if (result0 !== null) {
              result0 = function(offset2, head, tail) {
                return parseInt(head + tail.join(""));
              }(pos0, result0[0], result0[1]);
            }
            if (result0 === null) {
              pos = pos0;
            }
          }
          return result0;
        }
        function parse_size() {
          var result0, result1;
          var pos0, pos1;
          pos0 = pos;
          pos1 = pos;
          if (input.charCodeAt(pos) === 58) {
            result0 = ":";
            pos++;
          } else {
            result0 = null;
            if (reportFailures === 0) {
              matchFailed("\":\"");
            }
          }
          if (result0 !== null) {
            result1 = parse_number();
            if (result1 !== null) {
              result0 = [result0, result1];
            } else {
              result0 = null;
              pos = pos1;
            }
          } else {
            result0 = null;
            pos = pos1;
          }
          if (result0 !== null) {
            result0 = function(offset2, num) {
              return num;
            }(pos0, result0[1]);
          }
          if (result0 === null) {
            pos = pos0;
          }
          if (result0 === null) {
            pos0 = pos;
            pos1 = pos;
            if (input.charCodeAt(pos) === 58) {
              result0 = ":";
              pos++;
            } else {
              result0 = null;
              if (reportFailures === 0) {
                matchFailed("\":\"");
              }
            }
            if (result0 !== null) {
              result1 = parse_identifier();
              if (result1 !== null) {
                result0 = [result0, result1];
              } else {
                result0 = null;
                pos = pos1;
              }
            } else {
              result0 = null;
              pos = pos1;
            }
            if (result0 !== null) {
              result0 = function(offset2, id) {
                return id;
              }(pos0, result0[1]);
            }
            if (result0 === null) {
              pos = pos0;
            }
          }
          return result0;
        }
        function parse_specifierList() {
          var result0, result1, result22, result32;
          var pos0, pos1;
          pos0 = pos;
          pos1 = pos;
          if (input.charCodeAt(pos) === 47) {
            result0 = "/";
            pos++;
          } else {
            result0 = null;
            if (reportFailures === 0) {
              matchFailed("\"/\"");
            }
          }
          if (result0 !== null) {
            result1 = parse_specifier();
            if (result1 !== null) {
              result22 = [];
              result32 = parse_specifierTail();
              while (result32 !== null) {
                result22.push(result32);
                result32 = parse_specifierTail();
              }
              if (result22 !== null) {
                result0 = [result0, result1, result22];
              } else {
                result0 = null;
                pos = pos1;
              }
            } else {
              result0 = null;
              pos = pos1;
            }
          } else {
            result0 = null;
            pos = pos1;
          }
          if (result0 !== null) {
            result0 = function(offset2, head, tail) {
              tail.unshift(head);
              return tail;
            }(pos0, result0[1], result0[2]);
          }
          if (result0 === null) {
            pos = pos0;
          }
          return result0;
        }
        function parse_specifierTail() {
          var result0, result1;
          var pos0, pos1;
          pos0 = pos;
          pos1 = pos;
          if (input.charCodeAt(pos) === 45) {
            result0 = "-";
            pos++;
          } else {
            result0 = null;
            if (reportFailures === 0) {
              matchFailed("\"-\"");
            }
          }
          if (result0 !== null) {
            result1 = parse_specifier();
            if (result1 !== null) {
              result0 = [result0, result1];
            } else {
              result0 = null;
              pos = pos1;
            }
          } else {
            result0 = null;
            pos = pos1;
          }
          if (result0 !== null) {
            result0 = function(offset2, spec) {
              return spec;
            }(pos0, result0[1]);
          }
          if (result0 === null) {
            pos = pos0;
          }
          return result0;
        }
        function parse_specifier() {
          var result0;
          if (input.substr(pos, 6) === "little") {
            result0 = "little";
            pos += 6;
          } else {
            result0 = null;
            if (reportFailures === 0) {
              matchFailed("\"little\"");
            }
          }
          if (result0 === null) {
            if (input.substr(pos, 3) === "big") {
              result0 = "big";
              pos += 3;
            } else {
              result0 = null;
              if (reportFailures === 0) {
                matchFailed("\"big\"");
              }
            }
            if (result0 === null) {
              if (input.substr(pos, 6) === "signed") {
                result0 = "signed";
                pos += 6;
              } else {
                result0 = null;
                if (reportFailures === 0) {
                  matchFailed("\"signed\"");
                }
              }
              if (result0 === null) {
                if (input.substr(pos, 8) === "unsigned") {
                  result0 = "unsigned";
                  pos += 8;
                } else {
                  result0 = null;
                  if (reportFailures === 0) {
                    matchFailed("\"unsigned\"");
                  }
                }
                if (result0 === null) {
                  if (input.substr(pos, 7) === "integer") {
                    result0 = "integer";
                    pos += 7;
                  } else {
                    result0 = null;
                    if (reportFailures === 0) {
                      matchFailed("\"integer\"");
                    }
                  }
                  if (result0 === null) {
                    if (input.substr(pos, 6) === "binary") {
                      result0 = "binary";
                      pos += 6;
                    } else {
                      result0 = null;
                      if (reportFailures === 0) {
                        matchFailed("\"binary\"");
                      }
                    }
                    if (result0 === null) {
                      if (input.substr(pos, 5) === "float") {
                        result0 = "float";
                        pos += 5;
                      } else {
                        result0 = null;
                        if (reportFailures === 0) {
                          matchFailed("\"float\"");
                        }
                      }
                      if (result0 === null) {
                        result0 = parse_unit();
                      }
                    }
                  }
                }
              }
            }
          }
          return result0;
        }
        function parse_unit() {
          var result0, result1;
          var pos0, pos1;
          pos0 = pos;
          pos1 = pos;
          if (input.substr(pos, 5) === "unit:") {
            result0 = "unit:";
            pos += 5;
          } else {
            result0 = null;
            if (reportFailures === 0) {
              matchFailed("\"unit:\"");
            }
          }
          if (result0 !== null) {
            result1 = parse_number();
            if (result1 !== null) {
              result0 = [result0, result1];
            } else {
              result0 = null;
              pos = pos1;
            }
          } else {
            result0 = null;
            pos = pos1;
          }
          if (result0 !== null) {
            result0 = function(offset2, num) {
              return "unit:" + num;
            }(pos0, result0[1]);
          }
          if (result0 === null) {
            pos = pos0;
          }
          return result0;
        }
        function parse_ws() {
          var result0, result1;
          result0 = [];
          if (/^[ \t\n]/.test(input.charAt(pos))) {
            result1 = input.charAt(pos);
            pos++;
          } else {
            result1 = null;
            if (reportFailures === 0) {
              matchFailed("[ \\t\\n]");
            }
          }
          while (result1 !== null) {
            result0.push(result1);
            if (/^[ \t\n]/.test(input.charAt(pos))) {
              result1 = input.charAt(pos);
              pos++;
            } else {
              result1 = null;
              if (reportFailures === 0) {
                matchFailed("[ \\t\\n]");
              }
            }
          }
          return result0;
        }
        function cleanupExpected(expected) {
          expected.sort();
          var lastExpected = null;
          var cleanExpected = [];
          for (var i = 0;i < expected.length; i++) {
            if (expected[i] !== lastExpected) {
              cleanExpected.push(expected[i]);
              lastExpected = expected[i];
            }
          }
          return cleanExpected;
        }
        function computeErrorPosition() {
          var line = 1;
          var column = 1;
          var seenCR = false;
          for (var i = 0;i < Math.max(pos, rightmostFailuresPos); i++) {
            var ch = input.charAt(i);
            if (ch === "\n") {
              if (!seenCR) {
                line++;
              }
              column = 1;
              seenCR = false;
            } else if (ch === "\r" || ch === "\u2028" || ch === "\u2029") {
              line++;
              column = 1;
              seenCR = true;
            } else {
              column++;
              seenCR = false;
            }
          }
          return { line, column };
        }
        var result3 = parseFunctions[startRule]();
        if (result3 === null || pos !== input.length) {
          var offset = Math.max(pos, rightmostFailuresPos);
          var found = offset < input.length ? input.charAt(offset) : null;
          var errorPosition = computeErrorPosition();
          throw new this.SyntaxError(cleanupExpected(rightmostFailuresExpected), found, offset, errorPosition.line, errorPosition.column);
        }
        return result3;
      },
      toSource: function() {
        return this._source;
      }
    };
    result2.SyntaxError = function(expected, found, offset, line, column) {
      function buildMessage(expected2, found2) {
        var expectedHumanized, foundHumanized;
        switch (expected2.length) {
          case 0:
            expectedHumanized = "end of input";
            break;
          case 1:
            expectedHumanized = expected2[0];
            break;
          default:
            expectedHumanized = expected2.slice(0, expected2.length - 1).join(", ") + " or " + expected2[expected2.length - 1];
        }
        foundHumanized = found2 ? quote(found2) : "end of input";
        return "Expected " + expectedHumanized + " but " + foundHumanized + " found.";
      }
      this.name = "SyntaxError";
      this.expected = expected;
      this.found = found;
      this.message = buildMessage(expected, found);
      this.offset = offset;
      this.line = line;
      this.column = column;
    };
    result2.SyntaxError.prototype = Error.prototype;
    return result2;
  }();
});

// node_modules/bitsyntax/lib/parse.js
var require_parse2 = __commonJS((exports, module) => {
  var parse_pattern = function(string) {
    var segments = parser.parse(string);
    for (var i = 0, len = segments.length;i < len; i++) {
      var s = segments[i];
      if (s.string != null) {
        segments[i] = ast.string(s.string);
      } else if (s.value != null) {
        segments[i] = ast.value(s.value, s.size, s.specifiers);
      } else if (s.name != null) {
        segments[i] = ast.variable(s.name, s.size, s.specifiers);
      } else {
        throw "Unknown segment " + s;
      }
    }
    return segments;
  };
  var ast = require_pattern();
  var parser = require_parser2();
  exports.parse = function() {
    var str = [].join.call(arguments, ",");
    return parse_pattern(str);
  };
});

// node_modules/bitsyntax/node_modules/debug/node_modules/ms/index.js
var require_ms2 = __commonJS((exports, module) => {
  var parse4 = function(str) {
    str = String(str);
    if (str.length > 100) {
      return;
    }
    var match = /^((?:\d+)?\.?\d+) *(milliseconds?|msecs?|ms|seconds?|secs?|s|minutes?|mins?|m|hours?|hrs?|h|days?|d|years?|yrs?|y)?$/i.exec(str);
    if (!match) {
      return;
    }
    var n = parseFloat(match[1]);
    var type = (match[2] || "ms").toLowerCase();
    switch (type) {
      case "years":
      case "year":
      case "yrs":
      case "yr":
      case "y":
        return n * y;
      case "days":
      case "day":
      case "d":
        return n * d;
      case "hours":
      case "hour":
      case "hrs":
      case "hr":
      case "h":
        return n * h;
      case "minutes":
      case "minute":
      case "mins":
      case "min":
      case "m":
        return n * m;
      case "seconds":
      case "second":
      case "secs":
      case "sec":
      case "s":
        return n * s;
      case "milliseconds":
      case "millisecond":
      case "msecs":
      case "msec":
      case "ms":
        return n;
      default:
        return;
    }
  };
  var fmtShort = function(ms) {
    if (ms >= d) {
      return Math.round(ms / d) + "d";
    }
    if (ms >= h) {
      return Math.round(ms / h) + "h";
    }
    if (ms >= m) {
      return Math.round(ms / m) + "m";
    }
    if (ms >= s) {
      return Math.round(ms / s) + "s";
    }
    return ms + "ms";
  };
  var fmtLong = function(ms) {
    return plural(ms, d, "day") || plural(ms, h, "hour") || plural(ms, m, "minute") || plural(ms, s, "second") || ms + " ms";
  };
  var plural = function(ms, n, name) {
    if (ms < n) {
      return;
    }
    if (ms < n * 1.5) {
      return Math.floor(ms / n) + " " + name;
    }
    return Math.ceil(ms / n) + " " + name + "s";
  };
  var s = 1000;
  var m = s * 60;
  var h = m * 60;
  var d = h * 24;
  var y = d * 365.25;
  module.exports = function(val, options) {
    options = options || {};
    var type = typeof val;
    if (type === "string" && val.length > 0) {
      return parse4(val);
    } else if (type === "number" && isNaN(val) === false) {
      return options.long ? fmtLong(val) : fmtShort(val);
    }
    throw new Error("val is not a non-empty string or a valid number. val=" + JSON.stringify(val));
  };
});

// node_modules/bitsyntax/node_modules/debug/src/debug.js
var require_debug2 = __commonJS((exports, module) => {
  var selectColor = function(namespace) {
    var hash = 0, i;
    for (i in namespace) {
      hash = (hash << 5) - hash + namespace.charCodeAt(i);
      hash |= 0;
    }
    return exports.colors[Math.abs(hash) % exports.colors.length];
  };
  var createDebug = function(namespace) {
    function debug() {
      if (!debug.enabled)
        return;
      var self2 = debug;
      var curr = +new Date;
      var ms = curr - (prevTime || curr);
      self2.diff = ms;
      self2.prev = prevTime;
      self2.curr = curr;
      prevTime = curr;
      var args = new Array(arguments.length);
      for (var i = 0;i < args.length; i++) {
        args[i] = arguments[i];
      }
      args[0] = exports.coerce(args[0]);
      if (typeof args[0] !== "string") {
        args.unshift("%O");
      }
      var index = 0;
      args[0] = args[0].replace(/%([a-zA-Z%])/g, function(match, format) {
        if (match === "%%")
          return match;
        index++;
        var formatter = exports.formatters[format];
        if (typeof formatter === "function") {
          var val = args[index];
          match = formatter.call(self2, val);
          args.splice(index, 1);
          index--;
        }
        return match;
      });
      exports.formatArgs.call(self2, args);
      var logFn = debug.log || exports.log || console.log.bind(console);
      logFn.apply(self2, args);
    }
    debug.namespace = namespace;
    debug.enabled = exports.enabled(namespace);
    debug.useColors = exports.useColors();
    debug.color = selectColor(namespace);
    if (typeof exports.init === "function") {
      exports.init(debug);
    }
    return debug;
  };
  var enable = function(namespaces) {
    exports.save(namespaces);
    exports.names = [];
    exports.skips = [];
    var split = (typeof namespaces === "string" ? namespaces : "").split(/[\s,]+/);
    var len = split.length;
    for (var i = 0;i < len; i++) {
      if (!split[i])
        continue;
      namespaces = split[i].replace(/\*/g, ".*?");
      if (namespaces[0] === "-") {
        exports.skips.push(new RegExp("^" + namespaces.substr(1) + "$"));
      } else {
        exports.names.push(new RegExp("^" + namespaces + "$"));
      }
    }
  };
  var disable = function() {
    exports.enable("");
  };
  var enabled = function(name) {
    var i, len;
    for (i = 0, len = exports.skips.length;i < len; i++) {
      if (exports.skips[i].test(name)) {
        return false;
      }
    }
    for (i = 0, len = exports.names.length;i < len; i++) {
      if (exports.names[i].test(name)) {
        return true;
      }
    }
    return false;
  };
  var coerce = function(val) {
    if (val instanceof Error)
      return val.stack || val.message;
    return val;
  };
  exports = module.exports = createDebug.debug = createDebug["default"] = createDebug;
  exports.coerce = coerce;
  exports.disable = disable;
  exports.enable = enable;
  exports.enabled = enabled;
  exports.humanize = require_ms2();
  exports.names = [];
  exports.skips = [];
  exports.formatters = {};
  var prevTime;
});

// node_modules/bitsyntax/node_modules/debug/src/browser.js
var require_browser2 = __commonJS((exports, module) => {
  var useColors = function() {
    if (typeof window !== "undefined" && window.process && window.process.type === "renderer") {
      return true;
    }
    return typeof document !== "undefined" && document.documentElement && document.documentElement.style && document.documentElement.style.WebkitAppearance || typeof window !== "undefined" && window.console && (window.console.firebug || window.console.exception && window.console.table) || typeof navigator !== "undefined" && navigator.userAgent && navigator.userAgent.toLowerCase().match(/firefox\/(\d+)/) && parseInt(RegExp.$1, 10) >= 31 || typeof navigator !== "undefined" && navigator.userAgent && navigator.userAgent.toLowerCase().match(/applewebkit\/(\d+)/);
  };
  var formatArgs = function(args) {
    var useColors2 = this.useColors;
    args[0] = (useColors2 ? "%c" : "") + this.namespace + (useColors2 ? " %c" : " ") + args[0] + (useColors2 ? "%c " : " ") + "+" + exports.humanize(this.diff);
    if (!useColors2)
      return;
    var c = "color: " + this.color;
    args.splice(1, 0, c, "color: inherit");
    var index = 0;
    var lastC = 0;
    args[0].replace(/%[a-zA-Z%]/g, function(match) {
      if (match === "%%")
        return;
      index++;
      if (match === "%c") {
        lastC = index;
      }
    });
    args.splice(lastC, 0, c);
  };
  var log = function() {
    return typeof console === "object" && console.log && Function.prototype.apply.call(console.log, console, arguments);
  };
  var save = function(namespaces) {
    try {
      if (namespaces == null) {
        exports.storage.removeItem("debug");
      } else {
        exports.storage.debug = namespaces;
      }
    } catch (e) {
    }
  };
  var load = function() {
    var r;
    try {
      r = exports.storage.debug;
    } catch (e) {
    }
    if (!r && typeof process !== "undefined" && ("env" in process)) {
      r = process.env.DEBUG;
    }
    return r;
  };
  var localstorage = function() {
    try {
      return window.localStorage;
    } catch (e) {
    }
  };
  exports = module.exports = require_debug2();
  exports.log = log;
  exports.formatArgs = formatArgs;
  exports.save = save;
  exports.load = load;
  exports.useColors = useColors;
  exports.storage = typeof chrome != "undefined" && typeof chrome.storage != "undefined" ? chrome.storage.local : localstorage();
  exports.colors = [
    "lightseagreen",
    "forestgreen",
    "goldenrod",
    "dodgerblue",
    "darkorchid",
    "crimson"
  ];
  exports.formatters.j = function(v) {
    try {
      return JSON.stringify(v);
    } catch (err) {
      return "[UnexpectedJSONParseError]: " + err.message;
    }
  };
  exports.enable(load());
});

// node_modules/bitsyntax/node_modules/debug/src/node.js
var require_node2 = __commonJS((exports, module) => {
  var useColors = function() {
    return "colors" in exports.inspectOpts ? Boolean(exports.inspectOpts.colors) : tty.isatty(fd);
  };
  var formatArgs = function(args) {
    var name = this.namespace;
    var useColors2 = this.useColors;
    if (useColors2) {
      var c = this.color;
      var prefix = "  \x1B[3" + c + ";1m" + name + " " + "\x1B[0m";
      args[0] = prefix + args[0].split("\n").join("\n" + prefix);
      args.push("\x1B[3" + c + "m+" + exports.humanize(this.diff) + "\x1B[0m");
    } else {
      args[0] = new Date().toUTCString() + " " + name + " " + args[0];
    }
  };
  var log = function() {
    return stream.write(util3.format.apply(util3, arguments) + "\n");
  };
  var save = function(namespaces) {
    if (namespaces == null) {
      delete process.env.DEBUG;
    } else {
      process.env.DEBUG = namespaces;
    }
  };
  var load = function() {
    return process.env.DEBUG;
  };
  var createWritableStdioStream = function(fd2) {
    var stream2;
    var tty_wrap = process.binding("tty_wrap");
    switch (tty_wrap.guessHandleType(fd2)) {
      case "TTY":
        stream2 = new tty.WriteStream(fd2);
        stream2._type = "tty";
        if (stream2._handle && stream2._handle.unref) {
          stream2._handle.unref();
        }
        break;
      case "FILE":
        var fs2 = __require("fs");
        stream2 = new fs2.SyncWriteStream(fd2, { autoClose: false });
        stream2._type = "fs";
        break;
      case "PIPE":
      case "TCP":
        var net2 = __require("net");
        stream2 = new net2.Socket({
          fd: fd2,
          readable: false,
          writable: true
        });
        stream2.readable = false;
        stream2.read = null;
        stream2._type = "pipe";
        if (stream2._handle && stream2._handle.unref) {
          stream2._handle.unref();
        }
        break;
      default:
        throw new Error("Implement me. Unknown stream file type!");
    }
    stream2.fd = fd2;
    stream2._isStdio = true;
    return stream2;
  };
  var init = function(debug) {
    debug.inspectOpts = {};
    var keys = Object.keys(exports.inspectOpts);
    for (var i = 0;i < keys.length; i++) {
      debug.inspectOpts[keys[i]] = exports.inspectOpts[keys[i]];
    }
  };
  var tty = __require("tty");
  var util3 = __require("util");
  exports = module.exports = require_debug2();
  exports.init = init;
  exports.log = log;
  exports.formatArgs = formatArgs;
  exports.save = save;
  exports.load = load;
  exports.useColors = useColors;
  exports.colors = [6, 2, 3, 4, 5, 1];
  exports.inspectOpts = Object.keys(process.env).filter(function(key) {
    return /^debug_/i.test(key);
  }).reduce(function(obj, key) {
    var prop = key.substring(6).toLowerCase().replace(/_([a-z])/g, function(_, k) {
      return k.toUpperCase();
    });
    var val = process.env[key];
    if (/^(yes|on|true|enabled)$/i.test(val))
      val = true;
    else if (/^(no|off|false|disabled)$/i.test(val))
      val = false;
    else if (val === "null")
      val = null;
    else
      val = Number(val);
    obj[prop] = val;
    return obj;
  }, {});
  var fd = parseInt(process.env.DEBUG_FD, 10) || 2;
  if (fd !== 1 && fd !== 2) {
    util3.deprecate(function() {
    }, "except for stderr(2) and stdout(1), any other usage of DEBUG_FD is deprecated. Override debug.log if you want to use a different log function (https://git.io/debug_fd)")();
  }
  var stream = fd === 1 ? process.stdout : fd === 2 ? process.stderr : createWritableStdioStream(fd);
  exports.formatters.o = function(v) {
    this.inspectOpts.colors = this.useColors;
    return util3.inspect(v, this.inspectOpts).split("\n").map(function(str) {
      return str.trim();
    }).join(" ");
  };
  exports.formatters.O = function(v) {
    this.inspectOpts.colors = this.useColors;
    return util3.inspect(v, this.inspectOpts);
  };
  exports.enable(load());
});

// node_modules/bitsyntax/node_modules/debug/src/index.js
var require_src2 = __commonJS((exports, module) => {
  if (typeof process !== "undefined" && process.type === "renderer") {
    module.exports = require_browser2();
  } else {
    module.exports = require_node2();
  }
});

// node_modules/bitsyntax/lib/interp.js
var require_interp = __commonJS((exports, module) => {
  var parse_int = function(bin, off, sizeInBytes, bigendian, signed) {
    switch (sizeInBytes) {
      case 1:
        return signed ? bin.readInt8(off) : bin.readUInt8(off);
      case 2:
        return bigendian ? signed ? bin.readInt16BE(off) : bin.readUInt16BE(off) : signed ? bin.readInt16LE(off) : bin.readUInt16LE(off);
      case 4:
        return bigendian ? signed ? bin.readInt32BE(off) : bin.readUInt32BE(off) : signed ? bin.readInt32LE(off) : bin.readUInt32LE(off);
      case 8:
        return bigendian ? (signed ? ints.readInt64BE : ints.readUInt64BE)(bin, off) : (signed ? ints.readInt64LE : ints.readUInt64LE)(bin, off);
      default:
        throw "Integers must be 8-, 16-, 32- or 64-bit";
    }
  };
  var parse_float = function(bin, off, sizeInBytes, bigendian) {
    switch (sizeInBytes) {
      case 4:
        return bigendian ? bin.readFloatBE(off) : bin.readFloatLE(off);
      case 8:
        return bigendian ? bin.readDoubleBE(off) : bin.readDoubleLE(off);
      default:
        throw "Floats must be 32- or 64-bit";
    }
  };
  var size_of = function(segment, bound) {
    var size2 = segment.size;
    if (typeof size2 === "string") {
      return bound[size2];
    } else {
      return size2;
    }
  };
  var new_scope = function(env) {
    function scope() {
    }
    scope.prototype = env;
    return new scope;
  };
  var bindings = function(scope) {
    var s = {};
    for (var k in scope) {
      if (scope.hasOwnProperty(k)) {
        s[k] = scope[k];
      }
    }
    return s;
  };
  var match = function(pattern, binary, boundvars) {
    var offset = 0, vars = new_scope(boundvars);
    var binsize = binary.length * 8;
    function skip_bits(segment2) {
      debug("skip bits");
      debug(segment2);
      var size2 = size_of(segment2, vars);
      if (size2 === true) {
        if (offset % 8 === 0) {
          offset = binsize;
          return true;
        } else {
          return false;
        }
      }
      var bits = segment2.unit * size2;
      if (offset + bits > binsize) {
        return false;
      } else {
        offset += bits;
      }
    }
    function get_integer(segment2) {
      debug("get_integer");
      debug(segment2);
      var unit = segment2.unit, size2 = size_of(segment2, vars);
      var bitsize = size2 * unit;
      var byteoffset = offset / 8;
      offset += bitsize;
      if (bitsize % 8 > 0 || offset > binsize) {
        return false;
      } else {
        return parse_int(binary, byteoffset, bitsize / 8, segment2.bigendian, segment2.signed);
      }
    }
    function get_float(segment2) {
      debug("get_float");
      debug(segment2);
      var unit = segment2.unit;
      var size2 = size_of(segment2, vars);
      var bitsize = size2 * unit;
      var byteoffset = offset / 8;
      offset += bitsize;
      if (offset > binsize) {
        return false;
      } else {
        return parse_float(binary, byteoffset, bitsize / 8, segment2.bigendian);
      }
    }
    function get_binary(segment2) {
      debug("get_binary");
      debug(segment2);
      var unit = segment2.unit, size2 = size_of(segment2, vars);
      var byteoffset = offset / 8;
      if (size2 === true) {
        offset = binsize;
        return binary.slice(byteoffset);
      } else {
        var bitsize = size2 * unit;
        if (bitsize % 8 > 0 || offset + bitsize > binsize) {
          return false;
        } else {
          offset += bitsize;
          return binary.slice(byteoffset, byteoffset + bitsize / 8);
        }
      }
    }
    function get_string(segment2) {
      debug("get_string");
      debug(segment2);
      var len = segment2.value.length;
      var byteoffset = offset / 8;
      offset += len * 8;
      if (offset > binsize) {
        return false;
      }
      return binary.slice(byteoffset, byteoffset + len).toString("utf8");
    }
    var patternlen = pattern.length;
    for (var i = 0;i < patternlen; i++) {
      var segment = pattern[i];
      var result2 = false;
      if (segment.name === "_") {
        result2 = skip_bits(segment);
      } else {
        switch (segment.type) {
          case "string":
            result2 = get_string(segment);
            break;
          case "integer":
            result2 = get_integer(segment);
            break;
          case "float":
            result2 = get_float(segment);
            break;
          case "binary":
            result2 = get_binary(segment);
            break;
        }
        if (result2 === false) {
          return false;
        } else if (segment.name) {
          vars[segment.name] = result2;
        } else if (segment.value != result2) {
          return false;
        }
      }
    }
    if (offset == binsize) {
      return bindings(vars);
    } else {
      return false;
    }
  };
  var ints = require_buffer_more_ints();
  var debug = require_src2()("bitsyntax-Interpreter");
  exports.match = match;
  exports.parse_int = parse_int;
  exports.parse_float = parse_float;
});

// node_modules/bitsyntax/node_modules/safe-buffer/index.js
var require_safe_buffer2 = __commonJS((exports, module) => {
  var copyProps = function(src, dst) {
    for (var key in src) {
      dst[key] = src[key];
    }
  };
  var SafeBuffer = function(arg, encodingOrOffset, length) {
    return Buffer4(arg, encodingOrOffset, length);
  };
  var buffer2 = __require("buffer");
  var Buffer4 = buffer2.Buffer;
  if (Buffer4.from && Buffer4.alloc && Buffer4.allocUnsafe && Buffer4.allocUnsafeSlow) {
    module.exports = buffer2;
  } else {
    copyProps(buffer2, exports);
    exports.Buffer = SafeBuffer;
  }
  copyProps(Buffer4, SafeBuffer);
  SafeBuffer.from = function(arg, encodingOrOffset, length) {
    if (typeof arg === "number") {
      throw new TypeError("Argument must not be a number");
    }
    return Buffer4(arg, encodingOrOffset, length);
  };
  SafeBuffer.alloc = function(size2, fill, encoding) {
    if (typeof size2 !== "number") {
      throw new TypeError("Argument must be a number");
    }
    var buf = Buffer4(size2);
    if (fill !== undefined) {
      if (typeof encoding === "string") {
        buf.fill(fill, encoding);
      } else {
        buf.fill(fill);
      }
    } else {
      buf.fill(0);
    }
    return buf;
  };
  SafeBuffer.allocUnsafe = function(size2) {
    if (typeof size2 !== "number") {
      throw new TypeError("Argument must be a number");
    }
    return Buffer4(size2);
  };
  SafeBuffer.allocUnsafeSlow = function(size2) {
    if (typeof size2 !== "number") {
      throw new TypeError("Argument must be a number");
    }
    return buffer2.SlowBuffer(size2);
  };
});

// node_modules/bitsyntax/lib/constructor.js
var require_constructor = __commonJS((exports, module) => {
  var write = function(buf, offset, pattern, bindings) {
    for (var i = 0, len = pattern.length;i < len; i++) {
      var segment = pattern[i];
      switch (segment.type) {
        case "string":
          offset += buf.write(segment.value, offset, "utf8");
          break;
        case "binary":
          offset += writeBinary(segment, buf, offset, bindings);
          break;
        case "integer":
          offset += writeInteger(segment, buf, offset, bindings);
          break;
        case "float":
          offset += writeFloat(segment, buf, offset, bindings);
          break;
      }
    }
    return offset;
  };
  var build = function(pattern, bindings) {
    var bufsize = size_of(pattern, bindings);
    var buf = Buffer4.alloc(bufsize);
    write(buf, 0, pattern, bindings);
    return buf;
  };
  var size_of_segment = function(segment, bindings) {
    if (typeof segment.size === "string") {
      return bindings[segment.size] * segment.unit / 8;
    }
    if (segment.type === "string") {
      return Buffer4.byteLength(segment.value, "utf8");
    }
    if (segment.type === "binary" && segment.size === true) {
      var val = bindings[segment.name];
      return val.length;
    }
    return segment.size * segment.unit / 8;
  };
  var size_of = function(segments, bindings) {
    var size2 = 0;
    for (var i = 0, len = segments.length;i < len; i++) {
      size2 += size_of_segment(segments[i], bindings);
    }
    return size2;
  };
  var writeBinary = function(segment, buf, offset, bindings) {
    var bin = bindings[segment.name];
    var size2 = size_of_segment(segment, bindings);
    bin.copy(buf, offset, 0, size2);
    return size2;
  };
  var writeInteger = function(segment, buf, offset, bindings) {
    var value = segment.name ? bindings[segment.name] : segment.value;
    var size2 = size_of_segment(segment, bindings);
    return write_int(buf, value, offset, size2, segment.bigendian);
  };
  var write_int = function(buf, value, offset, size2, bigendian) {
    switch (size2) {
      case 1:
        buf.writeUInt8(value, offset);
        break;
      case 2:
        bigendian ? buf.writeUInt16BE(value, offset) : buf.writeUInt16LE(value, offset);
        break;
      case 4:
        bigendian ? buf.writeUInt32BE(value, offset) : buf.writeUInt32LE(value, offset);
        break;
      case 8:
        bigendian ? ints.writeUInt64BE(buf, value, offset) : ints.writeUInt64LE(buf, value, offset);
        break;
      default:
        throw new Error("integer size * unit must be 8, 16, 32 or 64");
    }
    return size2;
  };
  var writeFloat = function(segment, buf, offset, bindings) {
    var value = segment.name ? bindings[segment.name] : segment.value;
    var size2 = size_of_segment(segment, bindings);
    return write_float(buf, value, offset, size2, segment.bigendian);
  };
  var write_float = function(buf, value, offset, size2, bigendian) {
    if (size2 === 4) {
      bigendian ? buf.writeFloatBE(value, offset) : buf.writeFloatLE(value, offset);
    } else if (size2 === 8) {
      bigendian ? buf.writeDoubleBE(value, offset) : buf.writeDoubleLE(value, offset);
    } else {
      throw new Error("float size * unit must be 32 or 64");
    }
    return size2;
  };
  var ints = require_buffer_more_ints();
  var Buffer4 = require_safe_buffer2().Buffer;
  var parse4 = require_parse2().parse;
  exports.write = write;
  exports.build = build;
  exports.write_int = write_int;
  exports.write_float = write_float;
  exports.builder = function(pstr) {
    pstr = arguments.length > 1 ? [].join.call(arguments, ",") : pstr;
    var pattern = parse4(pstr);
    return function(vars) {
      return build(pattern, vars);
    };
  };
});

// node_modules/bitsyntax/lib/compile.js
var require_compile = __commonJS((exports, module) => {
  var $start = function() {
    lines = [];
  };
  var $line = function() {
    lines.push($.apply(null, arguments));
  };
  var $result = function() {
    return lines.join("\n");
  };
  var bits_expr = function(segment) {
    if (typeof segment.size === "string") {
      return $("%s * %d", var_name(segment.size), segment.unit);
    } else {
      return (segment.size * segment.unit).toString();
    }
  };
  var get_number = function(segment) {
    $line("bits = %s;\n", bits_expr(segment));
    var parser = segment.type === "integer" ? "parse_int" : "parse_float";
    var { bigendian: be, signed: sg } = segment;
    $line("byteoffset = offset / 8; offset += bits");
    $line("if (offset > binsize) { return false; }");
    $line("else { result = %s(bin, byteoffset, bits / 8, %s, %s); }", parser, be, sg);
  };
  var get_binary = function(segment) {
    $line("byteoffset = offset / 8;");
    if (segment.size === true) {
      $line("offset = binsize;");
      $line("result = bin.slice(byteoffset);");
    } else {
      $line("bits = %s;", bits_expr(segment));
      $line("offset += bits;");
      $line("if (offset > binsize) { return false; }");
      $line("else { result = bin.slice(byteoffset,", "byteoffset + bits / 8); }");
    }
  };
  var get_string = function(segment) {
    $line("byteoffset = offset / 8;");
    var strlen = segment.value.length;
    var strlenbits = strlen * 8;
    $line("offset += %d;", strlenbits);
    $line("if (offset > binsize) { return false; }");
    $line("else { result = bin.toString(byteoffset,", $("byteoffset + %d); }", strlen));
  };
  var skip_bits = function(segment) {
    if (typeof segment.size === "string") {
      $line("var skipbits = %s * %d;", var_name(segment.size), segment.unit);
      $line("if (offset + skipbits > binsize) { return false; }");
      $line("else { offset += skipbits; }");
    } else if (segment.size === true) {
      $line("if (offset % 8 === 0) { offset = binsize; }");
      $line("else { return false; }");
    } else {
      var bits = segment.unit * segment.size;
      $line("if (offset + %d > binsize) { return false; }", bits);
      $line("else { offset += %d; }", bits);
    }
  };
  var match_seg = function(segment) {
    if (segment.name === "_") {
      skip_bits(segment);
    } else {
      var assign_result;
      switch (segment.type) {
        case "integer":
        case "float":
          get_number(segment);
          break;
        case "binary":
          get_binary(segment);
          break;
        case "string":
          get_string(segment);
          break;
      }
      $line("if (result === false) return false;");
      if (segment.name) {
        $line("else if (%s !== undefined) {", var_name(segment.name));
        $line("if (%s != result) return false;", var_name(segment.name));
        $line("}");
        $line("else %s = result;", var_name(segment.name));
      } else {
        var repr = JSON.stringify(segment.value);
        $line("else if (result != %s) return false;", repr);
      }
    }
  };
  var var_name = function(name) {
    return "var_" + name;
  };
  var variables = function(segments) {
    var names = {};
    for (var i = 0;i < segments.length; i++) {
      var name = segments[i].name;
      if (name && name !== "_") {
        names[name] = true;
      }
      name = segments[i].size;
      if (typeof name === "string") {
        names[name] = true;
      }
    }
    return Object.keys(names);
  };
  var compile_pattern = function(segments) {
    $start();
    $line("return function(binary, env) {");
    $line("'use strict';");
    $line("var bin = binary, env = env || {};");
    $line("var offset = 0, binsize = bin.length * 8;");
    $line("var bits, result, byteoffset;");
    var varnames = variables(segments);
    for (var v = 0;v < varnames.length; v++) {
      var name = varnames[v];
      $line("var %s = env['%s'];", var_name(name), name);
    }
    var len = segments.length;
    for (var i = 0;i < len; i++) {
      var segment = segments[i];
      $line("// " + JSON.stringify(segment));
      match_seg(segment);
    }
    $line("if (offset == binsize) {");
    $line("return {");
    for (var v = 0;v < varnames.length; v++) {
      var name = varnames[v];
      $line("%s: %s,", name, var_name(name));
    }
    $line("};");
    $line("}");
    $line("else return false;");
    $line("}");
    var fn = new Function("parse_int", "parse_float", $result());
    return fn(parse_int, parse_float);
  };
  var write_seg = function(segment) {
    switch (segment.type) {
      case "string":
        $line("offset += buf.write(%s, offset, 'utf8');", JSON.stringify(segment.value));
        break;
      case "binary":
        $line("val = bindings['%s'];", segment.name);
        if (segment.size === true) {
          $line("size = val.length;");
        } else if (typeof segment.size === "string") {
          $line("size = (bindings['%s'] * %d) / 8;", segment.size, segment.unit);
        } else {
          $line("size = %d;", segment.size * segment.unit / 8);
        }
        $line("val.copy(buf, offset, 0, size);");
        $line("offset += size;");
        break;
      case "integer":
      case "float":
        write_number(segment);
        break;
    }
  };
  var write_number = function(segment) {
    if (segment.name) {
      $line("val = bindings['%s'];", segment.name);
    } else {
      $line("val = %d", segment.value);
    }
    var writer = segment.type === "integer" ? "write_int" : "write_float";
    if (typeof segment.size === "string") {
      $line("size = (bindings['%s'] * %d) / 8;", segment.size, segment.unit);
    } else {
      $line("size = %d;", segment.size * segment.unit / 8);
    }
    $line("%s(buf, val, offset, size, %s);", writer, segment.bigendian);
    $line("offset += size;");
  };
  var size_of = function(segments) {
    var variable = [];
    var fixed = 0;
    for (var i = 0;i < segments.length; i++) {
      var segment = segments[i];
      if (typeof segment.size === "string" || segment.size === true) {
        variable.push(segment);
      } else if (segment.type === "string") {
        fixed += Buffer4.byteLength(segment.value);
      } else {
        fixed += segment.size * segment.unit / 8;
      }
    }
    $line("var buffersize = %d;", fixed);
    if (variable.length > 0) {
      for (var j = 0;j < variable.length; j++) {
        var segment = variable[j];
        if (segment.size === true) {
          $line("buffersize += bindings['%s'].length;", segment.name);
        } else {
          $line("buffersize += (bindings['%s'] * %d) / 8;", segment.size, segment.unit);
        }
      }
    }
  };
  var emit_write = function(segments) {
    $line("var val, size;");
    var len = segments.length;
    for (var i = 0;i < len; i++) {
      var segment = segments[i];
      $line("// %s", JSON.stringify(segment));
      write_seg(segment);
    }
  };
  var compile_ctor = function(segments) {
    $start();
    $line("return function(bindings) {");
    $line("'use strict';");
    size_of(segments);
    $line("var buf = Buffer.alloc(buffersize);");
    $line("var offset = 0;");
    emit_write(segments);
    $line("return buf;");
    $line("}");
    return new Function("write_int", "write_float", "Buffer", $result())(write_int, write_float, Buffer4);
  };
  require_buffer_more_ints();
  var $ = __require("util").format;
  var parse4 = require_parse2().parse;
  var interp = require_interp();
  var parse_int = interp.parse_int;
  var parse_float = interp.parse_float;
  var construct = require_constructor();
  var write_int = construct.write_int;
  var write_float = construct.write_float;
  var Buffer4 = require_safe_buffer2().Buffer;
  var lines = [];
  exports.compile_pattern = compile_pattern;
  exports.compile = function() {
    var str = [].join.call(arguments, ",");
    var p = parse4(str);
    return compile_pattern(p);
  };
  exports.compile_builder = function() {
    var str = [].join.call(arguments, ",");
    var p = parse4(str);
    return compile_ctor(p);
  };
});

// node_modules/bitsyntax/index.js
var require_bitsyntax = __commonJS((exports, module) => {
  exports.parse = require_parse2().parse;
  exports.match = require_interp().match;
  exports.build = require_constructor().build;
  exports.write = require_constructor().write;
  exports.matcher = exports.compile = require_compile().compile;
  exports.builder = require_compile().compile_builder;
});

// node_modules/amqplib/lib/frame.js
var require_frame = __commonJS((exports, module) => {
  var parseFrame = function(bin, max) {
    var fh = frameHeaderPattern(bin);
    if (fh) {
      var { size: size2, rest } = fh;
      if (size2 > max) {
        throw new Error("Frame size exceeds frame max");
      } else if (rest.length > size2) {
        if (rest[size2] !== FRAME_END)
          throw new Error("Invalid frame");
        return {
          type: fh.type,
          channel: fh.channel,
          size: size2,
          payload: rest.slice(0, size2),
          rest: rest.slice(size2 + 1)
        };
      }
    }
    return false;
  };
  var defs = require_defs();
  var constants2 = defs.constants;
  var decode2 = defs.decode;
  var Buffer4 = require_safe_buffer().Buffer;
  var Bits = require_bitsyntax();
  exports.PROTOCOL_HEADER = "AMQP" + String.fromCharCode(0, 0, 9, 1);
  var FRAME_METHOD = constants2.FRAME_METHOD;
  var FRAME_HEARTBEAT = constants2.FRAME_HEARTBEAT;
  var FRAME_HEADER = constants2.FRAME_HEADER;
  var FRAME_BODY = constants2.FRAME_BODY;
  var FRAME_END = constants2.FRAME_END;
  var bodyCons = Bits.builder(FRAME_BODY, "channel:16, size:32, payload:size/binary", FRAME_END);
  exports.makeBodyFrame = function(channel, payload) {
    return bodyCons({ channel, size: payload.length, payload });
  };
  var frameHeaderPattern = Bits.matcher("type:8", "channel:16", "size:32", "rest/binary");
  exports.parseFrame = parseFrame;
  var headerPattern = Bits.matcher("class:16", "_weight:16", "size:64", "flagsAndfields/binary");
  var methodPattern = Bits.matcher("id:32, args/binary");
  var HEARTBEAT = { channel: 0 };
  exports.decodeFrame = function(frame) {
    var payload = frame.payload;
    switch (frame.type) {
      case FRAME_METHOD:
        var idAndArgs = methodPattern(payload);
        var id = idAndArgs.id;
        var fields = decode2(id, idAndArgs.args);
        return { id, channel: frame.channel, fields };
      case FRAME_HEADER:
        var parts = headerPattern(payload);
        var id = parts["class"];
        var fields = decode2(id, parts.flagsAndfields);
        return {
          id,
          channel: frame.channel,
          size: parts.size,
          fields
        };
      case FRAME_BODY:
        return { channel: frame.channel, content: frame.payload };
      case FRAME_HEARTBEAT:
        return HEARTBEAT;
      default:
        throw new Error("Unknown frame type " + frame.type);
    }
  };
  exports.HEARTBEAT_BUF = Buffer4.from([
    constants2.FRAME_HEARTBEAT,
    0,
    0,
    0,
    0,
    0,
    0,
    constants2.FRAME_END
  ]);
  exports.HEARTBEAT = HEARTBEAT;
});

// node_modules/amqplib/lib/mux.js
var require_mux = __commonJS((exports, module) => {
  var Mux = function(downstream) {
    this.newStreams = [];
    this.oldStreams = [];
    this.blocked = false;
    this.scheduledRead = false;
    this.out = downstream;
    var self2 = this;
    downstream.on("drain", function() {
      self2.blocked = false;
      self2._readIncoming();
    });
  };
  var inherits = __require("util").inherits;
  var assert = __require("assert");
  var schedule = typeof setImmediate === "function" ? setImmediate : process.nextTick;
  Mux.prototype._readIncoming = function() {
    if (this.blocked)
      return;
    var self2 = this;
    var accepting = true;
    var out = this.out;
    function roundrobin(streams) {
      var s;
      while (accepting && (s = streams.shift())) {
        var chunk = s.read();
        if (chunk !== null) {
          accepting = out.write(chunk);
          streams.push(s);
        }
      }
    }
    roundrobin(this.newStreams);
    if (accepting) {
      assert.equal(0, this.newStreams.length);
      roundrobin(this.oldStreams);
    } else {
      assert(this.newStreams.length > 0, "Expect some new streams to remain");
      this.oldStreams = this.oldStreams.concat(this.newStreams);
      this.newStreams = [];
    }
    this.blocked = !accepting;
  };
  Mux.prototype._scheduleRead = function() {
    var self2 = this;
    if (!self2.scheduledRead) {
      schedule(function() {
        self2.scheduledRead = false;
        self2._readIncoming();
      });
      self2.scheduledRead = true;
    }
  };
  Mux.prototype.pipeFrom = function(readable) {
    var self2 = this;
    function enqueue() {
      self2.newStreams.push(readable);
      self2._scheduleRead();
    }
    function cleanup() {
      readable.removeListener("readable", enqueue);
      readable.removeListener("error", cleanup);
      readable.removeListener("end", cleanup);
      readable.removeListener("unpipeFrom", cleanupIfMe);
    }
    function cleanupIfMe(dest) {
      if (dest === self2)
        cleanup();
    }
    readable.on("unpipeFrom", cleanupIfMe);
    readable.on("end", cleanup);
    readable.on("error", cleanup);
    readable.on("readable", enqueue);
  };
  Mux.prototype.unpipeFrom = function(readable) {
    readable.emit("unpipeFrom", this);
  };
  exports.Mux = Mux;
});

// node_modules/core-util-is/lib/util.js
var require_util2 = __commonJS((exports) => {
  var isArray = function(arg) {
    if (Array.isArray) {
      return Array.isArray(arg);
    }
    return objectToString(arg) === "[object Array]";
  };
  var isBoolean = function(arg) {
    return typeof arg === "boolean";
  };
  var isNull = function(arg) {
    return arg === null;
  };
  var isNullOrUndefined = function(arg) {
    return arg == null;
  };
  var isNumber = function(arg) {
    return typeof arg === "number";
  };
  var isString = function(arg) {
    return typeof arg === "string";
  };
  var isSymbol = function(arg) {
    return typeof arg === "symbol";
  };
  var isUndefined = function(arg) {
    return arg === undefined;
  };
  var isRegExp = function(re) {
    return objectToString(re) === "[object RegExp]";
  };
  var isObject2 = function(arg) {
    return typeof arg === "object" && arg !== null;
  };
  var isDate = function(d) {
    return objectToString(d) === "[object Date]";
  };
  var isError = function(e) {
    return objectToString(e) === "[object Error]" || e instanceof Error;
  };
  var isFunction = function(arg) {
    return typeof arg === "function";
  };
  var isPrimitive = function(arg) {
    return arg === null || typeof arg === "boolean" || typeof arg === "number" || typeof arg === "string" || typeof arg === "symbol" || typeof arg === "undefined";
  };
  var objectToString = function(o) {
    return Object.prototype.toString.call(o);
  };
  exports.isArray = isArray;
  exports.isBoolean = isBoolean;
  exports.isNull = isNull;
  exports.isNullOrUndefined = isNullOrUndefined;
  exports.isNumber = isNumber;
  exports.isString = isString;
  exports.isSymbol = isSymbol;
  exports.isUndefined = isUndefined;
  exports.isRegExp = isRegExp;
  exports.isObject = isObject2;
  exports.isDate = isDate;
  exports.isError = isError;
  exports.isFunction = isFunction;
  exports.isPrimitive = isPrimitive;
  exports.isBuffer = __require("buffer").Buffer.isBuffer;
});

// node_modules/inherits/inherits_browser.js
var require_inherits_browser = __commonJS((exports, module) => {
  if (typeof Object.create === "function") {
    module.exports = function inherits(ctor, superCtor) {
      if (superCtor) {
        ctor.super_ = superCtor;
        ctor.prototype = Object.create(superCtor.prototype, {
          constructor: {
            value: ctor,
            enumerable: false,
            writable: true,
            configurable: true
          }
        });
      }
    };
  } else {
    module.exports = function inherits(ctor, superCtor) {
      if (superCtor) {
        ctor.super_ = superCtor;
        var TempCtor = function() {
        };
        TempCtor.prototype = superCtor.prototype;
        ctor.prototype = new TempCtor;
        ctor.prototype.constructor = ctor;
      }
    };
  }
});

// node_modules/inherits/inherits.js
var require_inherits = __commonJS((exports, module) => {
  try {
    util3 = __require("util");
    if (typeof util3.inherits !== "function")
      throw "";
    module.exports = util3.inherits;
  } catch (e) {
    module.exports = require_inherits_browser();
  }
  var util3;
});

// node_modules/isarray/index.js
var require_isarray = __commonJS((exports, module) => {
  module.exports = Array.isArray || function(arr) {
    return Object.prototype.toString.call(arr) == "[object Array]";
  };
});

// node_modules/readable-stream/lib/_stream_readable.js
var require__stream_readable = __commonJS((exports, module) => {
  var ReadableState = function(options, stream) {
    var Duplex = require__stream_duplex();
    options = options || {};
    var hwm = options.highWaterMark;
    var defaultHwm = options.objectMode ? 16 : 16 * 1024;
    this.highWaterMark = hwm || hwm === 0 ? hwm : defaultHwm;
    this.highWaterMark = ~~this.highWaterMark;
    this.buffer = [];
    this.length = 0;
    this.pipes = null;
    this.pipesCount = 0;
    this.flowing = null;
    this.ended = false;
    this.endEmitted = false;
    this.reading = false;
    this.sync = true;
    this.needReadable = false;
    this.emittedReadable = false;
    this.readableListening = false;
    this.objectMode = !!options.objectMode;
    if (stream instanceof Duplex)
      this.objectMode = this.objectMode || !!options.readableObjectMode;
    this.defaultEncoding = options.defaultEncoding || "utf8";
    this.ranOut = false;
    this.awaitDrain = 0;
    this.readingMore = false;
    this.decoder = null;
    this.encoding = null;
    if (options.encoding) {
      if (!StringDecoder)
        StringDecoder = __require("string_decoder/").StringDecoder;
      this.decoder = new StringDecoder(options.encoding);
      this.encoding = options.encoding;
    }
  };
  var Readable = function(options) {
    var Duplex = require__stream_duplex();
    if (!(this instanceof Readable))
      return new Readable(options);
    this._readableState = new ReadableState(options, this);
    this.readable = true;
    Stream3.call(this);
  };
  var readableAddChunk = function(stream, state, chunk, encoding, addToFront) {
    var er = chunkInvalid(state, chunk);
    if (er) {
      stream.emit("error", er);
    } else if (util3.isNullOrUndefined(chunk)) {
      state.reading = false;
      if (!state.ended)
        onEofChunk(stream, state);
    } else if (state.objectMode || chunk && chunk.length > 0) {
      if (state.ended && !addToFront) {
        var e = new Error("stream.push() after EOF");
        stream.emit("error", e);
      } else if (state.endEmitted && addToFront) {
        var e = new Error("stream.unshift() after end event");
        stream.emit("error", e);
      } else {
        if (state.decoder && !addToFront && !encoding)
          chunk = state.decoder.write(chunk);
        if (!addToFront)
          state.reading = false;
        if (state.flowing && state.length === 0 && !state.sync) {
          stream.emit("data", chunk);
          stream.read(0);
        } else {
          state.length += state.objectMode ? 1 : chunk.length;
          if (addToFront)
            state.buffer.unshift(chunk);
          else
            state.buffer.push(chunk);
          if (state.needReadable)
            emitReadable(stream);
        }
        maybeReadMore(stream, state);
      }
    } else if (!addToFront) {
      state.reading = false;
    }
    return needMoreData(state);
  };
  var needMoreData = function(state) {
    return !state.ended && (state.needReadable || state.length < state.highWaterMark || state.length === 0);
  };
  var roundUpToNextPowerOf2 = function(n) {
    if (n >= MAX_HWM) {
      n = MAX_HWM;
    } else {
      n--;
      for (var p = 1;p < 32; p <<= 1)
        n |= n >> p;
      n++;
    }
    return n;
  };
  var howMuchToRead = function(n, state) {
    if (state.length === 0 && state.ended)
      return 0;
    if (state.objectMode)
      return n === 0 ? 0 : 1;
    if (isNaN(n) || util3.isNull(n)) {
      if (state.flowing && state.buffer.length)
        return state.buffer[0].length;
      else
        return state.length;
    }
    if (n <= 0)
      return 0;
    if (n > state.highWaterMark)
      state.highWaterMark = roundUpToNextPowerOf2(n);
    if (n > state.length) {
      if (!state.ended) {
        state.needReadable = true;
        return 0;
      } else
        return state.length;
    }
    return n;
  };
  var chunkInvalid = function(state, chunk) {
    var er = null;
    if (!util3.isBuffer(chunk) && !util3.isString(chunk) && !util3.isNullOrUndefined(chunk) && !state.objectMode) {
      er = new TypeError("Invalid non-string/buffer chunk");
    }
    return er;
  };
  var onEofChunk = function(stream, state) {
    if (state.decoder && !state.ended) {
      var chunk = state.decoder.end();
      if (chunk && chunk.length) {
        state.buffer.push(chunk);
        state.length += state.objectMode ? 1 : chunk.length;
      }
    }
    state.ended = true;
    emitReadable(stream);
  };
  var emitReadable = function(stream) {
    var state = stream._readableState;
    state.needReadable = false;
    if (!state.emittedReadable) {
      debug("emitReadable", state.flowing);
      state.emittedReadable = true;
      if (state.sync)
        process.nextTick(function() {
          emitReadable_(stream);
        });
      else
        emitReadable_(stream);
    }
  };
  var emitReadable_ = function(stream) {
    debug("emit readable");
    stream.emit("readable");
    flow(stream);
  };
  var maybeReadMore = function(stream, state) {
    if (!state.readingMore) {
      state.readingMore = true;
      process.nextTick(function() {
        maybeReadMore_(stream, state);
      });
    }
  };
  var maybeReadMore_ = function(stream, state) {
    var len = state.length;
    while (!state.reading && !state.flowing && !state.ended && state.length < state.highWaterMark) {
      debug("maybeReadMore read 0");
      stream.read(0);
      if (len === state.length)
        break;
      else
        len = state.length;
    }
    state.readingMore = false;
  };
  var pipeOnDrain = function(src) {
    return function() {
      var state = src._readableState;
      debug("pipeOnDrain", state.awaitDrain);
      if (state.awaitDrain)
        state.awaitDrain--;
      if (state.awaitDrain === 0 && EE.listenerCount(src, "data")) {
        state.flowing = true;
        flow(src);
      }
    };
  };
  var resume = function(stream, state) {
    if (!state.resumeScheduled) {
      state.resumeScheduled = true;
      process.nextTick(function() {
        resume_(stream, state);
      });
    }
  };
  var resume_ = function(stream, state) {
    state.resumeScheduled = false;
    stream.emit("resume");
    flow(stream);
    if (state.flowing && !state.reading)
      stream.read(0);
  };
  var flow = function(stream) {
    var state = stream._readableState;
    debug("flow", state.flowing);
    if (state.flowing) {
      do {
        var chunk = stream.read();
      } while (chunk !== null && state.flowing);
    }
  };
  var fromList = function(n, state) {
    var list = state.buffer;
    var length = state.length;
    var stringMode = !!state.decoder;
    var objectMode = !!state.objectMode;
    var ret;
    if (list.length === 0)
      return null;
    if (length === 0)
      ret = null;
    else if (objectMode)
      ret = list.shift();
    else if (!n || n >= length) {
      if (stringMode)
        ret = list.join("");
      else
        ret = Buffer4.concat(list, length);
      list.length = 0;
    } else {
      if (n < list[0].length) {
        var buf = list[0];
        ret = buf.slice(0, n);
        list[0] = buf.slice(n);
      } else if (n === list[0].length) {
        ret = list.shift();
      } else {
        if (stringMode)
          ret = "";
        else
          ret = new Buffer4(n);
        var c = 0;
        for (var i = 0, l = list.length;i < l && c < n; i++) {
          var buf = list[0];
          var cpy = Math.min(n - c, buf.length);
          if (stringMode)
            ret += buf.slice(0, cpy);
          else
            buf.copy(ret, c, 0, cpy);
          if (cpy < buf.length)
            list[0] = buf.slice(cpy);
          else
            list.shift();
          c += cpy;
        }
      }
    }
    return ret;
  };
  var endReadable = function(stream) {
    var state = stream._readableState;
    if (state.length > 0)
      throw new Error("endReadable called on non-empty stream");
    if (!state.endEmitted) {
      state.ended = true;
      process.nextTick(function() {
        if (!state.endEmitted && state.length === 0) {
          state.endEmitted = true;
          stream.readable = false;
          stream.emit("end");
        }
      });
    }
  };
  var forEach = function(xs, f) {
    for (var i = 0, l = xs.length;i < l; i++) {
      f(xs[i], i);
    }
  };
  var indexOf = function(xs, x) {
    for (var i = 0, l = xs.length;i < l; i++) {
      if (xs[i] === x)
        return i;
    }
    return -1;
  };
  module.exports = Readable;
  var isArray = require_isarray();
  var Buffer4 = __require("buffer").Buffer;
  Readable.ReadableState = ReadableState;
  var EE = __require("events").EventEmitter;
  if (!EE.listenerCount)
    EE.listenerCount = function(emitter, type) {
      return emitter.listeners(type).length;
    };
  var Stream3 = __require("stream");
  var util3 = require_util2();
  util3.inherits = require_inherits();
  var StringDecoder;
  var debug = __require("util");
  if (debug && debug.debuglog) {
    debug = debug.debuglog("stream");
  } else {
    debug = function() {
    };
  }
  util3.inherits(Readable, Stream3);
  Readable.prototype.push = function(chunk, encoding) {
    var state = this._readableState;
    if (util3.isString(chunk) && !state.objectMode) {
      encoding = encoding || state.defaultEncoding;
      if (encoding !== state.encoding) {
        chunk = new Buffer4(chunk, encoding);
        encoding = "";
      }
    }
    return readableAddChunk(this, state, chunk, encoding, false);
  };
  Readable.prototype.unshift = function(chunk) {
    var state = this._readableState;
    return readableAddChunk(this, state, chunk, "", true);
  };
  Readable.prototype.setEncoding = function(enc) {
    if (!StringDecoder)
      StringDecoder = __require("string_decoder/").StringDecoder;
    this._readableState.decoder = new StringDecoder(enc);
    this._readableState.encoding = enc;
    return this;
  };
  var MAX_HWM = 8388608;
  Readable.prototype.read = function(n) {
    debug("read", n);
    var state = this._readableState;
    var nOrig = n;
    if (!util3.isNumber(n) || n > 0)
      state.emittedReadable = false;
    if (n === 0 && state.needReadable && (state.length >= state.highWaterMark || state.ended)) {
      debug("read: emitReadable", state.length, state.ended);
      if (state.length === 0 && state.ended)
        endReadable(this);
      else
        emitReadable(this);
      return null;
    }
    n = howMuchToRead(n, state);
    if (n === 0 && state.ended) {
      if (state.length === 0)
        endReadable(this);
      return null;
    }
    var doRead = state.needReadable;
    debug("need readable", doRead);
    if (state.length === 0 || state.length - n < state.highWaterMark) {
      doRead = true;
      debug("length less than watermark", doRead);
    }
    if (state.ended || state.reading) {
      doRead = false;
      debug("reading or ended", doRead);
    }
    if (doRead) {
      debug("do read");
      state.reading = true;
      state.sync = true;
      if (state.length === 0)
        state.needReadable = true;
      this._read(state.highWaterMark);
      state.sync = false;
    }
    if (doRead && !state.reading)
      n = howMuchToRead(nOrig, state);
    var ret;
    if (n > 0)
      ret = fromList(n, state);
    else
      ret = null;
    if (util3.isNull(ret)) {
      state.needReadable = true;
      n = 0;
    }
    state.length -= n;
    if (state.length === 0 && !state.ended)
      state.needReadable = true;
    if (nOrig !== n && state.ended && state.length === 0)
      endReadable(this);
    if (!util3.isNull(ret))
      this.emit("data", ret);
    return ret;
  };
  Readable.prototype._read = function(n) {
    this.emit("error", new Error("not implemented"));
  };
  Readable.prototype.pipe = function(dest, pipeOpts) {
    var src = this;
    var state = this._readableState;
    switch (state.pipesCount) {
      case 0:
        state.pipes = dest;
        break;
      case 1:
        state.pipes = [state.pipes, dest];
        break;
      default:
        state.pipes.push(dest);
        break;
    }
    state.pipesCount += 1;
    debug("pipe count=%d opts=%j", state.pipesCount, pipeOpts);
    var doEnd = (!pipeOpts || pipeOpts.end !== false) && dest !== process.stdout && dest !== process.stderr;
    var endFn = doEnd ? onend : cleanup;
    if (state.endEmitted)
      process.nextTick(endFn);
    else
      src.once("end", endFn);
    dest.on("unpipe", onunpipe);
    function onunpipe(readable) {
      debug("onunpipe");
      if (readable === src) {
        cleanup();
      }
    }
    function onend() {
      debug("onend");
      dest.end();
    }
    var ondrain = pipeOnDrain(src);
    dest.on("drain", ondrain);
    function cleanup() {
      debug("cleanup");
      dest.removeListener("close", onclose);
      dest.removeListener("finish", onfinish);
      dest.removeListener("drain", ondrain);
      dest.removeListener("error", onerror);
      dest.removeListener("unpipe", onunpipe);
      src.removeListener("end", onend);
      src.removeListener("end", cleanup);
      src.removeListener("data", ondata);
      if (state.awaitDrain && (!dest._writableState || dest._writableState.needDrain))
        ondrain();
    }
    src.on("data", ondata);
    function ondata(chunk) {
      debug("ondata");
      var ret = dest.write(chunk);
      if (ret === false) {
        debug("false write response, pause", src._readableState.awaitDrain);
        src._readableState.awaitDrain++;
        src.pause();
      }
    }
    function onerror(er) {
      debug("onerror", er);
      unpipe();
      dest.removeListener("error", onerror);
      if (EE.listenerCount(dest, "error") === 0)
        dest.emit("error", er);
    }
    if (!dest._events || !dest._events.error)
      dest.on("error", onerror);
    else if (isArray(dest._events.error))
      dest._events.error.unshift(onerror);
    else
      dest._events.error = [onerror, dest._events.error];
    function onclose() {
      dest.removeListener("finish", onfinish);
      unpipe();
    }
    dest.once("close", onclose);
    function onfinish() {
      debug("onfinish");
      dest.removeListener("close", onclose);
      unpipe();
    }
    dest.once("finish", onfinish);
    function unpipe() {
      debug("unpipe");
      src.unpipe(dest);
    }
    dest.emit("pipe", src);
    if (!state.flowing) {
      debug("pipe resume");
      src.resume();
    }
    return dest;
  };
  Readable.prototype.unpipe = function(dest) {
    var state = this._readableState;
    if (state.pipesCount === 0)
      return this;
    if (state.pipesCount === 1) {
      if (dest && dest !== state.pipes)
        return this;
      if (!dest)
        dest = state.pipes;
      state.pipes = null;
      state.pipesCount = 0;
      state.flowing = false;
      if (dest)
        dest.emit("unpipe", this);
      return this;
    }
    if (!dest) {
      var dests = state.pipes;
      var len = state.pipesCount;
      state.pipes = null;
      state.pipesCount = 0;
      state.flowing = false;
      for (var i = 0;i < len; i++)
        dests[i].emit("unpipe", this);
      return this;
    }
    var i = indexOf(state.pipes, dest);
    if (i === -1)
      return this;
    state.pipes.splice(i, 1);
    state.pipesCount -= 1;
    if (state.pipesCount === 1)
      state.pipes = state.pipes[0];
    dest.emit("unpipe", this);
    return this;
  };
  Readable.prototype.on = function(ev, fn) {
    var res = Stream3.prototype.on.call(this, ev, fn);
    if (ev === "data" && this._readableState.flowing !== false) {
      this.resume();
    }
    if (ev === "readable" && this.readable) {
      var state = this._readableState;
      if (!state.readableListening) {
        state.readableListening = true;
        state.emittedReadable = false;
        state.needReadable = true;
        if (!state.reading) {
          var self2 = this;
          process.nextTick(function() {
            debug("readable nexttick read 0");
            self2.read(0);
          });
        } else if (state.length) {
          emitReadable(this, state);
        }
      }
    }
    return res;
  };
  Readable.prototype.addListener = Readable.prototype.on;
  Readable.prototype.resume = function() {
    var state = this._readableState;
    if (!state.flowing) {
      debug("resume");
      state.flowing = true;
      if (!state.reading) {
        debug("resume read 0");
        this.read(0);
      }
      resume(this, state);
    }
    return this;
  };
  Readable.prototype.pause = function() {
    debug("call pause flowing=%j", this._readableState.flowing);
    if (this._readableState.flowing !== false) {
      debug("pause");
      this._readableState.flowing = false;
      this.emit("pause");
    }
    return this;
  };
  Readable.prototype.wrap = function(stream) {
    var state = this._readableState;
    var paused = false;
    var self2 = this;
    stream.on("end", function() {
      debug("wrapped end");
      if (state.decoder && !state.ended) {
        var chunk = state.decoder.end();
        if (chunk && chunk.length)
          self2.push(chunk);
      }
      self2.push(null);
    });
    stream.on("data", function(chunk) {
      debug("wrapped data");
      if (state.decoder)
        chunk = state.decoder.write(chunk);
      if (!chunk || !state.objectMode && !chunk.length)
        return;
      var ret = self2.push(chunk);
      if (!ret) {
        paused = true;
        stream.pause();
      }
    });
    for (var i in stream) {
      if (util3.isFunction(stream[i]) && util3.isUndefined(this[i])) {
        this[i] = function(method) {
          return function() {
            return stream[method].apply(stream, arguments);
          };
        }(i);
      }
    }
    var events = ["error", "close", "destroy", "pause", "resume"];
    forEach(events, function(ev) {
      stream.on(ev, self2.emit.bind(self2, ev));
    });
    self2._read = function(n) {
      debug("wrapped _read", n);
      if (paused) {
        paused = false;
        stream.resume();
      }
    };
    return self2;
  };
  Readable._fromList = fromList;
});

// node_modules/readable-stream/lib/_stream_writable.js
var require__stream_writable = __commonJS((exports, module) => {
  var WriteReq = function(chunk, encoding, cb) {
    this.chunk = chunk;
    this.encoding = encoding;
    this.callback = cb;
  };
  var WritableState = function(options, stream) {
    var Duplex = require__stream_duplex();
    options = options || {};
    var hwm = options.highWaterMark;
    var defaultHwm = options.objectMode ? 16 : 16 * 1024;
    this.highWaterMark = hwm || hwm === 0 ? hwm : defaultHwm;
    this.objectMode = !!options.objectMode;
    if (stream instanceof Duplex)
      this.objectMode = this.objectMode || !!options.writableObjectMode;
    this.highWaterMark = ~~this.highWaterMark;
    this.needDrain = false;
    this.ending = false;
    this.ended = false;
    this.finished = false;
    var noDecode = options.decodeStrings === false;
    this.decodeStrings = !noDecode;
    this.defaultEncoding = options.defaultEncoding || "utf8";
    this.length = 0;
    this.writing = false;
    this.corked = 0;
    this.sync = true;
    this.bufferProcessing = false;
    this.onwrite = function(er) {
      onwrite(stream, er);
    };
    this.writecb = null;
    this.writelen = 0;
    this.buffer = [];
    this.pendingcb = 0;
    this.prefinished = false;
    this.errorEmitted = false;
  };
  var Writable = function(options) {
    var Duplex = require__stream_duplex();
    if (!(this instanceof Writable) && !(this instanceof Duplex))
      return new Writable(options);
    this._writableState = new WritableState(options, this);
    this.writable = true;
    Stream3.call(this);
  };
  var writeAfterEnd = function(stream, state, cb) {
    var er = new Error("write after end");
    stream.emit("error", er);
    process.nextTick(function() {
      cb(er);
    });
  };
  var validChunk = function(stream, state, chunk, cb) {
    var valid = true;
    if (!util3.isBuffer(chunk) && !util3.isString(chunk) && !util3.isNullOrUndefined(chunk) && !state.objectMode) {
      var er = new TypeError("Invalid non-string/buffer chunk");
      stream.emit("error", er);
      process.nextTick(function() {
        cb(er);
      });
      valid = false;
    }
    return valid;
  };
  var decodeChunk = function(state, chunk, encoding) {
    if (!state.objectMode && state.decodeStrings !== false && util3.isString(chunk)) {
      chunk = new Buffer4(chunk, encoding);
    }
    return chunk;
  };
  var writeOrBuffer = function(stream, state, chunk, encoding, cb) {
    chunk = decodeChunk(state, chunk, encoding);
    if (util3.isBuffer(chunk))
      encoding = "buffer";
    var len = state.objectMode ? 1 : chunk.length;
    state.length += len;
    var ret = state.length < state.highWaterMark;
    if (!ret)
      state.needDrain = true;
    if (state.writing || state.corked)
      state.buffer.push(new WriteReq(chunk, encoding, cb));
    else
      doWrite(stream, state, false, len, chunk, encoding, cb);
    return ret;
  };
  var doWrite = function(stream, state, writev, len, chunk, encoding, cb) {
    state.writelen = len;
    state.writecb = cb;
    state.writing = true;
    state.sync = true;
    if (writev)
      stream._writev(chunk, state.onwrite);
    else
      stream._write(chunk, encoding, state.onwrite);
    state.sync = false;
  };
  var onwriteError = function(stream, state, sync, er, cb) {
    if (sync)
      process.nextTick(function() {
        state.pendingcb--;
        cb(er);
      });
    else {
      state.pendingcb--;
      cb(er);
    }
    stream._writableState.errorEmitted = true;
    stream.emit("error", er);
  };
  var onwriteStateUpdate = function(state) {
    state.writing = false;
    state.writecb = null;
    state.length -= state.writelen;
    state.writelen = 0;
  };
  var onwrite = function(stream, er) {
    var state = stream._writableState;
    var sync = state.sync;
    var cb = state.writecb;
    onwriteStateUpdate(state);
    if (er)
      onwriteError(stream, state, sync, er, cb);
    else {
      var finished = needFinish(stream, state);
      if (!finished && !state.corked && !state.bufferProcessing && state.buffer.length) {
        clearBuffer(stream, state);
      }
      if (sync) {
        process.nextTick(function() {
          afterWrite(stream, state, finished, cb);
        });
      } else {
        afterWrite(stream, state, finished, cb);
      }
    }
  };
  var afterWrite = function(stream, state, finished, cb) {
    if (!finished)
      onwriteDrain(stream, state);
    state.pendingcb--;
    cb();
    finishMaybe(stream, state);
  };
  var onwriteDrain = function(stream, state) {
    if (state.length === 0 && state.needDrain) {
      state.needDrain = false;
      stream.emit("drain");
    }
  };
  var clearBuffer = function(stream, state) {
    state.bufferProcessing = true;
    if (stream._writev && state.buffer.length > 1) {
      var cbs = [];
      for (var c = 0;c < state.buffer.length; c++)
        cbs.push(state.buffer[c].callback);
      state.pendingcb++;
      doWrite(stream, state, true, state.length, state.buffer, "", function(err) {
        for (var i = 0;i < cbs.length; i++) {
          state.pendingcb--;
          cbs[i](err);
        }
      });
      state.buffer = [];
    } else {
      for (var c = 0;c < state.buffer.length; c++) {
        var entry = state.buffer[c];
        var chunk = entry.chunk;
        var encoding = entry.encoding;
        var cb = entry.callback;
        var len = state.objectMode ? 1 : chunk.length;
        doWrite(stream, state, false, len, chunk, encoding, cb);
        if (state.writing) {
          c++;
          break;
        }
      }
      if (c < state.buffer.length)
        state.buffer = state.buffer.slice(c);
      else
        state.buffer.length = 0;
    }
    state.bufferProcessing = false;
  };
  var needFinish = function(stream, state) {
    return state.ending && state.length === 0 && !state.finished && !state.writing;
  };
  var prefinish = function(stream, state) {
    if (!state.prefinished) {
      state.prefinished = true;
      stream.emit("prefinish");
    }
  };
  var finishMaybe = function(stream, state) {
    var need = needFinish(stream, state);
    if (need) {
      if (state.pendingcb === 0) {
        prefinish(stream, state);
        state.finished = true;
        stream.emit("finish");
      } else
        prefinish(stream, state);
    }
    return need;
  };
  var endWritable = function(stream, state, cb) {
    state.ending = true;
    finishMaybe(stream, state);
    if (cb) {
      if (state.finished)
        process.nextTick(cb);
      else
        stream.once("finish", cb);
    }
    state.ended = true;
  };
  module.exports = Writable;
  var Buffer4 = __require("buffer").Buffer;
  Writable.WritableState = WritableState;
  var util3 = require_util2();
  util3.inherits = require_inherits();
  var Stream3 = __require("stream");
  util3.inherits(Writable, Stream3);
  Writable.prototype.pipe = function() {
    this.emit("error", new Error("Cannot pipe. Not readable."));
  };
  Writable.prototype.write = function(chunk, encoding, cb) {
    var state = this._writableState;
    var ret = false;
    if (util3.isFunction(encoding)) {
      cb = encoding;
      encoding = null;
    }
    if (util3.isBuffer(chunk))
      encoding = "buffer";
    else if (!encoding)
      encoding = state.defaultEncoding;
    if (!util3.isFunction(cb))
      cb = function() {
      };
    if (state.ended)
      writeAfterEnd(this, state, cb);
    else if (validChunk(this, state, chunk, cb)) {
      state.pendingcb++;
      ret = writeOrBuffer(this, state, chunk, encoding, cb);
    }
    return ret;
  };
  Writable.prototype.cork = function() {
    var state = this._writableState;
    state.corked++;
  };
  Writable.prototype.uncork = function() {
    var state = this._writableState;
    if (state.corked) {
      state.corked--;
      if (!state.writing && !state.corked && !state.finished && !state.bufferProcessing && state.buffer.length)
        clearBuffer(this, state);
    }
  };
  Writable.prototype._write = function(chunk, encoding, cb) {
    cb(new Error("not implemented"));
  };
  Writable.prototype._writev = null;
  Writable.prototype.end = function(chunk, encoding, cb) {
    var state = this._writableState;
    if (util3.isFunction(chunk)) {
      cb = chunk;
      chunk = null;
      encoding = null;
    } else if (util3.isFunction(encoding)) {
      cb = encoding;
      encoding = null;
    }
    if (!util3.isNullOrUndefined(chunk))
      this.write(chunk, encoding);
    if (state.corked) {
      state.corked = 1;
      this.uncork();
    }
    if (!state.ending && !state.finished)
      endWritable(this, state, cb);
  };
});

// node_modules/readable-stream/lib/_stream_duplex.js
var require__stream_duplex = __commonJS((exports, module) => {
  var Duplex = function(options) {
    if (!(this instanceof Duplex))
      return new Duplex(options);
    Readable.call(this, options);
    Writable.call(this, options);
    if (options && options.readable === false)
      this.readable = false;
    if (options && options.writable === false)
      this.writable = false;
    this.allowHalfOpen = true;
    if (options && options.allowHalfOpen === false)
      this.allowHalfOpen = false;
    this.once("end", onend);
  };
  var onend = function() {
    if (this.allowHalfOpen || this._writableState.ended)
      return;
    process.nextTick(this.end.bind(this));
  };
  var forEach = function(xs, f) {
    for (var i = 0, l = xs.length;i < l; i++) {
      f(xs[i], i);
    }
  };
  module.exports = Duplex;
  var objectKeys = Object.keys || function(obj) {
    var keys = [];
    for (var key in obj)
      keys.push(key);
    return keys;
  };
  var util3 = require_util2();
  util3.inherits = require_inherits();
  var Readable = require__stream_readable();
  var Writable = require__stream_writable();
  util3.inherits(Duplex, Readable);
  forEach(objectKeys(Writable.prototype), function(method) {
    if (!Duplex.prototype[method])
      Duplex.prototype[method] = Writable.prototype[method];
  });
});

// node_modules/amqplib/lib/heartbeat.js
var require_heartbeat = __commonJS((exports, module) => {
  var Heart = function(interval, checkSend, checkRecv) {
    EventEmitter.call(this);
    this.interval = interval;
    var intervalMs = interval * exports.UNITS_TO_MS;
    var beat = this.emit.bind(this, "beat");
    var timeout = this.emit.bind(this, "timeout");
    this.sendTimer = setInterval(this.runHeartbeat.bind(this, checkSend, beat), intervalMs / 2);
    var recvMissed = 0;
    function missedTwo() {
      if (!checkRecv())
        return ++recvMissed < 2;
      else {
        recvMissed = 0;
        return true;
      }
    }
    this.recvTimer = setInterval(this.runHeartbeat.bind(this, missedTwo, timeout), intervalMs);
  };
  var inherits = __require("util").inherits;
  var EventEmitter = __require("events").EventEmitter;
  exports.UNITS_TO_MS = 1000;
  inherits(Heart, EventEmitter);
  exports.Heart = Heart;
  Heart.prototype.clear = function() {
    clearInterval(this.sendTimer);
    clearInterval(this.recvTimer);
  };
  Heart.prototype.runHeartbeat = function(check, fail) {
    if (!check())
      fail();
  };
});

// node_modules/amqplib/lib/format.js
var require_format = __commonJS((exports, module) => {
  var defs = require_defs();
  var format = __require("util").format;
  var inherits = __require("util").inherits;
  var HEARTBEAT = require_frame().HEARTBEAT;
  exports.closeMessage = function(close) {
    var code = close.fields.replyCode;
    return format('%d (%s) with message "%s"', code, defs.constant_strs[code], close.fields.replyText);
  };
  exports.methodName = function(id) {
    return defs.info(id).name;
  };
  exports.inspect = function(frame, showFields) {
    if (frame === HEARTBEAT) {
      return "<Heartbeat>";
    } else if (!frame.id) {
      return format("<Content channel:%d size:%d>", frame.channel, frame.size);
    } else {
      var info = defs.info(frame.id);
      return format("<%s channel:%d%s>", info.name, frame.channel, showFields ? " " + JSON.stringify(frame.fields, undefined, 2) : "");
    }
  };
});

// node_modules/amqplib/lib/bitset.js
var require_bitset = __commonJS((exports, module) => {
  var BitSet = function(size2) {
    if (size2) {
      var numWords = Math.ceil(size2 / 32);
      this.words = new Array(numWords);
    } else {
      this.words = [];
    }
    this.wordsInUse = 0;
  };
  var wordIndex = function(bitIndex) {
    return Math.floor(bitIndex / 32);
  };
  var trailingZeros = function(i) {
    if (i === 0)
      return 32;
    var y, n = 31;
    y = i << 16;
    if (y != 0) {
      n = n - 16;
      i = y;
    }
    y = i << 8;
    if (y != 0) {
      n = n - 8;
      i = y;
    }
    y = i << 4;
    if (y != 0) {
      n = n - 4;
      i = y;
    }
    y = i << 2;
    if (y != 0) {
      n = n - 2;
      i = y;
    }
    return n - (i << 1 >>> 31);
  };
  var P = BitSet.prototype;
  P.ensureSize = function(numWords) {
    var wordsPresent = this.words.length;
    if (wordsPresent < numWords) {
      this.words = this.words.concat(new Array(numWords - wordsPresent));
    }
  };
  P.set = function(bitIndex) {
    var w = wordIndex(bitIndex);
    if (w >= this.wordsInUse) {
      this.ensureSize(w + 1);
      this.wordsInUse = w + 1;
    }
    var bit = 1 << bitIndex;
    this.words[w] |= bit;
  };
  P.clear = function(bitIndex) {
    var w = wordIndex(bitIndex);
    if (w >= this.wordsInUse)
      return;
    var mask = ~(1 << bitIndex);
    this.words[w] &= mask;
  };
  P.get = function(bitIndex) {
    var w = wordIndex(bitIndex);
    if (w >= this.wordsInUse)
      return false;
    var bit = 1 << bitIndex;
    return !!(this.words[w] & bit);
  };
  P.nextSetBit = function(fromIndex) {
    var w = wordIndex(fromIndex);
    if (w >= this.wordsInUse)
      return -1;
    var word = this.words[w] & 4294967295 << fromIndex;
    while (true) {
      if (word)
        return w * 32 + trailingZeros(word);
      w++;
      if (w === this.wordsInUse)
        return -1;
      word = this.words[w];
    }
  };
  P.nextClearBit = function(fromIndex) {
    var w = wordIndex(fromIndex);
    if (w >= this.wordsInUse)
      return fromIndex;
    var word = ~this.words[w] & 4294967295 << fromIndex;
    while (true) {
      if (word)
        return w * 32 + trailingZeros(word);
      w++;
      if (w == this.wordsInUse)
        return w * 32;
      word = ~this.words[w];
    }
  };
  exports.BitSet = BitSet;
});

// node_modules/readable-stream/lib/_stream_transform.js
var require__stream_transform = __commonJS((exports, module) => {
  var TransformState = function(options, stream) {
    this.afterTransform = function(er, data) {
      return afterTransform(stream, er, data);
    };
    this.needTransform = false;
    this.transforming = false;
    this.writecb = null;
    this.writechunk = null;
  };
  var afterTransform = function(stream, er, data) {
    var ts = stream._transformState;
    ts.transforming = false;
    var cb = ts.writecb;
    if (!cb)
      return stream.emit("error", new Error("no writecb in Transform class"));
    ts.writechunk = null;
    ts.writecb = null;
    if (!util3.isNullOrUndefined(data))
      stream.push(data);
    if (cb)
      cb(er);
    var rs = stream._readableState;
    rs.reading = false;
    if (rs.needReadable || rs.length < rs.highWaterMark) {
      stream._read(rs.highWaterMark);
    }
  };
  var Transform = function(options) {
    if (!(this instanceof Transform))
      return new Transform(options);
    Duplex.call(this, options);
    this._transformState = new TransformState(options, this);
    var stream = this;
    this._readableState.needReadable = true;
    this._readableState.sync = false;
    this.once("prefinish", function() {
      if (util3.isFunction(this._flush))
        this._flush(function(er) {
          done(stream, er);
        });
      else
        done(stream);
    });
  };
  var done = function(stream, er) {
    if (er)
      return stream.emit("error", er);
    var ws = stream._writableState;
    var ts = stream._transformState;
    if (ws.length)
      throw new Error("calling transform done when ws.length != 0");
    if (ts.transforming)
      throw new Error("calling transform done when still transforming");
    return stream.push(null);
  };
  module.exports = Transform;
  var Duplex = require__stream_duplex();
  var util3 = require_util2();
  util3.inherits = require_inherits();
  util3.inherits(Transform, Duplex);
  Transform.prototype.push = function(chunk, encoding) {
    this._transformState.needTransform = false;
    return Duplex.prototype.push.call(this, chunk, encoding);
  };
  Transform.prototype._transform = function(chunk, encoding, cb) {
    throw new Error("not implemented");
  };
  Transform.prototype._write = function(chunk, encoding, cb) {
    var ts = this._transformState;
    ts.writecb = cb;
    ts.writechunk = chunk;
    ts.writeencoding = encoding;
    if (!ts.transforming) {
      var rs = this._readableState;
      if (ts.needTransform || rs.needReadable || rs.length < rs.highWaterMark)
        this._read(rs.highWaterMark);
    }
  };
  Transform.prototype._read = function(n) {
    var ts = this._transformState;
    if (!util3.isNull(ts.writechunk) && ts.writecb && !ts.transforming) {
      ts.transforming = true;
      this._transform(ts.writechunk, ts.writeencoding, ts.afterTransform);
    } else {
      ts.needTransform = true;
    }
  };
});

// node_modules/readable-stream/lib/_stream_passthrough.js
var require__stream_passthrough = __commonJS((exports, module) => {
  var PassThrough = function(options) {
    if (!(this instanceof PassThrough))
      return new PassThrough(options);
    Transform.call(this, options);
  };
  module.exports = PassThrough;
  var Transform = require__stream_transform();
  var util3 = require_util2();
  util3.inherits = require_inherits();
  util3.inherits(PassThrough, Transform);
  PassThrough.prototype._transform = function(chunk, encoding, cb) {
    cb(null, chunk);
  };
});

// node_modules/amqplib/lib/error.js
var require_error = __commonJS((exports, module) => {
  var trimStack = function(stack, num) {
    return stack && stack.split("\n").slice(num).join("\n");
  };
  var IllegalOperationError = function(msg, stack) {
    var tmp = new Error;
    this.message = msg;
    this.stack = this.toString() + "\n" + trimStack(tmp.stack, 2);
    this.stackAtStateChange = stack;
  };
  var stackCapture = function(reason) {
    var e = new Error;
    return "Stack capture: " + reason + "\n" + trimStack(e.stack, 2);
  };
  var inherits = __require("util").inherits;
  inherits(IllegalOperationError, Error);
  IllegalOperationError.prototype.name = "IllegalOperationError";
  exports.IllegalOperationError = IllegalOperationError;
  exports.stackCapture = stackCapture;
});

// node_modules/amqplib/lib/connection.js
var require_connection = __commonJS((exports, module) => {
  var Connection2 = function(underlying) {
    EventEmitter.call(this);
    var stream = this.stream = wrapStream(underlying);
    this.muxer = new Mux(stream);
    this.rest = Buffer4.alloc(0);
    this.frameMax = constants2.FRAME_MIN_SIZE;
    this.sentSinceLastCheck = false;
    this.recvSinceLastCheck = false;
    this.expectSocketClose = false;
    this.freeChannels = new BitSet;
    this.channels = [{
      channel: { accept: channel0(this) },
      buffer: underlying
    }];
  };
  var mainAccept = function(frame2) {
    var rec = this.channels[frame2.channel];
    if (rec) {
      return rec.channel.accept(frame2);
    } else
      this.closeWithError(fmt("Frame on unknown channel %d", frame2.channel), constants2.CHANNEL_ERROR, new Error(fmt("Frame on unknown channel: %s", inspect2(frame2, false))));
  };
  var channel0 = function(connection3) {
    return function(f) {
      if (f === HEARTBEAT)
        ;
      else if (f.id === defs.ConnectionClose) {
        connection3.sendMethod(0, defs.ConnectionCloseOk, {});
        var emsg = fmt("Connection closed: %s", closeMsg(f));
        var s = stackCapture(emsg);
        var e = new Error(emsg);
        e.code = f.fields.replyCode;
        if (isFatalError(e)) {
          connection3.emit("error", e);
        }
        connection3.toClosed(s, e);
      } else if (f.id === defs.ConnectionBlocked) {
        connection3.emit("blocked", f.fields.reason);
      } else if (f.id === defs.ConnectionUnblocked) {
        connection3.emit("unblocked");
      } else {
        connection3.closeWithError(fmt("Unexpected frame on channel 0"), constants2.UNEXPECTED_FRAME, new Error(fmt("Unexpected frame on channel 0: %s", inspect2(f, false))));
      }
    };
  };
  var invalidOp = function(msg, stack) {
    return function() {
      throw new IllegalOperationError(msg, stack);
    };
  };
  var invalidateSend = function(conn, msg, stack) {
    conn.sendMethod = conn.sendContent = conn.sendMessage = invalidOp(msg, stack);
  };
  var wrapStream = function(s) {
    if (s instanceof Duplex)
      return s;
    else {
      var ws = new Duplex;
      ws.wrap(s);
      ws._write = function(chunk, encoding, callback) {
        return s.write(chunk, encoding, callback);
      };
      return ws;
    }
  };
  var isFatalError = function(error) {
    switch (error && error.code) {
      case defs.constants.CONNECTION_FORCED:
      case defs.constants.REPLY_SUCCESS:
        return false;
      default:
        return true;
    }
  };
  var defs = require_defs();
  var constants2 = defs.constants;
  var frame = require_frame();
  var HEARTBEAT = frame.HEARTBEAT;
  var Mux = require_mux().Mux;
  var Buffer4 = require_safe_buffer().Buffer;
  var Duplex = __require("stream").Duplex || require__stream_duplex();
  var EventEmitter = __require("events").EventEmitter;
  var Heart = require_heartbeat().Heart;
  var methodName = require_format().methodName;
  var closeMsg = require_format().closeMessage;
  var inspect2 = require_format().inspect;
  var BitSet = require_bitset().BitSet;
  var inherits = __require("util").inherits;
  var fmt = __require("util").format;
  var PassThrough = __require("stream").PassThrough || require__stream_passthrough();
  var IllegalOperationError = require_error().IllegalOperationError;
  var stackCapture = require_error().stackCapture;
  var DEFAULT_WRITE_HWM = 1024;
  var SINGLE_CHUNK_THRESHOLD = 2048;
  inherits(Connection2, EventEmitter);
  var C = Connection2.prototype;
  C.sendProtocolHeader = function() {
    this.sendBytes(frame.PROTOCOL_HEADER);
  };
  C.open = function(allFields, openCallback0) {
    var self2 = this;
    var openCallback = openCallback0 || function() {
    };
    var tunedOptions = Object.create(allFields);
    function wait(k) {
      self2.step(function(err, frame2) {
        if (err !== null)
          bail(err);
        else if (frame2.channel !== 0) {
          bail(new Error(fmt("Frame on channel != 0 during handshake: %s", inspect2(frame2, false))));
        } else
          k(frame2);
      });
    }
    function expect(Method, k) {
      wait(function(frame2) {
        if (frame2.id === Method)
          k(frame2);
        else {
          bail(new Error(fmt("Expected %s; got %s", methodName(Method), inspect2(frame2, false))));
        }
      });
    }
    function bail(err) {
      openCallback(err);
    }
    function send(Method) {
      try {
        self2.sendMethod(0, Method, tunedOptions);
      } catch (err) {
        bail(err);
      }
    }
    function negotiate(server, desired) {
      if (server === 0 || desired === 0) {
        return Math.max(server, desired);
      } else {
        return Math.min(server, desired);
      }
    }
    function onStart(start) {
      var mechanisms = start.fields.mechanisms.toString().split(" ");
      if (mechanisms.indexOf(allFields.mechanism) < 0) {
        bail(new Error(fmt("SASL mechanism %s is not provided by the server", allFields.mechanism)));
        return;
      }
      self2.serverProperties = start.fields.serverProperties;
      send(defs.ConnectionStartOk);
      wait(afterStartOk);
    }
    function afterStartOk(reply) {
      switch (reply.id) {
        case defs.ConnectionSecure:
          bail(new Error("Wasn't expecting to have to go through secure"));
          break;
        case defs.ConnectionClose:
          bail(new Error(fmt("Handshake terminated by server: %s", closeMsg(reply))));
          break;
        case defs.ConnectionTune:
          var fields = reply.fields;
          tunedOptions.frameMax = negotiate(fields.frameMax, allFields.frameMax);
          tunedOptions.channelMax = negotiate(fields.channelMax, allFields.channelMax);
          tunedOptions.heartbeat = negotiate(fields.heartbeat, allFields.heartbeat);
          send(defs.ConnectionTuneOk);
          send(defs.ConnectionOpen);
          expect(defs.ConnectionOpenOk, onOpenOk);
          break;
        default:
          bail(new Error(fmt("Expected connection.secure, connection.close, or connection.tune during handshake; got %s", inspect2(reply, false))));
          break;
      }
    }
    function onOpenOk(openOk) {
      self2.channelMax = tunedOptions.channelMax || 65535;
      self2.frameMax = tunedOptions.frameMax || 4294967295;
      self2.heartbeat = tunedOptions.heartbeat;
      self2.heartbeater = self2.startHeartbeater();
      self2.accept = mainAccept;
      succeed(openOk);
    }
    function endWhileOpening(err) {
      bail(err || new Error("Socket closed abruptly during opening handshake"));
    }
    this.stream.on("end", endWhileOpening);
    this.stream.on("error", endWhileOpening);
    function succeed(ok) {
      self2.stream.removeListener("end", endWhileOpening);
      self2.stream.removeListener("error", endWhileOpening);
      self2.stream.on("error", self2.onSocketError.bind(self2));
      self2.stream.on("end", self2.onSocketError.bind(self2, new Error("Unexpected close")));
      self2.on("frameError", self2.onSocketError.bind(self2));
      self2.acceptLoop();
      openCallback(null, ok);
    }
    this.sendProtocolHeader();
    expect(defs.ConnectionStart, onStart);
  };
  C.close = function(closeCallback) {
    var k = closeCallback && function() {
      closeCallback(null);
    };
    this.closeBecause("Cheers, thanks", constants2.REPLY_SUCCESS, k);
  };
  C.closeBecause = function(reason, code, k) {
    this.sendMethod(0, defs.ConnectionClose, {
      replyText: reason,
      replyCode: code,
      methodId: 0,
      classId: 0
    });
    var s = stackCapture("closeBecause called: " + reason);
    this.toClosing(s, k);
  };
  C.closeWithError = function(reason, code, error) {
    this.emit("error", error);
    this.closeBecause(reason, code);
  };
  C.onSocketError = function(err) {
    if (!this.expectSocketClose) {
      this.expectSocketClose = true;
      this.emit("error", err);
      var s = stackCapture("Socket error");
      this.toClosed(s, err);
    }
  };
  C.toClosing = function(capturedStack, k) {
    var send = this.sendMethod.bind(this);
    this.accept = function(f) {
      if (f.id === defs.ConnectionCloseOk) {
        if (k)
          k();
        var s = stackCapture("ConnectionCloseOk received");
        this.toClosed(s, undefined);
      } else if (f.id === defs.ConnectionClose) {
        send(0, defs.ConnectionCloseOk, {});
      }
    };
    invalidateSend(this, "Connection closing", capturedStack);
  };
  C._closeChannels = function(capturedStack) {
    for (var i = 1;i < this.channels.length; i++) {
      var ch = this.channels[i];
      if (ch !== null) {
        ch.channel.toClosed(capturedStack);
      }
    }
  };
  C.toClosed = function(capturedStack, maybeErr) {
    this._closeChannels(capturedStack);
    var info = fmt("Connection closed (%s)", maybeErr ? maybeErr.toString() : "by client");
    invalidateSend(this, info, capturedStack);
    this.accept = invalidOp(info, capturedStack);
    this.close = function(cb) {
      cb && cb(new IllegalOperationError(info, capturedStack));
    };
    if (this.heartbeater)
      this.heartbeater.clear();
    this.expectSocketClose = true;
    this.stream.end();
    this.emit("close", maybeErr);
  };
  C.startHeartbeater = function() {
    if (this.heartbeat === 0)
      return null;
    else {
      var self2 = this;
      var hb = new Heart(this.heartbeat, this.checkSend.bind(this), this.checkRecv.bind(this));
      hb.on("timeout", function() {
        var hberr = new Error("Heartbeat timeout");
        self2.emit("error", hberr);
        var s = stackCapture("Heartbeat timeout");
        self2.toClosed(s, hberr);
      });
      hb.on("beat", function() {
        self2.sendHeartbeat();
      });
      return hb;
    }
  };
  C.freshChannel = function(channel, options) {
    var next = this.freeChannels.nextClearBit(1);
    if (next < 0 || next > this.channelMax)
      throw new Error("No channels left to allocate");
    this.freeChannels.set(next);
    var hwm = options && options.highWaterMark || DEFAULT_WRITE_HWM;
    var writeBuffer = new PassThrough({
      objectMode: true,
      highWaterMark: hwm
    });
    this.channels[next] = { channel, buffer: writeBuffer };
    writeBuffer.on("drain", function() {
      channel.onBufferDrain();
    });
    this.muxer.pipeFrom(writeBuffer);
    return next;
  };
  C.releaseChannel = function(channel) {
    this.freeChannels.clear(channel);
    var buffer2 = this.channels[channel].buffer;
    buffer2.end();
    this.channels[channel] = null;
  };
  C.acceptLoop = function() {
    var self2 = this;
    function go() {
      try {
        var f;
        while (f = self2.recvFrame())
          self2.accept(f);
      } catch (e) {
        self2.emit("frameError", e);
      }
    }
    self2.stream.on("readable", go);
    go();
  };
  C.step = function(cb) {
    var self2 = this;
    function recv() {
      var f;
      try {
        f = self2.recvFrame();
      } catch (e) {
        cb(e, null);
        return;
      }
      if (f)
        cb(null, f);
      else
        self2.stream.once("readable", recv);
    }
    recv();
  };
  C.checkSend = function() {
    var check = this.sentSinceLastCheck;
    this.sentSinceLastCheck = false;
    return check;
  };
  C.checkRecv = function() {
    var check = this.recvSinceLastCheck;
    this.recvSinceLastCheck = false;
    return check;
  };
  C.sendBytes = function(bytes2) {
    this.sentSinceLastCheck = true;
    this.stream.write(bytes2);
  };
  C.sendHeartbeat = function() {
    return this.sendBytes(frame.HEARTBEAT_BUF);
  };
  var encodeMethod = defs.encodeMethod;
  var encodeProperties = defs.encodeProperties;
  C.sendMethod = function(channel, Method, fields) {
    var frame2 = encodeMethod(Method, channel, fields);
    this.sentSinceLastCheck = true;
    var buffer2 = this.channels[channel].buffer;
    return buffer2.write(frame2);
  };
  C.sendMessage = function(channel, Method, fields, Properties, props, content) {
    if (!Buffer4.isBuffer(content))
      throw new TypeError("content is not a buffer");
    var mframe = encodeMethod(Method, channel, fields);
    var pframe = encodeProperties(Properties, channel, content.length, props);
    var buffer2 = this.channels[channel].buffer;
    this.sentSinceLastCheck = true;
    var methodHeaderLen = mframe.length + pframe.length;
    var bodyLen = content.length > 0 ? content.length + FRAME_OVERHEAD : 0;
    var allLen = methodHeaderLen + bodyLen;
    if (allLen < SINGLE_CHUNK_THRESHOLD) {
      var all = Buffer4.alloc(allLen);
      var offset = mframe.copy(all, 0);
      offset += pframe.copy(all, offset);
      if (bodyLen > 0)
        makeBodyFrame(channel, content).copy(all, offset);
      return buffer2.write(all);
    } else {
      if (methodHeaderLen < SINGLE_CHUNK_THRESHOLD) {
        var both = Buffer4.alloc(methodHeaderLen);
        var offset = mframe.copy(both, 0);
        pframe.copy(both, offset);
        buffer2.write(both);
      } else {
        buffer2.write(mframe);
        buffer2.write(pframe);
      }
      return this.sendContent(channel, content);
    }
  };
  var FRAME_OVERHEAD = defs.FRAME_OVERHEAD;
  var makeBodyFrame = frame.makeBodyFrame;
  C.sendContent = function(channel, body2) {
    if (!Buffer4.isBuffer(body2)) {
      throw new TypeError(fmt("Expected buffer; got %s", body2));
    }
    var writeResult = true;
    var buffer2 = this.channels[channel].buffer;
    var maxBody = this.frameMax - FRAME_OVERHEAD;
    for (var offset = 0;offset < body2.length; offset += maxBody) {
      var end = offset + maxBody;
      var slice = end > body2.length ? body2.slice(offset) : body2.slice(offset, end);
      var bodyFrame = makeBodyFrame(channel, slice);
      writeResult = buffer2.write(bodyFrame);
    }
    this.sentSinceLastCheck = true;
    return writeResult;
  };
  var parseFrame = frame.parseFrame;
  var decodeFrame = frame.decodeFrame;
  C.recvFrame = function() {
    var frame2 = parseFrame(this.rest, this.frameMax);
    if (!frame2) {
      var incoming = this.stream.read();
      if (incoming === null) {
        return false;
      } else {
        this.recvSinceLastCheck = true;
        this.rest = Buffer4.concat([this.rest, incoming]);
        return this.recvFrame();
      }
    } else {
      this.rest = frame2.rest;
      return decodeFrame(frame2);
    }
  };
  exports.Connection = Connection2;
  exports.isFatalError = isFatalError;
});

// node_modules/amqplib/lib/credentials.js
var require_credentials = __commonJS((exports, module) => {
  var Buffer4 = require_safe_buffer().Buffer;
  var codec = require_codec();
  exports.plain = function(user, passwd) {
    return {
      mechanism: "PLAIN",
      response: function() {
        return Buffer4.from(["", user, passwd].join(String.fromCharCode(0)));
      },
      username: user,
      password: passwd
    };
  };
  exports.amqplain = function(user, passwd) {
    return {
      mechanism: "AMQPLAIN",
      response: function() {
        const buffer2 = Buffer4.alloc(16384);
        const size2 = codec.encodeTable(buffer2, { LOGIN: user, PASSWORD: passwd }, 0);
        return buffer2.slice(4, size2);
      },
      username: user,
      password: passwd
    };
  };
  exports.external = function() {
    return {
      mechanism: "EXTERNAL",
      response: function() {
        return Buffer4.from("");
      }
    };
  };
});

// node_modules/amqplib/package.json
var require_package = __commonJS((exports, module) => {
  module.exports = {
    name: "amqplib",
    homepage: "http://squaremo.github.io/amqp.node/",
    main: "./channel_api.js",
    version: "0.8.0",
    description: "An AMQP 0-9-1 (e.g., RabbitMQ) library and client.",
    repository: {
      type: "git",
      url: "https://github.com/squaremo/amqp.node.git"
    },
    engines: {
      node: ">=10"
    },
    dependencies: {
      bitsyntax: "~0.1.0",
      bluebird: "^3.7.2",
      "buffer-more-ints": "~1.0.0",
      "readable-stream": "1.x >=1.1.9",
      "safe-buffer": "~5.2.1",
      "url-parse": "~1.5.1"
    },
    devDependencies: {
      claire: "0.4.1",
      istanbul: "0.1.x",
      mocha: "^3.5.3",
      "uglify-js": "2.8.x"
    },
    scripts: {
      test: "make test",
      prepare: "make"
    },
    keywords: [
      "AMQP",
      "AMQP 0-9-1",
      "RabbitMQ"
    ],
    author: "Michael Bridgen <mikeb@squaremobius.net>",
    license: "MIT"
  };
});

// node_modules/amqplib/lib/connect.js
var require_connect = __commonJS((exports, module) => {
  var copyInto = function(obj, target) {
    var keys = Object.keys(obj);
    var i = keys.length;
    while (i--) {
      var k = keys[i];
      target[k] = obj[k];
    }
    return target;
  };
  var clone = function(obj) {
    return copyInto(obj, {});
  };
  var openFrames = function(vhost, query4, credentials2, extraClientProperties) {
    if (!vhost)
      vhost = "/";
    else
      vhost = QS.unescape(vhost);
    var query4 = query4 || {};
    function intOrDefault(val, def) {
      return val === undefined ? def : parseInt(val);
    }
    var clientProperties = Object.create(CLIENT_PROPERTIES);
    return {
      clientProperties: copyInto(extraClientProperties, clientProperties),
      mechanism: credentials2.mechanism,
      response: credentials2.response(),
      locale: query4.locale || "en_US",
      channelMax: intOrDefault(query4.channelMax, 0),
      frameMax: intOrDefault(query4.frameMax, 4096),
      heartbeat: intOrDefault(query4.heartbeat, 0),
      virtualHost: vhost,
      capabilities: "",
      insist: 0
    };
  };
  var credentialsFromUrl = function(parts) {
    var user = "guest", passwd = "guest";
    if (parts.username != "" || parts.password != "") {
      user = parts.username ? unescape(parts.username) : "";
      passwd = parts.password ? unescape(parts.password) : "";
    }
    return credentials.plain(user, passwd);
  };
  var connect = function(url7, socketOptions, openCallback) {
    var sockopts = clone(socketOptions || {});
    url7 = url7 || "amqp://localhost";
    var noDelay = !!sockopts.noDelay;
    var timeout = sockopts.timeout;
    var keepAlive = !!sockopts.keepAlive;
    var keepAliveDelay = sockopts.keepAliveDelay || 0;
    var extraClientProperties = sockopts.clientProperties || {};
    var protocol, fields;
    if (typeof url7 === "object") {
      protocol = (url7.protocol || "amqp") + ":";
      sockopts.host = url7.hostname;
      sockopts.servername = url7.hostname;
      sockopts.port = url7.port || (protocol === "amqp:" ? 5672 : 5671);
      var user, pass;
      if (url7.username == undefined && url7.password == undefined) {
        user = "guest";
        pass = "guest";
      } else {
        user = url7.username || "";
        pass = url7.password || "";
      }
      var config = {
        locale: url7.locale,
        channelMax: url7.channelMax,
        frameMax: url7.frameMax,
        heartbeat: url7.heartbeat
      };
      fields = openFrames(url7.vhost, config, sockopts.credentials || credentials.plain(user, pass), extraClientProperties);
    } else {
      var parts = URL2(url7, true);
      protocol = parts.protocol;
      sockopts.host = parts.hostname;
      sockopts.servername = parts.hostname;
      sockopts.port = parseInt(parts.port) || (protocol === "amqp:" ? 5672 : 5671);
      var vhost = parts.pathname ? parts.pathname.substr(1) : null;
      fields = openFrames(vhost, parts.query, sockopts.credentials || credentialsFromUrl(parts), extraClientProperties);
    }
    var sockok = false;
    var sock;
    function onConnect() {
      sockok = true;
      sock.setNoDelay(noDelay);
      if (keepAlive)
        sock.setKeepAlive(keepAlive, keepAliveDelay);
      var c = new Connection2(sock);
      c.open(fields, function(err, ok) {
        if (timeout)
          sock.setTimeout(0);
        if (err === null) {
          openCallback(null, c);
        } else
          openCallback(err);
      });
    }
    if (protocol === "amqp:") {
      sock = __require("net").connect(sockopts, onConnect);
    } else if (protocol === "amqps:") {
      sock = __require("tls").connect(sockopts, onConnect);
    } else {
      throw new Error("Expected amqp: or amqps: as the protocol; got " + protocol);
    }
    if (timeout) {
      sock.setTimeout(timeout, function() {
        sock.end();
        sock.destroy();
        openCallback(new Error("connect ETIMEDOUT"));
      });
    }
    sock.once("error", function(err) {
      if (!sockok)
        openCallback(err);
    });
  };
  var URL2 = require_url_parse();
  var QS = __require("querystring");
  var Connection2 = require_connection().Connection;
  var fmt = __require("util").format;
  var credentials = require_credentials();
  var CLIENT_PROPERTIES = {
    product: "amqplib",
    version: require_package().version,
    platform: fmt("Node.JS %s", process.version),
    information: "http://squaremo.github.io/amqp.node",
    capabilities: {
      publisher_confirms: true,
      exchange_exchange_bindings: true,
      "basic.nack": true,
      consumer_cancel_notify: true,
      "connection.blocked": true,
      authentication_failure_close: true
    }
  };
  exports.connect = connect;
  exports.credentialsFromUrl = credentialsFromUrl;
});

// node_modules/bluebird/js/release/es5.js
var require_es5 = __commonJS((exports, module) => {
  var isES5 = function() {
    return this === undefined;
  }();
  if (isES5) {
    module.exports = {
      freeze: Object.freeze,
      defineProperty: Object.defineProperty,
      getDescriptor: Object.getOwnPropertyDescriptor,
      keys: Object.keys,
      names: Object.getOwnPropertyNames,
      getPrototypeOf: Object.getPrototypeOf,
      isArray: Array.isArray,
      isES5,
      propertyIsWritable: function(obj, prop) {
        var descriptor = Object.getOwnPropertyDescriptor(obj, prop);
        return !!(!descriptor || descriptor.writable || descriptor.set);
      }
    };
  } else {
    has = {}.hasOwnProperty;
    str = {}.toString;
    proto = {}.constructor.prototype;
    ObjectKeys = function(o) {
      var ret = [];
      for (var key in o) {
        if (has.call(o, key)) {
          ret.push(key);
        }
      }
      return ret;
    };
    ObjectGetDescriptor = function(o, key) {
      return { value: o[key] };
    };
    ObjectDefineProperty = function(o, key, desc) {
      o[key] = desc.value;
      return o;
    };
    ObjectFreeze = function(obj) {
      return obj;
    };
    ObjectGetPrototypeOf = function(obj) {
      try {
        return Object(obj).constructor.prototype;
      } catch (e) {
        return proto;
      }
    };
    ArrayIsArray = function(obj) {
      try {
        return str.call(obj) === "[object Array]";
      } catch (e) {
        return false;
      }
    };
    module.exports = {
      isArray: ArrayIsArray,
      keys: ObjectKeys,
      names: ObjectKeys,
      defineProperty: ObjectDefineProperty,
      getDescriptor: ObjectGetDescriptor,
      freeze: ObjectFreeze,
      getPrototypeOf: ObjectGetPrototypeOf,
      isES5,
      propertyIsWritable: function() {
        return true;
      }
    };
  }
  var has;
  var str;
  var proto;
  var ObjectKeys;
  var ObjectGetDescriptor;
  var ObjectDefineProperty;
  var ObjectFreeze;
  var ObjectGetPrototypeOf;
  var ArrayIsArray;
});

// node_modules/bluebird/js/release/util.js
var require_util3 = __commonJS((exports, module) => {
  var tryCatcher = function() {
    try {
      var target = tryCatchTarget;
      tryCatchTarget = null;
      return target.apply(this, arguments);
    } catch (e) {
      errorObj.e = e;
      return errorObj;
    }
  };
  var tryCatch = function(fn) {
    tryCatchTarget = fn;
    return tryCatcher;
  };
  var isPrimitive = function(val) {
    return val == null || val === true || val === false || typeof val === "string" || typeof val === "number";
  };
  var isObject2 = function(value) {
    return typeof value === "function" || typeof value === "object" && value !== null;
  };
  var maybeWrapAsError = function(maybeError) {
    if (!isPrimitive(maybeError))
      return maybeError;
    return new Error(safeToString(maybeError));
  };
  var withAppended = function(target, appendee) {
    var len = target.length;
    var ret2 = new Array(len + 1);
    var i;
    for (i = 0;i < len; ++i) {
      ret2[i] = target[i];
    }
    ret2[i] = appendee;
    return ret2;
  };
  var getDataPropertyOrDefault = function(obj, key, defaultValue) {
    if (es5.isES5) {
      var desc = Object.getOwnPropertyDescriptor(obj, key);
      if (desc != null) {
        return desc.get == null && desc.set == null ? desc.value : defaultValue;
      }
    } else {
      return {}.hasOwnProperty.call(obj, key) ? obj[key] : undefined;
    }
  };
  var notEnumerableProp = function(obj, name, value) {
    if (isPrimitive(obj))
      return obj;
    var descriptor = {
      value,
      configurable: true,
      enumerable: false,
      writable: true
    };
    es5.defineProperty(obj, name, descriptor);
    return obj;
  };
  var thrower = function(r) {
    throw r;
  };
  var isClass = function(fn) {
    try {
      if (typeof fn === "function") {
        var keys = es5.names(fn.prototype);
        var hasMethods = es5.isES5 && keys.length > 1;
        var hasMethodsOtherThanConstructor = keys.length > 0 && !(keys.length === 1 && keys[0] === "constructor");
        var hasThisAssignmentAndStaticMethods = thisAssignmentPattern.test(fn + "") && es5.names(fn).length > 0;
        if (hasMethods || hasMethodsOtherThanConstructor || hasThisAssignmentAndStaticMethods) {
          return true;
        }
      }
      return false;
    } catch (e) {
      return false;
    }
  };
  var toFastProperties = function(obj) {
    function FakeConstructor() {
    }
    FakeConstructor.prototype = obj;
    var receiver = new FakeConstructor;
    function ic() {
      return typeof receiver.foo;
    }
    ic();
    ic();
    return obj;
    (0, eval)(obj);
  };
  var isIdentifier = function(str) {
    return rident.test(str);
  };
  var filledRange = function(count, prefix, suffix) {
    var ret2 = new Array(count);
    for (var i = 0;i < count; ++i) {
      ret2[i] = prefix + i + suffix;
    }
    return ret2;
  };
  var safeToString = function(obj) {
    try {
      return obj + "";
    } catch (e) {
      return "[no string representation]";
    }
  };
  var isError = function(obj) {
    return obj instanceof Error || obj !== null && typeof obj === "object" && typeof obj.message === "string" && typeof obj.name === "string";
  };
  var markAsOriginatingFromRejection = function(e) {
    try {
      notEnumerableProp(e, "isOperational", true);
    } catch (ignore) {
    }
  };
  var originatesFromRejection = function(e) {
    if (e == null)
      return false;
    return e instanceof Error["__BluebirdErrorTypes__"].OperationalError || e["isOperational"] === true;
  };
  var canAttachTrace = function(obj) {
    return isError(obj) && es5.propertyIsWritable(obj, "stack");
  };
  var classString = function(obj) {
    return {}.toString.call(obj);
  };
  var copyDescriptors = function(from, to, filter) {
    var keys = es5.names(from);
    for (var i = 0;i < keys.length; ++i) {
      var key = keys[i];
      if (filter(key)) {
        try {
          es5.defineProperty(to, key, es5.getDescriptor(from, key));
        } catch (ignore) {
        }
      }
    }
  };
  var env = function(key) {
    return hasEnvVariables ? process.env[key] : undefined;
  };
  var getNativePromise = function() {
    if (typeof Promise === "function") {
      try {
        var promise = new Promise(function() {
        });
        if (classString(promise) === "[object Promise]") {
          return Promise;
        }
      } catch (e) {
      }
    }
  };
  var contextBind = function(ctx, cb) {
    if (ctx === null || typeof cb !== "function" || cb === reflectHandler) {
      return cb;
    }
    if (ctx.domain !== null) {
      cb = ctx.domain.bind(cb);
    }
    var async = ctx.async;
    if (async !== null) {
      var old = cb;
      cb = function() {
        var $_len = arguments.length + 2;
        var args = new Array($_len);
        for (var $_i = 2;$_i < $_len; ++$_i) {
          args[$_i] = arguments[$_i - 2];
        }
        args[0] = old;
        args[1] = this;
        return async.runInAsyncScope.apply(async, args);
      };
    }
    return cb;
  };
  var es5 = require_es5();
  var canEvaluate = typeof navigator == "undefined";
  var errorObj = { e: {} };
  var tryCatchTarget;
  var globalObject = typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : typeof global !== "undefined" ? global : exports !== undefined ? exports : null;
  var inherits = function(Child, Parent) {
    var hasProp = {}.hasOwnProperty;
    function T() {
      this.constructor = Child;
      this.constructor$ = Parent;
      for (var propertyName in Parent.prototype) {
        if (hasProp.call(Parent.prototype, propertyName) && propertyName.charAt(propertyName.length - 1) !== "$") {
          this[propertyName + "$"] = Parent.prototype[propertyName];
        }
      }
    }
    T.prototype = Parent.prototype;
    Child.prototype = new T;
    return Child.prototype;
  };
  var inheritedDataKeys = function() {
    var excludedPrototypes = [
      Array.prototype,
      Object.prototype,
      Function.prototype
    ];
    var isExcludedProto = function(val) {
      for (var i = 0;i < excludedPrototypes.length; ++i) {
        if (excludedPrototypes[i] === val) {
          return true;
        }
      }
      return false;
    };
    if (es5.isES5) {
      var getKeys = Object.getOwnPropertyNames;
      return function(obj) {
        var ret2 = [];
        var visitedKeys = Object.create(null);
        while (obj != null && !isExcludedProto(obj)) {
          var keys;
          try {
            keys = getKeys(obj);
          } catch (e) {
            return ret2;
          }
          for (var i = 0;i < keys.length; ++i) {
            var key = keys[i];
            if (visitedKeys[key])
              continue;
            visitedKeys[key] = true;
            var desc = Object.getOwnPropertyDescriptor(obj, key);
            if (desc != null && desc.get == null && desc.set == null) {
              ret2.push(key);
            }
          }
          obj = es5.getPrototypeOf(obj);
        }
        return ret2;
      };
    } else {
      var hasProp = {}.hasOwnProperty;
      return function(obj) {
        if (isExcludedProto(obj))
          return [];
        var ret2 = [];
        enumeration:
          for (var key in obj) {
            if (hasProp.call(obj, key)) {
              ret2.push(key);
            } else {
              for (var i = 0;i < excludedPrototypes.length; ++i) {
                if (hasProp.call(excludedPrototypes[i], key)) {
                  continue enumeration;
                }
              }
              ret2.push(key);
            }
          }
        return ret2;
      };
    }
  }();
  var thisAssignmentPattern = /this\s*\.\s*\S+\s*=/;
  var rident = /^[a-z$_][a-z$_0-9]*$/i;
  var ensureErrorObject = function() {
    if (!("stack" in new Error)) {
      return function(value) {
        if (canAttachTrace(value))
          return value;
        try {
          throw new Error(safeToString(value));
        } catch (err) {
          return err;
        }
      };
    } else {
      return function(value) {
        if (canAttachTrace(value))
          return value;
        return new Error(safeToString(value));
      };
    }
  }();
  var asArray = function(v) {
    if (es5.isArray(v)) {
      return v;
    }
    return null;
  };
  if (typeof Symbol !== "undefined" && Symbol.iterator) {
    ArrayFrom = typeof Array.from === "function" ? function(v) {
      return Array.from(v);
    } : function(v) {
      var ret2 = [];
      var it = v[Symbol.iterator]();
      var itResult;
      while (!(itResult = it.next()).done) {
        ret2.push(itResult.value);
      }
      return ret2;
    };
    asArray = function(v) {
      if (es5.isArray(v)) {
        return v;
      } else if (v != null && typeof v[Symbol.iterator] === "function") {
        return ArrayFrom(v);
      }
      return null;
    };
  }
  var ArrayFrom;
  var isNode = typeof process !== "undefined" && classString(process).toLowerCase() === "[object process]";
  var hasEnvVariables = typeof process !== "undefined" && typeof process.env !== "undefined";
  var reflectHandler;
  var ret = {
    setReflectHandler: function(fn) {
      reflectHandler = fn;
    },
    isClass,
    isIdentifier,
    inheritedDataKeys,
    getDataPropertyOrDefault,
    thrower,
    isArray: es5.isArray,
    asArray,
    notEnumerableProp,
    isPrimitive,
    isObject: isObject2,
    isError,
    canEvaluate,
    errorObj,
    tryCatch,
    inherits,
    withAppended,
    maybeWrapAsError,
    toFastProperties,
    filledRange,
    toString: safeToString,
    canAttachTrace,
    ensureErrorObject,
    originatesFromRejection,
    markAsOriginatingFromRejection,
    classString,
    copyDescriptors,
    isNode,
    hasEnvVariables,
    env,
    global: globalObject,
    getNativePromise,
    contextBind
  };
  ret.isRecentNode = ret.isNode && function() {
    var version2;
    if (process.versions && process.versions.node) {
      version2 = process.versions.node.split(".").map(Number);
    } else if (process.version) {
      version2 = process.version.split(".").map(Number);
    }
    return version2[0] === 0 && version2[1] > 10 || version2[0] > 0;
  }();
  ret.nodeSupportsAsyncResource = ret.isNode && function() {
    var supportsAsync = false;
    try {
      var res = __require("async_hooks").AsyncResource;
      supportsAsync = typeof res.prototype.runInAsyncScope === "function";
    } catch (e) {
      supportsAsync = false;
    }
    return supportsAsync;
  }();
  if (ret.isNode)
    ret.toFastProperties(process);
  try {
    throw new Error;
  } catch (e) {
    ret.lastLineError = e;
  }
  module.exports = ret;
});

// node_modules/bluebird/js/release/schedule.js
var require_schedule = __commonJS((exports, module) => {
  var util3 = require_util3();
  var schedule;
  var noAsyncScheduler = function() {
    throw new Error(`No async scheduler available

    See http://goo.gl/MqrFmX
`);
  };
  var NativePromise = util3.getNativePromise();
  if (util3.isNode && typeof MutationObserver === "undefined") {
    GlobalSetImmediate = global.setImmediate;
    ProcessNextTick = process.nextTick;
    schedule = util3.isRecentNode ? function(fn) {
      GlobalSetImmediate.call(global, fn);
    } : function(fn) {
      ProcessNextTick.call(process, fn);
    };
  } else if (typeof NativePromise === "function" && typeof NativePromise.resolve === "function") {
    nativePromise = NativePromise.resolve();
    schedule = function(fn) {
      nativePromise.then(fn);
    };
  } else if (typeof MutationObserver !== "undefined" && !(typeof window !== "undefined" && window.navigator && (window.navigator.standalone || window.cordova)) && ("classList" in document.documentElement)) {
    schedule = function() {
      var div = document.createElement("div");
      var opts = { attributes: true };
      var toggleScheduled = false;
      var div2 = document.createElement("div");
      var o2 = new MutationObserver(function() {
        div.classList.toggle("foo");
        toggleScheduled = false;
      });
      o2.observe(div2, opts);
      var scheduleToggle = function() {
        if (toggleScheduled)
          return;
        toggleScheduled = true;
        div2.classList.toggle("foo");
      };
      return function schedule(fn) {
        var o = new MutationObserver(function() {
          o.disconnect();
          fn();
        });
        o.observe(div, opts);
        scheduleToggle();
      };
    }();
  } else if (typeof setImmediate !== "undefined") {
    schedule = function(fn) {
      setImmediate(fn);
    };
  } else if (typeof setTimeout !== "undefined") {
    schedule = function(fn) {
      setTimeout(fn, 0);
    };
  } else {
    schedule = noAsyncScheduler;
  }
  var GlobalSetImmediate;
  var ProcessNextTick;
  var nativePromise;
  module.exports = schedule;
});

// node_modules/bluebird/js/release/queue.js
var require_queue = __commonJS((exports, module) => {
  var arrayMove = function(src, srcIndex, dst, dstIndex, len) {
    for (var j = 0;j < len; ++j) {
      dst[j + dstIndex] = src[j + srcIndex];
      src[j + srcIndex] = undefined;
    }
  };
  var Queue2 = function(capacity) {
    this._capacity = capacity;
    this._length = 0;
    this._front = 0;
  };
  Queue2.prototype._willBeOverCapacity = function(size2) {
    return this._capacity < size2;
  };
  Queue2.prototype._pushOne = function(arg) {
    var length = this.length();
    this._checkCapacity(length + 1);
    var i = this._front + length & this._capacity - 1;
    this[i] = arg;
    this._length = length + 1;
  };
  Queue2.prototype.push = function(fn, receiver, arg) {
    var length = this.length() + 3;
    if (this._willBeOverCapacity(length)) {
      this._pushOne(fn);
      this._pushOne(receiver);
      this._pushOne(arg);
      return;
    }
    var j = this._front + length - 3;
    this._checkCapacity(length);
    var wrapMask = this._capacity - 1;
    this[j + 0 & wrapMask] = fn;
    this[j + 1 & wrapMask] = receiver;
    this[j + 2 & wrapMask] = arg;
    this._length = length;
  };
  Queue2.prototype.shift = function() {
    var front = this._front, ret = this[front];
    this[front] = undefined;
    this._front = front + 1 & this._capacity - 1;
    this._length--;
    return ret;
  };
  Queue2.prototype.length = function() {
    return this._length;
  };
  Queue2.prototype._checkCapacity = function(size2) {
    if (this._capacity < size2) {
      this._resizeTo(this._capacity << 1);
    }
  };
  Queue2.prototype._resizeTo = function(capacity) {
    var oldCapacity = this._capacity;
    this._capacity = capacity;
    var front = this._front;
    var length = this._length;
    var moveItemsCount = front + length & oldCapacity - 1;
    arrayMove(this, 0, this, oldCapacity, moveItemsCount);
  };
  module.exports = Queue2;
});

// node_modules/bluebird/js/release/async.js
var require_async = __commonJS((exports, module) => {
  var Async = function() {
    this._customScheduler = false;
    this._isTickUsed = false;
    this._lateQueue = new Queue2(16);
    this._normalQueue = new Queue2(16);
    this._haveDrainedQueues = false;
    var self2 = this;
    this.drainQueues = function() {
      self2._drainQueues();
    };
    this._schedule = schedule;
  };
  var AsyncInvokeLater = function(fn, receiver, arg) {
    this._lateQueue.push(fn, receiver, arg);
    this._queueTick();
  };
  var AsyncInvoke = function(fn, receiver, arg) {
    this._normalQueue.push(fn, receiver, arg);
    this._queueTick();
  };
  var AsyncSettlePromises = function(promise) {
    this._normalQueue._pushOne(promise);
    this._queueTick();
  };
  var _drainQueue = function(queue3) {
    while (queue3.length() > 0) {
      _drainQueueStep(queue3);
    }
  };
  var _drainQueueStep = function(queue3) {
    var fn = queue3.shift();
    if (typeof fn !== "function") {
      fn._settlePromises();
    } else {
      var receiver = queue3.shift();
      var arg = queue3.shift();
      fn.call(receiver, arg);
    }
  };
  var firstLineError;
  try {
    throw new Error;
  } catch (e) {
    firstLineError = e;
  }
  var schedule = require_schedule();
  var Queue2 = require_queue();
  Async.prototype.setScheduler = function(fn) {
    var prev = this._schedule;
    this._schedule = fn;
    this._customScheduler = true;
    return prev;
  };
  Async.prototype.hasCustomScheduler = function() {
    return this._customScheduler;
  };
  Async.prototype.haveItemsQueued = function() {
    return this._isTickUsed || this._haveDrainedQueues;
  };
  Async.prototype.fatalError = function(e, isNode) {
    if (isNode) {
      process.stderr.write("Fatal " + (e instanceof Error ? e.stack : e) + "\n");
      process.exit(2);
    } else {
      this.throwLater(e);
    }
  };
  Async.prototype.throwLater = function(fn, arg) {
    if (arguments.length === 1) {
      arg = fn;
      fn = function() {
        throw arg;
      };
    }
    if (typeof setTimeout !== "undefined") {
      setTimeout(function() {
        fn(arg);
      }, 0);
    } else
      try {
        this._schedule(function() {
          fn(arg);
        });
      } catch (e) {
        throw new Error(`No async scheduler available

    See http://goo.gl/MqrFmX
`);
      }
  };
  Async.prototype.invokeLater = AsyncInvokeLater;
  Async.prototype.invoke = AsyncInvoke;
  Async.prototype.settlePromises = AsyncSettlePromises;
  Async.prototype._drainQueues = function() {
    _drainQueue(this._normalQueue);
    this._reset();
    this._haveDrainedQueues = true;
    _drainQueue(this._lateQueue);
  };
  Async.prototype._queueTick = function() {
    if (!this._isTickUsed) {
      this._isTickUsed = true;
      this._schedule(this.drainQueues);
    }
  };
  Async.prototype._reset = function() {
    this._isTickUsed = false;
  };
  module.exports = Async;
  module.exports.firstLineError = firstLineError;
});

// node_modules/bluebird/js/release/errors.js
var require_errors2 = __commonJS((exports, module) => {
  var subError = function(nameProperty, defaultMessage) {
    function SubError(message2) {
      if (!(this instanceof SubError))
        return new SubError(message2);
      notEnumerableProp(this, "message", typeof message2 === "string" ? message2 : defaultMessage);
      notEnumerableProp(this, "name", nameProperty);
      if (Error.captureStackTrace) {
        Error.captureStackTrace(this, this.constructor);
      } else {
        Error.call(this);
      }
    }
    inherits(SubError, Error);
    return SubError;
  };
  var OperationalError = function(message2) {
    if (!(this instanceof OperationalError))
      return new OperationalError(message2);
    notEnumerableProp(this, "name", "OperationalError");
    notEnumerableProp(this, "message", message2);
    this.cause = message2;
    this["isOperational"] = true;
    if (message2 instanceof Error) {
      notEnumerableProp(this, "message", message2.message);
      notEnumerableProp(this, "stack", message2.stack);
    } else if (Error.captureStackTrace) {
      Error.captureStackTrace(this, this.constructor);
    }
  };
  var es5 = require_es5();
  var Objectfreeze = es5.freeze;
  var util3 = require_util3();
  var inherits = util3.inherits;
  var notEnumerableProp = util3.notEnumerableProp;
  var _TypeError;
  var _RangeError;
  var Warning = subError("Warning", "warning");
  var CancellationError = subError("CancellationError", "cancellation error");
  var TimeoutError = subError("TimeoutError", "timeout error");
  var AggregateError = subError("AggregateError", "aggregate error");
  try {
    _TypeError = TypeError;
    _RangeError = RangeError;
  } catch (e) {
    _TypeError = subError("TypeError", "type error");
    _RangeError = subError("RangeError", "range error");
  }
  var methods = "join pop push shift unshift slice filter forEach some every map indexOf lastIndexOf reduce reduceRight sort reverse".split(" ");
  for (i = 0;i < methods.length; ++i) {
    if (typeof Array.prototype[methods[i]] === "function") {
      AggregateError.prototype[methods[i]] = Array.prototype[methods[i]];
    }
  }
  var i;
  es5.defineProperty(AggregateError.prototype, "length", {
    value: 0,
    configurable: false,
    writable: true,
    enumerable: true
  });
  AggregateError.prototype["isOperational"] = true;
  var level = 0;
  AggregateError.prototype.toString = function() {
    var indent = Array(level * 4 + 1).join(" ");
    var ret = "\n" + indent + "AggregateError of:\n";
    level++;
    indent = Array(level * 4 + 1).join(" ");
    for (var i2 = 0;i2 < this.length; ++i2) {
      var str = this[i2] === this ? "[Circular AggregateError]" : this[i2] + "";
      var lines = str.split("\n");
      for (var j = 0;j < lines.length; ++j) {
        lines[j] = indent + lines[j];
      }
      str = lines.join("\n");
      ret += str + "\n";
    }
    level--;
    return ret;
  };
  inherits(OperationalError, Error);
  var errorTypes = Error["__BluebirdErrorTypes__"];
  if (!errorTypes) {
    errorTypes = Objectfreeze({
      CancellationError,
      TimeoutError,
      OperationalError,
      RejectionError: OperationalError,
      AggregateError
    });
    es5.defineProperty(Error, "__BluebirdErrorTypes__", {
      value: errorTypes,
      writable: false,
      enumerable: false,
      configurable: false
    });
  }
  module.exports = {
    Error,
    TypeError: _TypeError,
    RangeError: _RangeError,
    CancellationError: errorTypes.CancellationError,
    OperationalError: errorTypes.OperationalError,
    TimeoutError: errorTypes.TimeoutError,
    AggregateError: errorTypes.AggregateError,
    Warning
  };
});

// node_modules/bluebird/js/release/thenables.js
var require_thenables = __commonJS((exports, module) => {
  module.exports = function(Promise2, INTERNAL) {
    var util3 = require_util3();
    var errorObj = util3.errorObj;
    var isObject2 = util3.isObject;
    function tryConvertToPromise(obj, context3) {
      if (isObject2(obj)) {
        if (obj instanceof Promise2)
          return obj;
        var then = getThen(obj);
        if (then === errorObj) {
          if (context3)
            context3._pushContext();
          var ret = Promise2.reject(then.e);
          if (context3)
            context3._popContext();
          return ret;
        } else if (typeof then === "function") {
          if (isAnyBluebirdPromise(obj)) {
            var ret = new Promise2(INTERNAL);
            obj._then(ret._fulfill, ret._reject, undefined, ret, null);
            return ret;
          }
          return doThenable(obj, then, context3);
        }
      }
      return obj;
    }
    function doGetThen(obj) {
      return obj.then;
    }
    function getThen(obj) {
      try {
        return doGetThen(obj);
      } catch (e) {
        errorObj.e = e;
        return errorObj;
      }
    }
    var hasProp = {}.hasOwnProperty;
    function isAnyBluebirdPromise(obj) {
      try {
        return hasProp.call(obj, "_promise0");
      } catch (e) {
        return false;
      }
    }
    function doThenable(x, then, context3) {
      var promise = new Promise2(INTERNAL);
      var ret = promise;
      if (context3)
        context3._pushContext();
      promise._captureStackTrace();
      if (context3)
        context3._popContext();
      var synchronous = true;
      var result2 = util3.tryCatch(then).call(x, resolve, reject);
      synchronous = false;
      if (promise && result2 === errorObj) {
        promise._rejectCallback(result2.e, true, true);
        promise = null;
      }
      function resolve(value) {
        if (!promise)
          return;
        promise._resolveCallback(value);
        promise = null;
      }
      function reject(reason) {
        if (!promise)
          return;
        promise._rejectCallback(reason, synchronous, true);
        promise = null;
      }
      return ret;
    }
    return tryConvertToPromise;
  };
});

// node_modules/bluebird/js/release/promise_array.js
var require_promise_array = __commonJS((exports, module) => {
  module.exports = function(Promise2, INTERNAL, tryConvertToPromise, apiRejection, Proxyable) {
    var util3 = require_util3();
    var isArray = util3.isArray;
    function toResolutionValue(val) {
      switch (val) {
        case -2:
          return [];
        case -3:
          return {};
        case -6:
          return new Map;
      }
    }
    function PromiseArray(values2) {
      var promise = this._promise = new Promise2(INTERNAL);
      if (values2 instanceof Promise2) {
        promise._propagateFrom(values2, 3);
        values2.suppressUnhandledRejections();
      }
      promise._setOnCancel(this);
      this._values = values2;
      this._length = 0;
      this._totalResolved = 0;
      this._init(undefined, -2);
    }
    util3.inherits(PromiseArray, Proxyable);
    PromiseArray.prototype.length = function() {
      return this._length;
    };
    PromiseArray.prototype.promise = function() {
      return this._promise;
    };
    PromiseArray.prototype._init = function init(_, resolveValueIfEmpty) {
      var values2 = tryConvertToPromise(this._values, this._promise);
      if (values2 instanceof Promise2) {
        values2 = values2._target();
        var bitField = values2._bitField;
        this._values = values2;
        if ((bitField & 50397184) === 0) {
          this._promise._setAsyncGuaranteed();
          return values2._then(init, this._reject, undefined, this, resolveValueIfEmpty);
        } else if ((bitField & 33554432) !== 0) {
          values2 = values2._value();
        } else if ((bitField & 16777216) !== 0) {
          return this._reject(values2._reason());
        } else {
          return this._cancel();
        }
      }
      values2 = util3.asArray(values2);
      if (values2 === null) {
        var err = apiRejection("expecting an array or an iterable object but got " + util3.classString(values2)).reason();
        this._promise._rejectCallback(err, false);
        return;
      }
      if (values2.length === 0) {
        if (resolveValueIfEmpty === -5) {
          this._resolveEmptyArray();
        } else {
          this._resolve(toResolutionValue(resolveValueIfEmpty));
        }
        return;
      }
      this._iterate(values2);
    };
    PromiseArray.prototype._iterate = function(values2) {
      var len = this.getActualLength(values2.length);
      this._length = len;
      this._values = this.shouldCopyValues() ? new Array(len) : this._values;
      var result2 = this._promise;
      var isResolved = false;
      var bitField = null;
      for (var i = 0;i < len; ++i) {
        var maybePromise = tryConvertToPromise(values2[i], result2);
        if (maybePromise instanceof Promise2) {
          maybePromise = maybePromise._target();
          bitField = maybePromise._bitField;
        } else {
          bitField = null;
        }
        if (isResolved) {
          if (bitField !== null) {
            maybePromise.suppressUnhandledRejections();
          }
        } else if (bitField !== null) {
          if ((bitField & 50397184) === 0) {
            maybePromise._proxy(this, i);
            this._values[i] = maybePromise;
          } else if ((bitField & 33554432) !== 0) {
            isResolved = this._promiseFulfilled(maybePromise._value(), i);
          } else if ((bitField & 16777216) !== 0) {
            isResolved = this._promiseRejected(maybePromise._reason(), i);
          } else {
            isResolved = this._promiseCancelled(i);
          }
        } else {
          isResolved = this._promiseFulfilled(maybePromise, i);
        }
      }
      if (!isResolved)
        result2._setAsyncGuaranteed();
    };
    PromiseArray.prototype._isResolved = function() {
      return this._values === null;
    };
    PromiseArray.prototype._resolve = function(value) {
      this._values = null;
      this._promise._fulfill(value);
    };
    PromiseArray.prototype._cancel = function() {
      if (this._isResolved() || !this._promise._isCancellable())
        return;
      this._values = null;
      this._promise._cancel();
    };
    PromiseArray.prototype._reject = function(reason) {
      this._values = null;
      this._promise._rejectCallback(reason, false);
    };
    PromiseArray.prototype._promiseFulfilled = function(value, index) {
      this._values[index] = value;
      var totalResolved = ++this._totalResolved;
      if (totalResolved >= this._length) {
        this._resolve(this._values);
        return true;
      }
      return false;
    };
    PromiseArray.prototype._promiseCancelled = function() {
      this._cancel();
      return true;
    };
    PromiseArray.prototype._promiseRejected = function(reason) {
      this._totalResolved++;
      this._reject(reason);
      return true;
    };
    PromiseArray.prototype._resultCancelled = function() {
      if (this._isResolved())
        return;
      var values2 = this._values;
      this._cancel();
      if (values2 instanceof Promise2) {
        values2.cancel();
      } else {
        for (var i = 0;i < values2.length; ++i) {
          if (values2[i] instanceof Promise2) {
            values2[i].cancel();
          }
        }
      }
    };
    PromiseArray.prototype.shouldCopyValues = function() {
      return true;
    };
    PromiseArray.prototype.getActualLength = function(len) {
      return len;
    };
    return PromiseArray;
  };
});

// node_modules/bluebird/js/release/context.js
var require_context = __commonJS((exports, module) => {
  module.exports = function(Promise2) {
    var longStackTraces = false;
    var contextStack = [];
    Promise2.prototype._promiseCreated = function() {
    };
    Promise2.prototype._pushContext = function() {
    };
    Promise2.prototype._popContext = function() {
      return null;
    };
    Promise2._peekContext = Promise2.prototype._peekContext = function() {
    };
    function Context2() {
      this._trace = new Context2.CapturedTrace(peekContext());
    }
    Context2.prototype._pushContext = function() {
      if (this._trace !== undefined) {
        this._trace._promiseCreated = null;
        contextStack.push(this._trace);
      }
    };
    Context2.prototype._popContext = function() {
      if (this._trace !== undefined) {
        var trace = contextStack.pop();
        var ret = trace._promiseCreated;
        trace._promiseCreated = null;
        return ret;
      }
      return null;
    };
    function createContext() {
      if (longStackTraces)
        return new Context2;
    }
    function peekContext() {
      var lastIndex = contextStack.length - 1;
      if (lastIndex >= 0) {
        return contextStack[lastIndex];
      }
      return;
    }
    Context2.CapturedTrace = null;
    Context2.create = createContext;
    Context2.deactivateLongStackTraces = function() {
    };
    Context2.activateLongStackTraces = function() {
      var Promise_pushContext = Promise2.prototype._pushContext;
      var Promise_popContext = Promise2.prototype._popContext;
      var Promise_PeekContext = Promise2._peekContext;
      var Promise_peekContext = Promise2.prototype._peekContext;
      var Promise_promiseCreated = Promise2.prototype._promiseCreated;
      Context2.deactivateLongStackTraces = function() {
        Promise2.prototype._pushContext = Promise_pushContext;
        Promise2.prototype._popContext = Promise_popContext;
        Promise2._peekContext = Promise_PeekContext;
        Promise2.prototype._peekContext = Promise_peekContext;
        Promise2.prototype._promiseCreated = Promise_promiseCreated;
        longStackTraces = false;
      };
      longStackTraces = true;
      Promise2.prototype._pushContext = Context2.prototype._pushContext;
      Promise2.prototype._popContext = Context2.prototype._popContext;
      Promise2._peekContext = Promise2.prototype._peekContext = peekContext;
      Promise2.prototype._promiseCreated = function() {
        var ctx = this._peekContext();
        if (ctx && ctx._promiseCreated == null)
          ctx._promiseCreated = this;
      };
    };
    return Context2;
  };
});

// node_modules/bluebird/js/release/debuggability.js
var require_debuggability = __commonJS((exports, module) => {
  module.exports = function(Promise2, Context2, enableAsyncHooks, disableAsyncHooks) {
    var async = Promise2._async;
    var Warning = require_errors2().Warning;
    var util3 = require_util3();
    var es5 = require_es5();
    var canAttachTrace = util3.canAttachTrace;
    var unhandledRejectionHandled;
    var possiblyUnhandledRejection;
    var bluebirdFramePattern = /[\\\/]bluebird[\\\/]js[\\\/](release|debug|instrumented)/;
    var nodeFramePattern = /\((?:timers\.js):\d+:\d+\)/;
    var parseLinePattern = /[\/<\(](.+?):(\d+):(\d+)\)?\s*$/;
    var stackFramePattern = null;
    var formatStack = null;
    var indentStackFrames = false;
    var printWarning;
    var debugging = !!(util3.env("BLUEBIRD_DEBUG") != 0 && (util3.env("BLUEBIRD_DEBUG") || util3.env("NODE_ENV") === "development"));
    var warnings = !!(util3.env("BLUEBIRD_WARNINGS") != 0 && (debugging || util3.env("BLUEBIRD_WARNINGS")));
    var longStackTraces = !!(util3.env("BLUEBIRD_LONG_STACK_TRACES") != 0 && (debugging || util3.env("BLUEBIRD_LONG_STACK_TRACES")));
    var wForgottenReturn = util3.env("BLUEBIRD_W_FORGOTTEN_RETURN") != 0 && (warnings || !!util3.env("BLUEBIRD_W_FORGOTTEN_RETURN"));
    var deferUnhandledRejectionCheck;
    (function() {
      var promises = [];
      function unhandledRejectionCheck() {
        for (var i = 0;i < promises.length; ++i) {
          promises[i]._notifyUnhandledRejection();
        }
        unhandledRejectionClear();
      }
      function unhandledRejectionClear() {
        promises.length = 0;
      }
      deferUnhandledRejectionCheck = function(promise) {
        promises.push(promise);
        setTimeout(unhandledRejectionCheck, 1);
      };
      es5.defineProperty(Promise2, "_unhandledRejectionCheck", {
        value: unhandledRejectionCheck
      });
      es5.defineProperty(Promise2, "_unhandledRejectionClear", {
        value: unhandledRejectionClear
      });
    })();
    Promise2.prototype.suppressUnhandledRejections = function() {
      var target = this._target();
      target._bitField = target._bitField & ~1048576 | 524288;
    };
    Promise2.prototype._ensurePossibleRejectionHandled = function() {
      if ((this._bitField & 524288) !== 0)
        return;
      this._setRejectionIsUnhandled();
      deferUnhandledRejectionCheck(this);
    };
    Promise2.prototype._notifyUnhandledRejectionIsHandled = function() {
      fireRejectionEvent("rejectionHandled", unhandledRejectionHandled, undefined, this);
    };
    Promise2.prototype._setReturnedNonUndefined = function() {
      this._bitField = this._bitField | 268435456;
    };
    Promise2.prototype._returnedNonUndefined = function() {
      return (this._bitField & 268435456) !== 0;
    };
    Promise2.prototype._notifyUnhandledRejection = function() {
      if (this._isRejectionUnhandled()) {
        var reason = this._settledValue();
        this._setUnhandledRejectionIsNotified();
        fireRejectionEvent("unhandledRejection", possiblyUnhandledRejection, reason, this);
      }
    };
    Promise2.prototype._setUnhandledRejectionIsNotified = function() {
      this._bitField = this._bitField | 262144;
    };
    Promise2.prototype._unsetUnhandledRejectionIsNotified = function() {
      this._bitField = this._bitField & ~262144;
    };
    Promise2.prototype._isUnhandledRejectionNotified = function() {
      return (this._bitField & 262144) > 0;
    };
    Promise2.prototype._setRejectionIsUnhandled = function() {
      this._bitField = this._bitField | 1048576;
    };
    Promise2.prototype._unsetRejectionIsUnhandled = function() {
      this._bitField = this._bitField & ~1048576;
      if (this._isUnhandledRejectionNotified()) {
        this._unsetUnhandledRejectionIsNotified();
        this._notifyUnhandledRejectionIsHandled();
      }
    };
    Promise2.prototype._isRejectionUnhandled = function() {
      return (this._bitField & 1048576) > 0;
    };
    Promise2.prototype._warn = function(message2, shouldUseOwnTrace, promise) {
      return warn(message2, shouldUseOwnTrace, promise || this);
    };
    Promise2.onPossiblyUnhandledRejection = function(fn) {
      var context3 = Promise2._getContext();
      possiblyUnhandledRejection = util3.contextBind(context3, fn);
    };
    Promise2.onUnhandledRejectionHandled = function(fn) {
      var context3 = Promise2._getContext();
      unhandledRejectionHandled = util3.contextBind(context3, fn);
    };
    var disableLongStackTraces = function() {
    };
    Promise2.longStackTraces = function() {
      if (async.haveItemsQueued() && !config.longStackTraces) {
        throw new Error(`cannot enable long stack traces after promises have been created

    See http://goo.gl/MqrFmX
`);
      }
      if (!config.longStackTraces && longStackTracesIsSupported()) {
        var Promise_captureStackTrace = Promise2.prototype._captureStackTrace;
        var Promise_attachExtraTrace = Promise2.prototype._attachExtraTrace;
        var Promise_dereferenceTrace = Promise2.prototype._dereferenceTrace;
        config.longStackTraces = true;
        disableLongStackTraces = function() {
          if (async.haveItemsQueued() && !config.longStackTraces) {
            throw new Error(`cannot enable long stack traces after promises have been created

    See http://goo.gl/MqrFmX
`);
          }
          Promise2.prototype._captureStackTrace = Promise_captureStackTrace;
          Promise2.prototype._attachExtraTrace = Promise_attachExtraTrace;
          Promise2.prototype._dereferenceTrace = Promise_dereferenceTrace;
          Context2.deactivateLongStackTraces();
          config.longStackTraces = false;
        };
        Promise2.prototype._captureStackTrace = longStackTracesCaptureStackTrace;
        Promise2.prototype._attachExtraTrace = longStackTracesAttachExtraTrace;
        Promise2.prototype._dereferenceTrace = longStackTracesDereferenceTrace;
        Context2.activateLongStackTraces();
      }
    };
    Promise2.hasLongStackTraces = function() {
      return config.longStackTraces && longStackTracesIsSupported();
    };
    var legacyHandlers = {
      unhandledrejection: {
        before: function() {
          var ret = util3.global.onunhandledrejection;
          util3.global.onunhandledrejection = null;
          return ret;
        },
        after: function(fn) {
          util3.global.onunhandledrejection = fn;
        }
      },
      rejectionhandled: {
        before: function() {
          var ret = util3.global.onrejectionhandled;
          util3.global.onrejectionhandled = null;
          return ret;
        },
        after: function(fn) {
          util3.global.onrejectionhandled = fn;
        }
      }
    };
    var fireDomEvent = function() {
      var dispatch = function(legacy, e) {
        if (legacy) {
          var fn;
          try {
            fn = legacy.before();
            return !util3.global.dispatchEvent(e);
          } finally {
            legacy.after(fn);
          }
        } else {
          return !util3.global.dispatchEvent(e);
        }
      };
      try {
        if (typeof CustomEvent === "function") {
          var event = new CustomEvent("CustomEvent");
          util3.global.dispatchEvent(event);
          return function(name, event2) {
            name = name.toLowerCase();
            var eventData = {
              detail: event2,
              cancelable: true
            };
            var domEvent = new CustomEvent(name, eventData);
            es5.defineProperty(domEvent, "promise", { value: event2.promise });
            es5.defineProperty(domEvent, "reason", { value: event2.reason });
            return dispatch(legacyHandlers[name], domEvent);
          };
        } else if (typeof Event === "function") {
          var event = new Event("CustomEvent");
          util3.global.dispatchEvent(event);
          return function(name, event2) {
            name = name.toLowerCase();
            var domEvent = new Event(name, {
              cancelable: true
            });
            domEvent.detail = event2;
            es5.defineProperty(domEvent, "promise", { value: event2.promise });
            es5.defineProperty(domEvent, "reason", { value: event2.reason });
            return dispatch(legacyHandlers[name], domEvent);
          };
        } else {
          var event = document.createEvent("CustomEvent");
          event.initCustomEvent("testingtheevent", false, true, {});
          util3.global.dispatchEvent(event);
          return function(name, event2) {
            name = name.toLowerCase();
            var domEvent = document.createEvent("CustomEvent");
            domEvent.initCustomEvent(name, false, true, event2);
            return dispatch(legacyHandlers[name], domEvent);
          };
        }
      } catch (e) {
      }
      return function() {
        return false;
      };
    }();
    var fireGlobalEvent = function() {
      if (util3.isNode) {
        return function() {
          return process.emit.apply(process, arguments);
        };
      } else {
        if (!util3.global) {
          return function() {
            return false;
          };
        }
        return function(name) {
          var methodName = "on" + name.toLowerCase();
          var method = util3.global[methodName];
          if (!method)
            return false;
          method.apply(util3.global, [].slice.call(arguments, 1));
          return true;
        };
      }
    }();
    function generatePromiseLifecycleEventObject(name, promise) {
      return { promise };
    }
    var eventToObjectGenerator = {
      promiseCreated: generatePromiseLifecycleEventObject,
      promiseFulfilled: generatePromiseLifecycleEventObject,
      promiseRejected: generatePromiseLifecycleEventObject,
      promiseResolved: generatePromiseLifecycleEventObject,
      promiseCancelled: generatePromiseLifecycleEventObject,
      promiseChained: function(name, promise, child) {
        return { promise, child };
      },
      warning: function(name, warning) {
        return { warning };
      },
      unhandledRejection: function(name, reason, promise) {
        return { reason, promise };
      },
      rejectionHandled: generatePromiseLifecycleEventObject
    };
    var activeFireEvent = function(name) {
      var globalEventFired = false;
      try {
        globalEventFired = fireGlobalEvent.apply(null, arguments);
      } catch (e) {
        async.throwLater(e);
        globalEventFired = true;
      }
      var domEventFired = false;
      try {
        domEventFired = fireDomEvent(name, eventToObjectGenerator[name].apply(null, arguments));
      } catch (e) {
        async.throwLater(e);
        domEventFired = true;
      }
      return domEventFired || globalEventFired;
    };
    Promise2.config = function(opts) {
      opts = Object(opts);
      if ("longStackTraces" in opts) {
        if (opts.longStackTraces) {
          Promise2.longStackTraces();
        } else if (!opts.longStackTraces && Promise2.hasLongStackTraces()) {
          disableLongStackTraces();
        }
      }
      if ("warnings" in opts) {
        var warningsOption = opts.warnings;
        config.warnings = !!warningsOption;
        wForgottenReturn = config.warnings;
        if (util3.isObject(warningsOption)) {
          if ("wForgottenReturn" in warningsOption) {
            wForgottenReturn = !!warningsOption.wForgottenReturn;
          }
        }
      }
      if (("cancellation" in opts) && opts.cancellation && !config.cancellation) {
        if (async.haveItemsQueued()) {
          throw new Error("cannot enable cancellation after promises are in use");
        }
        Promise2.prototype._clearCancellationData = cancellationClearCancellationData;
        Promise2.prototype._propagateFrom = cancellationPropagateFrom;
        Promise2.prototype._onCancel = cancellationOnCancel;
        Promise2.prototype._setOnCancel = cancellationSetOnCancel;
        Promise2.prototype._attachCancellationCallback = cancellationAttachCancellationCallback;
        Promise2.prototype._execute = cancellationExecute;
        propagateFromFunction = cancellationPropagateFrom;
        config.cancellation = true;
      }
      if ("monitoring" in opts) {
        if (opts.monitoring && !config.monitoring) {
          config.monitoring = true;
          Promise2.prototype._fireEvent = activeFireEvent;
        } else if (!opts.monitoring && config.monitoring) {
          config.monitoring = false;
          Promise2.prototype._fireEvent = defaultFireEvent;
        }
      }
      if (("asyncHooks" in opts) && util3.nodeSupportsAsyncResource) {
        var prev = config.asyncHooks;
        var cur = !!opts.asyncHooks;
        if (prev !== cur) {
          config.asyncHooks = cur;
          if (cur) {
            enableAsyncHooks();
          } else {
            disableAsyncHooks();
          }
        }
      }
      return Promise2;
    };
    function defaultFireEvent() {
      return false;
    }
    Promise2.prototype._fireEvent = defaultFireEvent;
    Promise2.prototype._execute = function(executor, resolve, reject) {
      try {
        executor(resolve, reject);
      } catch (e) {
        return e;
      }
    };
    Promise2.prototype._onCancel = function() {
    };
    Promise2.prototype._setOnCancel = function(handler) {
    };
    Promise2.prototype._attachCancellationCallback = function(onCancel) {
    };
    Promise2.prototype._captureStackTrace = function() {
    };
    Promise2.prototype._attachExtraTrace = function() {
    };
    Promise2.prototype._dereferenceTrace = function() {
    };
    Promise2.prototype._clearCancellationData = function() {
    };
    Promise2.prototype._propagateFrom = function(parent, flags3) {
    };
    function cancellationExecute(executor, resolve, reject) {
      var promise = this;
      try {
        executor(resolve, reject, function(onCancel) {
          if (typeof onCancel !== "function") {
            throw new TypeError("onCancel must be a function, got: " + util3.toString(onCancel));
          }
          promise._attachCancellationCallback(onCancel);
        });
      } catch (e) {
        return e;
      }
    }
    function cancellationAttachCancellationCallback(onCancel) {
      if (!this._isCancellable())
        return this;
      var previousOnCancel = this._onCancel();
      if (previousOnCancel !== undefined) {
        if (util3.isArray(previousOnCancel)) {
          previousOnCancel.push(onCancel);
        } else {
          this._setOnCancel([previousOnCancel, onCancel]);
        }
      } else {
        this._setOnCancel(onCancel);
      }
    }
    function cancellationOnCancel() {
      return this._onCancelField;
    }
    function cancellationSetOnCancel(onCancel) {
      this._onCancelField = onCancel;
    }
    function cancellationClearCancellationData() {
      this._cancellationParent = undefined;
      this._onCancelField = undefined;
    }
    function cancellationPropagateFrom(parent, flags3) {
      if ((flags3 & 1) !== 0) {
        this._cancellationParent = parent;
        var branchesRemainingToCancel = parent._branchesRemainingToCancel;
        if (branchesRemainingToCancel === undefined) {
          branchesRemainingToCancel = 0;
        }
        parent._branchesRemainingToCancel = branchesRemainingToCancel + 1;
      }
      if ((flags3 & 2) !== 0 && parent._isBound()) {
        this._setBoundTo(parent._boundTo);
      }
    }
    function bindingPropagateFrom(parent, flags3) {
      if ((flags3 & 2) !== 0 && parent._isBound()) {
        this._setBoundTo(parent._boundTo);
      }
    }
    var propagateFromFunction = bindingPropagateFrom;
    function boundValueFunction() {
      var ret = this._boundTo;
      if (ret !== undefined) {
        if (ret instanceof Promise2) {
          if (ret.isFulfilled()) {
            return ret.value();
          } else {
            return;
          }
        }
      }
      return ret;
    }
    function longStackTracesCaptureStackTrace() {
      this._trace = new CapturedTrace(this._peekContext());
    }
    function longStackTracesAttachExtraTrace(error, ignoreSelf) {
      if (canAttachTrace(error)) {
        var trace = this._trace;
        if (trace !== undefined) {
          if (ignoreSelf)
            trace = trace._parent;
        }
        if (trace !== undefined) {
          trace.attachExtraTrace(error);
        } else if (!error.__stackCleaned__) {
          var parsed = parseStackAndMessage(error);
          util3.notEnumerableProp(error, "stack", parsed.message + "\n" + parsed.stack.join("\n"));
          util3.notEnumerableProp(error, "__stackCleaned__", true);
        }
      }
    }
    function longStackTracesDereferenceTrace() {
      this._trace = undefined;
    }
    function checkForgottenReturns(returnValue, promiseCreated, name, promise, parent) {
      if (returnValue === undefined && promiseCreated !== null && wForgottenReturn) {
        if (parent !== undefined && parent._returnedNonUndefined())
          return;
        if ((promise._bitField & 65535) === 0)
          return;
        if (name)
          name = name + " ";
        var handlerLine = "";
        var creatorLine = "";
        if (promiseCreated._trace) {
          var traceLines = promiseCreated._trace.stack.split("\n");
          var stack = cleanStack(traceLines);
          for (var i = stack.length - 1;i >= 0; --i) {
            var line = stack[i];
            if (!nodeFramePattern.test(line)) {
              var lineMatches = line.match(parseLinePattern);
              if (lineMatches) {
                handlerLine = "at " + lineMatches[1] + ":" + lineMatches[2] + ":" + lineMatches[3] + " ";
              }
              break;
            }
          }
          if (stack.length > 0) {
            var firstUserLine = stack[0];
            for (var i = 0;i < traceLines.length; ++i) {
              if (traceLines[i] === firstUserLine) {
                if (i > 0) {
                  creatorLine = "\n" + traceLines[i - 1];
                }
                break;
              }
            }
          }
        }
        var msg = "a promise was created in a " + name + "handler " + handlerLine + "but was not returned from it, see http://goo.gl/rRqMUw" + creatorLine;
        promise._warn(msg, true, promiseCreated);
      }
    }
    function deprecated(name, replacement) {
      var message2 = name + " is deprecated and will be removed in a future version.";
      if (replacement)
        message2 += " Use " + replacement + " instead.";
      return warn(message2);
    }
    function warn(message2, shouldUseOwnTrace, promise) {
      if (!config.warnings)
        return;
      var warning = new Warning(message2);
      var ctx;
      if (shouldUseOwnTrace) {
        promise._attachExtraTrace(warning);
      } else if (config.longStackTraces && (ctx = Promise2._peekContext())) {
        ctx.attachExtraTrace(warning);
      } else {
        var parsed = parseStackAndMessage(warning);
        warning.stack = parsed.message + "\n" + parsed.stack.join("\n");
      }
      if (!activeFireEvent("warning", warning)) {
        formatAndLogError(warning, "", true);
      }
    }
    function reconstructStack(message2, stacks) {
      for (var i = 0;i < stacks.length - 1; ++i) {
        stacks[i].push("From previous event:");
        stacks[i] = stacks[i].join("\n");
      }
      if (i < stacks.length) {
        stacks[i] = stacks[i].join("\n");
      }
      return message2 + "\n" + stacks.join("\n");
    }
    function removeDuplicateOrEmptyJumps(stacks) {
      for (var i = 0;i < stacks.length; ++i) {
        if (stacks[i].length === 0 || i + 1 < stacks.length && stacks[i][0] === stacks[i + 1][0]) {
          stacks.splice(i, 1);
          i--;
        }
      }
    }
    function removeCommonRoots(stacks) {
      var current = stacks[0];
      for (var i = 1;i < stacks.length; ++i) {
        var prev = stacks[i];
        var currentLastIndex = current.length - 1;
        var currentLastLine = current[currentLastIndex];
        var commonRootMeetPoint = -1;
        for (var j = prev.length - 1;j >= 0; --j) {
          if (prev[j] === currentLastLine) {
            commonRootMeetPoint = j;
            break;
          }
        }
        for (var j = commonRootMeetPoint;j >= 0; --j) {
          var line = prev[j];
          if (current[currentLastIndex] === line) {
            current.pop();
            currentLastIndex--;
          } else {
            break;
          }
        }
        current = prev;
      }
    }
    function cleanStack(stack) {
      var ret = [];
      for (var i = 0;i < stack.length; ++i) {
        var line = stack[i];
        var isTraceLine = line === "    (No stack trace)" || stackFramePattern.test(line);
        var isInternalFrame = isTraceLine && shouldIgnore(line);
        if (isTraceLine && !isInternalFrame) {
          if (indentStackFrames && line.charAt(0) !== " ") {
            line = "    " + line;
          }
          ret.push(line);
        }
      }
      return ret;
    }
    function stackFramesAsArray(error) {
      var stack = error.stack.replace(/\s+$/g, "").split("\n");
      for (var i = 0;i < stack.length; ++i) {
        var line = stack[i];
        if (line === "    (No stack trace)" || stackFramePattern.test(line)) {
          break;
        }
      }
      if (i > 0 && error.name != "SyntaxError") {
        stack = stack.slice(i);
      }
      return stack;
    }
    function parseStackAndMessage(error) {
      var stack = error.stack;
      var message2 = error.toString();
      stack = typeof stack === "string" && stack.length > 0 ? stackFramesAsArray(error) : ["    (No stack trace)"];
      return {
        message: message2,
        stack: error.name == "SyntaxError" ? stack : cleanStack(stack)
      };
    }
    function formatAndLogError(error, title, isSoft) {
      if (typeof console !== "undefined") {
        var message2;
        if (util3.isObject(error)) {
          var stack = error.stack;
          message2 = title + formatStack(stack, error);
        } else {
          message2 = title + String(error);
        }
        if (typeof printWarning === "function") {
          printWarning(message2, isSoft);
        } else if (typeof console.log === "function" || typeof console.log === "object") {
          console.log(message2);
        }
      }
    }
    function fireRejectionEvent(name, localHandler, reason, promise) {
      var localEventFired = false;
      try {
        if (typeof localHandler === "function") {
          localEventFired = true;
          if (name === "rejectionHandled") {
            localHandler(promise);
          } else {
            localHandler(reason, promise);
          }
        }
      } catch (e) {
        async.throwLater(e);
      }
      if (name === "unhandledRejection") {
        if (!activeFireEvent(name, reason, promise) && !localEventFired) {
          formatAndLogError(reason, "Unhandled rejection ");
        }
      } else {
        activeFireEvent(name, promise);
      }
    }
    function formatNonError(obj) {
      var str;
      if (typeof obj === "function") {
        str = "[function " + (obj.name || "anonymous") + "]";
      } else {
        str = obj && typeof obj.toString === "function" ? obj.toString() : util3.toString(obj);
        var ruselessToString = /\[object [a-zA-Z0-9$_]+\]/;
        if (ruselessToString.test(str)) {
          try {
            var newStr = JSON.stringify(obj);
            str = newStr;
          } catch (e) {
          }
        }
        if (str.length === 0) {
          str = "(empty array)";
        }
      }
      return "(<" + snip(str) + ">, no stack trace)";
    }
    function snip(str) {
      var maxChars = 41;
      if (str.length < maxChars) {
        return str;
      }
      return str.substr(0, maxChars - 3) + "...";
    }
    function longStackTracesIsSupported() {
      return typeof captureStackTrace === "function";
    }
    var shouldIgnore = function() {
      return false;
    };
    var parseLineInfoRegex = /[\/<\(]([^:\/]+):(\d+):(?:\d+)\)?\s*$/;
    function parseLineInfo(line) {
      var matches = line.match(parseLineInfoRegex);
      if (matches) {
        return {
          fileName: matches[1],
          line: parseInt(matches[2], 10)
        };
      }
    }
    function setBounds(firstLineError, lastLineError) {
      if (!longStackTracesIsSupported())
        return;
      var firstStackLines = (firstLineError.stack || "").split("\n");
      var lastStackLines = (lastLineError.stack || "").split("\n");
      var firstIndex = -1;
      var lastIndex = -1;
      var firstFileName;
      var lastFileName;
      for (var i = 0;i < firstStackLines.length; ++i) {
        var result2 = parseLineInfo(firstStackLines[i]);
        if (result2) {
          firstFileName = result2.fileName;
          firstIndex = result2.line;
          break;
        }
      }
      for (var i = 0;i < lastStackLines.length; ++i) {
        var result2 = parseLineInfo(lastStackLines[i]);
        if (result2) {
          lastFileName = result2.fileName;
          lastIndex = result2.line;
          break;
        }
      }
      if (firstIndex < 0 || lastIndex < 0 || !firstFileName || !lastFileName || firstFileName !== lastFileName || firstIndex >= lastIndex) {
        return;
      }
      shouldIgnore = function(line) {
        if (bluebirdFramePattern.test(line))
          return true;
        var info = parseLineInfo(line);
        if (info) {
          if (info.fileName === firstFileName && (firstIndex <= info.line && info.line <= lastIndex)) {
            return true;
          }
        }
        return false;
      };
    }
    function CapturedTrace(parent) {
      this._parent = parent;
      this._promisesCreated = 0;
      var length = this._length = 1 + (parent === undefined ? 0 : parent._length);
      captureStackTrace(this, CapturedTrace);
      if (length > 32)
        this.uncycle();
    }
    util3.inherits(CapturedTrace, Error);
    Context2.CapturedTrace = CapturedTrace;
    CapturedTrace.prototype.uncycle = function() {
      var length = this._length;
      if (length < 2)
        return;
      var nodes = [];
      var stackToIndex = {};
      for (var i = 0, node4 = this;node4 !== undefined; ++i) {
        nodes.push(node4);
        node4 = node4._parent;
      }
      length = this._length = i;
      for (var i = length - 1;i >= 0; --i) {
        var stack = nodes[i].stack;
        if (stackToIndex[stack] === undefined) {
          stackToIndex[stack] = i;
        }
      }
      for (var i = 0;i < length; ++i) {
        var currentStack = nodes[i].stack;
        var index = stackToIndex[currentStack];
        if (index !== undefined && index !== i) {
          if (index > 0) {
            nodes[index - 1]._parent = undefined;
            nodes[index - 1]._length = 1;
          }
          nodes[i]._parent = undefined;
          nodes[i]._length = 1;
          var cycleEdgeNode = i > 0 ? nodes[i - 1] : this;
          if (index < length - 1) {
            cycleEdgeNode._parent = nodes[index + 1];
            cycleEdgeNode._parent.uncycle();
            cycleEdgeNode._length = cycleEdgeNode._parent._length + 1;
          } else {
            cycleEdgeNode._parent = undefined;
            cycleEdgeNode._length = 1;
          }
          var currentChildLength = cycleEdgeNode._length + 1;
          for (var j = i - 2;j >= 0; --j) {
            nodes[j]._length = currentChildLength;
            currentChildLength++;
          }
          return;
        }
      }
    };
    CapturedTrace.prototype.attachExtraTrace = function(error) {
      if (error.__stackCleaned__)
        return;
      this.uncycle();
      var parsed = parseStackAndMessage(error);
      var message2 = parsed.message;
      var stacks = [parsed.stack];
      var trace = this;
      while (trace !== undefined) {
        stacks.push(cleanStack(trace.stack.split("\n")));
        trace = trace._parent;
      }
      removeCommonRoots(stacks);
      removeDuplicateOrEmptyJumps(stacks);
      util3.notEnumerableProp(error, "stack", reconstructStack(message2, stacks));
      util3.notEnumerableProp(error, "__stackCleaned__", true);
    };
    var captureStackTrace = function stackDetection() {
      var v8stackFramePattern = /^\s*at\s*/;
      var v8stackFormatter = function(stack, error) {
        if (typeof stack === "string")
          return stack;
        if (error.name !== undefined && error.message !== undefined) {
          return error.toString();
        }
        return formatNonError(error);
      };
      if (typeof Error.stackTraceLimit === "number" && typeof Error.captureStackTrace === "function") {
        Error.stackTraceLimit += 6;
        stackFramePattern = v8stackFramePattern;
        formatStack = v8stackFormatter;
        var captureStackTrace2 = Error.captureStackTrace;
        shouldIgnore = function(line) {
          return bluebirdFramePattern.test(line);
        };
        return function(receiver, ignoreUntil) {
          Error.stackTraceLimit += 6;
          captureStackTrace2(receiver, ignoreUntil);
          Error.stackTraceLimit -= 6;
        };
      }
      var err = new Error;
      if (typeof err.stack === "string" && err.stack.split("\n")[0].indexOf("stackDetection@") >= 0) {
        stackFramePattern = /@/;
        formatStack = v8stackFormatter;
        indentStackFrames = true;
        return function captureStackTrace(o) {
          o.stack = new Error().stack;
        };
      }
      var hasStackAfterThrow;
      try {
        throw new Error;
      } catch (e) {
        hasStackAfterThrow = ("stack" in e);
      }
      if (!("stack" in err) && hasStackAfterThrow && typeof Error.stackTraceLimit === "number") {
        stackFramePattern = v8stackFramePattern;
        formatStack = v8stackFormatter;
        return function captureStackTrace(o) {
          Error.stackTraceLimit += 6;
          try {
            throw new Error;
          } catch (e) {
            o.stack = e.stack;
          }
          Error.stackTraceLimit -= 6;
        };
      }
      formatStack = function(stack, error) {
        if (typeof stack === "string")
          return stack;
        if ((typeof error === "object" || typeof error === "function") && error.name !== undefined && error.message !== undefined) {
          return error.toString();
        }
        return formatNonError(error);
      };
      return null;
    }([]);
    if (typeof console !== "undefined" && typeof console.warn !== "undefined") {
      printWarning = function(message2) {
        console.warn(message2);
      };
      if (util3.isNode && process.stderr.isTTY) {
        printWarning = function(message2, isSoft) {
          var color = isSoft ? "\x1B[33m" : "\x1B[31m";
          console.warn(color + message2 + `\x1B[0m
`);
        };
      } else if (!util3.isNode && typeof new Error().stack === "string") {
        printWarning = function(message2, isSoft) {
          console.warn("%c" + message2, isSoft ? "color: darkorange" : "color: red");
        };
      }
    }
    var config = {
      warnings,
      longStackTraces: false,
      cancellation: false,
      monitoring: false,
      asyncHooks: false
    };
    if (longStackTraces)
      Promise2.longStackTraces();
    return {
      asyncHooks: function() {
        return config.asyncHooks;
      },
      longStackTraces: function() {
        return config.longStackTraces;
      },
      warnings: function() {
        return config.warnings;
      },
      cancellation: function() {
        return config.cancellation;
      },
      monitoring: function() {
        return config.monitoring;
      },
      propagateFromFunction: function() {
        return propagateFromFunction;
      },
      boundValueFunction: function() {
        return boundValueFunction;
      },
      checkForgottenReturns,
      setBounds,
      warn,
      deprecated,
      CapturedTrace,
      fireDomEvent,
      fireGlobalEvent
    };
  };
});

// node_modules/bluebird/js/release/catch_filter.js
var require_catch_filter = __commonJS((exports, module) => {
  module.exports = function(NEXT_FILTER) {
    var util3 = require_util3();
    var getKeys = require_es5().keys;
    var tryCatch = util3.tryCatch;
    var errorObj = util3.errorObj;
    function catchFilter(instances, cb, promise) {
      return function(e) {
        var boundTo = promise._boundValue();
        predicateLoop:
          for (var i = 0;i < instances.length; ++i) {
            var item = instances[i];
            if (item === Error || item != null && item.prototype instanceof Error) {
              if (e instanceof item) {
                return tryCatch(cb).call(boundTo, e);
              }
            } else if (typeof item === "function") {
              var matchesPredicate = tryCatch(item).call(boundTo, e);
              if (matchesPredicate === errorObj) {
                return matchesPredicate;
              } else if (matchesPredicate) {
                return tryCatch(cb).call(boundTo, e);
              }
            } else if (util3.isObject(e)) {
              var keys = getKeys(item);
              for (var j = 0;j < keys.length; ++j) {
                var key = keys[j];
                if (item[key] != e[key]) {
                  continue predicateLoop;
                }
              }
              return tryCatch(cb).call(boundTo, e);
            }
          }
        return NEXT_FILTER;
      };
    }
    return catchFilter;
  };
});

// node_modules/bluebird/js/release/finally.js
var require_finally = __commonJS((exports, module) => {
  module.exports = function(Promise2, tryConvertToPromise, NEXT_FILTER) {
    var util3 = require_util3();
    var CancellationError = Promise2.CancellationError;
    var errorObj = util3.errorObj;
    var catchFilter = require_catch_filter()(NEXT_FILTER);
    function PassThroughHandlerContext(promise, type, handler) {
      this.promise = promise;
      this.type = type;
      this.handler = handler;
      this.called = false;
      this.cancelPromise = null;
    }
    PassThroughHandlerContext.prototype.isFinallyHandler = function() {
      return this.type === 0;
    };
    function FinallyHandlerCancelReaction(finallyHandler2) {
      this.finallyHandler = finallyHandler2;
    }
    FinallyHandlerCancelReaction.prototype._resultCancelled = function() {
      checkCancel(this.finallyHandler);
    };
    function checkCancel(ctx, reason) {
      if (ctx.cancelPromise != null) {
        if (arguments.length > 1) {
          ctx.cancelPromise._reject(reason);
        } else {
          ctx.cancelPromise._cancel();
        }
        ctx.cancelPromise = null;
        return true;
      }
      return false;
    }
    function succeed() {
      return finallyHandler.call(this, this.promise._target()._settledValue());
    }
    function fail(reason) {
      if (checkCancel(this, reason))
        return;
      errorObj.e = reason;
      return errorObj;
    }
    function finallyHandler(reasonOrValue) {
      var promise = this.promise;
      var handler = this.handler;
      if (!this.called) {
        this.called = true;
        var ret = this.isFinallyHandler() ? handler.call(promise._boundValue()) : handler.call(promise._boundValue(), reasonOrValue);
        if (ret === NEXT_FILTER) {
          return ret;
        } else if (ret !== undefined) {
          promise._setReturnedNonUndefined();
          var maybePromise = tryConvertToPromise(ret, promise);
          if (maybePromise instanceof Promise2) {
            if (this.cancelPromise != null) {
              if (maybePromise._isCancelled()) {
                var reason = new CancellationError("late cancellation observer");
                promise._attachExtraTrace(reason);
                errorObj.e = reason;
                return errorObj;
              } else if (maybePromise.isPending()) {
                maybePromise._attachCancellationCallback(new FinallyHandlerCancelReaction(this));
              }
            }
            return maybePromise._then(succeed, fail, undefined, this, undefined);
          }
        }
      }
      if (promise.isRejected()) {
        checkCancel(this);
        errorObj.e = reasonOrValue;
        return errorObj;
      } else {
        checkCancel(this);
        return reasonOrValue;
      }
    }
    Promise2.prototype._passThrough = function(handler, type, success, fail2) {
      if (typeof handler !== "function")
        return this.then();
      return this._then(success, fail2, undefined, new PassThroughHandlerContext(this, type, handler), undefined);
    };
    Promise2.prototype.lastly = Promise2.prototype["finally"] = function(handler) {
      return this._passThrough(handler, 0, finallyHandler, finallyHandler);
    };
    Promise2.prototype.tap = function(handler) {
      return this._passThrough(handler, 1, finallyHandler);
    };
    Promise2.prototype.tapCatch = function(handlerOrPredicate) {
      var len = arguments.length;
      if (len === 1) {
        return this._passThrough(handlerOrPredicate, 1, undefined, finallyHandler);
      } else {
        var catchInstances = new Array(len - 1), j = 0, i;
        for (i = 0;i < len - 1; ++i) {
          var item = arguments[i];
          if (util3.isObject(item)) {
            catchInstances[j++] = item;
          } else {
            return Promise2.reject(new TypeError("tapCatch statement predicate: expecting an object but got " + util3.classString(item)));
          }
        }
        catchInstances.length = j;
        var handler = arguments[i];
        return this._passThrough(catchFilter(catchInstances, handler, this), 1, undefined, finallyHandler);
      }
    };
    return PassThroughHandlerContext;
  };
});

// node_modules/bluebird/js/release/nodeback.js
var require_nodeback = __commonJS((exports, module) => {
  var isUntypedError = function(obj) {
    return obj instanceof Error && es5.getPrototypeOf(obj) === Error.prototype;
  };
  var wrapAsOperationalError = function(obj) {
    var ret;
    if (isUntypedError(obj)) {
      ret = new OperationalError(obj);
      ret.name = obj.name;
      ret.message = obj.message;
      ret.stack = obj.stack;
      var keys = es5.keys(obj);
      for (var i = 0;i < keys.length; ++i) {
        var key = keys[i];
        if (!rErrorKey.test(key)) {
          ret[key] = obj[key];
        }
      }
      return ret;
    }
    util3.markAsOriginatingFromRejection(obj);
    return obj;
  };
  var nodebackForPromise = function(promise, multiArgs) {
    return function(err, value) {
      if (promise === null)
        return;
      if (err) {
        var wrapped = wrapAsOperationalError(maybeWrapAsError(err));
        promise._attachExtraTrace(wrapped);
        promise._reject(wrapped);
      } else if (!multiArgs) {
        promise._fulfill(value);
      } else {
        var $_len = arguments.length;
        var args = new Array(Math.max($_len - 1, 0));
        for (var $_i = 1;$_i < $_len; ++$_i) {
          args[$_i - 1] = arguments[$_i];
        }
        promise._fulfill(args);
      }
      promise = null;
    };
  };
  var util3 = require_util3();
  var maybeWrapAsError = util3.maybeWrapAsError;
  var errors15 = require_errors2();
  var OperationalError = errors15.OperationalError;
  var es5 = require_es5();
  var rErrorKey = /^(?:name|message|stack|cause)$/;
  module.exports = nodebackForPromise;
});

// node_modules/bluebird/js/release/method.js
var require_method = __commonJS((exports, module) => {
  module.exports = function(Promise2, INTERNAL, tryConvertToPromise, apiRejection, debug) {
    var util3 = require_util3();
    var tryCatch = util3.tryCatch;
    Promise2.method = function(fn) {
      if (typeof fn !== "function") {
        throw new Promise2.TypeError("expecting a function but got " + util3.classString(fn));
      }
      return function() {
        var ret = new Promise2(INTERNAL);
        ret._captureStackTrace();
        ret._pushContext();
        var value = tryCatch(fn).apply(this, arguments);
        var promiseCreated = ret._popContext();
        debug.checkForgottenReturns(value, promiseCreated, "Promise.method", ret);
        ret._resolveFromSyncValue(value);
        return ret;
      };
    };
    Promise2.attempt = Promise2["try"] = function(fn) {
      if (typeof fn !== "function") {
        return apiRejection("expecting a function but got " + util3.classString(fn));
      }
      var ret = new Promise2(INTERNAL);
      ret._captureStackTrace();
      ret._pushContext();
      var value;
      if (arguments.length > 1) {
        debug.deprecated("calling Promise.try with more than 1 argument");
        var arg = arguments[1];
        var ctx = arguments[2];
        value = util3.isArray(arg) ? tryCatch(fn).apply(ctx, arg) : tryCatch(fn).call(ctx, arg);
      } else {
        value = tryCatch(fn)();
      }
      var promiseCreated = ret._popContext();
      debug.checkForgottenReturns(value, promiseCreated, "Promise.try", ret);
      ret._resolveFromSyncValue(value);
      return ret;
    };
    Promise2.prototype._resolveFromSyncValue = function(value) {
      if (value === util3.errorObj) {
        this._rejectCallback(value.e, false);
      } else {
        this._resolveCallback(value, true);
      }
    };
  };
});

// node_modules/bluebird/js/release/bind.js
var require_bind = __commonJS((exports, module) => {
  module.exports = function(Promise2, INTERNAL, tryConvertToPromise, debug) {
    var calledBind = false;
    var rejectThis = function(_, e) {
      this._reject(e);
    };
    var targetRejected = function(e, context3) {
      context3.promiseRejectionQueued = true;
      context3.bindingPromise._then(rejectThis, rejectThis, null, this, e);
    };
    var bindingResolved = function(thisArg, context3) {
      if ((this._bitField & 50397184) === 0) {
        this._resolveCallback(context3.target);
      }
    };
    var bindingRejected = function(e, context3) {
      if (!context3.promiseRejectionQueued)
        this._reject(e);
    };
    Promise2.prototype.bind = function(thisArg) {
      if (!calledBind) {
        calledBind = true;
        Promise2.prototype._propagateFrom = debug.propagateFromFunction();
        Promise2.prototype._boundValue = debug.boundValueFunction();
      }
      var maybePromise = tryConvertToPromise(thisArg);
      var ret = new Promise2(INTERNAL);
      ret._propagateFrom(this, 1);
      var target = this._target();
      ret._setBoundTo(maybePromise);
      if (maybePromise instanceof Promise2) {
        var context3 = {
          promiseRejectionQueued: false,
          promise: ret,
          target,
          bindingPromise: maybePromise
        };
        target._then(INTERNAL, targetRejected, undefined, ret, context3);
        maybePromise._then(bindingResolved, bindingRejected, undefined, ret, context3);
        ret._setOnCancel(maybePromise);
      } else {
        ret._resolveCallback(target);
      }
      return ret;
    };
    Promise2.prototype._setBoundTo = function(obj) {
      if (obj !== undefined) {
        this._bitField = this._bitField | 2097152;
        this._boundTo = obj;
      } else {
        this._bitField = this._bitField & ~2097152;
      }
    };
    Promise2.prototype._isBound = function() {
      return (this._bitField & 2097152) === 2097152;
    };
    Promise2.bind = function(thisArg, value) {
      return Promise2.resolve(value).bind(thisArg);
    };
  };
});

// node_modules/bluebird/js/release/cancel.js
var require_cancel = __commonJS((exports, module) => {
  module.exports = function(Promise2, PromiseArray, apiRejection, debug) {
    var util3 = require_util3();
    var tryCatch = util3.tryCatch;
    var errorObj = util3.errorObj;
    var async = Promise2._async;
    Promise2.prototype["break"] = Promise2.prototype.cancel = function() {
      if (!debug.cancellation())
        return this._warn("cancellation is disabled");
      var promise = this;
      var child = promise;
      while (promise._isCancellable()) {
        if (!promise._cancelBy(child)) {
          if (child._isFollowing()) {
            child._followee().cancel();
          } else {
            child._cancelBranched();
          }
          break;
        }
        var parent = promise._cancellationParent;
        if (parent == null || !parent._isCancellable()) {
          if (promise._isFollowing()) {
            promise._followee().cancel();
          } else {
            promise._cancelBranched();
          }
          break;
        } else {
          if (promise._isFollowing())
            promise._followee().cancel();
          promise._setWillBeCancelled();
          child = promise;
          promise = parent;
        }
      }
    };
    Promise2.prototype._branchHasCancelled = function() {
      this._branchesRemainingToCancel--;
    };
    Promise2.prototype._enoughBranchesHaveCancelled = function() {
      return this._branchesRemainingToCancel === undefined || this._branchesRemainingToCancel <= 0;
    };
    Promise2.prototype._cancelBy = function(canceller) {
      if (canceller === this) {
        this._branchesRemainingToCancel = 0;
        this._invokeOnCancel();
        return true;
      } else {
        this._branchHasCancelled();
        if (this._enoughBranchesHaveCancelled()) {
          this._invokeOnCancel();
          return true;
        }
      }
      return false;
    };
    Promise2.prototype._cancelBranched = function() {
      if (this._enoughBranchesHaveCancelled()) {
        this._cancel();
      }
    };
    Promise2.prototype._cancel = function() {
      if (!this._isCancellable())
        return;
      this._setCancelled();
      async.invoke(this._cancelPromises, this, undefined);
    };
    Promise2.prototype._cancelPromises = function() {
      if (this._length() > 0)
        this._settlePromises();
    };
    Promise2.prototype._unsetOnCancel = function() {
      this._onCancelField = undefined;
    };
    Promise2.prototype._isCancellable = function() {
      return this.isPending() && !this._isCancelled();
    };
    Promise2.prototype.isCancellable = function() {
      return this.isPending() && !this.isCancelled();
    };
    Promise2.prototype._doInvokeOnCancel = function(onCancelCallback, internalOnly) {
      if (util3.isArray(onCancelCallback)) {
        for (var i = 0;i < onCancelCallback.length; ++i) {
          this._doInvokeOnCancel(onCancelCallback[i], internalOnly);
        }
      } else if (onCancelCallback !== undefined) {
        if (typeof onCancelCallback === "function") {
          if (!internalOnly) {
            var e = tryCatch(onCancelCallback).call(this._boundValue());
            if (e === errorObj) {
              this._attachExtraTrace(e.e);
              async.throwLater(e.e);
            }
          }
        } else {
          onCancelCallback._resultCancelled(this);
        }
      }
    };
    Promise2.prototype._invokeOnCancel = function() {
      var onCancelCallback = this._onCancel();
      this._unsetOnCancel();
      async.invoke(this._doInvokeOnCancel, this, onCancelCallback);
    };
    Promise2.prototype._invokeInternalOnCancel = function() {
      if (this._isCancellable()) {
        this._doInvokeOnCancel(this._onCancel(), true);
        this._unsetOnCancel();
      }
    };
    Promise2.prototype._resultCancelled = function() {
      this.cancel();
    };
  };
});

// node_modules/bluebird/js/release/direct_resolve.js
var require_direct_resolve = __commonJS((exports, module) => {
  module.exports = function(Promise2) {
    function returner() {
      return this.value;
    }
    function thrower() {
      throw this.reason;
    }
    Promise2.prototype["return"] = Promise2.prototype.thenReturn = function(value) {
      if (value instanceof Promise2)
        value.suppressUnhandledRejections();
      return this._then(returner, undefined, undefined, { value }, undefined);
    };
    Promise2.prototype["throw"] = Promise2.prototype.thenThrow = function(reason) {
      return this._then(thrower, undefined, undefined, { reason }, undefined);
    };
    Promise2.prototype.catchThrow = function(reason) {
      if (arguments.length <= 1) {
        return this._then(undefined, thrower, undefined, { reason }, undefined);
      } else {
        var _reason = arguments[1];
        var handler = function() {
          throw _reason;
        };
        return this.caught(reason, handler);
      }
    };
    Promise2.prototype.catchReturn = function(value) {
      if (arguments.length <= 1) {
        if (value instanceof Promise2)
          value.suppressUnhandledRejections();
        return this._then(undefined, returner, undefined, { value }, undefined);
      } else {
        var _value = arguments[1];
        if (_value instanceof Promise2)
          _value.suppressUnhandledRejections();
        var handler = function() {
          return _value;
        };
        return this.caught(value, handler);
      }
    };
  };
});

// node_modules/bluebird/js/release/synchronous_inspection.js
var require_synchronous_inspection = __commonJS((exports, module) => {
  module.exports = function(Promise2) {
    function PromiseInspection(promise) {
      if (promise !== undefined) {
        promise = promise._target();
        this._bitField = promise._bitField;
        this._settledValueField = promise._isFateSealed() ? promise._settledValue() : undefined;
      } else {
        this._bitField = 0;
        this._settledValueField = undefined;
      }
    }
    PromiseInspection.prototype._settledValue = function() {
      return this._settledValueField;
    };
    var value = PromiseInspection.prototype.value = function() {
      if (!this.isFulfilled()) {
        throw new TypeError(`cannot get fulfillment value of a non-fulfilled promise

    See http://goo.gl/MqrFmX
`);
      }
      return this._settledValue();
    };
    var reason = PromiseInspection.prototype.error = PromiseInspection.prototype.reason = function() {
      if (!this.isRejected()) {
        throw new TypeError(`cannot get rejection reason of a non-rejected promise

    See http://goo.gl/MqrFmX
`);
      }
      return this._settledValue();
    };
    var isFulfilled = PromiseInspection.prototype.isFulfilled = function() {
      return (this._bitField & 33554432) !== 0;
    };
    var isRejected = PromiseInspection.prototype.isRejected = function() {
      return (this._bitField & 16777216) !== 0;
    };
    var isPending = PromiseInspection.prototype.isPending = function() {
      return (this._bitField & 50397184) === 0;
    };
    var isResolved = PromiseInspection.prototype.isResolved = function() {
      return (this._bitField & 50331648) !== 0;
    };
    PromiseInspection.prototype.isCancelled = function() {
      return (this._bitField & 8454144) !== 0;
    };
    Promise2.prototype.__isCancelled = function() {
      return (this._bitField & 65536) === 65536;
    };
    Promise2.prototype._isCancelled = function() {
      return this._target().__isCancelled();
    };
    Promise2.prototype.isCancelled = function() {
      return (this._target()._bitField & 8454144) !== 0;
    };
    Promise2.prototype.isPending = function() {
      return isPending.call(this._target());
    };
    Promise2.prototype.isRejected = function() {
      return isRejected.call(this._target());
    };
    Promise2.prototype.isFulfilled = function() {
      return isFulfilled.call(this._target());
    };
    Promise2.prototype.isResolved = function() {
      return isResolved.call(this._target());
    };
    Promise2.prototype.value = function() {
      return value.call(this._target());
    };
    Promise2.prototype.reason = function() {
      var target = this._target();
      target._unsetRejectionIsUnhandled();
      return reason.call(target);
    };
    Promise2.prototype._value = function() {
      return this._settledValue();
    };
    Promise2.prototype._reason = function() {
      this._unsetRejectionIsUnhandled();
      return this._settledValue();
    };
    Promise2.PromiseInspection = PromiseInspection;
  };
});

// node_modules/bluebird/js/release/join.js
var require_join = __commonJS((exports, module) => {
  module.exports = function(Promise2, PromiseArray, tryConvertToPromise, INTERNAL, async) {
    var util3 = require_util3();
    var canEvaluate = util3.canEvaluate;
    var tryCatch = util3.tryCatch;
    var errorObj = util3.errorObj;
    var reject;
    if (true) {
      if (canEvaluate) {
        var thenCallback = function(i2) {
          return new Function("value", "holder", `                             
            'use strict';                                                    
            holder.pIndex = value;                                           
            holder.checkFulfillment(this);                                   
            `.replace(/Index/g, i2));
        };
        var promiseSetter = function(i2) {
          return new Function("promise", "holder", `                           
            'use strict';                                                    
            holder.pIndex = promise;                                         
            `.replace(/Index/g, i2));
        };
        var generateHolderClass = function(total) {
          var props = new Array(total);
          for (var i2 = 0;i2 < props.length; ++i2) {
            props[i2] = "this.p" + (i2 + 1);
          }
          var assignment = props.join(" = ") + " = null;";
          var cancellationCode = "var promise;\n" + props.map(function(prop) {
            return `                                                         
                promise = ` + prop + `;                                      
                if (promise instanceof Promise) {                            
                    promise.cancel();                                        
                }                                                            
            `;
          }).join("\n");
          var passedArguments = props.join(", ");
          var name = "Holder$" + total;
          var code = `return function(tryCatch, errorObj, Promise, async) {    
            'use strict';                                                    
            function [TheName](fn) {                                         
                [TheProperties]                                              
                this.fn = fn;                                                
                this.asyncNeeded = true;                                     
                this.now = 0;                                                
            }                                                                
                                                                             
            [TheName].prototype._callFunction = function(promise) {          
                promise._pushContext();                                      
                var ret = tryCatch(this.fn)([ThePassedArguments]);           
                promise._popContext();                                       
                if (ret === errorObj) {                                      
                    promise._rejectCallback(ret.e, false);                   
                } else {                                                     
                    promise._resolveCallback(ret);                           
                }                                                            
            };                                                               
                                                                             
            [TheName].prototype.checkFulfillment = function(promise) {       
                var now = ++this.now;                                        
                if (now === [TheTotal]) {                                    
                    if (this.asyncNeeded) {                                  
                        async.invoke(this._callFunction, this, promise);     
                    } else {                                                 
                        this._callFunction(promise);                         
                    }                                                        
                                                                             
                }                                                            
            };                                                               
                                                                             
            [TheName].prototype._resultCancelled = function() {              
                [CancellationCode]                                           
            };                                                               
                                                                             
            return [TheName];                                                
        }(tryCatch, errorObj, Promise, async);                               
        `;
          code = code.replace(/\[TheName\]/g, name).replace(/\[TheTotal\]/g, total).replace(/\[ThePassedArguments\]/g, passedArguments).replace(/\[TheProperties\]/g, assignment).replace(/\[CancellationCode\]/g, cancellationCode);
          return new Function("tryCatch", "errorObj", "Promise", "async", code)(tryCatch, errorObj, Promise2, async);
        };
        var holderClasses = [];
        var thenCallbacks = [];
        var promiseSetters = [];
        for (var i = 0;i < 8; ++i) {
          holderClasses.push(generateHolderClass(i + 1));
          thenCallbacks.push(thenCallback(i + 1));
          promiseSetters.push(promiseSetter(i + 1));
        }
        reject = function(reason) {
          this._reject(reason);
        };
      }
    }
    Promise2.join = function() {
      var last = arguments.length - 1;
      var fn;
      if (last > 0 && typeof arguments[last] === "function") {
        fn = arguments[last];
        if (true) {
          if (last <= 8 && canEvaluate) {
            var ret = new Promise2(INTERNAL);
            ret._captureStackTrace();
            var HolderClass = holderClasses[last - 1];
            var holder = new HolderClass(fn);
            var callbacks = thenCallbacks;
            for (var i2 = 0;i2 < last; ++i2) {
              var maybePromise = tryConvertToPromise(arguments[i2], ret);
              if (maybePromise instanceof Promise2) {
                maybePromise = maybePromise._target();
                var bitField = maybePromise._bitField;
                if ((bitField & 50397184) === 0) {
                  maybePromise._then(callbacks[i2], reject, undefined, ret, holder);
                  promiseSetters[i2](maybePromise, holder);
                  holder.asyncNeeded = false;
                } else if ((bitField & 33554432) !== 0) {
                  callbacks[i2].call(ret, maybePromise._value(), holder);
                } else if ((bitField & 16777216) !== 0) {
                  ret._reject(maybePromise._reason());
                } else {
                  ret._cancel();
                }
              } else {
                callbacks[i2].call(ret, maybePromise, holder);
              }
            }
            if (!ret._isFateSealed()) {
              if (holder.asyncNeeded) {
                var context3 = Promise2._getContext();
                holder.fn = util3.contextBind(context3, holder.fn);
              }
              ret._setAsyncGuaranteed();
              ret._setOnCancel(holder);
            }
            return ret;
          }
        }
      }
      var $_len = arguments.length;
      var args = new Array($_len);
      for (var $_i = 0;$_i < $_len; ++$_i) {
        args[$_i] = arguments[$_i];
      }
      if (fn)
        args.pop();
      var ret = new PromiseArray(args).promise();
      return fn !== undefined ? ret.spread(fn) : ret;
    };
  };
});

// node_modules/bluebird/js/release/call_get.js
var require_call_get = __commonJS((exports, module) => {
  var cr = Object.create;
  if (cr) {
    callerCache = cr(null);
    getterCache = cr(null);
    callerCache[" size"] = getterCache[" size"] = 0;
  }
  var callerCache;
  var getterCache;
  module.exports = function(Promise2) {
    var util3 = require_util3();
    var canEvaluate = util3.canEvaluate;
    var isIdentifier = util3.isIdentifier;
    var getMethodCaller;
    var getGetter;
    if (true) {
      var makeMethodCaller = function(methodName) {
        return new Function("ensureMethod", `                                    
        return function(obj) {                                               
            'use strict'                                                     
            var len = this.length;                                           
            ensureMethod(obj, 'methodName');                                 
            switch(len) {                                                    
                case 1: return obj.methodName(this[0]);                      
                case 2: return obj.methodName(this[0], this[1]);             
                case 3: return obj.methodName(this[0], this[1], this[2]);    
                case 0: return obj.methodName();                             
                default:                                                     
                    return obj.methodName.apply(obj, this);                  
            }                                                                
        };                                                                   
        `.replace(/methodName/g, methodName))(ensureMethod);
      };
      var makeGetter = function(propertyName) {
        return new Function("obj", `                                             
        'use strict';                                                        
        return obj.propertyName;                                             
        `.replace("propertyName", propertyName));
      };
      var getCompiled = function(name, compiler, cache) {
        var ret = cache[name];
        if (typeof ret !== "function") {
          if (!isIdentifier(name)) {
            return null;
          }
          ret = compiler(name);
          cache[name] = ret;
          cache[" size"]++;
          if (cache[" size"] > 512) {
            var keys = Object.keys(cache);
            for (var i = 0;i < 256; ++i)
              delete cache[keys[i]];
            cache[" size"] = keys.length - 256;
          }
        }
        return ret;
      };
      getMethodCaller = function(name) {
        return getCompiled(name, makeMethodCaller, callerCache);
      };
      getGetter = function(name) {
        return getCompiled(name, makeGetter, getterCache);
      };
    }
    function ensureMethod(obj, methodName) {
      var fn;
      if (obj != null)
        fn = obj[methodName];
      if (typeof fn !== "function") {
        var message2 = "Object " + util3.classString(obj) + " has no method '" + util3.toString(methodName) + "'";
        throw new Promise2.TypeError(message2);
      }
      return fn;
    }
    function caller(obj) {
      var methodName = this.pop();
      var fn = ensureMethod(obj, methodName);
      return fn.apply(obj, this);
    }
    Promise2.prototype.call = function(methodName) {
      var $_len = arguments.length;
      var args = new Array(Math.max($_len - 1, 0));
      for (var $_i = 1;$_i < $_len; ++$_i) {
        args[$_i - 1] = arguments[$_i];
      }
      if (true) {
        if (canEvaluate) {
          var maybeCaller = getMethodCaller(methodName);
          if (maybeCaller !== null) {
            return this._then(maybeCaller, undefined, undefined, args, undefined);
          }
        }
      }
      args.push(methodName);
      return this._then(caller, undefined, undefined, args, undefined);
    };
    function namedGetter(obj) {
      return obj[this];
    }
    function indexedGetter(obj) {
      var index = +this;
      if (index < 0)
        index = Math.max(0, index + obj.length);
      return obj[index];
    }
    Promise2.prototype.get = function(propertyName) {
      var isIndex = typeof propertyName === "number";
      var getter;
      if (!isIndex) {
        if (canEvaluate) {
          var maybeGetter = getGetter(propertyName);
          getter = maybeGetter !== null ? maybeGetter : namedGetter;
        } else {
          getter = namedGetter;
        }
      } else {
        getter = indexedGetter;
      }
      return this._then(getter, undefined, undefined, propertyName, undefined);
    };
  };
});

// node_modules/bluebird/js/release/generators.js
var require_generators = __commonJS((exports, module) => {
  module.exports = function(Promise2, apiRejection, INTERNAL, tryConvertToPromise, Proxyable, debug) {
    var errors15 = require_errors2();
    var TypeError2 = errors15.TypeError;
    var util3 = require_util3();
    var errorObj = util3.errorObj;
    var tryCatch = util3.tryCatch;
    var yieldHandlers = [];
    function promiseFromYieldHandler(value, yieldHandlers2, traceParent) {
      for (var i = 0;i < yieldHandlers2.length; ++i) {
        traceParent._pushContext();
        var result2 = tryCatch(yieldHandlers2[i])(value);
        traceParent._popContext();
        if (result2 === errorObj) {
          traceParent._pushContext();
          var ret = Promise2.reject(errorObj.e);
          traceParent._popContext();
          return ret;
        }
        var maybePromise = tryConvertToPromise(result2, traceParent);
        if (maybePromise instanceof Promise2)
          return maybePromise;
      }
      return null;
    }
    function PromiseSpawn(generatorFunction, receiver, yieldHandler, stack) {
      if (debug.cancellation()) {
        var internal = new Promise2(INTERNAL);
        var _finallyPromise = this._finallyPromise = new Promise2(INTERNAL);
        this._promise = internal.lastly(function() {
          return _finallyPromise;
        });
        internal._captureStackTrace();
        internal._setOnCancel(this);
      } else {
        var promise = this._promise = new Promise2(INTERNAL);
        promise._captureStackTrace();
      }
      this._stack = stack;
      this._generatorFunction = generatorFunction;
      this._receiver = receiver;
      this._generator = undefined;
      this._yieldHandlers = typeof yieldHandler === "function" ? [yieldHandler].concat(yieldHandlers) : yieldHandlers;
      this._yieldedPromise = null;
      this._cancellationPhase = false;
    }
    util3.inherits(PromiseSpawn, Proxyable);
    PromiseSpawn.prototype._isResolved = function() {
      return this._promise === null;
    };
    PromiseSpawn.prototype._cleanup = function() {
      this._promise = this._generator = null;
      if (debug.cancellation() && this._finallyPromise !== null) {
        this._finallyPromise._fulfill();
        this._finallyPromise = null;
      }
    };
    PromiseSpawn.prototype._promiseCancelled = function() {
      if (this._isResolved())
        return;
      var implementsReturn = typeof this._generator["return"] !== "undefined";
      var result2;
      if (!implementsReturn) {
        var reason = new Promise2.CancellationError("generator .return() sentinel");
        Promise2.coroutine.returnSentinel = reason;
        this._promise._attachExtraTrace(reason);
        this._promise._pushContext();
        result2 = tryCatch(this._generator["throw"]).call(this._generator, reason);
        this._promise._popContext();
      } else {
        this._promise._pushContext();
        result2 = tryCatch(this._generator["return"]).call(this._generator, undefined);
        this._promise._popContext();
      }
      this._cancellationPhase = true;
      this._yieldedPromise = null;
      this._continue(result2);
    };
    PromiseSpawn.prototype._promiseFulfilled = function(value) {
      this._yieldedPromise = null;
      this._promise._pushContext();
      var result2 = tryCatch(this._generator.next).call(this._generator, value);
      this._promise._popContext();
      this._continue(result2);
    };
    PromiseSpawn.prototype._promiseRejected = function(reason) {
      this._yieldedPromise = null;
      this._promise._attachExtraTrace(reason);
      this._promise._pushContext();
      var result2 = tryCatch(this._generator["throw"]).call(this._generator, reason);
      this._promise._popContext();
      this._continue(result2);
    };
    PromiseSpawn.prototype._resultCancelled = function() {
      if (this._yieldedPromise instanceof Promise2) {
        var promise = this._yieldedPromise;
        this._yieldedPromise = null;
        promise.cancel();
      }
    };
    PromiseSpawn.prototype.promise = function() {
      return this._promise;
    };
    PromiseSpawn.prototype._run = function() {
      this._generator = this._generatorFunction.call(this._receiver);
      this._receiver = this._generatorFunction = undefined;
      this._promiseFulfilled(undefined);
    };
    PromiseSpawn.prototype._continue = function(result2) {
      var promise = this._promise;
      if (result2 === errorObj) {
        this._cleanup();
        if (this._cancellationPhase) {
          return promise.cancel();
        } else {
          return promise._rejectCallback(result2.e, false);
        }
      }
      var value = result2.value;
      if (result2.done === true) {
        this._cleanup();
        if (this._cancellationPhase) {
          return promise.cancel();
        } else {
          return promise._resolveCallback(value);
        }
      } else {
        var maybePromise = tryConvertToPromise(value, this._promise);
        if (!(maybePromise instanceof Promise2)) {
          maybePromise = promiseFromYieldHandler(maybePromise, this._yieldHandlers, this._promise);
          if (maybePromise === null) {
            this._promiseRejected(new TypeError2(`A value %s was yielded that could not be treated as a promise

    See http://goo.gl/MqrFmX

`.replace("%s", String(value)) + `From coroutine:
` + this._stack.split("\n").slice(1, -7).join("\n")));
            return;
          }
        }
        maybePromise = maybePromise._target();
        var bitField = maybePromise._bitField;
        if ((bitField & 50397184) === 0) {
          this._yieldedPromise = maybePromise;
          maybePromise._proxy(this, null);
        } else if ((bitField & 33554432) !== 0) {
          Promise2._async.invoke(this._promiseFulfilled, this, maybePromise._value());
        } else if ((bitField & 16777216) !== 0) {
          Promise2._async.invoke(this._promiseRejected, this, maybePromise._reason());
        } else {
          this._promiseCancelled();
        }
      }
    };
    Promise2.coroutine = function(generatorFunction, options) {
      if (typeof generatorFunction !== "function") {
        throw new TypeError2(`generatorFunction must be a function

    See http://goo.gl/MqrFmX
`);
      }
      var yieldHandler = Object(options).yieldHandler;
      var PromiseSpawn$ = PromiseSpawn;
      var stack = new Error().stack;
      return function() {
        var generator = generatorFunction.apply(this, arguments);
        var spawn = new PromiseSpawn$(undefined, undefined, yieldHandler, stack);
        var ret = spawn.promise();
        spawn._generator = generator;
        spawn._promiseFulfilled(undefined);
        return ret;
      };
    };
    Promise2.coroutine.addYieldHandler = function(fn) {
      if (typeof fn !== "function") {
        throw new TypeError2("expecting a function but got " + util3.classString(fn));
      }
      yieldHandlers.push(fn);
    };
    Promise2.spawn = function(generatorFunction) {
      debug.deprecated("Promise.spawn()", "Promise.coroutine()");
      if (typeof generatorFunction !== "function") {
        return apiRejection(`generatorFunction must be a function

    See http://goo.gl/MqrFmX
`);
      }
      var spawn = new PromiseSpawn(generatorFunction, this);
      var ret = spawn.promise();
      spawn._run(Promise2.spawn);
      return ret;
    };
  };
});

// node_modules/bluebird/js/release/map.js
var require_map = __commonJS((exports, module) => {
  module.exports = function(Promise2, PromiseArray, apiRejection, tryConvertToPromise, INTERNAL, debug) {
    var util3 = require_util3();
    var tryCatch = util3.tryCatch;
    var errorObj = util3.errorObj;
    var async = Promise2._async;
    function MappingPromiseArray(promises, fn, limit, _filter) {
      this.constructor$(promises);
      this._promise._captureStackTrace();
      var context3 = Promise2._getContext();
      this._callback = util3.contextBind(context3, fn);
      this._preservedValues = _filter === INTERNAL ? new Array(this.length()) : null;
      this._limit = limit;
      this._inFlight = 0;
      this._queue = [];
      async.invoke(this._asyncInit, this, undefined);
      if (util3.isArray(promises)) {
        for (var i = 0;i < promises.length; ++i) {
          var maybePromise = promises[i];
          if (maybePromise instanceof Promise2) {
            maybePromise.suppressUnhandledRejections();
          }
        }
      }
    }
    util3.inherits(MappingPromiseArray, PromiseArray);
    MappingPromiseArray.prototype._asyncInit = function() {
      this._init$(undefined, -2);
    };
    MappingPromiseArray.prototype._init = function() {
    };
    MappingPromiseArray.prototype._promiseFulfilled = function(value, index) {
      var values2 = this._values;
      var length = this.length();
      var preservedValues = this._preservedValues;
      var limit = this._limit;
      if (index < 0) {
        index = index * -1 - 1;
        values2[index] = value;
        if (limit >= 1) {
          this._inFlight--;
          this._drainQueue();
          if (this._isResolved())
            return true;
        }
      } else {
        if (limit >= 1 && this._inFlight >= limit) {
          values2[index] = value;
          this._queue.push(index);
          return false;
        }
        if (preservedValues !== null)
          preservedValues[index] = value;
        var promise = this._promise;
        var callback = this._callback;
        var receiver = promise._boundValue();
        promise._pushContext();
        var ret = tryCatch(callback).call(receiver, value, index, length);
        var promiseCreated = promise._popContext();
        debug.checkForgottenReturns(ret, promiseCreated, preservedValues !== null ? "Promise.filter" : "Promise.map", promise);
        if (ret === errorObj) {
          this._reject(ret.e);
          return true;
        }
        var maybePromise = tryConvertToPromise(ret, this._promise);
        if (maybePromise instanceof Promise2) {
          maybePromise = maybePromise._target();
          var bitField = maybePromise._bitField;
          if ((bitField & 50397184) === 0) {
            if (limit >= 1)
              this._inFlight++;
            values2[index] = maybePromise;
            maybePromise._proxy(this, (index + 1) * -1);
            return false;
          } else if ((bitField & 33554432) !== 0) {
            ret = maybePromise._value();
          } else if ((bitField & 16777216) !== 0) {
            this._reject(maybePromise._reason());
            return true;
          } else {
            this._cancel();
            return true;
          }
        }
        values2[index] = ret;
      }
      var totalResolved = ++this._totalResolved;
      if (totalResolved >= length) {
        if (preservedValues !== null) {
          this._filter(values2, preservedValues);
        } else {
          this._resolve(values2);
        }
        return true;
      }
      return false;
    };
    MappingPromiseArray.prototype._drainQueue = function() {
      var queue3 = this._queue;
      var limit = this._limit;
      var values2 = this._values;
      while (queue3.length > 0 && this._inFlight < limit) {
        if (this._isResolved())
          return;
        var index = queue3.pop();
        this._promiseFulfilled(values2[index], index);
      }
    };
    MappingPromiseArray.prototype._filter = function(booleans, values2) {
      var len = values2.length;
      var ret = new Array(len);
      var j = 0;
      for (var i = 0;i < len; ++i) {
        if (booleans[i])
          ret[j++] = values2[i];
      }
      ret.length = j;
      this._resolve(ret);
    };
    MappingPromiseArray.prototype.preservedValues = function() {
      return this._preservedValues;
    };
    function map(promises, fn, options, _filter) {
      if (typeof fn !== "function") {
        return apiRejection("expecting a function but got " + util3.classString(fn));
      }
      var limit = 0;
      if (options !== undefined) {
        if (typeof options === "object" && options !== null) {
          if (typeof options.concurrency !== "number") {
            return Promise2.reject(new TypeError("'concurrency' must be a number but it is " + util3.classString(options.concurrency)));
          }
          limit = options.concurrency;
        } else {
          return Promise2.reject(new TypeError("options argument must be an object but it is " + util3.classString(options)));
        }
      }
      limit = typeof limit === "number" && isFinite(limit) && limit >= 1 ? limit : 0;
      return new MappingPromiseArray(promises, fn, limit, _filter).promise();
    }
    Promise2.prototype.map = function(fn, options) {
      return map(this, fn, options, null);
    };
    Promise2.map = function(promises, fn, options, _filter) {
      return map(promises, fn, options, _filter);
    };
  };
});

// node_modules/bluebird/js/release/nodeify.js
var require_nodeify = __commonJS((exports, module) => {
  module.exports = function(Promise2) {
    var util3 = require_util3();
    var async = Promise2._async;
    var tryCatch = util3.tryCatch;
    var errorObj = util3.errorObj;
    function spreadAdapter(val, nodeback) {
      var promise = this;
      if (!util3.isArray(val))
        return successAdapter.call(promise, val, nodeback);
      var ret = tryCatch(nodeback).apply(promise._boundValue(), [null].concat(val));
      if (ret === errorObj) {
        async.throwLater(ret.e);
      }
    }
    function successAdapter(val, nodeback) {
      var promise = this;
      var receiver = promise._boundValue();
      var ret = val === undefined ? tryCatch(nodeback).call(receiver, null) : tryCatch(nodeback).call(receiver, null, val);
      if (ret === errorObj) {
        async.throwLater(ret.e);
      }
    }
    function errorAdapter(reason, nodeback) {
      var promise = this;
      if (!reason) {
        var newReason = new Error(reason + "");
        newReason.cause = reason;
        reason = newReason;
      }
      var ret = tryCatch(nodeback).call(promise._boundValue(), reason);
      if (ret === errorObj) {
        async.throwLater(ret.e);
      }
    }
    Promise2.prototype.asCallback = Promise2.prototype.nodeify = function(nodeback, options) {
      if (typeof nodeback == "function") {
        var adapter = successAdapter;
        if (options !== undefined && Object(options).spread) {
          adapter = spreadAdapter;
        }
        this._then(adapter, errorAdapter, undefined, this, nodeback);
      }
      return this;
    };
  };
});

// node_modules/bluebird/js/release/promisify.js
var require_promisify = __commonJS((exports, module) => {
  module.exports = function(Promise2, INTERNAL) {
    var THIS = {};
    var util3 = require_util3();
    var nodebackForPromise = require_nodeback();
    var withAppended = util3.withAppended;
    var maybeWrapAsError = util3.maybeWrapAsError;
    var canEvaluate = util3.canEvaluate;
    var TypeError2 = require_errors2().TypeError;
    var defaultSuffix = "Async";
    var defaultPromisified = { __isPromisified__: true };
    var noCopyProps = [
      "arity",
      "length",
      "name",
      "arguments",
      "caller",
      "callee",
      "prototype",
      "__isPromisified__"
    ];
    var noCopyPropsPattern = new RegExp("^(?:" + noCopyProps.join("|") + ")$");
    var defaultFilter = function(name) {
      return util3.isIdentifier(name) && name.charAt(0) !== "_" && name !== "constructor";
    };
    function propsFilter(key) {
      return !noCopyPropsPattern.test(key);
    }
    function isPromisified(fn) {
      try {
        return fn.__isPromisified__ === true;
      } catch (e) {
        return false;
      }
    }
    function hasPromisified(obj, key, suffix) {
      var val = util3.getDataPropertyOrDefault(obj, key + suffix, defaultPromisified);
      return val ? isPromisified(val) : false;
    }
    function checkValid(ret, suffix, suffixRegexp) {
      for (var i = 0;i < ret.length; i += 2) {
        var key = ret[i];
        if (suffixRegexp.test(key)) {
          var keyWithoutAsyncSuffix = key.replace(suffixRegexp, "");
          for (var j = 0;j < ret.length; j += 2) {
            if (ret[j] === keyWithoutAsyncSuffix) {
              throw new TypeError2(`Cannot promisify an API that has normal methods with '%s'-suffix

    See http://goo.gl/MqrFmX
`.replace("%s", suffix));
            }
          }
        }
      }
    }
    function promisifiableMethods(obj, suffix, suffixRegexp, filter) {
      var keys = util3.inheritedDataKeys(obj);
      var ret = [];
      for (var i = 0;i < keys.length; ++i) {
        var key = keys[i];
        var value = obj[key];
        var passesDefaultFilter = filter === defaultFilter ? true : defaultFilter(key, value, obj);
        if (typeof value === "function" && !isPromisified(value) && !hasPromisified(obj, key, suffix) && filter(key, value, obj, passesDefaultFilter)) {
          ret.push(key, value);
        }
      }
      checkValid(ret, suffix, suffixRegexp);
      return ret;
    }
    var escapeIdentRegex = function(str) {
      return str.replace(/([$])/, "\\$");
    };
    var makeNodePromisifiedEval;
    if (true) {
      var switchCaseArgumentOrder = function(likelyArgumentCount) {
        var ret = [likelyArgumentCount];
        var min = Math.max(0, likelyArgumentCount - 1 - 3);
        for (var i = likelyArgumentCount - 1;i >= min; --i) {
          ret.push(i);
        }
        for (var i = likelyArgumentCount + 1;i <= 3; ++i) {
          ret.push(i);
        }
        return ret;
      };
      var argumentSequence = function(argumentCount) {
        return util3.filledRange(argumentCount, "_arg", "");
      };
      var parameterDeclaration = function(parameterCount2) {
        return util3.filledRange(Math.max(parameterCount2, 3), "_arg", "");
      };
      var parameterCount = function(fn) {
        if (typeof fn.length === "number") {
          return Math.max(Math.min(fn.length, 1023 + 1), 0);
        }
        return 0;
      };
      makeNodePromisifiedEval = function(callback, receiver, originalName, fn, _, multiArgs) {
        var newParameterCount = Math.max(0, parameterCount(fn) - 1);
        var argumentOrder = switchCaseArgumentOrder(newParameterCount);
        var shouldProxyThis = typeof callback === "string" || receiver === THIS;
        function generateCallForArgumentCount(count) {
          var args = argumentSequence(count).join(", ");
          var comma = count > 0 ? ", " : "";
          var ret;
          if (shouldProxyThis) {
            ret = "ret = callback.call(this, {{args}}, nodeback); break;\n";
          } else {
            ret = receiver === undefined ? "ret = callback({{args}}, nodeback); break;\n" : "ret = callback.call(receiver, {{args}}, nodeback); break;\n";
          }
          return ret.replace("{{args}}", args).replace(", ", comma);
        }
        function generateArgumentSwitchCase() {
          var ret = "";
          for (var i = 0;i < argumentOrder.length; ++i) {
            ret += "case " + argumentOrder[i] + ":" + generateCallForArgumentCount(argumentOrder[i]);
          }
          ret += `                                                             
        default:                                                             
            var args = new Array(len + 1);                                   
            var i = 0;                                                       
            for (var i = 0; i < len; ++i) {                                  
               args[i] = arguments[i];                                       
            }                                                                
            args[i] = nodeback;                                              
            [CodeForCall]                                                    
            break;                                                           
        `.replace("[CodeForCall]", shouldProxyThis ? "ret = callback.apply(this, args);\n" : "ret = callback.apply(receiver, args);\n");
          return ret;
        }
        var getFunctionCode = typeof callback === "string" ? "this != null ? this['" + callback + "'] : fn" : "fn";
        var body2 = `'use strict';                                                
        var ret = function (Parameters) {                                    
            'use strict';                                                    
            var len = arguments.length;                                      
            var promise = new Promise(INTERNAL);                             
            promise._captureStackTrace();                                    
            var nodeback = nodebackForPromise(promise, ` + multiArgs + `);   
            var ret;                                                         
            var callback = tryCatch([GetFunctionCode]);                      
            switch(len) {                                                    
                [CodeForSwitchCase]                                          
            }                                                                
            if (ret === errorObj) {                                          
                promise._rejectCallback(maybeWrapAsError(ret.e), true, true);
            }                                                                
            if (!promise._isFateSealed()) promise._setAsyncGuaranteed();     
            return promise;                                                  
        };                                                                   
        notEnumerableProp(ret, '__isPromisified__', true);                   
        return ret;                                                          
    `.replace("[CodeForSwitchCase]", generateArgumentSwitchCase()).replace("[GetFunctionCode]", getFunctionCode);
        body2 = body2.replace("Parameters", parameterDeclaration(newParameterCount));
        return new Function("Promise", "fn", "receiver", "withAppended", "maybeWrapAsError", "nodebackForPromise", "tryCatch", "errorObj", "notEnumerableProp", "INTERNAL", body2)(Promise2, fn, receiver, withAppended, maybeWrapAsError, nodebackForPromise, util3.tryCatch, util3.errorObj, util3.notEnumerableProp, INTERNAL);
      };
    }
    function makeNodePromisifiedClosure(callback, receiver, _, fn, __, multiArgs) {
      var defaultThis = function() {
        return this;
      }();
      var method = callback;
      if (typeof method === "string") {
        callback = fn;
      }
      function promisified() {
        var _receiver = receiver;
        if (receiver === THIS)
          _receiver = this;
        var promise = new Promise2(INTERNAL);
        promise._captureStackTrace();
        var cb = typeof method === "string" && this !== defaultThis ? this[method] : callback;
        var fn2 = nodebackForPromise(promise, multiArgs);
        try {
          cb.apply(_receiver, withAppended(arguments, fn2));
        } catch (e) {
          promise._rejectCallback(maybeWrapAsError(e), true, true);
        }
        if (!promise._isFateSealed())
          promise._setAsyncGuaranteed();
        return promise;
      }
      util3.notEnumerableProp(promisified, "__isPromisified__", true);
      return promisified;
    }
    var makeNodePromisified = canEvaluate ? makeNodePromisifiedEval : makeNodePromisifiedClosure;
    function promisifyAll(obj, suffix, filter, promisifier, multiArgs) {
      var suffixRegexp = new RegExp(escapeIdentRegex(suffix) + "$");
      var methods = promisifiableMethods(obj, suffix, suffixRegexp, filter);
      for (var i = 0, len = methods.length;i < len; i += 2) {
        var key = methods[i];
        var fn = methods[i + 1];
        var promisifiedKey = key + suffix;
        if (promisifier === makeNodePromisified) {
          obj[promisifiedKey] = makeNodePromisified(key, THIS, key, fn, suffix, multiArgs);
        } else {
          var promisified = promisifier(fn, function() {
            return makeNodePromisified(key, THIS, key, fn, suffix, multiArgs);
          });
          util3.notEnumerableProp(promisified, "__isPromisified__", true);
          obj[promisifiedKey] = promisified;
        }
      }
      util3.toFastProperties(obj);
      return obj;
    }
    function promisify3(callback, receiver, multiArgs) {
      return makeNodePromisified(callback, receiver, undefined, callback, null, multiArgs);
    }
    Promise2.promisify = function(fn, options) {
      if (typeof fn !== "function") {
        throw new TypeError2("expecting a function but got " + util3.classString(fn));
      }
      if (isPromisified(fn)) {
        return fn;
      }
      options = Object(options);
      var receiver = options.context === undefined ? THIS : options.context;
      var multiArgs = !!options.multiArgs;
      var ret = promisify3(fn, receiver, multiArgs);
      util3.copyDescriptors(fn, ret, propsFilter);
      return ret;
    };
    Promise2.promisifyAll = function(target, options) {
      if (typeof target !== "function" && typeof target !== "object") {
        throw new TypeError2(`the target of promisifyAll must be an object or a function

    See http://goo.gl/MqrFmX
`);
      }
      options = Object(options);
      var multiArgs = !!options.multiArgs;
      var suffix = options.suffix;
      if (typeof suffix !== "string")
        suffix = defaultSuffix;
      var filter = options.filter;
      if (typeof filter !== "function")
        filter = defaultFilter;
      var promisifier = options.promisifier;
      if (typeof promisifier !== "function")
        promisifier = makeNodePromisified;
      if (!util3.isIdentifier(suffix)) {
        throw new RangeError(`suffix must be a valid identifier

    See http://goo.gl/MqrFmX
`);
      }
      var keys = util3.inheritedDataKeys(target);
      for (var i = 0;i < keys.length; ++i) {
        var value = target[keys[i]];
        if (keys[i] !== "constructor" && util3.isClass(value)) {
          promisifyAll(value.prototype, suffix, filter, promisifier, multiArgs);
          promisifyAll(value, suffix, filter, promisifier, multiArgs);
        }
      }
      return promisifyAll(target, suffix, filter, promisifier, multiArgs);
    };
  };
});

// node_modules/bluebird/js/release/props.js
var require_props = __commonJS((exports, module) => {
  module.exports = function(Promise2, PromiseArray, tryConvertToPromise, apiRejection) {
    var util3 = require_util3();
    var isObject2 = util3.isObject;
    var es5 = require_es5();
    var Es6Map;
    if (typeof Map === "function")
      Es6Map = Map;
    var mapToEntries = function() {
      var index = 0;
      var size2 = 0;
      function extractEntry(value, key) {
        this[index] = value;
        this[index + size2] = key;
        index++;
      }
      return function mapToEntries(map) {
        size2 = map.size;
        index = 0;
        var ret = new Array(map.size * 2);
        map.forEach(extractEntry, ret);
        return ret;
      };
    }();
    var entriesToMap = function(entries) {
      var ret = new Es6Map;
      var length = entries.length / 2 | 0;
      for (var i = 0;i < length; ++i) {
        var key = entries[length + i];
        var value = entries[i];
        ret.set(key, value);
      }
      return ret;
    };
    function PropertiesPromiseArray(obj) {
      var isMap = false;
      var entries;
      if (Es6Map !== undefined && obj instanceof Es6Map) {
        entries = mapToEntries(obj);
        isMap = true;
      } else {
        var keys = es5.keys(obj);
        var len = keys.length;
        entries = new Array(len * 2);
        for (var i = 0;i < len; ++i) {
          var key = keys[i];
          entries[i] = obj[key];
          entries[i + len] = key;
        }
      }
      this.constructor$(entries);
      this._isMap = isMap;
      this._init$(undefined, isMap ? -6 : -3);
    }
    util3.inherits(PropertiesPromiseArray, PromiseArray);
    PropertiesPromiseArray.prototype._init = function() {
    };
    PropertiesPromiseArray.prototype._promiseFulfilled = function(value, index) {
      this._values[index] = value;
      var totalResolved = ++this._totalResolved;
      if (totalResolved >= this._length) {
        var val;
        if (this._isMap) {
          val = entriesToMap(this._values);
        } else {
          val = {};
          var keyOffset = this.length();
          for (var i = 0, len = this.length();i < len; ++i) {
            val[this._values[i + keyOffset]] = this._values[i];
          }
        }
        this._resolve(val);
        return true;
      }
      return false;
    };
    PropertiesPromiseArray.prototype.shouldCopyValues = function() {
      return false;
    };
    PropertiesPromiseArray.prototype.getActualLength = function(len) {
      return len >> 1;
    };
    function props(promises) {
      var ret;
      var castValue = tryConvertToPromise(promises);
      if (!isObject2(castValue)) {
        return apiRejection(`cannot await properties of a non-object

    See http://goo.gl/MqrFmX
`);
      } else if (castValue instanceof Promise2) {
        ret = castValue._then(Promise2.props, undefined, undefined, undefined, undefined);
      } else {
        ret = new PropertiesPromiseArray(castValue).promise();
      }
      if (castValue instanceof Promise2) {
        ret._propagateFrom(castValue, 2);
      }
      return ret;
    }
    Promise2.prototype.props = function() {
      return props(this);
    };
    Promise2.props = function(promises) {
      return props(promises);
    };
  };
});

// node_modules/bluebird/js/release/race.js
var require_race = __commonJS((exports, module) => {
  module.exports = function(Promise2, INTERNAL, tryConvertToPromise, apiRejection) {
    var util3 = require_util3();
    var raceLater = function(promise) {
      return promise.then(function(array) {
        return race(array, promise);
      });
    };
    function race(promises, parent) {
      var maybePromise = tryConvertToPromise(promises);
      if (maybePromise instanceof Promise2) {
        return raceLater(maybePromise);
      } else {
        promises = util3.asArray(promises);
        if (promises === null)
          return apiRejection("expecting an array or an iterable object but got " + util3.classString(promises));
      }
      var ret = new Promise2(INTERNAL);
      if (parent !== undefined) {
        ret._propagateFrom(parent, 3);
      }
      var fulfill = ret._fulfill;
      var reject = ret._reject;
      for (var i = 0, len = promises.length;i < len; ++i) {
        var val = promises[i];
        if (val === undefined && !(i in promises)) {
          continue;
        }
        Promise2.cast(val)._then(fulfill, reject, undefined, ret, null);
      }
      return ret;
    }
    Promise2.race = function(promises) {
      return race(promises, undefined);
    };
    Promise2.prototype.race = function() {
      return race(this, undefined);
    };
  };
});

// node_modules/bluebird/js/release/reduce.js
var require_reduce = __commonJS((exports, module) => {
  module.exports = function(Promise2, PromiseArray, apiRejection, tryConvertToPromise, INTERNAL, debug) {
    var util3 = require_util3();
    var tryCatch = util3.tryCatch;
    function ReductionPromiseArray(promises, fn, initialValue, _each) {
      this.constructor$(promises);
      var context3 = Promise2._getContext();
      this._fn = util3.contextBind(context3, fn);
      if (initialValue !== undefined) {
        initialValue = Promise2.resolve(initialValue);
        initialValue._attachCancellationCallback(this);
      }
      this._initialValue = initialValue;
      this._currentCancellable = null;
      if (_each === INTERNAL) {
        this._eachValues = Array(this._length);
      } else if (_each === 0) {
        this._eachValues = null;
      } else {
        this._eachValues = undefined;
      }
      this._promise._captureStackTrace();
      this._init$(undefined, -5);
    }
    util3.inherits(ReductionPromiseArray, PromiseArray);
    ReductionPromiseArray.prototype._gotAccum = function(accum) {
      if (this._eachValues !== undefined && this._eachValues !== null && accum !== INTERNAL) {
        this._eachValues.push(accum);
      }
    };
    ReductionPromiseArray.prototype._eachComplete = function(value) {
      if (this._eachValues !== null) {
        this._eachValues.push(value);
      }
      return this._eachValues;
    };
    ReductionPromiseArray.prototype._init = function() {
    };
    ReductionPromiseArray.prototype._resolveEmptyArray = function() {
      this._resolve(this._eachValues !== undefined ? this._eachValues : this._initialValue);
    };
    ReductionPromiseArray.prototype.shouldCopyValues = function() {
      return false;
    };
    ReductionPromiseArray.prototype._resolve = function(value) {
      this._promise._resolveCallback(value);
      this._values = null;
    };
    ReductionPromiseArray.prototype._resultCancelled = function(sender) {
      if (sender === this._initialValue)
        return this._cancel();
      if (this._isResolved())
        return;
      this._resultCancelled$();
      if (this._currentCancellable instanceof Promise2) {
        this._currentCancellable.cancel();
      }
      if (this._initialValue instanceof Promise2) {
        this._initialValue.cancel();
      }
    };
    ReductionPromiseArray.prototype._iterate = function(values2) {
      this._values = values2;
      var value;
      var i;
      var length = values2.length;
      if (this._initialValue !== undefined) {
        value = this._initialValue;
        i = 0;
      } else {
        value = Promise2.resolve(values2[0]);
        i = 1;
      }
      this._currentCancellable = value;
      for (var j = i;j < length; ++j) {
        var maybePromise = values2[j];
        if (maybePromise instanceof Promise2) {
          maybePromise.suppressUnhandledRejections();
        }
      }
      if (!value.isRejected()) {
        for (;i < length; ++i) {
          var ctx = {
            accum: null,
            value: values2[i],
            index: i,
            length,
            array: this
          };
          value = value._then(gotAccum, undefined, undefined, ctx, undefined);
          if ((i & 127) === 0) {
            value._setNoAsyncGuarantee();
          }
        }
      }
      if (this._eachValues !== undefined) {
        value = value._then(this._eachComplete, undefined, undefined, this, undefined);
      }
      value._then(completed, completed, undefined, value, this);
    };
    Promise2.prototype.reduce = function(fn, initialValue) {
      return reduce(this, fn, initialValue, null);
    };
    Promise2.reduce = function(promises, fn, initialValue, _each) {
      return reduce(promises, fn, initialValue, _each);
    };
    function completed(valueOrReason, array) {
      if (this.isFulfilled()) {
        array._resolve(valueOrReason);
      } else {
        array._reject(valueOrReason);
      }
    }
    function reduce(promises, fn, initialValue, _each) {
      if (typeof fn !== "function") {
        return apiRejection("expecting a function but got " + util3.classString(fn));
      }
      var array = new ReductionPromiseArray(promises, fn, initialValue, _each);
      return array.promise();
    }
    function gotAccum(accum) {
      this.accum = accum;
      this.array._gotAccum(accum);
      var value = tryConvertToPromise(this.value, this.array._promise);
      if (value instanceof Promise2) {
        this.array._currentCancellable = value;
        return value._then(gotValue, undefined, undefined, this, undefined);
      } else {
        return gotValue.call(this, value);
      }
    }
    function gotValue(value) {
      var array = this.array;
      var promise = array._promise;
      var fn = tryCatch(array._fn);
      promise._pushContext();
      var ret;
      if (array._eachValues !== undefined) {
        ret = fn.call(promise._boundValue(), value, this.index, this.length);
      } else {
        ret = fn.call(promise._boundValue(), this.accum, value, this.index, this.length);
      }
      if (ret instanceof Promise2) {
        array._currentCancellable = ret;
      }
      var promiseCreated = promise._popContext();
      debug.checkForgottenReturns(ret, promiseCreated, array._eachValues !== undefined ? "Promise.each" : "Promise.reduce", promise);
      return ret;
    }
  };
});

// node_modules/bluebird/js/release/settle.js
var require_settle = __commonJS((exports, module) => {
  module.exports = function(Promise2, PromiseArray, debug) {
    var PromiseInspection = Promise2.PromiseInspection;
    var util3 = require_util3();
    function SettledPromiseArray(values2) {
      this.constructor$(values2);
    }
    util3.inherits(SettledPromiseArray, PromiseArray);
    SettledPromiseArray.prototype._promiseResolved = function(index, inspection) {
      this._values[index] = inspection;
      var totalResolved = ++this._totalResolved;
      if (totalResolved >= this._length) {
        this._resolve(this._values);
        return true;
      }
      return false;
    };
    SettledPromiseArray.prototype._promiseFulfilled = function(value, index) {
      var ret = new PromiseInspection;
      ret._bitField = 33554432;
      ret._settledValueField = value;
      return this._promiseResolved(index, ret);
    };
    SettledPromiseArray.prototype._promiseRejected = function(reason, index) {
      var ret = new PromiseInspection;
      ret._bitField = 16777216;
      ret._settledValueField = reason;
      return this._promiseResolved(index, ret);
    };
    Promise2.settle = function(promises) {
      debug.deprecated(".settle()", ".reflect()");
      return new SettledPromiseArray(promises).promise();
    };
    Promise2.allSettled = function(promises) {
      return new SettledPromiseArray(promises).promise();
    };
    Promise2.prototype.settle = function() {
      return Promise2.settle(this);
    };
  };
});

// node_modules/bluebird/js/release/some.js
var require_some = __commonJS((exports, module) => {
  module.exports = function(Promise2, PromiseArray, apiRejection) {
    var util3 = require_util3();
    var RangeError2 = require_errors2().RangeError;
    var AggregateError = require_errors2().AggregateError;
    var isArray = util3.isArray;
    var CANCELLATION = {};
    function SomePromiseArray(values2) {
      this.constructor$(values2);
      this._howMany = 0;
      this._unwrap = false;
      this._initialized = false;
    }
    util3.inherits(SomePromiseArray, PromiseArray);
    SomePromiseArray.prototype._init = function() {
      if (!this._initialized) {
        return;
      }
      if (this._howMany === 0) {
        this._resolve([]);
        return;
      }
      this._init$(undefined, -5);
      var isArrayResolved = isArray(this._values);
      if (!this._isResolved() && isArrayResolved && this._howMany > this._canPossiblyFulfill()) {
        this._reject(this._getRangeError(this.length()));
      }
    };
    SomePromiseArray.prototype.init = function() {
      this._initialized = true;
      this._init();
    };
    SomePromiseArray.prototype.setUnwrap = function() {
      this._unwrap = true;
    };
    SomePromiseArray.prototype.howMany = function() {
      return this._howMany;
    };
    SomePromiseArray.prototype.setHowMany = function(count) {
      this._howMany = count;
    };
    SomePromiseArray.prototype._promiseFulfilled = function(value) {
      this._addFulfilled(value);
      if (this._fulfilled() === this.howMany()) {
        this._values.length = this.howMany();
        if (this.howMany() === 1 && this._unwrap) {
          this._resolve(this._values[0]);
        } else {
          this._resolve(this._values);
        }
        return true;
      }
      return false;
    };
    SomePromiseArray.prototype._promiseRejected = function(reason) {
      this._addRejected(reason);
      return this._checkOutcome();
    };
    SomePromiseArray.prototype._promiseCancelled = function() {
      if (this._values instanceof Promise2 || this._values == null) {
        return this._cancel();
      }
      this._addRejected(CANCELLATION);
      return this._checkOutcome();
    };
    SomePromiseArray.prototype._checkOutcome = function() {
      if (this.howMany() > this._canPossiblyFulfill()) {
        var e = new AggregateError;
        for (var i = this.length();i < this._values.length; ++i) {
          if (this._values[i] !== CANCELLATION) {
            e.push(this._values[i]);
          }
        }
        if (e.length > 0) {
          this._reject(e);
        } else {
          this._cancel();
        }
        return true;
      }
      return false;
    };
    SomePromiseArray.prototype._fulfilled = function() {
      return this._totalResolved;
    };
    SomePromiseArray.prototype._rejected = function() {
      return this._values.length - this.length();
    };
    SomePromiseArray.prototype._addRejected = function(reason) {
      this._values.push(reason);
    };
    SomePromiseArray.prototype._addFulfilled = function(value) {
      this._values[this._totalResolved++] = value;
    };
    SomePromiseArray.prototype._canPossiblyFulfill = function() {
      return this.length() - this._rejected();
    };
    SomePromiseArray.prototype._getRangeError = function(count) {
      var message2 = "Input array must contain at least " + this._howMany + " items but contains only " + count + " items";
      return new RangeError2(message2);
    };
    SomePromiseArray.prototype._resolveEmptyArray = function() {
      this._reject(this._getRangeError(0));
    };
    function some(promises, howMany) {
      if ((howMany | 0) !== howMany || howMany < 0) {
        return apiRejection(`expecting a positive integer

    See http://goo.gl/MqrFmX
`);
      }
      var ret = new SomePromiseArray(promises);
      var promise = ret.promise();
      ret.setHowMany(howMany);
      ret.init();
      return promise;
    }
    Promise2.some = function(promises, howMany) {
      return some(promises, howMany);
    };
    Promise2.prototype.some = function(howMany) {
      return some(this, howMany);
    };
    Promise2._SomePromiseArray = SomePromiseArray;
  };
});

// node_modules/bluebird/js/release/timers.js
var require_timers = __commonJS((exports, module) => {
  module.exports = function(Promise2, INTERNAL, debug) {
    var util3 = require_util3();
    var TimeoutError = Promise2.TimeoutError;
    function HandleWrapper(handle) {
      this.handle = handle;
    }
    HandleWrapper.prototype._resultCancelled = function() {
      clearTimeout(this.handle);
    };
    var afterValue = function(value) {
      return delay(+this).thenReturn(value);
    };
    var delay = Promise2.delay = function(ms, value) {
      var ret;
      var handle;
      if (value !== undefined) {
        ret = Promise2.resolve(value)._then(afterValue, null, null, ms, undefined);
        if (debug.cancellation() && value instanceof Promise2) {
          ret._setOnCancel(value);
        }
      } else {
        ret = new Promise2(INTERNAL);
        handle = setTimeout(function() {
          ret._fulfill();
        }, +ms);
        if (debug.cancellation()) {
          ret._setOnCancel(new HandleWrapper(handle));
        }
        ret._captureStackTrace();
      }
      ret._setAsyncGuaranteed();
      return ret;
    };
    Promise2.prototype.delay = function(ms) {
      return delay(ms, this);
    };
    var afterTimeout = function(promise, message2, parent) {
      var err;
      if (typeof message2 !== "string") {
        if (message2 instanceof Error) {
          err = message2;
        } else {
          err = new TimeoutError("operation timed out");
        }
      } else {
        err = new TimeoutError(message2);
      }
      util3.markAsOriginatingFromRejection(err);
      promise._attachExtraTrace(err);
      promise._reject(err);
      if (parent != null) {
        parent.cancel();
      }
    };
    function successClear(value) {
      clearTimeout(this.handle);
      return value;
    }
    function failureClear(reason) {
      clearTimeout(this.handle);
      throw reason;
    }
    Promise2.prototype.timeout = function(ms, message2) {
      ms = +ms;
      var ret, parent;
      var handleWrapper = new HandleWrapper(setTimeout(function timeoutTimeout() {
        if (ret.isPending()) {
          afterTimeout(ret, message2, parent);
        }
      }, ms));
      if (debug.cancellation()) {
        parent = this.then();
        ret = parent._then(successClear, failureClear, undefined, handleWrapper, undefined);
        ret._setOnCancel(handleWrapper);
      } else {
        ret = this._then(successClear, failureClear, undefined, handleWrapper, undefined);
      }
      return ret;
    };
  };
});

// node_modules/bluebird/js/release/using.js
var require_using = __commonJS((exports, module) => {
  module.exports = function(Promise2, apiRejection, tryConvertToPromise, createContext, INTERNAL, debug) {
    var util3 = require_util3();
    var TypeError2 = require_errors2().TypeError;
    var inherits = require_util3().inherits;
    var errorObj = util3.errorObj;
    var tryCatch = util3.tryCatch;
    var NULL = {};
    function thrower(e) {
      setTimeout(function() {
        throw e;
      }, 0);
    }
    function castPreservingDisposable(thenable) {
      var maybePromise = tryConvertToPromise(thenable);
      if (maybePromise !== thenable && typeof thenable._isDisposable === "function" && typeof thenable._getDisposer === "function" && thenable._isDisposable()) {
        maybePromise._setDisposable(thenable._getDisposer());
      }
      return maybePromise;
    }
    function dispose(resources, inspection) {
      var i = 0;
      var len = resources.length;
      var ret = new Promise2(INTERNAL);
      function iterator() {
        if (i >= len)
          return ret._fulfill();
        var maybePromise = castPreservingDisposable(resources[i++]);
        if (maybePromise instanceof Promise2 && maybePromise._isDisposable()) {
          try {
            maybePromise = tryConvertToPromise(maybePromise._getDisposer().tryDispose(inspection), resources.promise);
          } catch (e) {
            return thrower(e);
          }
          if (maybePromise instanceof Promise2) {
            return maybePromise._then(iterator, thrower, null, null, null);
          }
        }
        iterator();
      }
      iterator();
      return ret;
    }
    function Disposer(data, promise, context3) {
      this._data = data;
      this._promise = promise;
      this._context = context3;
    }
    Disposer.prototype.data = function() {
      return this._data;
    };
    Disposer.prototype.promise = function() {
      return this._promise;
    };
    Disposer.prototype.resource = function() {
      if (this.promise().isFulfilled()) {
        return this.promise().value();
      }
      return NULL;
    };
    Disposer.prototype.tryDispose = function(inspection) {
      var resource = this.resource();
      var context3 = this._context;
      if (context3 !== undefined)
        context3._pushContext();
      var ret = resource !== NULL ? this.doDispose(resource, inspection) : null;
      if (context3 !== undefined)
        context3._popContext();
      this._promise._unsetDisposable();
      this._data = null;
      return ret;
    };
    Disposer.isDisposer = function(d) {
      return d != null && typeof d.resource === "function" && typeof d.tryDispose === "function";
    };
    function FunctionDisposer(fn, promise, context3) {
      this.constructor$(fn, promise, context3);
    }
    inherits(FunctionDisposer, Disposer);
    FunctionDisposer.prototype.doDispose = function(resource, inspection) {
      var fn = this.data();
      return fn.call(resource, resource, inspection);
    };
    function maybeUnwrapDisposer(value) {
      if (Disposer.isDisposer(value)) {
        this.resources[this.index]._setDisposable(value);
        return value.promise();
      }
      return value;
    }
    function ResourceList(length) {
      this.length = length;
      this.promise = null;
      this[length - 1] = null;
    }
    ResourceList.prototype._resultCancelled = function() {
      var len = this.length;
      for (var i = 0;i < len; ++i) {
        var item = this[i];
        if (item instanceof Promise2) {
          item.cancel();
        }
      }
    };
    Promise2.using = function() {
      var len = arguments.length;
      if (len < 2)
        return apiRejection("you must pass at least 2 arguments to Promise.using");
      var fn = arguments[len - 1];
      if (typeof fn !== "function") {
        return apiRejection("expecting a function but got " + util3.classString(fn));
      }
      var input;
      var spreadArgs = true;
      if (len === 2 && Array.isArray(arguments[0])) {
        input = arguments[0];
        len = input.length;
        spreadArgs = false;
      } else {
        input = arguments;
        len--;
      }
      var resources = new ResourceList(len);
      for (var i = 0;i < len; ++i) {
        var resource = input[i];
        if (Disposer.isDisposer(resource)) {
          var disposer = resource;
          resource = resource.promise();
          resource._setDisposable(disposer);
        } else {
          var maybePromise = tryConvertToPromise(resource);
          if (maybePromise instanceof Promise2) {
            resource = maybePromise._then(maybeUnwrapDisposer, null, null, {
              resources,
              index: i
            }, undefined);
          }
        }
        resources[i] = resource;
      }
      var reflectedResources = new Array(resources.length);
      for (var i = 0;i < reflectedResources.length; ++i) {
        reflectedResources[i] = Promise2.resolve(resources[i]).reflect();
      }
      var resultPromise = Promise2.all(reflectedResources).then(function(inspections) {
        for (var i2 = 0;i2 < inspections.length; ++i2) {
          var inspection = inspections[i2];
          if (inspection.isRejected()) {
            errorObj.e = inspection.error();
            return errorObj;
          } else if (!inspection.isFulfilled()) {
            resultPromise.cancel();
            return;
          }
          inspections[i2] = inspection.value();
        }
        promise._pushContext();
        fn = tryCatch(fn);
        var ret = spreadArgs ? fn.apply(undefined, inspections) : fn(inspections);
        var promiseCreated = promise._popContext();
        debug.checkForgottenReturns(ret, promiseCreated, "Promise.using", promise);
        return ret;
      });
      var promise = resultPromise.lastly(function() {
        var inspection = new Promise2.PromiseInspection(resultPromise);
        return dispose(resources, inspection);
      });
      resources.promise = promise;
      promise._setOnCancel(resources);
      return promise;
    };
    Promise2.prototype._setDisposable = function(disposer) {
      this._bitField = this._bitField | 131072;
      this._disposer = disposer;
    };
    Promise2.prototype._isDisposable = function() {
      return (this._bitField & 131072) > 0;
    };
    Promise2.prototype._getDisposer = function() {
      return this._disposer;
    };
    Promise2.prototype._unsetDisposable = function() {
      this._bitField = this._bitField & ~131072;
      this._disposer = undefined;
    };
    Promise2.prototype.disposer = function(fn) {
      if (typeof fn === "function") {
        return new FunctionDisposer(fn, this, createContext());
      }
      throw new TypeError2;
    };
  };
});

// node_modules/bluebird/js/release/any.js
var require_any = __commonJS((exports, module) => {
  module.exports = function(Promise2) {
    var SomePromiseArray = Promise2._SomePromiseArray;
    function any(promises) {
      var ret = new SomePromiseArray(promises);
      var promise = ret.promise();
      ret.setHowMany(1);
      ret.setUnwrap();
      ret.init();
      return promise;
    }
    Promise2.any = function(promises) {
      return any(promises);
    };
    Promise2.prototype.any = function() {
      return any(this);
    };
  };
});

// node_modules/bluebird/js/release/each.js
var require_each = __commonJS((exports, module) => {
  module.exports = function(Promise2, INTERNAL) {
    var PromiseReduce = Promise2.reduce;
    var PromiseAll = Promise2.all;
    function promiseAllThis() {
      return PromiseAll(this);
    }
    function PromiseMapSeries(promises, fn) {
      return PromiseReduce(promises, fn, INTERNAL, INTERNAL);
    }
    Promise2.prototype.each = function(fn) {
      return PromiseReduce(this, fn, INTERNAL, 0)._then(promiseAllThis, undefined, undefined, this, undefined);
    };
    Promise2.prototype.mapSeries = function(fn) {
      return PromiseReduce(this, fn, INTERNAL, INTERNAL);
    };
    Promise2.each = function(promises, fn) {
      return PromiseReduce(promises, fn, INTERNAL, 0)._then(promiseAllThis, undefined, undefined, promises, undefined);
    };
    Promise2.mapSeries = PromiseMapSeries;
  };
});

// node_modules/bluebird/js/release/filter.js
var require_filter = __commonJS((exports, module) => {
  module.exports = function(Promise2, INTERNAL) {
    var PromiseMap = Promise2.map;
    Promise2.prototype.filter = function(fn, options) {
      return PromiseMap(this, fn, options, INTERNAL);
    };
    Promise2.filter = function(promises, fn, options) {
      return PromiseMap(promises, fn, options, INTERNAL);
    };
  };
});

// node_modules/bluebird/js/release/promise.js
var require_promise = __commonJS((exports, module) => {
  module.exports = function() {
    var makeSelfResolutionError = function() {
      return new TypeError2(`circular promise resolution chain

    See http://goo.gl/MqrFmX
`);
    };
    var reflectHandler = function() {
      return new Promise2.PromiseInspection(this._target());
    };
    var apiRejection = function(msg) {
      return Promise2.reject(new TypeError2(msg));
    };
    function Proxyable() {
    }
    var UNDEFINED_BINDING = {};
    var util3 = require_util3();
    util3.setReflectHandler(reflectHandler);
    var getDomain = function() {
      var domain = process.domain;
      if (domain === undefined) {
        return null;
      }
      return domain;
    };
    var getContextDefault = function() {
      return null;
    };
    var getContextDomain = function() {
      return {
        domain: getDomain(),
        async: null
      };
    };
    var AsyncResource = util3.isNode && util3.nodeSupportsAsyncResource ? __require("async_hooks").AsyncResource : null;
    var getContextAsyncHooks = function() {
      return {
        domain: getDomain(),
        async: new AsyncResource("Bluebird::Promise")
      };
    };
    var getContext = util3.isNode ? getContextDomain : getContextDefault;
    util3.notEnumerableProp(Promise2, "_getContext", getContext);
    var enableAsyncHooks = function() {
      getContext = getContextAsyncHooks;
      util3.notEnumerableProp(Promise2, "_getContext", getContextAsyncHooks);
    };
    var disableAsyncHooks = function() {
      getContext = getContextDomain;
      util3.notEnumerableProp(Promise2, "_getContext", getContextDomain);
    };
    var es5 = require_es5();
    var Async = require_async();
    var async = new Async;
    es5.defineProperty(Promise2, "_async", { value: async });
    var errors15 = require_errors2();
    var TypeError2 = Promise2.TypeError = errors15.TypeError;
    Promise2.RangeError = errors15.RangeError;
    var CancellationError = Promise2.CancellationError = errors15.CancellationError;
    Promise2.TimeoutError = errors15.TimeoutError;
    Promise2.OperationalError = errors15.OperationalError;
    Promise2.RejectionError = errors15.OperationalError;
    Promise2.AggregateError = errors15.AggregateError;
    var INTERNAL = function() {
    };
    var APPLY = {};
    var NEXT_FILTER = {};
    var tryConvertToPromise = require_thenables()(Promise2, INTERNAL);
    var PromiseArray = require_promise_array()(Promise2, INTERNAL, tryConvertToPromise, apiRejection, Proxyable);
    var Context2 = require_context()(Promise2);
    var createContext = Context2.create;
    var debug = require_debuggability()(Promise2, Context2, enableAsyncHooks, disableAsyncHooks);
    var CapturedTrace = debug.CapturedTrace;
    var PassThroughHandlerContext = require_finally()(Promise2, tryConvertToPromise, NEXT_FILTER);
    var catchFilter = require_catch_filter()(NEXT_FILTER);
    var nodebackForPromise = require_nodeback();
    var errorObj = util3.errorObj;
    var tryCatch = util3.tryCatch;
    function check(self2, executor) {
      if (self2 == null || self2.constructor !== Promise2) {
        throw new TypeError2(`the promise constructor cannot be invoked directly

    See http://goo.gl/MqrFmX
`);
      }
      if (typeof executor !== "function") {
        throw new TypeError2("expecting a function but got " + util3.classString(executor));
      }
    }
    function Promise2(executor) {
      if (executor !== INTERNAL) {
        check(this, executor);
      }
      this._bitField = 0;
      this._fulfillmentHandler0 = undefined;
      this._rejectionHandler0 = undefined;
      this._promise0 = undefined;
      this._receiver0 = undefined;
      this._resolveFromExecutor(executor);
      this._promiseCreated();
      this._fireEvent("promiseCreated", this);
    }
    Promise2.prototype.toString = function() {
      return "[object Promise]";
    };
    Promise2.prototype.caught = Promise2.prototype["catch"] = function(fn) {
      var len = arguments.length;
      if (len > 1) {
        var catchInstances = new Array(len - 1), j = 0, i;
        for (i = 0;i < len - 1; ++i) {
          var item = arguments[i];
          if (util3.isObject(item)) {
            catchInstances[j++] = item;
          } else {
            return apiRejection("Catch statement predicate: expecting an object but got " + util3.classString(item));
          }
        }
        catchInstances.length = j;
        fn = arguments[i];
        if (typeof fn !== "function") {
          throw new TypeError2("The last argument to .catch() must be a function, got " + util3.toString(fn));
        }
        return this.then(undefined, catchFilter(catchInstances, fn, this));
      }
      return this.then(undefined, fn);
    };
    Promise2.prototype.reflect = function() {
      return this._then(reflectHandler, reflectHandler, undefined, this, undefined);
    };
    Promise2.prototype.then = function(didFulfill, didReject) {
      if (debug.warnings() && arguments.length > 0 && typeof didFulfill !== "function" && typeof didReject !== "function") {
        var msg = ".then() only accepts functions but was passed: " + util3.classString(didFulfill);
        if (arguments.length > 1) {
          msg += ", " + util3.classString(didReject);
        }
        this._warn(msg);
      }
      return this._then(didFulfill, didReject, undefined, undefined, undefined);
    };
    Promise2.prototype.done = function(didFulfill, didReject) {
      var promise = this._then(didFulfill, didReject, undefined, undefined, undefined);
      promise._setIsFinal();
    };
    Promise2.prototype.spread = function(fn) {
      if (typeof fn !== "function") {
        return apiRejection("expecting a function but got " + util3.classString(fn));
      }
      return this.all()._then(fn, undefined, undefined, APPLY, undefined);
    };
    Promise2.prototype.toJSON = function() {
      var ret = {
        isFulfilled: false,
        isRejected: false,
        fulfillmentValue: undefined,
        rejectionReason: undefined
      };
      if (this.isFulfilled()) {
        ret.fulfillmentValue = this.value();
        ret.isFulfilled = true;
      } else if (this.isRejected()) {
        ret.rejectionReason = this.reason();
        ret.isRejected = true;
      }
      return ret;
    };
    Promise2.prototype.all = function() {
      if (arguments.length > 0) {
        this._warn(".all() was passed arguments but it does not take any");
      }
      return new PromiseArray(this).promise();
    };
    Promise2.prototype.error = function(fn) {
      return this.caught(util3.originatesFromRejection, fn);
    };
    Promise2.getNewLibraryCopy = module.exports;
    Promise2.is = function(val) {
      return val instanceof Promise2;
    };
    Promise2.fromNode = Promise2.fromCallback = function(fn) {
      var ret = new Promise2(INTERNAL);
      ret._captureStackTrace();
      var multiArgs = arguments.length > 1 ? !!Object(arguments[1]).multiArgs : false;
      var result2 = tryCatch(fn)(nodebackForPromise(ret, multiArgs));
      if (result2 === errorObj) {
        ret._rejectCallback(result2.e, true);
      }
      if (!ret._isFateSealed())
        ret._setAsyncGuaranteed();
      return ret;
    };
    Promise2.all = function(promises) {
      return new PromiseArray(promises).promise();
    };
    Promise2.cast = function(obj) {
      var ret = tryConvertToPromise(obj);
      if (!(ret instanceof Promise2)) {
        ret = new Promise2(INTERNAL);
        ret._captureStackTrace();
        ret._setFulfilled();
        ret._rejectionHandler0 = obj;
      }
      return ret;
    };
    Promise2.resolve = Promise2.fulfilled = Promise2.cast;
    Promise2.reject = Promise2.rejected = function(reason) {
      var ret = new Promise2(INTERNAL);
      ret._captureStackTrace();
      ret._rejectCallback(reason, true);
      return ret;
    };
    Promise2.setScheduler = function(fn) {
      if (typeof fn !== "function") {
        throw new TypeError2("expecting a function but got " + util3.classString(fn));
      }
      return async.setScheduler(fn);
    };
    Promise2.prototype._then = function(didFulfill, didReject, _, receiver, internalData) {
      var haveInternalData = internalData !== undefined;
      var promise = haveInternalData ? internalData : new Promise2(INTERNAL);
      var target = this._target();
      var bitField = target._bitField;
      if (!haveInternalData) {
        promise._propagateFrom(this, 3);
        promise._captureStackTrace();
        if (receiver === undefined && (this._bitField & 2097152) !== 0) {
          if (!((bitField & 50397184) === 0)) {
            receiver = this._boundValue();
          } else {
            receiver = target === this ? undefined : this._boundTo;
          }
        }
        this._fireEvent("promiseChained", this, promise);
      }
      var context3 = getContext();
      if (!((bitField & 50397184) === 0)) {
        var handler, value, settler = target._settlePromiseCtx;
        if ((bitField & 33554432) !== 0) {
          value = target._rejectionHandler0;
          handler = didFulfill;
        } else if ((bitField & 16777216) !== 0) {
          value = target._fulfillmentHandler0;
          handler = didReject;
          target._unsetRejectionIsUnhandled();
        } else {
          settler = target._settlePromiseLateCancellationObserver;
          value = new CancellationError("late cancellation observer");
          target._attachExtraTrace(value);
          handler = didReject;
        }
        async.invoke(settler, target, {
          handler: util3.contextBind(context3, handler),
          promise,
          receiver,
          value
        });
      } else {
        target._addCallbacks(didFulfill, didReject, promise, receiver, context3);
      }
      return promise;
    };
    Promise2.prototype._length = function() {
      return this._bitField & 65535;
    };
    Promise2.prototype._isFateSealed = function() {
      return (this._bitField & 117506048) !== 0;
    };
    Promise2.prototype._isFollowing = function() {
      return (this._bitField & 67108864) === 67108864;
    };
    Promise2.prototype._setLength = function(len) {
      this._bitField = this._bitField & -65536 | len & 65535;
    };
    Promise2.prototype._setFulfilled = function() {
      this._bitField = this._bitField | 33554432;
      this._fireEvent("promiseFulfilled", this);
    };
    Promise2.prototype._setRejected = function() {
      this._bitField = this._bitField | 16777216;
      this._fireEvent("promiseRejected", this);
    };
    Promise2.prototype._setFollowing = function() {
      this._bitField = this._bitField | 67108864;
      this._fireEvent("promiseResolved", this);
    };
    Promise2.prototype._setIsFinal = function() {
      this._bitField = this._bitField | 4194304;
    };
    Promise2.prototype._isFinal = function() {
      return (this._bitField & 4194304) > 0;
    };
    Promise2.prototype._unsetCancelled = function() {
      this._bitField = this._bitField & ~65536;
    };
    Promise2.prototype._setCancelled = function() {
      this._bitField = this._bitField | 65536;
      this._fireEvent("promiseCancelled", this);
    };
    Promise2.prototype._setWillBeCancelled = function() {
      this._bitField = this._bitField | 8388608;
    };
    Promise2.prototype._setAsyncGuaranteed = function() {
      if (async.hasCustomScheduler())
        return;
      var bitField = this._bitField;
      this._bitField = bitField | (bitField & 536870912) >> 2 ^ 134217728;
    };
    Promise2.prototype._setNoAsyncGuarantee = function() {
      this._bitField = (this._bitField | 536870912) & ~134217728;
    };
    Promise2.prototype._receiverAt = function(index) {
      var ret = index === 0 ? this._receiver0 : this[index * 4 - 4 + 3];
      if (ret === UNDEFINED_BINDING) {
        return;
      } else if (ret === undefined && this._isBound()) {
        return this._boundValue();
      }
      return ret;
    };
    Promise2.prototype._promiseAt = function(index) {
      return this[index * 4 - 4 + 2];
    };
    Promise2.prototype._fulfillmentHandlerAt = function(index) {
      return this[index * 4 - 4 + 0];
    };
    Promise2.prototype._rejectionHandlerAt = function(index) {
      return this[index * 4 - 4 + 1];
    };
    Promise2.prototype._boundValue = function() {
    };
    Promise2.prototype._migrateCallback0 = function(follower) {
      var bitField = follower._bitField;
      var fulfill = follower._fulfillmentHandler0;
      var reject = follower._rejectionHandler0;
      var promise = follower._promise0;
      var receiver = follower._receiverAt(0);
      if (receiver === undefined)
        receiver = UNDEFINED_BINDING;
      this._addCallbacks(fulfill, reject, promise, receiver, null);
    };
    Promise2.prototype._migrateCallbackAt = function(follower, index) {
      var fulfill = follower._fulfillmentHandlerAt(index);
      var reject = follower._rejectionHandlerAt(index);
      var promise = follower._promiseAt(index);
      var receiver = follower._receiverAt(index);
      if (receiver === undefined)
        receiver = UNDEFINED_BINDING;
      this._addCallbacks(fulfill, reject, promise, receiver, null);
    };
    Promise2.prototype._addCallbacks = function(fulfill, reject, promise, receiver, context3) {
      var index = this._length();
      if (index >= 65535 - 4) {
        index = 0;
        this._setLength(0);
      }
      if (index === 0) {
        this._promise0 = promise;
        this._receiver0 = receiver;
        if (typeof fulfill === "function") {
          this._fulfillmentHandler0 = util3.contextBind(context3, fulfill);
        }
        if (typeof reject === "function") {
          this._rejectionHandler0 = util3.contextBind(context3, reject);
        }
      } else {
        var base = index * 4 - 4;
        this[base + 2] = promise;
        this[base + 3] = receiver;
        if (typeof fulfill === "function") {
          this[base + 0] = util3.contextBind(context3, fulfill);
        }
        if (typeof reject === "function") {
          this[base + 1] = util3.contextBind(context3, reject);
        }
      }
      this._setLength(index + 1);
      return index;
    };
    Promise2.prototype._proxy = function(proxyable, arg) {
      this._addCallbacks(undefined, undefined, arg, proxyable, null);
    };
    Promise2.prototype._resolveCallback = function(value, shouldBind) {
      if ((this._bitField & 117506048) !== 0)
        return;
      if (value === this)
        return this._rejectCallback(makeSelfResolutionError(), false);
      var maybePromise = tryConvertToPromise(value, this);
      if (!(maybePromise instanceof Promise2))
        return this._fulfill(value);
      if (shouldBind)
        this._propagateFrom(maybePromise, 2);
      var promise = maybePromise._target();
      if (promise === this) {
        this._reject(makeSelfResolutionError());
        return;
      }
      var bitField = promise._bitField;
      if ((bitField & 50397184) === 0) {
        var len = this._length();
        if (len > 0)
          promise._migrateCallback0(this);
        for (var i = 1;i < len; ++i) {
          promise._migrateCallbackAt(this, i);
        }
        this._setFollowing();
        this._setLength(0);
        this._setFollowee(maybePromise);
      } else if ((bitField & 33554432) !== 0) {
        this._fulfill(promise._value());
      } else if ((bitField & 16777216) !== 0) {
        this._reject(promise._reason());
      } else {
        var reason = new CancellationError("late cancellation observer");
        promise._attachExtraTrace(reason);
        this._reject(reason);
      }
    };
    Promise2.prototype._rejectCallback = function(reason, synchronous, ignoreNonErrorWarnings) {
      var trace = util3.ensureErrorObject(reason);
      var hasStack = trace === reason;
      if (!hasStack && !ignoreNonErrorWarnings && debug.warnings()) {
        var message2 = "a promise was rejected with a non-error: " + util3.classString(reason);
        this._warn(message2, true);
      }
      this._attachExtraTrace(trace, synchronous ? hasStack : false);
      this._reject(reason);
    };
    Promise2.prototype._resolveFromExecutor = function(executor) {
      if (executor === INTERNAL)
        return;
      var promise = this;
      this._captureStackTrace();
      this._pushContext();
      var synchronous = true;
      var r = this._execute(executor, function(value) {
        promise._resolveCallback(value);
      }, function(reason) {
        promise._rejectCallback(reason, synchronous);
      });
      synchronous = false;
      this._popContext();
      if (r !== undefined) {
        promise._rejectCallback(r, true);
      }
    };
    Promise2.prototype._settlePromiseFromHandler = function(handler, receiver, value, promise) {
      var bitField = promise._bitField;
      if ((bitField & 65536) !== 0)
        return;
      promise._pushContext();
      var x;
      if (receiver === APPLY) {
        if (!value || typeof value.length !== "number") {
          x = errorObj;
          x.e = new TypeError2("cannot .spread() a non-array: " + util3.classString(value));
        } else {
          x = tryCatch(handler).apply(this._boundValue(), value);
        }
      } else {
        x = tryCatch(handler).call(receiver, value);
      }
      var promiseCreated = promise._popContext();
      bitField = promise._bitField;
      if ((bitField & 65536) !== 0)
        return;
      if (x === NEXT_FILTER) {
        promise._reject(value);
      } else if (x === errorObj) {
        promise._rejectCallback(x.e, false);
      } else {
        debug.checkForgottenReturns(x, promiseCreated, "", promise, this);
        promise._resolveCallback(x);
      }
    };
    Promise2.prototype._target = function() {
      var ret = this;
      while (ret._isFollowing())
        ret = ret._followee();
      return ret;
    };
    Promise2.prototype._followee = function() {
      return this._rejectionHandler0;
    };
    Promise2.prototype._setFollowee = function(promise) {
      this._rejectionHandler0 = promise;
    };
    Promise2.prototype._settlePromise = function(promise, handler, receiver, value) {
      var isPromise = promise instanceof Promise2;
      var bitField = this._bitField;
      var asyncGuaranteed = (bitField & 134217728) !== 0;
      if ((bitField & 65536) !== 0) {
        if (isPromise)
          promise._invokeInternalOnCancel();
        if (receiver instanceof PassThroughHandlerContext && receiver.isFinallyHandler()) {
          receiver.cancelPromise = promise;
          if (tryCatch(handler).call(receiver, value) === errorObj) {
            promise._reject(errorObj.e);
          }
        } else if (handler === reflectHandler) {
          promise._fulfill(reflectHandler.call(receiver));
        } else if (receiver instanceof Proxyable) {
          receiver._promiseCancelled(promise);
        } else if (isPromise || promise instanceof PromiseArray) {
          promise._cancel();
        } else {
          receiver.cancel();
        }
      } else if (typeof handler === "function") {
        if (!isPromise) {
          handler.call(receiver, value, promise);
        } else {
          if (asyncGuaranteed)
            promise._setAsyncGuaranteed();
          this._settlePromiseFromHandler(handler, receiver, value, promise);
        }
      } else if (receiver instanceof Proxyable) {
        if (!receiver._isResolved()) {
          if ((bitField & 33554432) !== 0) {
            receiver._promiseFulfilled(value, promise);
          } else {
            receiver._promiseRejected(value, promise);
          }
        }
      } else if (isPromise) {
        if (asyncGuaranteed)
          promise._setAsyncGuaranteed();
        if ((bitField & 33554432) !== 0) {
          promise._fulfill(value);
        } else {
          promise._reject(value);
        }
      }
    };
    Promise2.prototype._settlePromiseLateCancellationObserver = function(ctx) {
      var handler = ctx.handler;
      var promise = ctx.promise;
      var receiver = ctx.receiver;
      var value = ctx.value;
      if (typeof handler === "function") {
        if (!(promise instanceof Promise2)) {
          handler.call(receiver, value, promise);
        } else {
          this._settlePromiseFromHandler(handler, receiver, value, promise);
        }
      } else if (promise instanceof Promise2) {
        promise._reject(value);
      }
    };
    Promise2.prototype._settlePromiseCtx = function(ctx) {
      this._settlePromise(ctx.promise, ctx.handler, ctx.receiver, ctx.value);
    };
    Promise2.prototype._settlePromise0 = function(handler, value, bitField) {
      var promise = this._promise0;
      var receiver = this._receiverAt(0);
      this._promise0 = undefined;
      this._receiver0 = undefined;
      this._settlePromise(promise, handler, receiver, value);
    };
    Promise2.prototype._clearCallbackDataAtIndex = function(index) {
      var base = index * 4 - 4;
      this[base + 2] = this[base + 3] = this[base + 0] = this[base + 1] = undefined;
    };
    Promise2.prototype._fulfill = function(value) {
      var bitField = this._bitField;
      if ((bitField & 117506048) >>> 16)
        return;
      if (value === this) {
        var err = makeSelfResolutionError();
        this._attachExtraTrace(err);
        return this._reject(err);
      }
      this._setFulfilled();
      this._rejectionHandler0 = value;
      if ((bitField & 65535) > 0) {
        if ((bitField & 134217728) !== 0) {
          this._settlePromises();
        } else {
          async.settlePromises(this);
        }
        this._dereferenceTrace();
      }
    };
    Promise2.prototype._reject = function(reason) {
      var bitField = this._bitField;
      if ((bitField & 117506048) >>> 16)
        return;
      this._setRejected();
      this._fulfillmentHandler0 = reason;
      if (this._isFinal()) {
        return async.fatalError(reason, util3.isNode);
      }
      if ((bitField & 65535) > 0) {
        async.settlePromises(this);
      } else {
        this._ensurePossibleRejectionHandled();
      }
    };
    Promise2.prototype._fulfillPromises = function(len, value) {
      for (var i = 1;i < len; i++) {
        var handler = this._fulfillmentHandlerAt(i);
        var promise = this._promiseAt(i);
        var receiver = this._receiverAt(i);
        this._clearCallbackDataAtIndex(i);
        this._settlePromise(promise, handler, receiver, value);
      }
    };
    Promise2.prototype._rejectPromises = function(len, reason) {
      for (var i = 1;i < len; i++) {
        var handler = this._rejectionHandlerAt(i);
        var promise = this._promiseAt(i);
        var receiver = this._receiverAt(i);
        this._clearCallbackDataAtIndex(i);
        this._settlePromise(promise, handler, receiver, reason);
      }
    };
    Promise2.prototype._settlePromises = function() {
      var bitField = this._bitField;
      var len = bitField & 65535;
      if (len > 0) {
        if ((bitField & 16842752) !== 0) {
          var reason = this._fulfillmentHandler0;
          this._settlePromise0(this._rejectionHandler0, reason, bitField);
          this._rejectPromises(len, reason);
        } else {
          var value = this._rejectionHandler0;
          this._settlePromise0(this._fulfillmentHandler0, value, bitField);
          this._fulfillPromises(len, value);
        }
        this._setLength(0);
      }
      this._clearCancellationData();
    };
    Promise2.prototype._settledValue = function() {
      var bitField = this._bitField;
      if ((bitField & 33554432) !== 0) {
        return this._rejectionHandler0;
      } else if ((bitField & 16777216) !== 0) {
        return this._fulfillmentHandler0;
      }
    };
    if (typeof Symbol !== "undefined" && Symbol.toStringTag) {
      es5.defineProperty(Promise2.prototype, Symbol.toStringTag, {
        get: function() {
          return "Object";
        }
      });
    }
    function deferResolve(v) {
      this.promise._resolveCallback(v);
    }
    function deferReject(v) {
      this.promise._rejectCallback(v, false);
    }
    Promise2.defer = Promise2.pending = function() {
      debug.deprecated("Promise.defer", "new Promise");
      var promise = new Promise2(INTERNAL);
      return {
        promise,
        resolve: deferResolve,
        reject: deferReject
      };
    };
    util3.notEnumerableProp(Promise2, "_makeSelfResolutionError", makeSelfResolutionError);
    require_method()(Promise2, INTERNAL, tryConvertToPromise, apiRejection, debug);
    require_bind()(Promise2, INTERNAL, tryConvertToPromise, debug);
    require_cancel()(Promise2, PromiseArray, apiRejection, debug);
    require_direct_resolve()(Promise2);
    require_synchronous_inspection()(Promise2);
    require_join()(Promise2, PromiseArray, tryConvertToPromise, INTERNAL, async);
    Promise2.Promise = Promise2;
    Promise2.version = "3.7.2";
    require_call_get()(Promise2);
    require_generators()(Promise2, apiRejection, INTERNAL, tryConvertToPromise, Proxyable, debug);
    require_map()(Promise2, PromiseArray, apiRejection, tryConvertToPromise, INTERNAL, debug);
    require_nodeify()(Promise2);
    require_promisify()(Promise2, INTERNAL);
    require_props()(Promise2, PromiseArray, tryConvertToPromise, apiRejection);
    require_race()(Promise2, INTERNAL, tryConvertToPromise, apiRejection);
    require_reduce()(Promise2, PromiseArray, apiRejection, tryConvertToPromise, INTERNAL, debug);
    require_settle()(Promise2, PromiseArray, debug);
    require_some()(Promise2, PromiseArray, apiRejection);
    require_timers()(Promise2, INTERNAL, debug);
    require_using()(Promise2, apiRejection, tryConvertToPromise, createContext, INTERNAL, debug);
    require_any()(Promise2);
    require_each()(Promise2, INTERNAL);
    require_filter()(Promise2, INTERNAL);
    util3.toFastProperties(Promise2);
    util3.toFastProperties(Promise2.prototype);
    function fillTypes(value) {
      var p = new Promise2(INTERNAL);
      p._fulfillmentHandler0 = value;
      p._rejectionHandler0 = value;
      p._promise0 = value;
      p._receiver0 = value;
    }
    fillTypes({ a: 1 });
    fillTypes({ b: 2 });
    fillTypes({ c: 3 });
    fillTypes(1);
    fillTypes(function() {
    });
    fillTypes(undefined);
    fillTypes(false);
    fillTypes(new Promise2(INTERNAL));
    debug.setBounds(Async.firstLineError, util3.lastLineError);
    return Promise2;
  };
});

// node_modules/bluebird/js/release/bluebird.js
var require_bluebird = __commonJS((exports, module) => {
  var noConflict = function() {
    try {
      if (Promise === bluebird)
        Promise = old;
    } catch (e) {
    }
    return bluebird;
  };
  var old;
  if (typeof Promise !== "undefined")
    old = Promise;
  var bluebird = require_promise()();
  bluebird.noConflict = noConflict;
  module.exports = bluebird;
});

// node_modules/amqplib/lib/channel.js
var require_channel = __commonJS((exports, module) => {
  var Channel = function(connection3) {
    EventEmitter.call(this);
    this.connection = connection3;
    this.reply = null;
    this.pending = [];
    this.lwm = 1;
    this.unconfirmed = [];
    this.on("ack", this.handleConfirm.bind(this, function(cb) {
      if (cb)
        cb(null);
    }));
    this.on("nack", this.handleConfirm.bind(this, function(cb) {
      if (cb)
        cb(new Error("message nacked"));
    }));
    this.on("close", function() {
      var cb;
      while (cb = this.unconfirmed.shift()) {
        if (cb)
          cb(new Error("channel closed"));
      }
    });
    this.handleMessage = acceptDeliveryOrReturn;
  };
  var invalidOp = function(msg, stack) {
    return function() {
      throw new IllegalOperationError(msg, stack);
    };
  };
  var invalidateSend = function(ch, msg, stack) {
    ch.sendImmediately = ch.sendOrEnqueue = ch.sendMessage = invalidOp(msg, stack);
  };
  var acceptDeliveryOrReturn = function(f) {
    var event;
    if (f.id === defs.BasicDeliver)
      event = "delivery";
    else if (f.id === defs.BasicReturn)
      event = "return";
    else
      throw fmt("Expected BasicDeliver or BasicReturn; got %s", inspect2(f));
    var self2 = this;
    var fields = f.fields;
    return acceptMessage(function(message2) {
      message2.fields = fields;
      self2.emit(event, message2);
    });
  };
  var acceptMessage = function(continuation) {
    var totalSize = 0, remaining = 0;
    var buffers = null;
    var message2 = {
      fields: null,
      properties: null,
      content: null
    };
    return headers;
    function headers(f) {
      if (f.id === defs.BasicProperties) {
        message2.properties = f.fields;
        totalSize = remaining = f.size;
        if (totalSize === 0) {
          message2.content = Buffer4.alloc(0);
          continuation(message2);
          return acceptDeliveryOrReturn;
        } else {
          return content;
        }
      } else {
        throw "Expected headers frame after delivery";
      }
    }
    function content(f) {
      if (f.content) {
        var size2 = f.content.length;
        remaining -= size2;
        if (remaining === 0) {
          if (buffers !== null) {
            buffers.push(f.content);
            message2.content = Buffer4.concat(buffers);
          } else {
            message2.content = f.content;
          }
          continuation(message2);
          return acceptDeliveryOrReturn;
        } else if (remaining < 0) {
          throw fmt("Too much content sent! Expected %d bytes", totalSize);
        } else {
          if (buffers !== null)
            buffers.push(f.content);
          else
            buffers = [f.content];
          return content;
        }
      } else
        throw "Expected content frame after headers";
    }
  };
  var BaseChannel = function(connection3) {
    Channel.call(this, connection3);
    this.consumers = {};
  };
  var defs = require_defs();
  var closeMsg = require_format().closeMessage;
  var inspect2 = require_format().inspect;
  var methodName = require_format().methodName;
  var assert = __require("assert");
  var inherits = __require("util").inherits;
  var EventEmitter = __require("events").EventEmitter;
  var fmt = __require("util").format;
  var IllegalOperationError = require_error().IllegalOperationError;
  var stackCapture = require_error().stackCapture;
  var Buffer4 = require_safe_buffer().Buffer;
  inherits(Channel, EventEmitter);
  exports.Channel = Channel;
  exports.acceptMessage = acceptMessage;
  var C = Channel.prototype;
  C.allocate = function() {
    this.ch = this.connection.freshChannel(this);
    return this;
  };
  C.sendImmediately = function(method, fields) {
    return this.connection.sendMethod(this.ch, method, fields);
  };
  C.sendOrEnqueue = function(method, fields, reply) {
    if (!this.reply) {
      assert(this.pending.length === 0);
      this.reply = reply;
      this.sendImmediately(method, fields);
    } else {
      this.pending.push({
        method,
        fields,
        reply
      });
    }
  };
  C.sendMessage = function(fields, properties, content) {
    return this.connection.sendMessage(this.ch, defs.BasicPublish, fields, defs.BasicProperties, properties, content);
  };
  C._rpc = function(method, fields, expect, cb) {
    var self2 = this;
    function reply(err, f) {
      if (err === null) {
        if (f.id === expect) {
          return cb(null, f);
        } else {
          var expectedName = methodName(expect);
          var e = new Error(fmt("Expected %s; got %s", expectedName, inspect2(f, false)));
          self2.closeWithError(f.id, fmt("Expected %s; got %s", expectedName, methodName(f.id)), defs.constants.UNEXPECTED_FRAME, e);
          return cb(e);
        }
      } else if (err instanceof Error)
        return cb(err);
      else {
        var closeReason = (err.fields.classId << 16) + err.fields.methodId;
        var e = method === closeReason ? fmt("Operation failed: %s; %s", methodName(method), closeMsg(err)) : fmt("Channel closed by server: %s", closeMsg(err));
        var closeFrameError = new Error(e);
        closeFrameError.code = err.fields.replyCode;
        closeFrameError.classId = err.fields.classId;
        closeFrameError.methodId = err.fields.methodId;
        return cb(closeFrameError);
      }
    }
    this.sendOrEnqueue(method, fields, reply);
  };
  C.toClosed = function(capturedStack) {
    this._rejectPending();
    invalidateSend(this, "Channel closed", capturedStack);
    this.accept = invalidOp("Channel closed", capturedStack);
    this.connection.releaseChannel(this.ch);
    this.emit("close");
  };
  C.toClosing = function(capturedStack, k) {
    var send = this.sendImmediately.bind(this);
    invalidateSend(this, "Channel closing", capturedStack);
    this.accept = function(f) {
      if (f.id === defs.ChannelCloseOk) {
        if (k)
          k();
        var s = stackCapture("ChannelCloseOk frame received");
        this.toClosed(s);
      } else if (f.id === defs.ChannelClose) {
        send(defs.ChannelCloseOk, {});
      }
    };
  };
  C._rejectPending = function() {
    function rej(r) {
      r(new Error("Channel ended, no reply will be forthcoming"));
    }
    if (this.reply !== null)
      rej(this.reply);
    this.reply = null;
    var discard;
    while (discard = this.pending.shift())
      rej(discard.reply);
    this.pending = null;
  };
  C.closeBecause = function(reason, code, k) {
    this.sendImmediately(defs.ChannelClose, {
      replyText: reason,
      replyCode: code,
      methodId: 0,
      classId: 0
    });
    var s = stackCapture("closeBecause called: " + reason);
    this.toClosing(s, k);
  };
  C.closeWithError = function(id, reason, code, error) {
    var self2 = this;
    this.closeBecause(reason, code, function() {
      error.code = code;
      if (id) {
        error.classId = defs.info(id).classId;
        error.methodId = defs.info(id).methodId;
      }
      self2.emit("error", error);
    });
  };
  C.acceptMessageFrame = function(f) {
    try {
      this.handleMessage = this.handleMessage(f);
    } catch (msg) {
      if (typeof msg === "string") {
        this.closeWithError(f.id, msg, defs.constants.UNEXPECTED_FRAME, new Error(msg));
      } else if (msg instanceof Error) {
        this.closeWithError(f.id, "Error while processing message", defs.constants.INTERNAL_ERROR, msg);
      } else {
        this.closeWithError(f.id, "Internal error while processing message", defs.constants.INTERNAL_ERROR, new Error(msg.toString()));
      }
    }
  };
  C.handleConfirm = function(handle, f) {
    var tag = f.deliveryTag;
    var multi = f.multiple;
    if (multi) {
      var confirmed = this.unconfirmed.splice(0, tag - this.lwm + 1);
      this.lwm = tag + 1;
      confirmed.forEach(handle);
    } else {
      var c;
      if (tag === this.lwm) {
        c = this.unconfirmed.shift();
        this.lwm++;
        while (this.unconfirmed[0] === null) {
          this.unconfirmed.shift();
          this.lwm++;
        }
      } else {
        c = this.unconfirmed[tag - this.lwm];
        this.unconfirmed[tag - this.lwm] = null;
      }
      handle(c);
    }
  };
  C.pushConfirmCallback = function(cb) {
    this.unconfirmed.push(cb || false);
  };
  C.accept = function(f) {
    switch (f.id) {
      case undefined:
      case defs.BasicDeliver:
      case defs.BasicReturn:
      case defs.BasicProperties:
        return this.acceptMessageFrame(f);
      case defs.BasicAck:
        return this.emit("ack", f.fields);
      case defs.BasicNack:
        return this.emit("nack", f.fields);
      case defs.BasicCancel:
        return this.emit("cancel", f.fields);
      case defs.ChannelClose:
        if (this.reply) {
          var reply = this.reply;
          this.reply = null;
          reply(f);
        }
        var emsg = "Channel closed by server: " + closeMsg(f);
        this.sendImmediately(defs.ChannelCloseOk, {});
        var error = new Error(emsg);
        error.code = f.fields.replyCode;
        error.classId = f.fields.classId;
        error.methodId = f.fields.methodId;
        this.emit("error", error);
        var s = stackCapture(emsg);
        this.toClosed(s);
        return;
      case defs.BasicFlow:
        return this.closeWithError(f.id, "Flow not implemented", defs.constants.NOT_IMPLEMENTED, new Error("Flow not implemented"));
      default:
        var reply = this.reply;
        this.reply = null;
        if (this.pending.length > 0) {
          var send = this.pending.shift();
          this.reply = send.reply;
          this.sendImmediately(send.method, send.fields);
        }
        return reply(null, f);
    }
  };
  C.onBufferDrain = function() {
    this.emit("drain");
  };
  inherits(BaseChannel, Channel);
  exports.BaseChannel = BaseChannel;
  BaseChannel.prototype.registerConsumer = function(tag, callback) {
    this.consumers[tag] = callback;
  };
  BaseChannel.prototype.unregisterConsumer = function(tag) {
    delete this.consumers[tag];
  };
  BaseChannel.prototype.dispatchMessage = function(fields, message2) {
    var consumerTag = fields.consumerTag;
    var consumer = this.consumers[consumerTag];
    if (consumer) {
      return consumer(message2);
    } else {
      throw new Error("Unknown consumer: " + consumerTag);
    }
  };
  BaseChannel.prototype.handleDelivery = function(message2) {
    return this.dispatchMessage(message2.fields, message2);
  };
  BaseChannel.prototype.handleCancel = function(fields) {
    return this.dispatchMessage(fields, null);
  };
});

// node_modules/amqplib/lib/api_args.js
var require_api_args = __commonJS((exports, module) => {
  var setIfDefined = function(obj, prop, value) {
    if (value != null)
      obj[prop] = value;
  };
  var EMPTY_OPTIONS = Object.freeze({});
  var Args = {};
  Args.assertQueue = function(queue3, options) {
    queue3 = queue3 || "";
    options = options || EMPTY_OPTIONS;
    var argt = Object.create(options.arguments || null);
    setIfDefined(argt, "x-expires", options.expires);
    setIfDefined(argt, "x-message-ttl", options.messageTtl);
    setIfDefined(argt, "x-dead-letter-exchange", options.deadLetterExchange);
    setIfDefined(argt, "x-dead-letter-routing-key", options.deadLetterRoutingKey);
    setIfDefined(argt, "x-max-length", options.maxLength);
    setIfDefined(argt, "x-max-priority", options.maxPriority);
    setIfDefined(argt, "x-overflow", options.overflow);
    setIfDefined(argt, "x-queue-mode", options.queueMode);
    return {
      queue: queue3,
      exclusive: !!options.exclusive,
      durable: options.durable === undefined ? true : options.durable,
      autoDelete: !!options.autoDelete,
      arguments: argt,
      passive: false,
      ticket: 0,
      nowait: false
    };
  };
  Args.checkQueue = function(queue3) {
    return {
      queue: queue3,
      passive: true,
      nowait: false,
      durable: true,
      autoDelete: false,
      exclusive: false,
      ticket: 0
    };
  };
  Args.deleteQueue = function(queue3, options) {
    options = options || EMPTY_OPTIONS;
    return {
      queue: queue3,
      ifUnused: !!options.ifUnused,
      ifEmpty: !!options.ifEmpty,
      ticket: 0,
      nowait: false
    };
  };
  Args.purgeQueue = function(queue3) {
    return {
      queue: queue3,
      ticket: 0,
      nowait: false
    };
  };
  Args.bindQueue = function(queue3, source, pattern, argt) {
    return {
      queue: queue3,
      exchange: source,
      routingKey: pattern,
      arguments: argt,
      ticket: 0,
      nowait: false
    };
  };
  Args.unbindQueue = function(queue3, source, pattern, argt) {
    return {
      queue: queue3,
      exchange: source,
      routingKey: pattern,
      arguments: argt,
      ticket: 0,
      nowait: false
    };
  };
  Args.assertExchange = function(exchange, type, options) {
    options = options || EMPTY_OPTIONS;
    var argt = Object.create(options.arguments || null);
    setIfDefined(argt, "alternate-exchange", options.alternateExchange);
    return {
      exchange,
      ticket: 0,
      type,
      passive: false,
      durable: options.durable === undefined ? true : options.durable,
      autoDelete: !!options.autoDelete,
      internal: !!options.internal,
      nowait: false,
      arguments: argt
    };
  };
  Args.checkExchange = function(exchange) {
    return {
      exchange,
      passive: true,
      nowait: false,
      durable: true,
      internal: false,
      type: "",
      autoDelete: false,
      ticket: 0
    };
  };
  Args.deleteExchange = function(exchange, options) {
    options = options || EMPTY_OPTIONS;
    return {
      exchange,
      ifUnused: !!options.ifUnused,
      ticket: 0,
      nowait: false
    };
  };
  Args.bindExchange = function(dest, source, pattern, argt) {
    return {
      source,
      destination: dest,
      routingKey: pattern,
      arguments: argt,
      ticket: 0,
      nowait: false
    };
  };
  Args.unbindExchange = function(dest, source, pattern, argt) {
    return {
      source,
      destination: dest,
      routingKey: pattern,
      arguments: argt,
      ticket: 0,
      nowait: false
    };
  };
  Args.publish = function(exchange, routingKey, options) {
    options = options || EMPTY_OPTIONS;
    function convertCC(cc) {
      if (cc === undefined) {
        return;
      } else if (Array.isArray(cc)) {
        return cc.map(String);
      } else
        return [String(cc)];
    }
    var headers = Object.create(options.headers || null);
    setIfDefined(headers, "CC", convertCC(options.CC));
    setIfDefined(headers, "BCC", convertCC(options.BCC));
    var deliveryMode;
    if (options.persistent !== undefined)
      deliveryMode = options.persistent ? 2 : 1;
    else if (typeof options.deliveryMode === "number")
      deliveryMode = options.deliveryMode;
    else if (options.deliveryMode)
      deliveryMode = 2;
    var expiration = options.expiration;
    if (expiration !== undefined)
      expiration = expiration.toString();
    return {
      exchange,
      routingKey,
      mandatory: !!options.mandatory,
      immediate: false,
      ticket: undefined,
      contentType: options.contentType,
      contentEncoding: options.contentEncoding,
      headers,
      deliveryMode,
      priority: options.priority,
      correlationId: options.correlationId,
      replyTo: options.replyTo,
      expiration,
      messageId: options.messageId,
      timestamp: options.timestamp,
      type: options.type,
      userId: options.userId,
      appId: options.appId,
      clusterId: undefined
    };
  };
  Args.consume = function(queue3, options) {
    options = options || EMPTY_OPTIONS;
    var argt = Object.create(options.arguments || null);
    setIfDefined(argt, "x-priority", options.priority);
    return {
      ticket: 0,
      queue: queue3,
      consumerTag: options.consumerTag || "",
      noLocal: !!options.noLocal,
      noAck: !!options.noAck,
      exclusive: !!options.exclusive,
      nowait: false,
      arguments: argt
    };
  };
  Args.cancel = function(consumerTag) {
    return {
      consumerTag,
      nowait: false
    };
  };
  Args.get = function(queue3, options) {
    options = options || EMPTY_OPTIONS;
    return {
      ticket: 0,
      queue: queue3,
      noAck: !!options.noAck
    };
  };
  Args.ack = function(tag, allUpTo) {
    return {
      deliveryTag: tag,
      multiple: !!allUpTo
    };
  };
  Args.nack = function(tag, allUpTo, requeue) {
    return {
      deliveryTag: tag,
      multiple: !!allUpTo,
      requeue: requeue === undefined ? true : requeue
    };
  };
  Args.reject = function(tag, requeue) {
    return {
      deliveryTag: tag,
      requeue: requeue === undefined ? true : requeue
    };
  };
  Args.prefetch = function(count, global2) {
    return {
      prefetchCount: count || 0,
      prefetchSize: 0,
      global: !!global2
    };
  };
  Args.recover = function() {
    return { requeue: true };
  };
  module.exports = Object.freeze(Args);
});

// node_modules/amqplib/lib/channel_model.js
var require_channel_model = __commonJS((exports, module) => {
  var ChannelModel = function(connection3) {
    if (!(this instanceof ChannelModel))
      return new ChannelModel(connection3);
    EventEmitter.call(this);
    this.connection = connection3;
    var self2 = this;
    ["error", "close", "blocked", "unblocked"].forEach(function(ev) {
      connection3.on(ev, self2.emit.bind(self2, ev));
    });
  };
  var Channel = function(connection3) {
    BaseChannel.call(this, connection3);
    this.on("delivery", this.handleDelivery.bind(this));
    this.on("cancel", this.handleCancel.bind(this));
  };
  var ConfirmChannel = function(connection3) {
    Channel.call(this, connection3);
  };
  var defs = require_defs();
  var Promise2 = require_bluebird();
  var inherits = __require("util").inherits;
  var EventEmitter = __require("events").EventEmitter;
  var BaseChannel = require_channel().BaseChannel;
  var acceptMessage = require_channel().acceptMessage;
  var Args = require_api_args();
  inherits(ChannelModel, EventEmitter);
  exports.ChannelModel = ChannelModel;
  var CM = ChannelModel.prototype;
  CM.close = function() {
    return Promise2.fromCallback(this.connection.close.bind(this.connection));
  };
  inherits(Channel, BaseChannel);
  exports.Channel = Channel;
  CM.createChannel = function() {
    var c = new Channel(this.connection);
    return c.open().then(function(openOk) {
      return c;
    });
  };
  var C = Channel.prototype;
  C.rpc = function(method, fields, expect) {
    var self2 = this;
    return Promise2.fromCallback(function(cb) {
      return self2._rpc(method, fields, expect, cb);
    }).then(function(f) {
      return f.fields;
    });
  };
  C.open = function() {
    return Promise2.try(this.allocate.bind(this)).then(function(ch) {
      return ch.rpc(defs.ChannelOpen, { outOfBand: "" }, defs.ChannelOpenOk);
    });
  };
  C.close = function() {
    var self2 = this;
    return Promise2.fromCallback(function(cb) {
      return self2.closeBecause("Goodbye", defs.constants.REPLY_SUCCESS, cb);
    });
  };
  C.assertQueue = function(queue3, options) {
    return this.rpc(defs.QueueDeclare, Args.assertQueue(queue3, options), defs.QueueDeclareOk);
  };
  C.checkQueue = function(queue3) {
    return this.rpc(defs.QueueDeclare, Args.checkQueue(queue3), defs.QueueDeclareOk);
  };
  C.deleteQueue = function(queue3, options) {
    return this.rpc(defs.QueueDelete, Args.deleteQueue(queue3, options), defs.QueueDeleteOk);
  };
  C.purgeQueue = function(queue3) {
    return this.rpc(defs.QueuePurge, Args.purgeQueue(queue3), defs.QueuePurgeOk);
  };
  C.bindQueue = function(queue3, source, pattern, argt) {
    return this.rpc(defs.QueueBind, Args.bindQueue(queue3, source, pattern, argt), defs.QueueBindOk);
  };
  C.unbindQueue = function(queue3, source, pattern, argt) {
    return this.rpc(defs.QueueUnbind, Args.unbindQueue(queue3, source, pattern, argt), defs.QueueUnbindOk);
  };
  C.assertExchange = function(exchange, type, options) {
    return this.rpc(defs.ExchangeDeclare, Args.assertExchange(exchange, type, options), defs.ExchangeDeclareOk).then(function(_ok) {
      return { exchange };
    });
  };
  C.checkExchange = function(exchange) {
    return this.rpc(defs.ExchangeDeclare, Args.checkExchange(exchange), defs.ExchangeDeclareOk);
  };
  C.deleteExchange = function(name, options) {
    return this.rpc(defs.ExchangeDelete, Args.deleteExchange(name, options), defs.ExchangeDeleteOk);
  };
  C.bindExchange = function(dest, source, pattern, argt) {
    return this.rpc(defs.ExchangeBind, Args.bindExchange(dest, source, pattern, argt), defs.ExchangeBindOk);
  };
  C.unbindExchange = function(dest, source, pattern, argt) {
    return this.rpc(defs.ExchangeUnbind, Args.unbindExchange(dest, source, pattern, argt), defs.ExchangeUnbindOk);
  };
  C.publish = function(exchange, routingKey, content, options) {
    var fieldsAndProps = Args.publish(exchange, routingKey, options);
    return this.sendMessage(fieldsAndProps, fieldsAndProps, content);
  };
  C.sendToQueue = function(queue3, content, options) {
    return this.publish("", queue3, content, options);
  };
  C.consume = function(queue3, callback, options) {
    var self2 = this;
    var fields = Args.consume(queue3, options);
    return Promise2.fromCallback(function(cb) {
      self2._rpc(defs.BasicConsume, fields, defs.BasicConsumeOk, cb);
    }).then(function(ok) {
      self2.registerConsumer(ok.fields.consumerTag, callback);
      return ok.fields;
    });
  };
  C.cancel = function(consumerTag) {
    var self2 = this;
    return Promise2.fromCallback(function(cb) {
      self2._rpc(defs.BasicCancel, Args.cancel(consumerTag), defs.BasicCancelOk, cb);
    }).then(function(ok) {
      self2.unregisterConsumer(consumerTag);
      return ok.fields;
    });
  };
  C.get = function(queue3, options) {
    var self2 = this;
    var fields = Args.get(queue3, options);
    return Promise2.fromCallback(function(cb) {
      return self2.sendOrEnqueue(defs.BasicGet, fields, cb);
    }).then(function(f) {
      if (f.id === defs.BasicGetEmpty) {
        return false;
      } else if (f.id === defs.BasicGetOk) {
        var fields2 = f.fields;
        return new Promise2(function(resolve) {
          self2.handleMessage = acceptMessage(function(m) {
            m.fields = fields2;
            resolve(m);
          });
        });
      } else {
        throw new Error("Unexpected response to BasicGet: " + inspect(f));
      }
    });
  };
  C.ack = function(message2, allUpTo) {
    this.sendImmediately(defs.BasicAck, Args.ack(message2.fields.deliveryTag, allUpTo));
  };
  C.ackAll = function() {
    this.sendImmediately(defs.BasicAck, Args.ack(0, true));
  };
  C.nack = function(message2, allUpTo, requeue) {
    this.sendImmediately(defs.BasicNack, Args.nack(message2.fields.deliveryTag, allUpTo, requeue));
  };
  C.nackAll = function(requeue) {
    this.sendImmediately(defs.BasicNack, Args.nack(0, true, requeue));
  };
  C.reject = function(message2, requeue) {
    this.sendImmediately(defs.BasicReject, Args.reject(message2.fields.deliveryTag, requeue));
  };
  C.prefetch = C.qos = function(count, global2) {
    return this.rpc(defs.BasicQos, Args.prefetch(count, global2), defs.BasicQosOk);
  };
  C.recover = function() {
    return this.rpc(defs.BasicRecover, Args.recover(), defs.BasicRecoverOk);
  };
  inherits(ConfirmChannel, Channel);
  exports.ConfirmChannel = ConfirmChannel;
  CM.createConfirmChannel = function() {
    var c = new ConfirmChannel(this.connection);
    return c.open().then(function(openOk) {
      return c.rpc(defs.ConfirmSelect, { nowait: false }, defs.ConfirmSelectOk);
    }).then(function() {
      return c;
    });
  };
  var CC = ConfirmChannel.prototype;
  CC.publish = function(exchange, routingKey, content, options, cb) {
    this.pushConfirmCallback(cb);
    return C.publish.call(this, exchange, routingKey, content, options);
  };
  CC.sendToQueue = function(queue3, content, options, cb) {
    return this.publish("", queue3, content, options, cb);
  };
  CC.waitForConfirms = function() {
    var awaiting = [];
    var unconfirmed = this.unconfirmed;
    unconfirmed.forEach(function(val, index) {
      if (val === null)
        ;
      else {
        var confirmed = new Promise2(function(resolve, reject) {
          unconfirmed[index] = function(err) {
            if (val)
              val(err);
            if (err === null)
              resolve();
            else
              reject(err);
          };
        });
        awaiting.push(confirmed);
      }
    });
    return Promise2.all(awaiting);
  };
});

// node_modules/amqplib/channel_api.js
var require_channel_api = __commonJS((exports, module) => {
  var connect = function(url7, connOptions) {
    return Promise2.fromCallback(function(cb) {
      return raw_connect(url7, connOptions, cb);
    }).then(function(conn) {
      return new ChannelModel(conn);
    });
  };
  var raw_connect = require_connect().connect;
  var ChannelModel = require_channel_model().ChannelModel;
  var Promise2 = require_bluebird();
  exports.connect = connect;
  exports.credentials = require_credentials();
  exports.IllegalOperationError = require_error().IllegalOperationError;
});

// node_modules/celery-node/dist/kombu/brokers/amqp.js
var require_amqp = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  var amqplib = require_channel_api();
  var message_1 = require_message();

  class AMQPMessage extends message_1.Message {
    constructor(payload) {
      super(payload.content, payload.properties.contentType, payload.properties.contentEncoding, payload.properties, payload.properties.headers);
    }
  }

  class AMQPBroker {
    constructor(url7, opts, queue3 = "celery") {
      this.queue = queue3;
      this.connect = amqplib.connect(url7, opts);
      this.channel = this.connect.then((conn) => conn.createChannel());
    }
    isReady() {
      return new Promise((resolve, reject) => {
        this.channel.then((ch) => {
          Promise.all([
            ch.assertExchange("default", "direct", {
              durable: true,
              autoDelete: true,
              internal: false,
              arguments: null
            }),
            ch.assertQueue(this.queue, {
              durable: true,
              autoDelete: false,
              exclusive: false,
              arguments: null
            })
          ]).then(() => resolve()).catch(reject);
        });
      });
    }
    disconnect() {
      return this.connect.then((conn) => conn.close());
    }
    publish(body2, exchange, routingKey, headers, properties) {
      const messageBody = JSON.stringify(body2);
      const contentType = "application/json";
      const contentEncoding = "utf-8";
      return this.channel.then((ch) => ch.assertQueue(routingKey, {
        durable: true,
        autoDelete: false,
        exclusive: false,
        arguments: null
      }).then(() => Promise.resolve(ch))).then((ch) => ch.publish(exchange, routingKey, Buffer.from(messageBody), Object.assign({
        contentType,
        contentEncoding,
        headers,
        deliveryMode: 2
      }, properties)));
    }
    subscribe(queue3, callback) {
      return this.channel.then((ch) => ch.assertQueue(queue3, {
        durable: true,
        autoDelete: false,
        exclusive: false,
        arguments: null
      }).then(() => Promise.resolve(ch))).then((ch) => ch.consume(queue3, (rawMsg) => {
        ch.ack(rawMsg);
        if (rawMsg.properties.contentType !== "application/json") {
          throw new Error(`unsupported content type ${rawMsg.properties.contentType}`);
        }
        if (rawMsg.properties.contentEncoding !== "utf-8") {
          throw new Error(`unsupported content encoding ${rawMsg.properties.contentEncoding}`);
        }
        callback(new AMQPMessage(rawMsg));
      }));
    }
  }
  exports.default = AMQPBroker;
});

// node_modules/celery-node/dist/kombu/brokers/index.js
var require_brokers = __commonJS((exports) => {
  var getProtocol = function(uri) {
    const protocol = url7.parse(uri).protocol.slice(0, -1);
    if (supportedProtocols.indexOf(protocol) === -1) {
      throw new Error(`Unsupported type: ${protocol}`);
    }
    return protocol;
  };
  var newCeleryBroker = function(CELERY_BROKER, CELERY_BROKER_OPTIONS, CELERY_QUEUE = "celery") {
    const brokerProtocol = getProtocol(CELERY_BROKER);
    if (["redis", "rediss"].indexOf(brokerProtocol) > -1) {
      return new redis_1.default(CELERY_BROKER, CELERY_BROKER_OPTIONS);
    }
    if (["amqp", "amqps"].indexOf(brokerProtocol) > -1) {
      return new amqp_1.default(CELERY_BROKER, CELERY_BROKER_OPTIONS, CELERY_QUEUE);
    }
    throw new Error("unsupprted celery broker");
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.newCeleryBroker = undefined;
  var url7 = __require("url");
  var redis_1 = require_redis2();
  var amqp_1 = require_amqp();
  var supportedProtocols = ["redis", "rediss", "amqp", "amqps"];
  exports.newCeleryBroker = newCeleryBroker;
});

// node_modules/celery-node/dist/backends/redis.js
var require_redis3 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  var Redis = require_built2();
  var keyPrefix = "celery-task-meta-";

  class RedisBackend {
    constructor(url7, opts) {
      this.redis = new Redis(url7, Object.assign({}, opts));
    }
    isReady() {
      return new Promise((resolve, reject) => {
        if (this.redis.status === "ready") {
          resolve();
        } else {
          let handleError;
          const handleReady = () => {
            this.redis.removeListener("error", handleError);
            resolve();
          };
          handleError = (err) => {
            this.redis.removeListener("ready", handleReady);
            reject(err);
          };
          this.redis.once("ready", handleReady);
          this.redis.once("error", handleError);
        }
      });
    }
    disconnect() {
      return this.redis.quit();
    }
    storeResult(taskId, result2, state) {
      return this.set(`${keyPrefix}${taskId}`, JSON.stringify({
        status: state,
        result: state == "FAILURE" ? null : result2,
        traceback: result2,
        children: [],
        task_id: taskId,
        date_done: new Date().toISOString()
      }));
    }
    getTaskMeta(taskId) {
      return this.get(`${keyPrefix}${taskId}`).then((msg) => JSON.parse(msg));
    }
    set(key, value) {
      return Promise.all([
        this.redis.setex(key, 86400, value),
        this.redis.publish(key, value)
      ]);
    }
    get(key) {
      return this.redis.get(key);
    }
  }
  exports.default = RedisBackend;
});

// node_modules/celery-node/dist/backends/amqp.js
var require_amqp2 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  var amqplib = require_channel_api();

  class AMQPBackend {
    constructor(url7, opts) {
      this.opts = opts;
      this.connect = amqplib.connect(url7, opts);
      this.channel = this.connect.then((conn) => conn.createChannel()).then((ch) => ch.assertExchange("default", "direct", {
        durable: true,
        autoDelete: true,
        internal: false,
        arguments: null
      }).then(() => Promise.resolve(ch)));
    }
    isReady() {
      return this.connect;
    }
    disconnect() {
      return this.connect.then((conn) => conn.close());
    }
    storeResult(taskId, result2, state) {
      const queue3 = taskId.replace(/-/g, "");
      return this.channel.then((ch) => ch.assertQueue(queue3, {
        durable: true,
        autoDelete: true,
        exclusive: false,
        arguments: {
          "x-expires": this.opts.CELERY_RESULT_EXPIRES || 86400000
        }
      }).then(() => Promise.resolve(ch))).then((ch) => ch.publish("", queue3, Buffer.from(JSON.stringify({
        status: state,
        result: state == "FAILURE" ? null : result2,
        traceback: null,
        children: [],
        task_id: taskId,
        date_done: new Date().toISOString()
      })), {
        contentType: "application/json",
        contentEncoding: "utf-8"
      }));
    }
    getTaskMeta(taskId) {
      const queue3 = taskId.replace(/-/g, "");
      return this.channel.then((ch) => ch.assertQueue(queue3, {
        durable: true,
        autoDelete: true,
        exclusive: false,
        arguments: {
          "x-expires": this.opts.CELERY_RESULT_EXPIRES || 86400000
        }
      }).then(() => Promise.resolve(ch))).then((ch) => ch.get(queue3, {
        noAck: false
      })).then((msg) => {
        if (msg === false) {
          return null;
        }
        if (msg.properties.contentType !== "application/json") {
          throw new Error(`unsupported content type ${msg.properties.contentType}`);
        }
        if (msg.properties.contentEncoding !== "utf-8") {
          throw new Error(`unsupported content encoding ${msg.properties.contentEncoding}`);
        }
        const body2 = msg.content.toString("utf-8");
        return JSON.parse(body2);
      });
    }
  }
  exports.default = AMQPBackend;
});

// node_modules/celery-node/dist/backends/index.js
var require_backends = __commonJS((exports) => {
  var getProtocol = function(uri) {
    const protocol = url7.parse(uri).protocol.slice(0, -1);
    if (supportedProtocols.indexOf(protocol) === -1) {
      throw new Error(`Unsupported type: ${protocol}`);
    }
    return protocol;
  };
  var newCeleryBackend = function(CELERY_BACKEND, CELERY_BACKEND_OPTIONS) {
    const brokerProtocol = getProtocol(CELERY_BACKEND);
    if (["redis", "rediss"].indexOf(brokerProtocol) > -1) {
      return new redis_1.default(CELERY_BACKEND, CELERY_BACKEND_OPTIONS);
    }
    if (["amqp", "amqps"].indexOf(brokerProtocol) > -1) {
      return new amqp_1.default(CELERY_BACKEND, CELERY_BACKEND_OPTIONS);
    }
    throw new Error("unsupprted celery backend");
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.newCeleryBackend = undefined;
  var url7 = __require("url");
  var redis_1 = require_redis3();
  var amqp_1 = require_amqp2();
  var supportedProtocols = ["redis", "rediss", "amqp", "amqps"];
  exports.newCeleryBackend = newCeleryBackend;
});

// node_modules/celery-node/dist/app/base.js
var require_base = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  var conf_1 = require_conf();
  var brokers_1 = require_brokers();
  var backends_1 = require_backends();

  class Base {
    constructor(broker, backend, queue3 = "celery") {
      this.conf = conf_1.defaultConf();
      this.conf.CELERY_BROKER = broker;
      this.conf.CELERY_BACKEND = backend;
      this.conf.CELERY_QUEUE = queue3;
    }
    get broker() {
      if (!this._broker) {
        this._broker = brokers_1.newCeleryBroker(this.conf.CELERY_BROKER, this.conf.CELERY_BROKER_OPTIONS, this.conf.CELERY_QUEUE);
      }
      return this._broker;
    }
    get backend() {
      if (!this._backend) {
        this._backend = backends_1.newCeleryBackend(this.conf.CELERY_BACKEND, this.conf.CELERY_BACKEND_OPTIONS);
      }
      return this._backend;
    }
    isReady() {
      return Promise.all([this.backend.isReady(), this.broker.isReady()]);
    }
    disconnect() {
      return this.broker.disconnect().then(() => this.backend.disconnect());
    }
  }
  exports.default = Base;
});

// node_modules/celery-node/dist/app/task.js
var require_task = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });

  class Task {
    constructor(client, name) {
      this.client = client;
      this.name = name;
    }
    delay(...args) {
      return this.applyAsync([...args]);
    }
    applyAsync(args, kwargs) {
      if (args && !Array.isArray(args)) {
        throw new Error("args is not array");
      }
      if (kwargs && typeof kwargs !== "object") {
        throw new Error("kwargs is not object");
      }
      return this.client.sendTask(this.name, args || [], kwargs || {});
    }
  }
  exports.default = Task;
});

// node_modules/celery-node/dist/app/result.js
var require_result = __commonJS((exports) => {
  var createError = function(message2, data) {
    const error = new Error(message2);
    Object.assign(error, data);
    return error;
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.AsyncResult = undefined;
  var isFinalStatus = {
    SUCCESS: true,
    FAILURE: true,
    REVOKED: true
  };
  var isErrorStatus = {
    TIMEOUT: true,
    FAILURE: true,
    REVOKED: true
  };

  class AsyncResult {
    constructor(taskId, backend) {
      this.taskId = taskId;
      this.backend = backend;
      this._cache = null;
    }
    get(timeout, interval = 500) {
      const waitFor = (resolve) => {
        let timeoutId;
        let intervalId;
        if (timeout) {
          timeoutId = setTimeout(() => {
            clearInterval(intervalId);
            resolve({ status: "TIMEOUT", result: {} });
          }, timeout);
        }
        intervalId = setInterval(() => {
          this.backend.getTaskMeta(this.taskId).then((meta) => {
            if (meta && isFinalStatus[meta["status"]]) {
              if (timeout) {
                clearTimeout(timeoutId);
              }
              clearInterval(intervalId);
              resolve(meta);
            }
          });
        }, interval);
      };
      if (!this._cache) {
        this._cache = new Promise((resolve) => {
          waitFor(resolve);
        });
      } else {
        const p = new Promise((resolve) => {
          this._cache.then((meta) => {
            if (meta && isFinalStatus[meta["status"]]) {
              resolve(meta);
            } else {
              waitFor(resolve);
            }
          });
        });
        this._cache = p;
      }
      return this._cache.then((meta) => {
        if (isErrorStatus[meta["status"]]) {
          throw createError(meta["status"], meta["result"]);
        } else {
          return meta["result"];
        }
      });
    }
    getTaskMeta() {
      if (!this._cache) {
        this._cache = new Promise((resolve) => {
          this.backend.getTaskMeta(this.taskId).then(resolve);
        });
      } else {
        const p = new Promise((resolve) => {
          this._cache.then((meta) => {
            if (meta && isFinalStatus[meta["status"]]) {
              resolve(meta);
            } else {
              this.backend.getTaskMeta(this.taskId).then(resolve);
            }
          });
        });
        this._cache = p;
      }
      return this._cache;
    }
    result() {
      return this.getTaskMeta().then((meta) => {
        if (meta) {
          return meta["result"];
        } else {
          return null;
        }
      });
    }
    status() {
      return this.getTaskMeta().then((meta) => {
        if (meta) {
          return meta["status"];
        } else {
          return null;
        }
      });
    }
  }
  exports.AsyncResult = AsyncResult;
});

// node_modules/celery-node/dist/app/client.js
var require_client = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  var uuid_1 = require_uuid();
  var base_1 = require_base();
  var task_1 = require_task();
  var result_1 = require_result();

  class Client extends base_1.default {
    constructor() {
      super(...arguments);
      this.taskProtocols = {
        1: this.asTaskV1,
        2: this.asTaskV2
      };
    }
    get createTaskMessage() {
      return this.taskProtocols[this.conf.TASK_PROTOCOL];
    }
    sendTaskMessage(taskName, message2) {
      const { headers, properties, body: body2 } = message2;
      const exchange = "";
      this.isReady().then(() => this.broker.publish(body2, exchange, this.conf.CELERY_QUEUE, headers, properties));
    }
    asTaskV2(taskId, taskName, args, kwargs) {
      const message2 = {
        headers: {
          lang: "js",
          task: taskName,
          id: taskId
        },
        properties: {
          correlationId: taskId,
          replyTo: ""
        },
        body: [args, kwargs, {}],
        sentEvent: null
      };
      return message2;
    }
    asTaskV1(taskId, taskName, args, kwargs) {
      const message2 = {
        headers: {},
        properties: {
          correlationId: taskId,
          replyTo: ""
        },
        body: {
          task: taskName,
          id: taskId,
          args,
          kwargs
        },
        sentEvent: null
      };
      return message2;
    }
    createTask(name) {
      return new task_1.default(this, name);
    }
    asyncResult(taskId) {
      return new result_1.AsyncResult(taskId, this.backend);
    }
    sendTask(taskName, args, kwargs, taskId) {
      taskId = taskId || uuid_1.v4();
      const message2 = this.createTaskMessage(taskId, taskName, args, kwargs);
      this.sendTaskMessage(taskName, message2);
      const result2 = new result_1.AsyncResult(taskId, this.backend);
      return result2;
    }
  }
  exports.default = Client;
});

// node_modules/celery-node/dist/app/worker.js
var require_worker = __commonJS((exports) => {
  var __awaiter = exports && exports.__awaiter || function(thisArg, _arguments, P, generator) {
    function adopt(value) {
      return value instanceof P ? value : new P(function(resolve) {
        resolve(value);
      });
    }
    return new (P || (P = Promise))(function(resolve, reject) {
      function fulfilled(value) {
        try {
          step(generator.next(value));
        } catch (e) {
          reject(e);
        }
      }
      function rejected(value) {
        try {
          step(generator["throw"](value));
        } catch (e) {
          reject(e);
        }
      }
      function step(result2) {
        result2.done ? resolve(result2.value) : adopt(result2.value).then(fulfilled, rejected);
      }
      step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  var base_1 = require_base();

  class Worker extends base_1.default {
    constructor() {
      super(...arguments);
      this.handlers = {};
      this.activeTasks = new Set;
    }
    register(name, handler) {
      if (!handler) {
        throw new Error("Undefined handler");
      }
      if (this.handlers[name]) {
        throw new Error("Handler is already set");
      }
      this.handlers[name] = function registHandler(...args) {
        try {
          return Promise.resolve(handler(...args));
        } catch (err) {
          return Promise.reject(err);
        }
      };
    }
    start() {
      console.info("celery.node worker starting...");
      console.info(`registered task: ${Object.keys(this.handlers)}`);
      return this.run().catch((err) => console.error(err));
    }
    run() {
      return this.isReady().then(() => this.processTasks());
    }
    processTasks() {
      const consumer = this.getConsumer(this.conf.CELERY_QUEUE);
      return consumer();
    }
    getConsumer(queue3) {
      const onMessage = this.createTaskHandler();
      return () => this.broker.subscribe(queue3, onMessage);
    }
    createTaskHandler() {
      const onTaskReceived = (message2) => {
        if (!message2) {
          return Promise.resolve();
        }
        let payload = null;
        let taskName = message2.headers["task"];
        if (!taskName) {
          payload = message2.decode();
          taskName = payload["task"];
        }
        let body2;
        let headers;
        if (payload == null && !("args" in message2.decode())) {
          body2 = message2.decode();
          headers = message2.headers;
        } else {
          const args2 = payload["args"] || [];
          const kwargs2 = payload["kwargs"] || {};
          const embed = {
            callbacks: payload["callbacks"],
            errbacks: payload["errbacks"],
            chord: payload["chord"],
            chain: null
          };
          body2 = [args2, kwargs2, embed];
          headers = {
            lang: payload["lang"],
            task: payload["task"],
            id: payload["id"],
            rootId: payload["root_id"],
            parentId: payload["parentId"],
            group: payload["group"],
            meth: payload["meth"],
            shadow: payload["shadow"],
            eta: payload["eta"],
            expires: payload["expires"],
            retries: payload["retries"] || 0,
            timelimit: payload["timelimit"] || [null, null],
            kwargsrepr: payload["kwargsrepr"],
            origin: payload["origin"]
          };
        }
        const [args, kwargs] = body2;
        const taskId = headers["id"];
        const handler = this.handlers[taskName];
        if (!handler) {
          throw new Error(`Missing process handler for task ${taskName}`);
        }
        console.info(`celery.node Received task: ${taskName}[${taskId}], args: ${args}, kwargs: ${JSON.stringify(kwargs)}`);
        const timeStart = process.hrtime();
        const taskPromise = handler(...args, kwargs).then((result2) => {
          const diff = process.hrtime(timeStart);
          console.info(`celery.node Task ${taskName}[${taskId}] succeeded in ${diff[0] + diff[1] / 1e9}s: ${result2}`);
          this.backend.storeResult(taskId, result2, "SUCCESS");
          this.activeTasks.delete(taskPromise);
        }).catch((err) => {
          console.info(`celery.node Task ${taskName}[${taskId}] failed: [${err}]`);
          this.backend.storeResult(taskId, err, "FAILURE");
          this.activeTasks.delete(taskPromise);
        });
        this.activeTasks.add(taskPromise);
        return taskPromise;
      };
      return onTaskReceived;
    }
    whenCurrentJobsFinished() {
      return __awaiter(this, undefined, undefined, function* () {
        return Promise.all(Array.from(this.activeTasks));
      });
    }
    stop() {
      throw new Error("not implemented yet");
    }
  }
  exports.default = Worker;
});

// node_modules/celery-node/dist/index.js
var require_dist2 = __commonJS((exports) => {
  var createClient = function(broker = "amqp://", backend = "amqp://", queue3 = "celery") {
    return new client_1.default(broker, backend, queue3);
  };
  var createWorker = function(broker = "amqp://", backend = "amqp://", queue3 = "celery") {
    return new worker_1.default(broker, backend, queue3);
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.createWorker = exports.createClient = undefined;
  var client_1 = require_client();
  var worker_1 = require_worker();
  exports.createClient = createClient;
  exports.createWorker = createWorker;
});

// node_modules/@redis/client/dist/lib/commands/APPEND.js
var require_APPEND = __commonJS((exports) => {
  var transformArguments = function(key, value) {
    return ["APPEND", key, value];
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.transformArguments = exports.FIRST_KEY_INDEX = undefined;
  exports.FIRST_KEY_INDEX = 1;
  exports.transformArguments = transformArguments;
});

// node_modules/@redis/client/dist/lib/commands/BITCOUNT.js
var require_BITCOUNT = __commonJS((exports) => {
  var transformArguments = function(key, range) {
    const args = ["BITCOUNT", key];
    if (range) {
      args.push(range.start.toString(), range.end.toString());
      if (range.mode) {
        args.push(range.mode);
      }
    }
    return args;
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.transformArguments = exports.IS_READ_ONLY = exports.FIRST_KEY_INDEX = undefined;
  exports.FIRST_KEY_INDEX = 1;
  exports.IS_READ_ONLY = true;
  exports.transformArguments = transformArguments;
});

// node_modules/@redis/client/dist/lib/commands/BITFIELD_RO.js
var require_BITFIELD_RO = __commonJS((exports) => {
  var transformArguments = function(key, operations) {
    const args = ["BITFIELD_RO", key];
    for (const operation of operations) {
      args.push("GET", operation.encoding, operation.offset.toString());
    }
    return args;
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.transformArguments = exports.IS_READ_ONLY = exports.FIRST_KEY_INDEX = undefined;
  exports.FIRST_KEY_INDEX = 1;
  exports.IS_READ_ONLY = true;
  exports.transformArguments = transformArguments;
});

// node_modules/@redis/client/dist/lib/commands/BITFIELD.js
var require_BITFIELD = __commonJS((exports) => {
  var transformArguments = function(key, operations) {
    const args = ["BITFIELD", key];
    for (const options of operations) {
      switch (options.operation) {
        case "GET":
          args.push("GET", options.encoding, options.offset.toString());
          break;
        case "SET":
          args.push("SET", options.encoding, options.offset.toString(), options.value.toString());
          break;
        case "INCRBY":
          args.push("INCRBY", options.encoding, options.offset.toString(), options.increment.toString());
          break;
        case "OVERFLOW":
          args.push("OVERFLOW", options.behavior);
          break;
      }
    }
    return args;
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.transformArguments = exports.FIRST_KEY_INDEX = undefined;
  exports.FIRST_KEY_INDEX = 1;
  exports.transformArguments = transformArguments;
});

// node_modules/@redis/client/dist/lib/commands/generic-transformers.js
var require_generic_transformers = __commonJS((exports) => {
  var transformBooleanReply = function(reply) {
    return reply === 1;
  };
  var transformBooleanArrayReply = function(reply) {
    return reply.map(transformBooleanReply);
  };
  var pushScanArguments = function(args, cursor, options) {
    args.push(cursor.toString());
    if (options?.MATCH) {
      args.push("MATCH", options.MATCH);
    }
    if (options?.COUNT) {
      args.push("COUNT", options.COUNT.toString());
    }
    return args;
  };
  var transformNumberInfinityReply = function(reply) {
    switch (reply.toString()) {
      case "+inf":
        return Infinity;
      case "-inf":
        return (-Infinity);
      default:
        return Number(reply);
    }
  };
  var transformNumberInfinityNullReply = function(reply) {
    if (reply === null)
      return null;
    return transformNumberInfinityReply(reply);
  };
  var transformNumberInfinityNullArrayReply = function(reply) {
    return reply.map(transformNumberInfinityNullReply);
  };
  var transformNumberInfinityArgument = function(num) {
    switch (num) {
      case Infinity:
        return "+inf";
      case (-Infinity):
        return "-inf";
      default:
        return num.toString();
    }
  };
  var transformStringNumberInfinityArgument = function(num) {
    if (typeof num !== "number")
      return num;
    return transformNumberInfinityArgument(num);
  };
  var transformTuplesReply = function(reply) {
    const message2 = Object.create(null);
    for (let i = 0;i < reply.length; i += 2) {
      message2[reply[i].toString()] = reply[i + 1];
    }
    return message2;
  };
  var transformStreamMessagesReply = function(reply) {
    const messages2 = [];
    for (const [id, message2] of reply) {
      messages2.push({
        id,
        message: transformTuplesReply(message2)
      });
    }
    return messages2;
  };
  var transformStreamsMessagesReply = function(reply) {
    if (reply === null)
      return null;
    return reply.map(([name, rawMessages]) => ({
      name,
      messages: transformStreamMessagesReply(rawMessages)
    }));
  };
  var transformSortedSetMemberNullReply = function(reply) {
    if (!reply.length)
      return null;
    return transformSortedSetMemberReply(reply);
  };
  var transformSortedSetMemberReply = function(reply) {
    return {
      value: reply[0],
      score: transformNumberInfinityReply(reply[1])
    };
  };
  var transformSortedSetWithScoresReply = function(reply) {
    const members = [];
    for (let i = 0;i < reply.length; i += 2) {
      members.push({
        value: reply[i],
        score: transformNumberInfinityReply(reply[i + 1])
      });
    }
    return members;
  };
  var transformZMPopArguments = function(args, keys, side, options) {
    pushVerdictArgument(args, keys);
    args.push(side);
    if (options?.COUNT) {
      args.push("COUNT", options.COUNT.toString());
    }
    return args;
  };
  var transformLMPopArguments = function(args, keys, side, options) {
    pushVerdictArgument(args, keys);
    args.push(side);
    if (options?.COUNT) {
      args.push("COUNT", options.COUNT.toString());
    }
    return args;
  };
  var pushGeoCountArgument = function(args, count) {
    if (typeof count === "number") {
      args.push("COUNT", count.toString());
    } else if (count) {
      args.push("COUNT", count.value.toString());
      if (count.ANY) {
        args.push("ANY");
      }
    }
    return args;
  };
  var pushGeoSearchArguments = function(args, key, from, by, options) {
    args.push(key);
    if (typeof from === "string") {
      args.push("FROMMEMBER", from);
    } else {
      args.push("FROMLONLAT", from.longitude.toString(), from.latitude.toString());
    }
    if ("radius" in by) {
      args.push("BYRADIUS", by.radius.toString());
    } else {
      args.push("BYBOX", by.width.toString(), by.height.toString());
    }
    args.push(by.unit);
    if (options?.SORT) {
      args.push(options.SORT);
    }
    pushGeoCountArgument(args, options?.COUNT);
    return args;
  };
  var pushGeoRadiusArguments = function(args, key, from, radius, unit, options) {
    args.push(key);
    if (typeof from === "string") {
      args.push(from);
    } else {
      args.push(from.longitude.toString(), from.latitude.toString());
    }
    args.push(radius.toString(), unit);
    if (options?.SORT) {
      args.push(options.SORT);
    }
    pushGeoCountArgument(args, options?.COUNT);
    return args;
  };
  var pushGeoRadiusStoreArguments = function(args, key, from, radius, unit, destination, options) {
    pushGeoRadiusArguments(args, key, from, radius, unit, options);
    if (options?.STOREDIST) {
      args.push("STOREDIST", destination);
    } else {
      args.push("STORE", destination);
    }
    return args;
  };
  var transformGeoMembersWithReply = function(reply, replyWith) {
    const replyWithSet = new Set(replyWith);
    let index = 0;
    const distanceIndex = replyWithSet.has(GeoReplyWith.DISTANCE) && ++index, hashIndex = replyWithSet.has(GeoReplyWith.HASH) && ++index, coordinatesIndex = replyWithSet.has(GeoReplyWith.COORDINATES) && ++index;
    return reply.map((member) => {
      const transformedMember = {
        member: member[0]
      };
      if (distanceIndex) {
        transformedMember.distance = member[distanceIndex];
      }
      if (hashIndex) {
        transformedMember.hash = member[hashIndex];
      }
      if (coordinatesIndex) {
        const [longitude, latitude] = member[coordinatesIndex];
        transformedMember.coordinates = {
          longitude,
          latitude
        };
      }
      return transformedMember;
    });
  };
  var transformEXAT = function(EXAT) {
    return (typeof EXAT === "number" ? EXAT : Math.floor(EXAT.getTime() / 1000)).toString();
  };
  var transformPXAT = function(PXAT) {
    return (typeof PXAT === "number" ? PXAT : PXAT.getTime()).toString();
  };
  var evalFirstKeyIndex = function(options) {
    return options?.keys?.[0];
  };
  var pushEvalArguments = function(args, options) {
    if (options?.keys) {
      args.push(options.keys.length.toString(), ...options.keys);
    } else {
      args.push("0");
    }
    if (options?.arguments) {
      args.push(...options.arguments);
    }
    return args;
  };
  var pushVerdictArguments = function(args, value) {
    if (Array.isArray(value)) {
      args = args.concat(value);
    } else {
      args.push(value);
    }
    return args;
  };
  var pushVerdictNumberArguments = function(args, value) {
    if (Array.isArray(value)) {
      for (const item of value) {
        args.push(item.toString());
      }
    } else {
      args.push(value.toString());
    }
    return args;
  };
  var pushVerdictArgument = function(args, value) {
    if (Array.isArray(value)) {
      args.push(value.length.toString(), ...value);
    } else {
      args.push("1", value);
    }
    return args;
  };
  var pushOptionalVerdictArgument = function(args, name, value) {
    if (value === undefined)
      return args;
    args.push(name);
    return pushVerdictArgument(args, value);
  };
  var transformCommandReply = function([name, arity, flags3, firstKeyIndex, lastKeyIndex, step, categories]) {
    return {
      name,
      arity,
      flags: new Set(flags3),
      firstKeyIndex,
      lastKeyIndex,
      step,
      categories: new Set(categories)
    };
  };
  var transformFunctionListItemReply = function(reply) {
    return {
      libraryName: reply[1],
      engine: reply[3],
      functions: reply[5].map((fn) => ({
        name: fn[1],
        description: fn[3],
        flags: fn[5]
      }))
    };
  };
  var pushSortArguments = function(args, options) {
    if (options?.BY) {
      args.push("BY", options.BY);
    }
    if (options?.LIMIT) {
      args.push("LIMIT", options.LIMIT.offset.toString(), options.LIMIT.count.toString());
    }
    if (options?.GET) {
      for (const pattern of typeof options.GET === "string" ? [options.GET] : options.GET) {
        args.push("GET", pattern);
      }
    }
    if (options?.DIRECTION) {
      args.push(options.DIRECTION);
    }
    if (options?.ALPHA) {
      args.push("ALPHA");
    }
    return args;
  };
  var pushSlotRangeArguments = function(args, range) {
    args.push(range.start.toString(), range.end.toString());
  };
  var pushSlotRangesArguments = function(args, ranges) {
    if (Array.isArray(ranges)) {
      for (const range of ranges) {
        pushSlotRangeArguments(args, range);
      }
    } else {
      pushSlotRangeArguments(args, ranges);
    }
    return args;
  };
  var transformRangeReply = function([start, end]) {
    return {
      start,
      end
    };
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.transformRangeReply = exports.pushSlotRangesArguments = exports.pushSortArguments = exports.transformFunctionListItemReply = exports.RedisFunctionFlags = exports.transformCommandReply = exports.CommandCategories = exports.CommandFlags = exports.pushOptionalVerdictArgument = exports.pushVerdictArgument = exports.pushVerdictNumberArguments = exports.pushVerdictArguments = exports.pushEvalArguments = exports.evalFirstKeyIndex = exports.transformPXAT = exports.transformEXAT = exports.transformGeoMembersWithReply = exports.GeoReplyWith = exports.pushGeoRadiusStoreArguments = exports.pushGeoRadiusArguments = exports.pushGeoSearchArguments = exports.pushGeoCountArgument = exports.transformLMPopArguments = exports.transformZMPopArguments = exports.transformSortedSetWithScoresReply = exports.transformSortedSetMemberReply = exports.transformSortedSetMemberNullReply = exports.transformStreamsMessagesReply = exports.transformStreamMessagesReply = exports.transformTuplesReply = exports.transformStringNumberInfinityArgument = exports.transformNumberInfinityArgument = exports.transformNumberInfinityNullArrayReply = exports.transformNumberInfinityNullReply = exports.transformNumberInfinityReply = exports.pushScanArguments = exports.transformBooleanArrayReply = exports.transformBooleanReply = undefined;
  exports.transformBooleanReply = transformBooleanReply;
  exports.transformBooleanArrayReply = transformBooleanArrayReply;
  exports.pushScanArguments = pushScanArguments;
  exports.transformNumberInfinityReply = transformNumberInfinityReply;
  exports.transformNumberInfinityNullReply = transformNumberInfinityNullReply;
  exports.transformNumberInfinityNullArrayReply = transformNumberInfinityNullArrayReply;
  exports.transformNumberInfinityArgument = transformNumberInfinityArgument;
  exports.transformStringNumberInfinityArgument = transformStringNumberInfinityArgument;
  exports.transformTuplesReply = transformTuplesReply;
  exports.transformStreamMessagesReply = transformStreamMessagesReply;
  exports.transformStreamsMessagesReply = transformStreamsMessagesReply;
  exports.transformSortedSetMemberNullReply = transformSortedSetMemberNullReply;
  exports.transformSortedSetMemberReply = transformSortedSetMemberReply;
  exports.transformSortedSetWithScoresReply = transformSortedSetWithScoresReply;
  exports.transformZMPopArguments = transformZMPopArguments;
  exports.transformLMPopArguments = transformLMPopArguments;
  exports.pushGeoCountArgument = pushGeoCountArgument;
  exports.pushGeoSearchArguments = pushGeoSearchArguments;
  exports.pushGeoRadiusArguments = pushGeoRadiusArguments;
  exports.pushGeoRadiusStoreArguments = pushGeoRadiusStoreArguments;
  var GeoReplyWith;
  (function(GeoReplyWith2) {
    GeoReplyWith2["DISTANCE"] = "WITHDIST";
    GeoReplyWith2["HASH"] = "WITHHASH";
    GeoReplyWith2["COORDINATES"] = "WITHCOORD";
  })(GeoReplyWith || (exports.GeoReplyWith = GeoReplyWith = {}));
  exports.transformGeoMembersWithReply = transformGeoMembersWithReply;
  exports.transformEXAT = transformEXAT;
  exports.transformPXAT = transformPXAT;
  exports.evalFirstKeyIndex = evalFirstKeyIndex;
  exports.pushEvalArguments = pushEvalArguments;
  exports.pushVerdictArguments = pushVerdictArguments;
  exports.pushVerdictNumberArguments = pushVerdictNumberArguments;
  exports.pushVerdictArgument = pushVerdictArgument;
  exports.pushOptionalVerdictArgument = pushOptionalVerdictArgument;
  var CommandFlags;
  (function(CommandFlags2) {
    CommandFlags2["WRITE"] = "write";
    CommandFlags2["READONLY"] = "readonly";
    CommandFlags2["DENYOOM"] = "denyoom";
    CommandFlags2["ADMIN"] = "admin";
    CommandFlags2["PUBSUB"] = "pubsub";
    CommandFlags2["NOSCRIPT"] = "noscript";
    CommandFlags2["RANDOM"] = "random";
    CommandFlags2["SORT_FOR_SCRIPT"] = "sort_for_script";
    CommandFlags2["LOADING"] = "loading";
    CommandFlags2["STALE"] = "stale";
    CommandFlags2["SKIP_MONITOR"] = "skip_monitor";
    CommandFlags2["ASKING"] = "asking";
    CommandFlags2["FAST"] = "fast";
    CommandFlags2["MOVABLEKEYS"] = "movablekeys";
  })(CommandFlags || (exports.CommandFlags = CommandFlags = {}));
  var CommandCategories;
  (function(CommandCategories2) {
    CommandCategories2["KEYSPACE"] = "@keyspace";
    CommandCategories2["READ"] = "@read";
    CommandCategories2["WRITE"] = "@write";
    CommandCategories2["SET"] = "@set";
    CommandCategories2["SORTEDSET"] = "@sortedset";
    CommandCategories2["LIST"] = "@list";
    CommandCategories2["HASH"] = "@hash";
    CommandCategories2["STRING"] = "@string";
    CommandCategories2["BITMAP"] = "@bitmap";
    CommandCategories2["HYPERLOGLOG"] = "@hyperloglog";
    CommandCategories2["GEO"] = "@geo";
    CommandCategories2["STREAM"] = "@stream";
    CommandCategories2["PUBSUB"] = "@pubsub";
    CommandCategories2["ADMIN"] = "@admin";
    CommandCategories2["FAST"] = "@fast";
    CommandCategories2["SLOW"] = "@slow";
    CommandCategories2["BLOCKING"] = "@blocking";
    CommandCategories2["DANGEROUS"] = "@dangerous";
    CommandCategories2["CONNECTION"] = "@connection";
    CommandCategories2["TRANSACTION"] = "@transaction";
    CommandCategories2["SCRIPTING"] = "@scripting";
  })(CommandCategories || (exports.CommandCategories = CommandCategories = {}));
  exports.transformCommandReply = transformCommandReply;
  var RedisFunctionFlags;
  (function(RedisFunctionFlags2) {
    RedisFunctionFlags2["NO_WRITES"] = "no-writes";
    RedisFunctionFlags2["ALLOW_OOM"] = "allow-oom";
    RedisFunctionFlags2["ALLOW_STALE"] = "allow-stale";
    RedisFunctionFlags2["NO_CLUSTER"] = "no-cluster";
  })(RedisFunctionFlags || (exports.RedisFunctionFlags = RedisFunctionFlags = {}));
  exports.transformFunctionListItemReply = transformFunctionListItemReply;
  exports.pushSortArguments = pushSortArguments;
  exports.pushSlotRangesArguments = pushSlotRangesArguments;
  exports.transformRangeReply = transformRangeReply;
});

// node_modules/@redis/client/dist/lib/commands/BITOP.js
var require_BITOP = __commonJS((exports) => {
  var transformArguments = function(operation, destKey, key) {
    return (0, generic_transformers_1.pushVerdictArguments)(["BITOP", operation, destKey], key);
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.transformArguments = exports.FIRST_KEY_INDEX = undefined;
  var generic_transformers_1 = require_generic_transformers();
  exports.FIRST_KEY_INDEX = 2;
  exports.transformArguments = transformArguments;
});

// node_modules/@redis/client/dist/lib/commands/BITPOS.js
var require_BITPOS = __commonJS((exports) => {
  var transformArguments = function(key, bit, start, end, mode) {
    const args = ["BITPOS", key, bit.toString()];
    if (typeof start === "number") {
      args.push(start.toString());
    }
    if (typeof end === "number") {
      args.push(end.toString());
    }
    if (mode) {
      args.push(mode);
    }
    return args;
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.transformArguments = exports.IS_READ_ONLY = exports.FIRST_KEY_INDEX = undefined;
  exports.FIRST_KEY_INDEX = 1;
  exports.IS_READ_ONLY = true;
  exports.transformArguments = transformArguments;
});

// node_modules/@redis/client/dist/lib/commands/BLMOVE.js
var require_BLMOVE = __commonJS((exports) => {
  var transformArguments = function(source, destination, sourceDirection, destinationDirection, timeout) {
    return [
      "BLMOVE",
      source,
      destination,
      sourceDirection,
      destinationDirection,
      timeout.toString()
    ];
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.transformArguments = exports.FIRST_KEY_INDEX = undefined;
  exports.FIRST_KEY_INDEX = 1;
  exports.transformArguments = transformArguments;
});

// node_modules/@redis/client/dist/lib/commands/LMPOP.js
var require_LMPOP = __commonJS((exports) => {
  var transformArguments = function(keys, side, options) {
    return (0, generic_transformers_1.transformLMPopArguments)(["LMPOP"], keys, side, options);
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.transformArguments = exports.FIRST_KEY_INDEX = undefined;
  var generic_transformers_1 = require_generic_transformers();
  exports.FIRST_KEY_INDEX = 2;
  exports.transformArguments = transformArguments;
});

// node_modules/@redis/client/dist/lib/commands/BLMPOP.js
var require_BLMPOP = __commonJS((exports) => {
  var transformArguments = function(timeout, keys, side, options) {
    return (0, generic_transformers_1.transformLMPopArguments)(["BLMPOP", timeout.toString()], keys, side, options);
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.transformReply = exports.transformArguments = exports.FIRST_KEY_INDEX = undefined;
  var generic_transformers_1 = require_generic_transformers();
  exports.FIRST_KEY_INDEX = 3;
  exports.transformArguments = transformArguments;
  var LMPOP_1 = require_LMPOP();
  Object.defineProperty(exports, "transformReply", { enumerable: true, get: function() {
    return LMPOP_1.transformReply;
  } });
});

// node_modules/@redis/client/dist/lib/commands/BLPOP.js
var require_BLPOP = __commonJS((exports) => {
  var transformArguments = function(keys, timeout) {
    const args = (0, generic_transformers_1.pushVerdictArguments)(["BLPOP"], keys);
    args.push(timeout.toString());
    return args;
  };
  var transformReply = function(reply) {
    if (reply === null)
      return null;
    return {
      key: reply[0],
      element: reply[1]
    };
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.transformReply = exports.transformArguments = exports.FIRST_KEY_INDEX = undefined;
  var generic_transformers_1 = require_generic_transformers();
  exports.FIRST_KEY_INDEX = 1;
  exports.transformArguments = transformArguments;
  exports.transformReply = transformReply;
});

// node_modules/@redis/client/dist/lib/commands/BRPOP.js
var require_BRPOP = __commonJS((exports) => {
  var transformArguments = function(key, timeout) {
    const args = (0, generic_transformers_1.pushVerdictArguments)(["BRPOP"], key);
    args.push(timeout.toString());
    return args;
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.transformReply = exports.transformArguments = exports.FIRST_KEY_INDEX = undefined;
  var generic_transformers_1 = require_generic_transformers();
  exports.FIRST_KEY_INDEX = 1;
  exports.transformArguments = transformArguments;
  var BLPOP_1 = require_BLPOP();
  Object.defineProperty(exports, "transformReply", { enumerable: true, get: function() {
    return BLPOP_1.transformReply;
  } });
});

// node_modules/@redis/client/dist/lib/commands/BRPOPLPUSH.js
var require_BRPOPLPUSH = __commonJS((exports) => {
  var transformArguments = function(source, destination, timeout) {
    return ["BRPOPLPUSH", source, destination, timeout.toString()];
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.transformArguments = exports.FIRST_KEY_INDEX = undefined;
  exports.FIRST_KEY_INDEX = 1;
  exports.transformArguments = transformArguments;
});

// node_modules/@redis/client/dist/lib/commands/ZMPOP.js
var require_ZMPOP = __commonJS((exports) => {
  var transformArguments = function(keys, side, options) {
    return (0, generic_transformers_1.transformZMPopArguments)(["ZMPOP"], keys, side, options);
  };
  var transformReply = function(reply) {
    return reply === null ? null : {
      key: reply[0],
      elements: reply[1].map(generic_transformers_1.transformSortedSetMemberReply)
    };
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.transformReply = exports.transformArguments = exports.FIRST_KEY_INDEX = undefined;
  var generic_transformers_1 = require_generic_transformers();
  exports.FIRST_KEY_INDEX = 2;
  exports.transformArguments = transformArguments;
  exports.transformReply = transformReply;
});

// node_modules/@redis/client/dist/lib/commands/BZMPOP.js
var require_BZMPOP = __commonJS((exports) => {
  var transformArguments = function(timeout, keys, side, options) {
    return (0, generic_transformers_1.transformZMPopArguments)(["BZMPOP", timeout.toString()], keys, side, options);
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.transformReply = exports.transformArguments = exports.FIRST_KEY_INDEX = undefined;
  var generic_transformers_1 = require_generic_transformers();
  exports.FIRST_KEY_INDEX = 3;
  exports.transformArguments = transformArguments;
  var ZMPOP_1 = require_ZMPOP();
  Object.defineProperty(exports, "transformReply", { enumerable: true, get: function() {
    return ZMPOP_1.transformReply;
  } });
});

// node_modules/@redis/client/dist/lib/commands/BZPOPMAX.js
var require_BZPOPMAX = __commonJS((exports) => {
  var transformArguments = function(key, timeout) {
    const args = (0, generic_transformers_1.pushVerdictArguments)(["BZPOPMAX"], key);
    args.push(timeout.toString());
    return args;
  };
  var transformReply = function(reply) {
    if (!reply)
      return null;
    return {
      key: reply[0],
      value: reply[1],
      score: (0, generic_transformers_1.transformNumberInfinityReply)(reply[2])
    };
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.transformReply = exports.transformArguments = exports.FIRST_KEY_INDEX = undefined;
  var generic_transformers_1 = require_generic_transformers();
  exports.FIRST_KEY_INDEX = 1;
  exports.transformArguments = transformArguments;
  exports.transformReply = transformReply;
});

// node_modules/@redis/client/dist/lib/commands/BZPOPMIN.js
var require_BZPOPMIN = __commonJS((exports) => {
  var transformArguments = function(key, timeout) {
    const args = (0, generic_transformers_1.pushVerdictArguments)(["BZPOPMIN"], key);
    args.push(timeout.toString());
    return args;
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.transformReply = exports.transformArguments = exports.FIRST_KEY_INDEX = undefined;
  var generic_transformers_1 = require_generic_transformers();
  exports.FIRST_KEY_INDEX = 1;
  exports.transformArguments = transformArguments;
  var BZPOPMAX_1 = require_BZPOPMAX();
  Object.defineProperty(exports, "transformReply", { enumerable: true, get: function() {
    return BZPOPMAX_1.transformReply;
  } });
});

// node_modules/@redis/client/dist/lib/commands/COPY.js
var require_COPY = __commonJS((exports) => {
  var transformArguments = function(source, destination, options) {
    const args = ["COPY", source, destination];
    if (options?.destinationDb) {
      args.push("DB", options.destinationDb.toString());
    }
    if (options?.replace) {
      args.push("REPLACE");
    }
    return args;
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.transformReply = exports.transformArguments = exports.FIRST_KEY_INDEX = undefined;
  exports.FIRST_KEY_INDEX = 1;
  exports.transformArguments = transformArguments;
  var generic_transformers_1 = require_generic_transformers();
  Object.defineProperty(exports, "transformReply", { enumerable: true, get: function() {
    return generic_transformers_1.transformBooleanReply;
  } });
});

// node_modules/@redis/client/dist/lib/commands/DECR.js
var require_DECR = __commonJS((exports) => {
  var transformArguments = function(key) {
    return ["DECR", key];
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.transformArguments = exports.FIRST_KEY_INDEX = undefined;
  exports.FIRST_KEY_INDEX = 1;
  exports.transformArguments = transformArguments;
});

// node_modules/@redis/client/dist/lib/commands/DECRBY.js
var require_DECRBY = __commonJS((exports) => {
  var transformArguments = function(key, decrement) {
    return ["DECRBY", key, decrement.toString()];
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.transformArguments = exports.FIRST_KEY_INDEX = undefined;
  exports.FIRST_KEY_INDEX = 1;
  exports.transformArguments = transformArguments;
});

// node_modules/@redis/client/dist/lib/commands/DEL.js
var require_DEL = __commonJS((exports) => {
  var transformArguments = function(keys) {
    return (0, generic_transformers_1.pushVerdictArguments)(["DEL"], keys);
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.transformArguments = exports.FIRST_KEY_INDEX = undefined;
  var generic_transformers_1 = require_generic_transformers();
  exports.FIRST_KEY_INDEX = 1;
  exports.transformArguments = transformArguments;
});

// node_modules/@redis/client/dist/lib/commands/DUMP.js
var require_DUMP = __commonJS((exports) => {
  var transformArguments = function(key) {
    return ["DUMP", key];
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.transformArguments = exports.FIRST_KEY_INDEX = undefined;
  exports.FIRST_KEY_INDEX = 1;
  exports.transformArguments = transformArguments;
});

// node_modules/@redis/client/dist/lib/commands/EVAL_RO.js
var require_EVAL_RO = __commonJS((exports) => {
  var transformArguments = function(script, options) {
    return (0, generic_transformers_1.pushEvalArguments)(["EVAL_RO", script], options);
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.transformArguments = exports.IS_READ_ONLY = exports.FIRST_KEY_INDEX = undefined;
  var generic_transformers_1 = require_generic_transformers();
  exports.FIRST_KEY_INDEX = generic_transformers_1.evalFirstKeyIndex;
  exports.IS_READ_ONLY = true;
  exports.transformArguments = transformArguments;
});

// node_modules/@redis/client/dist/lib/commands/EVAL.js
var require_EVAL = __commonJS((exports) => {
  var transformArguments = function(script, options) {
    return (0, generic_transformers_1.pushEvalArguments)(["EVAL", script], options);
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.transformArguments = exports.FIRST_KEY_INDEX = undefined;
  var generic_transformers_1 = require_generic_transformers();
  exports.FIRST_KEY_INDEX = generic_transformers_1.evalFirstKeyIndex;
  exports.transformArguments = transformArguments;
});

// node_modules/@redis/client/dist/lib/commands/EVALSHA_RO.js
var require_EVALSHA_RO = __commonJS((exports) => {
  var transformArguments = function(sha1, options) {
    return (0, generic_transformers_1.pushEvalArguments)(["EVALSHA_RO", sha1], options);
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.transformArguments = exports.IS_READ_ONLY = exports.FIRST_KEY_INDEX = undefined;
  var generic_transformers_1 = require_generic_transformers();
  exports.FIRST_KEY_INDEX = generic_transformers_1.evalFirstKeyIndex;
  exports.IS_READ_ONLY = true;
  exports.transformArguments = transformArguments;
});

// node_modules/@redis/client/dist/lib/commands/EVALSHA.js
var require_EVALSHA = __commonJS((exports) => {
  var transformArguments = function(sha1, options) {
    return (0, generic_transformers_1.pushEvalArguments)(["EVALSHA", sha1], options);
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.transformArguments = exports.FIRST_KEY_INDEX = undefined;
  var generic_transformers_1 = require_generic_transformers();
  exports.FIRST_KEY_INDEX = generic_transformers_1.evalFirstKeyIndex;
  exports.transformArguments = transformArguments;
});

// node_modules/@redis/client/dist/lib/commands/EXISTS.js
var require_EXISTS = __commonJS((exports) => {
  var transformArguments = function(keys) {
    return (0, generic_transformers_1.pushVerdictArguments)(["EXISTS"], keys);
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.transformArguments = exports.IS_READ_ONLY = exports.FIRST_KEY_INDEX = undefined;
  var generic_transformers_1 = require_generic_transformers();
  exports.FIRST_KEY_INDEX = 1;
  exports.IS_READ_ONLY = true;
  exports.transformArguments = transformArguments;
});

// node_modules/@redis/client/dist/lib/commands/EXPIRE.js
var require_EXPIRE = __commonJS((exports) => {
  var transformArguments = function(key, seconds, mode) {
    const args = ["EXPIRE", key, seconds.toString()];
    if (mode) {
      args.push(mode);
    }
    return args;
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.transformReply = exports.transformArguments = exports.FIRST_KEY_INDEX = undefined;
  exports.FIRST_KEY_INDEX = 1;
  exports.transformArguments = transformArguments;
  var generic_transformers_1 = require_generic_transformers();
  Object.defineProperty(exports, "transformReply", { enumerable: true, get: function() {
    return generic_transformers_1.transformBooleanReply;
  } });
});

// node_modules/@redis/client/dist/lib/commands/EXPIREAT.js
var require_EXPIREAT = __commonJS((exports) => {
  var transformArguments = function(key, timestamp, mode) {
    const args = [
      "EXPIREAT",
      key,
      (0, generic_transformers_1.transformEXAT)(timestamp)
    ];
    if (mode) {
      args.push(mode);
    }
    return args;
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.transformReply = exports.transformArguments = exports.FIRST_KEY_INDEX = undefined;
  var generic_transformers_1 = require_generic_transformers();
  exports.FIRST_KEY_INDEX = 1;
  exports.transformArguments = transformArguments;
  var generic_transformers_2 = require_generic_transformers();
  Object.defineProperty(exports, "transformReply", { enumerable: true, get: function() {
    return generic_transformers_2.transformBooleanReply;
  } });
});

// node_modules/@redis/client/dist/lib/commands/EXPIRETIME.js
var require_EXPIRETIME = __commonJS((exports) => {
  var transformArguments = function(key) {
    return ["EXPIRETIME", key];
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.transformArguments = exports.FIRST_KEY_INDEX = undefined;
  exports.FIRST_KEY_INDEX = 1;
  exports.transformArguments = transformArguments;
});

// node_modules/@redis/client/dist/lib/commands/FCALL_RO.js
var require_FCALL_RO = __commonJS((exports) => {
  var transformArguments = function(fn, options) {
    return (0, generic_transformers_1.pushEvalArguments)(["FCALL_RO", fn], options);
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.transformArguments = exports.IS_READ_ONLY = exports.FIRST_KEY_INDEX = undefined;
  var generic_transformers_1 = require_generic_transformers();
  exports.FIRST_KEY_INDEX = generic_transformers_1.evalFirstKeyIndex;
  exports.IS_READ_ONLY = true;
  exports.transformArguments = transformArguments;
});

// node_modules/@redis/client/dist/lib/commands/FCALL.js
var require_FCALL = __commonJS((exports) => {
  var transformArguments = function(fn, options) {
    return (0, generic_transformers_1.pushEvalArguments)(["FCALL", fn], options);
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.transformArguments = exports.FIRST_KEY_INDEX = undefined;
  var generic_transformers_1 = require_generic_transformers();
  exports.FIRST_KEY_INDEX = generic_transformers_1.evalFirstKeyIndex;
  exports.transformArguments = transformArguments;
});

// node_modules/@redis/client/dist/lib/commands/GEOADD.js
var require_GEOADD = __commonJS((exports) => {
  var transformArguments = function(key, toAdd, options) {
    const args = ["GEOADD", key];
    if (options?.NX) {
      args.push("NX");
    } else if (options?.XX) {
      args.push("XX");
    }
    if (options?.CH) {
      args.push("CH");
    }
    for (const { longitude, latitude, member } of Array.isArray(toAdd) ? toAdd : [toAdd]) {
      args.push(longitude.toString(), latitude.toString(), member);
    }
    return args;
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.transformArguments = exports.FIRST_KEY_INDEX = undefined;
  exports.FIRST_KEY_INDEX = 1;
  exports.transformArguments = transformArguments;
});

// node_modules/@redis/client/dist/lib/commands/GEODIST.js
var require_GEODIST = __commonJS((exports) => {
  var transformArguments = function(key, member1, member2, unit) {
    const args = ["GEODIST", key, member1, member2];
    if (unit) {
      args.push(unit);
    }
    return args;
  };
  var transformReply = function(reply) {
    return reply === null ? null : Number(reply);
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.transformReply = exports.transformArguments = exports.IS_READ_ONLY = exports.FIRST_KEY_INDEX = undefined;
  exports.FIRST_KEY_INDEX = 1;
  exports.IS_READ_ONLY = true;
  exports.transformArguments = transformArguments;
  exports.transformReply = transformReply;
});

// node_modules/@redis/client/dist/lib/commands/GEOHASH.js
var require_GEOHASH = __commonJS((exports) => {
  var transformArguments = function(key, member) {
    return (0, generic_transformers_1.pushVerdictArguments)(["GEOHASH", key], member);
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.transformArguments = exports.IS_READ_ONLY = exports.FIRST_KEY_INDEX = undefined;
  var generic_transformers_1 = require_generic_transformers();
  exports.FIRST_KEY_INDEX = 1;
  exports.IS_READ_ONLY = true;
  exports.transformArguments = transformArguments;
});

// node_modules/@redis/client/dist/lib/commands/GEOPOS.js
var require_GEOPOS = __commonJS((exports) => {
  var transformArguments = function(key, member) {
    return (0, generic_transformers_1.pushVerdictArguments)(["GEOPOS", key], member);
  };
  var transformReply = function(reply) {
    return reply.map((coordinates) => coordinates === null ? null : {
      longitude: coordinates[0],
      latitude: coordinates[1]
    });
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.transformReply = exports.transformArguments = exports.IS_READ_ONLY = exports.FIRST_KEY_INDEX = undefined;
  var generic_transformers_1 = require_generic_transformers();
  exports.FIRST_KEY_INDEX = 1;
  exports.IS_READ_ONLY = true;
  exports.transformArguments = transformArguments;
  exports.transformReply = transformReply;
});

// node_modules/@redis/client/dist/lib/commands/GEORADIUS_RO.js
var require_GEORADIUS_RO = __commonJS((exports) => {
  var transformArguments = function(key, coordinates, radius, unit, options) {
    return (0, generic_transformers_1.pushGeoRadiusArguments)(["GEORADIUS_RO"], key, coordinates, radius, unit, options);
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.transformArguments = exports.IS_READ_ONLY = exports.FIRST_KEY_INDEX = undefined;
  var generic_transformers_1 = require_generic_transformers();
  exports.FIRST_KEY_INDEX = 1;
  exports.IS_READ_ONLY = true;
  exports.transformArguments = transformArguments;
});

// node_modules/@redis/client/dist/lib/commands/GEORADIUS_RO_WITH.js
var require_GEORADIUS_RO_WITH = __commonJS((exports) => {
  var transformArguments = function(key, coordinates, radius, unit, replyWith, options) {
    const args = (0, GEORADIUS_RO_1.transformArguments)(key, coordinates, radius, unit, options);
    args.push(...replyWith);
    args.preserve = replyWith;
    return args;
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.transformReply = exports.transformArguments = exports.IS_READ_ONLY = exports.FIRST_KEY_INDEX = undefined;
  var GEORADIUS_RO_1 = require_GEORADIUS_RO();
  var GEORADIUS_RO_2 = require_GEORADIUS_RO();
  Object.defineProperty(exports, "FIRST_KEY_INDEX", { enumerable: true, get: function() {
    return GEORADIUS_RO_2.FIRST_KEY_INDEX;
  } });
  Object.defineProperty(exports, "IS_READ_ONLY", { enumerable: true, get: function() {
    return GEORADIUS_RO_2.IS_READ_ONLY;
  } });
  exports.transformArguments = transformArguments;
  var generic_transformers_1 = require_generic_transformers();
  Object.defineProperty(exports, "transformReply", { enumerable: true, get: function() {
    return generic_transformers_1.transformGeoMembersWithReply;
  } });
});

// node_modules/@redis/client/dist/lib/commands/GEORADIUS.js
var require_GEORADIUS = __commonJS((exports) => {
  var transformArguments = function(key, coordinates, radius, unit, options) {
    return (0, generic_transformers_1.pushGeoRadiusArguments)(["GEORADIUS"], key, coordinates, radius, unit, options);
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.transformArguments = exports.IS_READ_ONLY = exports.FIRST_KEY_INDEX = undefined;
  var generic_transformers_1 = require_generic_transformers();
  exports.FIRST_KEY_INDEX = 1;
  exports.IS_READ_ONLY = true;
  exports.transformArguments = transformArguments;
});

// node_modules/@redis/client/dist/lib/commands/GEORADIUS_WITH.js
var require_GEORADIUS_WITH = __commonJS((exports) => {
  var transformArguments = function(key, coordinates, radius, unit, replyWith, options) {
    const args = (0, GEORADIUS_1.transformArguments)(key, coordinates, radius, unit, options);
    args.push(...replyWith);
    args.preserve = replyWith;
    return args;
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.transformReply = exports.transformArguments = exports.IS_READ_ONLY = exports.FIRST_KEY_INDEX = undefined;
  var GEORADIUS_1 = require_GEORADIUS();
  var GEORADIUS_2 = require_GEORADIUS();
  Object.defineProperty(exports, "FIRST_KEY_INDEX", { enumerable: true, get: function() {
    return GEORADIUS_2.FIRST_KEY_INDEX;
  } });
  Object.defineProperty(exports, "IS_READ_ONLY", { enumerable: true, get: function() {
    return GEORADIUS_2.IS_READ_ONLY;
  } });
  exports.transformArguments = transformArguments;
  var generic_transformers_1 = require_generic_transformers();
  Object.defineProperty(exports, "transformReply", { enumerable: true, get: function() {
    return generic_transformers_1.transformGeoMembersWithReply;
  } });
});

// node_modules/@redis/client/dist/lib/commands/GEORADIUSBYMEMBER_RO.js
var require_GEORADIUSBYMEMBER_RO = __commonJS((exports) => {
  var transformArguments = function(key, member, radius, unit, options) {
    return (0, generic_transformers_1.pushGeoRadiusArguments)(["GEORADIUSBYMEMBER_RO"], key, member, radius, unit, options);
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.transformArguments = exports.IS_READ_ONLY = exports.FIRST_KEY_INDEX = undefined;
  var generic_transformers_1 = require_generic_transformers();
  exports.FIRST_KEY_INDEX = 1;
  exports.IS_READ_ONLY = true;
  exports.transformArguments = transformArguments;
});

// node_modules/@redis/client/dist/lib/commands/GEORADIUSBYMEMBER_RO_WITH.js
var require_GEORADIUSBYMEMBER_RO_WITH = __commonJS((exports) => {
  var transformArguments = function(key, member, radius, unit, replyWith, options) {
    const args = (0, GEORADIUSBYMEMBER_RO_1.transformArguments)(key, member, radius, unit, options);
    args.push(...replyWith);
    args.preserve = replyWith;
    return args;
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.transformReply = exports.transformArguments = exports.IS_READ_ONLY = exports.FIRST_KEY_INDEX = undefined;
  var GEORADIUSBYMEMBER_RO_1 = require_GEORADIUSBYMEMBER_RO();
  var GEORADIUSBYMEMBER_RO_2 = require_GEORADIUSBYMEMBER_RO();
  Object.defineProperty(exports, "FIRST_KEY_INDEX", { enumerable: true, get: function() {
    return GEORADIUSBYMEMBER_RO_2.FIRST_KEY_INDEX;
  } });
  Object.defineProperty(exports, "IS_READ_ONLY", { enumerable: true, get: function() {
    return GEORADIUSBYMEMBER_RO_2.IS_READ_ONLY;
  } });
  exports.transformArguments = transformArguments;
  var generic_transformers_1 = require_generic_transformers();
  Object.defineProperty(exports, "transformReply", { enumerable: true, get: function() {
    return generic_transformers_1.transformGeoMembersWithReply;
  } });
});

// node_modules/@redis/client/dist/lib/commands/GEORADIUSBYMEMBER.js
var require_GEORADIUSBYMEMBER = __commonJS((exports) => {
  var transformArguments = function(key, member, radius, unit, options) {
    return (0, generic_transformers_1.pushGeoRadiusArguments)(["GEORADIUSBYMEMBER"], key, member, radius, unit, options);
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.transformArguments = exports.IS_READ_ONLY = exports.FIRST_KEY_INDEX = undefined;
  var generic_transformers_1 = require_generic_transformers();
  exports.FIRST_KEY_INDEX = 1;
  exports.IS_READ_ONLY = true;
  exports.transformArguments = transformArguments;
});

// node_modules/@redis/client/dist/lib/commands/GEORADIUSBYMEMBER_WITH.js
var require_GEORADIUSBYMEMBER_WITH = __commonJS((exports) => {
  var transformArguments = function(key, member, radius, unit, replyWith, options) {
    const args = (0, GEORADIUSBYMEMBER_1.transformArguments)(key, member, radius, unit, options);
    args.push(...replyWith);
    args.preserve = replyWith;
    return args;
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.transformReply = exports.transformArguments = exports.IS_READ_ONLY = exports.FIRST_KEY_INDEX = undefined;
  var GEORADIUSBYMEMBER_1 = require_GEORADIUSBYMEMBER();
  var GEORADIUSBYMEMBER_2 = require_GEORADIUSBYMEMBER();
  Object.defineProperty(exports, "FIRST_KEY_INDEX", { enumerable: true, get: function() {
    return GEORADIUSBYMEMBER_2.FIRST_KEY_INDEX;
  } });
  Object.defineProperty(exports, "IS_READ_ONLY", { enumerable: true, get: function() {
    return GEORADIUSBYMEMBER_2.IS_READ_ONLY;
  } });
  exports.transformArguments = transformArguments;
  var generic_transformers_1 = require_generic_transformers();
  Object.defineProperty(exports, "transformReply", { enumerable: true, get: function() {
    return generic_transformers_1.transformGeoMembersWithReply;
  } });
});

// node_modules/@redis/client/dist/lib/commands/GEORADIUSBYMEMBERSTORE.js
var require_GEORADIUSBYMEMBERSTORE = __commonJS((exports) => {
  var transformArguments = function(key, member, radius, unit, destination, options) {
    return (0, generic_transformers_1.pushGeoRadiusStoreArguments)(["GEORADIUSBYMEMBER"], key, member, radius, unit, destination, options);
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.transformArguments = exports.IS_READ_ONLY = exports.FIRST_KEY_INDEX = undefined;
  var generic_transformers_1 = require_generic_transformers();
  var GEORADIUSBYMEMBER_1 = require_GEORADIUSBYMEMBER();
  Object.defineProperty(exports, "FIRST_KEY_INDEX", { enumerable: true, get: function() {
    return GEORADIUSBYMEMBER_1.FIRST_KEY_INDEX;
  } });
  Object.defineProperty(exports, "IS_READ_ONLY", { enumerable: true, get: function() {
    return GEORADIUSBYMEMBER_1.IS_READ_ONLY;
  } });
  exports.transformArguments = transformArguments;
});

// node_modules/@redis/client/dist/lib/commands/GEORADIUSSTORE.js
var require_GEORADIUSSTORE = __commonJS((exports) => {
  var transformArguments = function(key, coordinates, radius, unit, destination, options) {
    return (0, generic_transformers_1.pushGeoRadiusStoreArguments)(["GEORADIUS"], key, coordinates, radius, unit, destination, options);
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.transformArguments = exports.IS_READ_ONLY = exports.FIRST_KEY_INDEX = undefined;
  var generic_transformers_1 = require_generic_transformers();
  var GEORADIUS_1 = require_GEORADIUS();
  Object.defineProperty(exports, "FIRST_KEY_INDEX", { enumerable: true, get: function() {
    return GEORADIUS_1.FIRST_KEY_INDEX;
  } });
  Object.defineProperty(exports, "IS_READ_ONLY", { enumerable: true, get: function() {
    return GEORADIUS_1.IS_READ_ONLY;
  } });
  exports.transformArguments = transformArguments;
});

// node_modules/@redis/client/dist/lib/commands/GEOSEARCH.js
var require_GEOSEARCH = __commonJS((exports) => {
  var transformArguments = function(key, from, by, options) {
    return (0, generic_transformers_1.pushGeoSearchArguments)(["GEOSEARCH"], key, from, by, options);
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.transformArguments = exports.IS_READ_ONLY = exports.FIRST_KEY_INDEX = undefined;
  var generic_transformers_1 = require_generic_transformers();
  exports.FIRST_KEY_INDEX = 1;
  exports.IS_READ_ONLY = true;
  exports.transformArguments = transformArguments;
});

// node_modules/@redis/client/dist/lib/commands/GEOSEARCH_WITH.js
var require_GEOSEARCH_WITH = __commonJS((exports) => {
  var transformArguments = function(key, from, by, replyWith, options) {
    const args = (0, GEOSEARCH_1.transformArguments)(key, from, by, options);
    args.push(...replyWith);
    args.preserve = replyWith;
    return args;
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.transformReply = exports.transformArguments = exports.IS_READ_ONLY = exports.FIRST_KEY_INDEX = undefined;
  var GEOSEARCH_1 = require_GEOSEARCH();
  var GEOSEARCH_2 = require_GEOSEARCH();
  Object.defineProperty(exports, "FIRST_KEY_INDEX", { enumerable: true, get: function() {
    return GEOSEARCH_2.FIRST_KEY_INDEX;
  } });
  Object.defineProperty(exports, "IS_READ_ONLY", { enumerable: true, get: function() {
    return GEOSEARCH_2.IS_READ_ONLY;
  } });
  exports.transformArguments = transformArguments;
  var generic_transformers_1 = require_generic_transformers();
  Object.defineProperty(exports, "transformReply", { enumerable: true, get: function() {
    return generic_transformers_1.transformGeoMembersWithReply;
  } });
});

// node_modules/@redis/client/dist/lib/commands/GEOSEARCHSTORE.js
var require_GEOSEARCHSTORE = __commonJS((exports) => {
  var transformArguments = function(destination, source, from, by, options) {
    const args = (0, generic_transformers_1.pushGeoSearchArguments)(["GEOSEARCHSTORE", destination], source, from, by, options);
    if (options?.STOREDIST) {
      args.push("STOREDIST");
    }
    return args;
  };
  var transformReply = function(reply) {
    if (typeof reply !== "number") {
      throw new TypeError(`https://github.com/redis/redis/issues/9261`);
    }
    return reply;
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.transformReply = exports.transformArguments = exports.IS_READ_ONLY = exports.FIRST_KEY_INDEX = undefined;
  var generic_transformers_1 = require_generic_transformers();
  var GEOSEARCH_1 = require_GEOSEARCH();
  Object.defineProperty(exports, "FIRST_KEY_INDEX", { enumerable: true, get: function() {
    return GEOSEARCH_1.FIRST_KEY_INDEX;
  } });
  Object.defineProperty(exports, "IS_READ_ONLY", { enumerable: true, get: function() {
    return GEOSEARCH_1.IS_READ_ONLY;
  } });
  exports.transformArguments = transformArguments;
  exports.transformReply = transformReply;
});

// node_modules/@redis/client/dist/lib/commands/GET.js
var require_GET = __commonJS((exports) => {
  var transformArguments = function(key) {
    return ["GET", key];
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.transformArguments = exports.IS_READ_ONLY = exports.FIRST_KEY_INDEX = undefined;
  exports.FIRST_KEY_INDEX = 1;
  exports.IS_READ_ONLY = true;
  exports.transformArguments = transformArguments;
});

// node_modules/@redis/client/dist/lib/commands/GETBIT.js
var require_GETBIT = __commonJS((exports) => {
  var transformArguments = function(key, offset) {
    return ["GETBIT", key, offset.toString()];
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.transformArguments = exports.IS_READ_ONLY = exports.FIRST_KEY_INDEX = undefined;
  exports.FIRST_KEY_INDEX = 1;
  exports.IS_READ_ONLY = true;
  exports.transformArguments = transformArguments;
});

// node_modules/@redis/client/dist/lib/commands/GETDEL.js
var require_GETDEL = __commonJS((exports) => {
  var transformArguments = function(key) {
    return ["GETDEL", key];
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.transformArguments = exports.FIRST_KEY_INDEX = undefined;
  exports.FIRST_KEY_INDEX = 1;
  exports.transformArguments = transformArguments;
});

// node_modules/@redis/client/dist/lib/commands/GETEX.js
var require_GETEX = __commonJS((exports) => {
  var transformArguments = function(key, mode) {
    const args = ["GETEX", key];
    if ("EX" in mode) {
      args.push("EX", mode.EX.toString());
    } else if ("PX" in mode) {
      args.push("PX", mode.PX.toString());
    } else if ("EXAT" in mode) {
      args.push("EXAT", (0, generic_transformers_1.transformEXAT)(mode.EXAT));
    } else if ("PXAT" in mode) {
      args.push("PXAT", (0, generic_transformers_1.transformPXAT)(mode.PXAT));
    } else {
      args.push("PERSIST");
    }
    return args;
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.transformArguments = exports.FIRST_KEY_INDEX = undefined;
  var generic_transformers_1 = require_generic_transformers();
  exports.FIRST_KEY_INDEX = 1;
  exports.transformArguments = transformArguments;
});

// node_modules/@redis/client/dist/lib/commands/GETRANGE.js
var require_GETRANGE = __commonJS((exports) => {
  var transformArguments = function(key, start, end) {
    return ["GETRANGE", key, start.toString(), end.toString()];
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.transformArguments = exports.IS_READ_ONLY = exports.FIRST_KEY_INDEX = undefined;
  exports.FIRST_KEY_INDEX = 1;
  exports.IS_READ_ONLY = true;
  exports.transformArguments = transformArguments;
});

// node_modules/@redis/client/dist/lib/commands/GETSET.js
var require_GETSET = __commonJS((exports) => {
  var transformArguments = function(key, value) {
    return ["GETSET", key, value];
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.transformArguments = exports.FIRST_KEY_INDEX = undefined;
  exports.FIRST_KEY_INDEX = 1;
  exports.transformArguments = transformArguments;
});

// node_modules/@redis/client/dist/lib/commands/HDEL.js
var require_HDEL = __commonJS((exports) => {
  var transformArguments = function(key, field) {
    return (0, generic_transformers_1.pushVerdictArguments)(["HDEL", key], field);
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.transformArguments = exports.FIRST_KEY_INDEX = undefined;
  var generic_transformers_1 = require_generic_transformers();
  exports.FIRST_KEY_INDEX = 1;
  exports.transformArguments = transformArguments;
});

// node_modules/@redis/client/dist/lib/commands/HEXISTS.js
var require_HEXISTS = __commonJS((exports) => {
  var transformArguments = function(key, field) {
    return ["HEXISTS", key, field];
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.transformReply = exports.transformArguments = exports.FIRST_KEY_INDEX = undefined;
  exports.FIRST_KEY_INDEX = 1;
  exports.transformArguments = transformArguments;
  var generic_transformers_1 = require_generic_transformers();
  Object.defineProperty(exports, "transformReply", { enumerable: true, get: function() {
    return generic_transformers_1.transformBooleanReply;
  } });
});

// node_modules/@redis/client/dist/lib/commands/HGET.js
var require_HGET = __commonJS((exports) => {
  var transformArguments = function(key, field) {
    return ["HGET", key, field];
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.transformArguments = exports.IS_READ_ONLY = exports.FIRST_KEY_INDEX = undefined;
  exports.FIRST_KEY_INDEX = 1;
  exports.IS_READ_ONLY = true;
  exports.transformArguments = transformArguments;
});

// node_modules/@redis/client/dist/lib/commands/HGETALL.js
var require_HGETALL = __commonJS((exports) => {
  var transformArguments = function(key) {
    return ["HGETALL", key];
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.transformReply = exports.transformArguments = exports.TRANSFORM_LEGACY_REPLY = exports.IS_READ_ONLY = exports.FIRST_KEY_INDEX = undefined;
  exports.FIRST_KEY_INDEX = 1;
  exports.IS_READ_ONLY = true;
  exports.TRANSFORM_LEGACY_REPLY = true;
  exports.transformArguments = transformArguments;
  var generic_transformers_1 = require_generic_transformers();
  Object.defineProperty(exports, "transformReply", { enumerable: true, get: function() {
    return generic_transformers_1.transformTuplesReply;
  } });
});

// node_modules/@redis/client/dist/lib/commands/HINCRBY.js
var require_HINCRBY = __commonJS((exports) => {
  var transformArguments = function(key, field, increment) {
    return ["HINCRBY", key, field, increment.toString()];
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.transformArguments = exports.FIRST_KEY_INDEX = undefined;
  exports.FIRST_KEY_INDEX = 1;
  exports.transformArguments = transformArguments;
});

// node_modules/@redis/client/dist/lib/commands/HINCRBYFLOAT.js
var require_HINCRBYFLOAT = __commonJS((exports) => {
  var transformArguments = function(key, field, increment) {
    return ["HINCRBYFLOAT", key, field, increment.toString()];
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.transformArguments = exports.FIRST_KEY_INDEX = undefined;
  exports.FIRST_KEY_INDEX = 1;
  exports.transformArguments = transformArguments;
});

// node_modules/@redis/client/dist/lib/commands/HKEYS.js
var require_HKEYS = __commonJS((exports) => {
  var transformArguments = function(key) {
    return ["HKEYS", key];
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.transformArguments = exports.FIRST_KEY_INDEX = undefined;
  exports.FIRST_KEY_INDEX = 1;
  exports.transformArguments = transformArguments;
});

// node_modules/@redis/client/dist/lib/commands/HLEN.js
var require_HLEN = __commonJS((exports) => {
  var transformArguments = function(key) {
    return ["HLEN", key];
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.transformArguments = exports.FIRST_KEY_INDEX = undefined;
  exports.FIRST_KEY_INDEX = 1;
  exports.transformArguments = transformArguments;
});

// node_modules/@redis/client/dist/lib/commands/HMGET.js
var require_HMGET = __commonJS((exports) => {
  var transformArguments = function(key, fields) {
    return (0, generic_transformers_1.pushVerdictArguments)(["HMGET", key], fields);
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.transformArguments = exports.IS_READ_ONLY = exports.FIRST_KEY_INDEX = undefined;
  var generic_transformers_1 = require_generic_transformers();
  exports.FIRST_KEY_INDEX = 1;
  exports.IS_READ_ONLY = true;
  exports.transformArguments = transformArguments;
});

// node_modules/@redis/client/dist/lib/commands/HRANDFIELD.js
var require_HRANDFIELD = __commonJS((exports) => {
  var transformArguments = function(key) {
    return ["HRANDFIELD", key];
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.transformArguments = exports.IS_READ_ONLY = exports.FIRST_KEY_INDEX = undefined;
  exports.FIRST_KEY_INDEX = 1;
  exports.IS_READ_ONLY = true;
  exports.transformArguments = transformArguments;
});

// node_modules/@redis/client/dist/lib/commands/HRANDFIELD_COUNT.js
var require_HRANDFIELD_COUNT = __commonJS((exports) => {
  var transformArguments = function(key, count) {
    return [
      ...(0, HRANDFIELD_1.transformArguments)(key),
      count.toString()
    ];
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.transformArguments = exports.IS_READ_ONLY = exports.FIRST_KEY_INDEX = undefined;
  var HRANDFIELD_1 = require_HRANDFIELD();
  var HRANDFIELD_2 = require_HRANDFIELD();
  Object.defineProperty(exports, "FIRST_KEY_INDEX", { enumerable: true, get: function() {
    return HRANDFIELD_2.FIRST_KEY_INDEX;
  } });
  Object.defineProperty(exports, "IS_READ_ONLY", { enumerable: true, get: function() {
    return HRANDFIELD_2.IS_READ_ONLY;
  } });
  exports.transformArguments = transformArguments;
});

// node_modules/@redis/client/dist/lib/commands/HRANDFIELD_COUNT_WITHVALUES.js
var require_HRANDFIELD_COUNT_WITHVALUES = __commonJS((exports) => {
  var transformArguments = function(key, count) {
    return [
      ...(0, HRANDFIELD_COUNT_1.transformArguments)(key, count),
      "WITHVALUES"
    ];
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.transformReply = exports.transformArguments = exports.IS_READ_ONLY = exports.FIRST_KEY_INDEX = undefined;
  var HRANDFIELD_COUNT_1 = require_HRANDFIELD_COUNT();
  var HRANDFIELD_COUNT_2 = require_HRANDFIELD_COUNT();
  Object.defineProperty(exports, "FIRST_KEY_INDEX", { enumerable: true, get: function() {
    return HRANDFIELD_COUNT_2.FIRST_KEY_INDEX;
  } });
  Object.defineProperty(exports, "IS_READ_ONLY", { enumerable: true, get: function() {
    return HRANDFIELD_COUNT_2.IS_READ_ONLY;
  } });
  exports.transformArguments = transformArguments;
  var generic_transformers_1 = require_generic_transformers();
  Object.defineProperty(exports, "transformReply", { enumerable: true, get: function() {
    return generic_transformers_1.transformTuplesReply;
  } });
});

// node_modules/@redis/client/dist/lib/commands/HSCAN.js
var require_HSCAN = __commonJS((exports) => {
  var transformArguments = function(key, cursor, options) {
    return (0, generic_transformers_1.pushScanArguments)([
      "HSCAN",
      key
    ], cursor, options);
  };
  var transformReply = function([cursor, rawTuples]) {
    const parsedTuples = [];
    for (let i = 0;i < rawTuples.length; i += 2) {
      parsedTuples.push({
        field: rawTuples[i],
        value: rawTuples[i + 1]
      });
    }
    return {
      cursor: Number(cursor),
      tuples: parsedTuples
    };
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.transformReply = exports.transformArguments = exports.IS_READ_ONLY = exports.FIRST_KEY_INDEX = undefined;
  var generic_transformers_1 = require_generic_transformers();
  exports.FIRST_KEY_INDEX = 1;
  exports.IS_READ_ONLY = true;
  exports.transformArguments = transformArguments;
  exports.transformReply = transformReply;
});

// node_modules/@redis/client/dist/lib/commands/HSET.js
var require_HSET = __commonJS((exports) => {
  var transformArguments = function(...[key, value, fieldValue]) {
    const args = ["HSET", key];
    if (typeof value === "string" || typeof value === "number" || Buffer.isBuffer(value)) {
      args.push(convertValue(value), convertValue(fieldValue));
    } else if (value instanceof Map) {
      pushMap(args, value);
    } else if (Array.isArray(value)) {
      pushTuples(args, value);
    } else {
      pushObject(args, value);
    }
    return args;
  };
  var pushMap = function(args, map) {
    for (const [key, value] of map.entries()) {
      args.push(convertValue(key), convertValue(value));
    }
  };
  var pushTuples = function(args, tuples2) {
    for (const tuple of tuples2) {
      if (Array.isArray(tuple)) {
        pushTuples(args, tuple);
        continue;
      }
      args.push(convertValue(tuple));
    }
  };
  var pushObject = function(args, object) {
    for (const key of Object.keys(object)) {
      args.push(convertValue(key), convertValue(object[key]));
    }
  };
  var convertValue = function(value) {
    return typeof value === "number" ? value.toString() : value;
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.transformArguments = exports.FIRST_KEY_INDEX = undefined;
  exports.FIRST_KEY_INDEX = 1;
  exports.transformArguments = transformArguments;
});

// node_modules/@redis/client/dist/lib/commands/HSETNX.js
var require_HSETNX = __commonJS((exports) => {
  var transformArguments = function(key, field, value) {
    return ["HSETNX", key, field, value];
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.transformReply = exports.transformArguments = exports.FIRST_KEY_INDEX = undefined;
  exports.FIRST_KEY_INDEX = 1;
  exports.transformArguments = transformArguments;
  var generic_transformers_1 = require_generic_transformers();
  Object.defineProperty(exports, "transformReply", { enumerable: true, get: function() {
    return generic_transformers_1.transformBooleanReply;
  } });
});

// node_modules/@redis/client/dist/lib/commands/HSTRLEN.js
var require_HSTRLEN = __commonJS((exports) => {
  var transformArguments = function(key, field) {
    return ["HSTRLEN", key, field];
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.transformArguments = exports.FIRST_KEY_INDEX = undefined;
  exports.FIRST_KEY_INDEX = 1;
  exports.transformArguments = transformArguments;
});

// node_modules/@redis/client/dist/lib/commands/HVALS.js
var require_HVALS = __commonJS((exports) => {
  var transformArguments = function(key) {
    return ["HVALS", key];
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.transformArguments = exports.FIRST_KEY_INDEX = undefined;
  exports.FIRST_KEY_INDEX = 1;
  exports.transformArguments = transformArguments;
});

// node_modules/@redis/client/dist/lib/commands/INCR.js
var require_INCR = __commonJS((exports) => {
  var transformArguments = function(key) {
    return ["INCR", key];
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.transformArguments = exports.FIRST_KEY_INDEX = undefined;
  exports.FIRST_KEY_INDEX = 1;
  exports.transformArguments = transformArguments;
});

// node_modules/@redis/client/dist/lib/commands/INCRBY.js
var require_INCRBY = __commonJS((exports) => {
  var transformArguments = function(key, increment) {
    return ["INCRBY", key, increment.toString()];
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.transformArguments = exports.FIRST_KEY_INDEX = undefined;
  exports.FIRST_KEY_INDEX = 1;
  exports.transformArguments = transformArguments;
});

// node_modules/@redis/client/dist/lib/commands/INCRBYFLOAT.js
var require_INCRBYFLOAT = __commonJS((exports) => {
  var transformArguments = function(key, increment) {
    return ["INCRBYFLOAT", key, increment.toString()];
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.transformArguments = exports.FIRST_KEY_INDEX = undefined;
  exports.FIRST_KEY_INDEX = 1;
  exports.transformArguments = transformArguments;
});

// node_modules/@redis/client/dist/lib/commands/LCS.js
var require_LCS = __commonJS((exports) => {
  var transformArguments = function(key1, key2) {
    return [
      "LCS",
      key1,
      key2
    ];
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.transformArguments = exports.IS_READ_ONLY = exports.FIRST_KEY_INDEX = undefined;
  exports.FIRST_KEY_INDEX = 1;
  exports.IS_READ_ONLY = true;
  exports.transformArguments = transformArguments;
});

// node_modules/@redis/client/dist/lib/commands/LCS_IDX_WITHMATCHLEN.js
var require_LCS_IDX_WITHMATCHLEN = __commonJS((exports) => {
  var transformArguments = function(key1, key2) {
    const args = (0, LCS_1.transformArguments)(key1, key2);
    args.push("IDX", "WITHMATCHLEN");
    return args;
  };
  var transformReply = function(reply) {
    return {
      matches: reply[1].map(([key1, key2, length]) => ({
        key1: (0, generic_transformers_1.transformRangeReply)(key1),
        key2: (0, generic_transformers_1.transformRangeReply)(key2),
        length
      })),
      length: reply[3]
    };
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.transformReply = exports.transformArguments = exports.IS_READ_ONLY = exports.FIRST_KEY_INDEX = undefined;
  var generic_transformers_1 = require_generic_transformers();
  var LCS_1 = require_LCS();
  var LCS_2 = require_LCS();
  Object.defineProperty(exports, "FIRST_KEY_INDEX", { enumerable: true, get: function() {
    return LCS_2.FIRST_KEY_INDEX;
  } });
  Object.defineProperty(exports, "IS_READ_ONLY", { enumerable: true, get: function() {
    return LCS_2.IS_READ_ONLY;
  } });
  exports.transformArguments = transformArguments;
  exports.transformReply = transformReply;
});

// node_modules/@redis/client/dist/lib/commands/LCS_IDX.js
var require_LCS_IDX = __commonJS((exports) => {
  var transformArguments = function(key1, key2) {
    const args = (0, LCS_1.transformArguments)(key1, key2);
    args.push("IDX");
    return args;
  };
  var transformReply = function(reply) {
    return {
      matches: reply[1].map(([key1, key2]) => ({
        key1: (0, generic_transformers_1.transformRangeReply)(key1),
        key2: (0, generic_transformers_1.transformRangeReply)(key2)
      })),
      length: reply[3]
    };
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.transformReply = exports.transformArguments = exports.IS_READ_ONLY = exports.FIRST_KEY_INDEX = undefined;
  var generic_transformers_1 = require_generic_transformers();
  var LCS_1 = require_LCS();
  var LCS_2 = require_LCS();
  Object.defineProperty(exports, "FIRST_KEY_INDEX", { enumerable: true, get: function() {
    return LCS_2.FIRST_KEY_INDEX;
  } });
  Object.defineProperty(exports, "IS_READ_ONLY", { enumerable: true, get: function() {
    return LCS_2.IS_READ_ONLY;
  } });
  exports.transformArguments = transformArguments;
  exports.transformReply = transformReply;
});

// node_modules/@redis/client/dist/lib/commands/LCS_LEN.js
var require_LCS_LEN = __commonJS((exports) => {
  var transformArguments = function(key1, key2) {
    const args = (0, LCS_1.transformArguments)(key1, key2);
    args.push("LEN");
    return args;
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.transformArguments = exports.IS_READ_ONLY = exports.FIRST_KEY_INDEX = undefined;
  var LCS_1 = require_LCS();
  var LCS_2 = require_LCS();
  Object.defineProperty(exports, "FIRST_KEY_INDEX", { enumerable: true, get: function() {
    return LCS_2.FIRST_KEY_INDEX;
  } });
  Object.defineProperty(exports, "IS_READ_ONLY", { enumerable: true, get: function() {
    return LCS_2.IS_READ_ONLY;
  } });
  exports.transformArguments = transformArguments;
});

// node_modules/@redis/client/dist/lib/commands/LINDEX.js
var require_LINDEX = __commonJS((exports) => {
  var transformArguments = function(key, index) {
    return ["LINDEX", key, index.toString()];
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.transformArguments = exports.IS_READ_ONLY = exports.FIRST_KEY_INDEX = undefined;
  exports.FIRST_KEY_INDEX = 1;
  exports.IS_READ_ONLY = true;
  exports.transformArguments = transformArguments;
});

// node_modules/@redis/client/dist/lib/commands/LINSERT.js
var require_LINSERT = __commonJS((exports) => {
  var transformArguments = function(key, position, pivot, element) {
    return [
      "LINSERT",
      key,
      position,
      pivot,
      element
    ];
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.transformArguments = exports.FIRST_KEY_INDEX = undefined;
  exports.FIRST_KEY_INDEX = 1;
  exports.transformArguments = transformArguments;
});

// node_modules/@redis/client/dist/lib/commands/LLEN.js
var require_LLEN = __commonJS((exports) => {
  var transformArguments = function(key) {
    return ["LLEN", key];
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.transformArguments = exports.IS_READ_ONLY = exports.FIRST_KEY_INDEX = undefined;
  exports.FIRST_KEY_INDEX = 1;
  exports.IS_READ_ONLY = true;
  exports.transformArguments = transformArguments;
});

// node_modules/@redis/client/dist/lib/commands/LMOVE.js
var require_LMOVE = __commonJS((exports) => {
  var transformArguments = function(source, destination, sourceSide, destinationSide) {
    return [
      "LMOVE",
      source,
      destination,
      sourceSide,
      destinationSide
    ];
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.transformArguments = exports.FIRST_KEY_INDEX = undefined;
  exports.FIRST_KEY_INDEX = 1;
  exports.transformArguments = transformArguments;
});

// node_modules/@redis/client/dist/lib/commands/LPOP_COUNT.js
var require_LPOP_COUNT = __commonJS((exports) => {
  var transformArguments = function(key, count) {
    return ["LPOP", key, count.toString()];
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.transformArguments = exports.FIRST_KEY_INDEX = undefined;
  exports.FIRST_KEY_INDEX = 1;
  exports.transformArguments = transformArguments;
});

// node_modules/@redis/client/dist/lib/commands/LPOP.js
var require_LPOP = __commonJS((exports) => {
  var transformArguments = function(key) {
    return ["LPOP", key];
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.transformArguments = exports.FIRST_KEY_INDEX = undefined;
  exports.FIRST_KEY_INDEX = 1;
  exports.transformArguments = transformArguments;
});

// node_modules/@redis/client/dist/lib/commands/LPOS.js
var require_LPOS = __commonJS((exports) => {
  var transformArguments = function(key, element, options) {
    const args = ["LPOS", key, element];
    if (typeof options?.RANK === "number") {
      args.push("RANK", options.RANK.toString());
    }
    if (typeof options?.MAXLEN === "number") {
      args.push("MAXLEN", options.MAXLEN.toString());
    }
    return args;
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.transformArguments = exports.IS_READ_ONLY = exports.FIRST_KEY_INDEX = undefined;
  exports.FIRST_KEY_INDEX = 1;
  exports.IS_READ_ONLY = true;
  exports.transformArguments = transformArguments;
});

// node_modules/@redis/client/dist/lib/commands/LPOS_COUNT.js
var require_LPOS_COUNT = __commonJS((exports) => {
  var transformArguments = function(key, element, count, options) {
    const args = ["LPOS", key, element];
    if (typeof options?.RANK === "number") {
      args.push("RANK", options.RANK.toString());
    }
    args.push("COUNT", count.toString());
    if (typeof options?.MAXLEN === "number") {
      args.push("MAXLEN", options.MAXLEN.toString());
    }
    return args;
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.transformArguments = exports.IS_READ_ONLY = exports.FIRST_KEY_INDEX = undefined;
  var LPOS_1 = require_LPOS();
  Object.defineProperty(exports, "FIRST_KEY_INDEX", { enumerable: true, get: function() {
    return LPOS_1.FIRST_KEY_INDEX;
  } });
  Object.defineProperty(exports, "IS_READ_ONLY", { enumerable: true, get: function() {
    return LPOS_1.IS_READ_ONLY;
  } });
  exports.transformArguments = transformArguments;
});

// node_modules/@redis/client/dist/lib/commands/LPUSH.js
var require_LPUSH = __commonJS((exports) => {
  var transformArguments = function(key, elements) {
    return (0, generic_transformers_1.pushVerdictArguments)(["LPUSH", key], elements);
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.transformArguments = exports.FIRST_KEY_INDEX = undefined;
  var generic_transformers_1 = require_generic_transformers();
  exports.FIRST_KEY_INDEX = 1;
  exports.transformArguments = transformArguments;
});

// node_modules/@redis/client/dist/lib/commands/LPUSHX.js
var require_LPUSHX = __commonJS((exports) => {
  var transformArguments = function(key, element) {
    return (0, generic_transformers_1.pushVerdictArguments)(["LPUSHX", key], element);
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.transformArguments = exports.FIRST_KEY_INDEX = undefined;
  var generic_transformers_1 = require_generic_transformers();
  exports.FIRST_KEY_INDEX = 1;
  exports.transformArguments = transformArguments;
});

// node_modules/@redis/client/dist/lib/commands/LRANGE.js
var require_LRANGE = __commonJS((exports) => {
  var transformArguments = function(key, start, stop) {
    return [
      "LRANGE",
      key,
      start.toString(),
      stop.toString()
    ];
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.transformArguments = exports.IS_READ_ONLY = exports.FIRST_KEY_INDEX = undefined;
  exports.FIRST_KEY_INDEX = 1;
  exports.IS_READ_ONLY = true;
  exports.transformArguments = transformArguments;
});

// node_modules/@redis/client/dist/lib/commands/LREM.js
var require_LREM = __commonJS((exports) => {
  var transformArguments = function(key, count, element) {
    return [
      "LREM",
      key,
      count.toString(),
      element
    ];
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.transformArguments = exports.FIRST_KEY_INDEX = undefined;
  exports.FIRST_KEY_INDEX = 1;
  exports.transformArguments = transformArguments;
});

// node_modules/@redis/client/dist/lib/commands/LSET.js
var require_LSET = __commonJS((exports) => {
  var transformArguments = function(key, index, element) {
    return [
      "LSET",
      key,
      index.toString(),
      element
    ];
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.transformArguments = exports.FIRST_KEY_INDEX = undefined;
  exports.FIRST_KEY_INDEX = 1;
  exports.transformArguments = transformArguments;
});

// node_modules/@redis/client/dist/lib/commands/LTRIM.js
var require_LTRIM = __commonJS((exports) => {
  var transformArguments = function(key, start, stop) {
    return [
      "LTRIM",
      key,
      start.toString(),
      stop.toString()
    ];
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.transformArguments = exports.FIRST_KEY_INDEX = undefined;
  exports.FIRST_KEY_INDEX = 1;
  exports.transformArguments = transformArguments;
});

// node_modules/@redis/client/dist/lib/commands/MGET.js
var require_MGET = __commonJS((exports) => {
  var transformArguments = function(keys) {
    return ["MGET", ...keys];
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.transformArguments = exports.IS_READ_ONLY = exports.FIRST_KEY_INDEX = undefined;
  exports.FIRST_KEY_INDEX = 1;
  exports.IS_READ_ONLY = true;
  exports.transformArguments = transformArguments;
});

// node_modules/@redis/client/dist/lib/commands/MIGRATE.js
var require_MIGRATE = __commonJS((exports) => {
  var transformArguments = function(host, port, key, destinationDb, timeout, options) {
    const args = ["MIGRATE", host, port.toString()], isKeyArray = Array.isArray(key);
    if (isKeyArray) {
      args.push("");
    } else {
      args.push(key);
    }
    args.push(destinationDb.toString(), timeout.toString());
    if (options?.COPY) {
      args.push("COPY");
    }
    if (options?.REPLACE) {
      args.push("REPLACE");
    }
    if (options?.AUTH) {
      if (options.AUTH.username) {
        args.push("AUTH2", options.AUTH.username, options.AUTH.password);
      } else {
        args.push("AUTH", options.AUTH.password);
      }
    }
    if (isKeyArray) {
      args.push("KEYS", ...key);
    }
    return args;
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.transformArguments = undefined;
  exports.transformArguments = transformArguments;
});

// node_modules/@redis/client/dist/lib/commands/MSET.js
var require_MSET = __commonJS((exports) => {
  var transformArguments = function(toSet) {
    const args = ["MSET"];
    if (Array.isArray(toSet)) {
      args.push(...toSet.flat());
    } else {
      for (const key of Object.keys(toSet)) {
        args.push(key, toSet[key]);
      }
    }
    return args;
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.transformArguments = exports.FIRST_KEY_INDEX = undefined;
  exports.FIRST_KEY_INDEX = 1;
  exports.transformArguments = transformArguments;
});

// node_modules/@redis/client/dist/lib/commands/MSETNX.js
var require_MSETNX = __commonJS((exports) => {
  var transformArguments = function(toSet) {
    const args = ["MSETNX"];
    if (Array.isArray(toSet)) {
      args.push(...toSet.flat());
    } else {
      for (const key of Object.keys(toSet)) {
        args.push(key, toSet[key]);
      }
    }
    return args;
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.transformReply = exports.transformArguments = exports.FIRST_KEY_INDEX = undefined;
  exports.FIRST_KEY_INDEX = 1;
  exports.transformArguments = transformArguments;
  var generic_transformers_1 = require_generic_transformers();
  Object.defineProperty(exports, "transformReply", { enumerable: true, get: function() {
    return generic_transformers_1.transformBooleanReply;
  } });
});

// node_modules/@redis/client/dist/lib/commands/OBJECT_ENCODING.js
var require_OBJECT_ENCODING = __commonJS((exports) => {
  var transformArguments = function(key) {
    return ["OBJECT", "ENCODING", key];
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.transformArguments = exports.IS_READ_ONLY = exports.FIRST_KEY_INDEX = undefined;
  exports.FIRST_KEY_INDEX = 2;
  exports.IS_READ_ONLY = true;
  exports.transformArguments = transformArguments;
});

// node_modules/@redis/client/dist/lib/commands/OBJECT_FREQ.js
var require_OBJECT_FREQ = __commonJS((exports) => {
  var transformArguments = function(key) {
    return ["OBJECT", "FREQ", key];
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.transformArguments = exports.IS_READ_ONLY = exports.FIRST_KEY_INDEX = undefined;
  exports.FIRST_KEY_INDEX = 2;
  exports.IS_READ_ONLY = true;
  exports.transformArguments = transformArguments;
});

// node_modules/@redis/client/dist/lib/commands/OBJECT_IDLETIME.js
var require_OBJECT_IDLETIME = __commonJS((exports) => {
  var transformArguments = function(key) {
    return ["OBJECT", "IDLETIME", key];
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.transformArguments = exports.IS_READ_ONLY = exports.FIRST_KEY_INDEX = undefined;
  exports.FIRST_KEY_INDEX = 2;
  exports.IS_READ_ONLY = true;
  exports.transformArguments = transformArguments;
});

// node_modules/@redis/client/dist/lib/commands/OBJECT_REFCOUNT.js
var require_OBJECT_REFCOUNT = __commonJS((exports) => {
  var transformArguments = function(key) {
    return ["OBJECT", "REFCOUNT", key];
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.transformArguments = exports.IS_READ_ONLY = exports.FIRST_KEY_INDEX = undefined;
  exports.FIRST_KEY_INDEX = 2;
  exports.IS_READ_ONLY = true;
  exports.transformArguments = transformArguments;
});

// node_modules/@redis/client/dist/lib/commands/PERSIST.js
var require_PERSIST = __commonJS((exports) => {
  var transformArguments = function(key) {
    return ["PERSIST", key];
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.transformReply = exports.transformArguments = exports.FIRST_KEY_INDEX = undefined;
  exports.FIRST_KEY_INDEX = 1;
  exports.transformArguments = transformArguments;
  var generic_transformers_1 = require_generic_transformers();
  Object.defineProperty(exports, "transformReply", { enumerable: true, get: function() {
    return generic_transformers_1.transformBooleanReply;
  } });
});

// node_modules/@redis/client/dist/lib/commands/PEXPIRE.js
var require_PEXPIRE = __commonJS((exports) => {
  var transformArguments = function(key, milliseconds, mode) {
    const args = ["PEXPIRE", key, milliseconds.toString()];
    if (mode) {
      args.push(mode);
    }
    return args;
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.transformReply = exports.transformArguments = exports.FIRST_KEY_INDEX = undefined;
  exports.FIRST_KEY_INDEX = 1;
  exports.transformArguments = transformArguments;
  var generic_transformers_1 = require_generic_transformers();
  Object.defineProperty(exports, "transformReply", { enumerable: true, get: function() {
    return generic_transformers_1.transformBooleanReply;
  } });
});

// node_modules/@redis/client/dist/lib/commands/PEXPIREAT.js
var require_PEXPIREAT = __commonJS((exports) => {
  var transformArguments = function(key, millisecondsTimestamp, mode) {
    const args = [
      "PEXPIREAT",
      key,
      (0, generic_transformers_1.transformPXAT)(millisecondsTimestamp)
    ];
    if (mode) {
      args.push(mode);
    }
    return args;
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.transformReply = exports.transformArguments = exports.FIRST_KEY_INDEX = undefined;
  var generic_transformers_1 = require_generic_transformers();
  exports.FIRST_KEY_INDEX = 1;
  exports.transformArguments = transformArguments;
  var generic_transformers_2 = require_generic_transformers();
  Object.defineProperty(exports, "transformReply", { enumerable: true, get: function() {
    return generic_transformers_2.transformBooleanReply;
  } });
});

// node_modules/@redis/client/dist/lib/commands/PEXPIRETIME.js
var require_PEXPIRETIME = __commonJS((exports) => {
  var transformArguments = function(key) {
    return ["PEXPIRETIME", key];
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.transformArguments = exports.FIRST_KEY_INDEX = undefined;
  exports.FIRST_KEY_INDEX = 1;
  exports.transformArguments = transformArguments;
});

// node_modules/@redis/client/dist/lib/commands/PFADD.js
var require_PFADD = __commonJS((exports) => {
  var transformArguments = function(key, element) {
    return (0, generic_transformers_1.pushVerdictArguments)(["PFADD", key], element);
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.transformReply = exports.transformArguments = exports.FIRST_KEY_INDEX = undefined;
  var generic_transformers_1 = require_generic_transformers();
  exports.FIRST_KEY_INDEX = 1;
  exports.transformArguments = transformArguments;
  var generic_transformers_2 = require_generic_transformers();
  Object.defineProperty(exports, "transformReply", { enumerable: true, get: function() {
    return generic_transformers_2.transformBooleanReply;
  } });
});

// node_modules/@redis/client/dist/lib/commands/PFCOUNT.js
var require_PFCOUNT = __commonJS((exports) => {
  var transformArguments = function(key) {
    return (0, generic_transformers_1.pushVerdictArguments)(["PFCOUNT"], key);
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.transformArguments = exports.FIRST_KEY_INDEX = undefined;
  var generic_transformers_1 = require_generic_transformers();
  exports.FIRST_KEY_INDEX = 1;
  exports.transformArguments = transformArguments;
});

// node_modules/@redis/client/dist/lib/commands/PFMERGE.js
var require_PFMERGE = __commonJS((exports) => {
  var transformArguments = function(destination, source) {
    return (0, generic_transformers_1.pushVerdictArguments)(["PFMERGE", destination], source);
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.transformArguments = exports.FIRST_KEY_INDEX = undefined;
  var generic_transformers_1 = require_generic_transformers();
  exports.FIRST_KEY_INDEX = 1;
  exports.transformArguments = transformArguments;
});

// node_modules/@redis/client/dist/lib/commands/PSETEX.js
var require_PSETEX = __commonJS((exports) => {
  var transformArguments = function(key, milliseconds, value) {
    return [
      "PSETEX",
      key,
      milliseconds.toString(),
      value
    ];
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.transformArguments = exports.FIRST_KEY_INDEX = undefined;
  exports.FIRST_KEY_INDEX = 1;
  exports.transformArguments = transformArguments;
});

// node_modules/@redis/client/dist/lib/commands/PTTL.js
var require_PTTL = __commonJS((exports) => {
  var transformArguments = function(key) {
    return ["PTTL", key];
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.transformArguments = exports.IS_READ_ONLY = exports.FIRST_KEY_INDEX = undefined;
  exports.FIRST_KEY_INDEX = 1;
  exports.IS_READ_ONLY = true;
  exports.transformArguments = transformArguments;
});

// node_modules/@redis/client/dist/lib/commands/PUBLISH.js
var require_PUBLISH = __commonJS((exports) => {
  var transformArguments = function(channel, message2) {
    return ["PUBLISH", channel, message2];
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.transformArguments = exports.IS_READ_ONLY = undefined;
  exports.IS_READ_ONLY = true;
  exports.transformArguments = transformArguments;
});

// node_modules/@redis/client/dist/lib/commands/RENAME.js
var require_RENAME = __commonJS((exports) => {
  var transformArguments = function(key, newKey) {
    return ["RENAME", key, newKey];
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.transformArguments = exports.FIRST_KEY_INDEX = undefined;
  exports.FIRST_KEY_INDEX = 1;
  exports.transformArguments = transformArguments;
});

// node_modules/@redis/client/dist/lib/commands/RENAMENX.js
var require_RENAMENX = __commonJS((exports) => {
  var transformArguments = function(key, newKey) {
    return ["RENAMENX", key, newKey];
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.transformReply = exports.transformArguments = exports.FIRST_KEY_INDEX = undefined;
  exports.FIRST_KEY_INDEX = 1;
  exports.transformArguments = transformArguments;
  var generic_transformers_1 = require_generic_transformers();
  Object.defineProperty(exports, "transformReply", { enumerable: true, get: function() {
    return generic_transformers_1.transformBooleanReply;
  } });
});

// node_modules/@redis/client/dist/lib/commands/RPOP_COUNT.js
var require_RPOP_COUNT = __commonJS((exports) => {
  var transformArguments = function(key, count) {
    return ["RPOP", key, count.toString()];
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.transformArguments = exports.FIRST_KEY_INDEX = undefined;
  exports.FIRST_KEY_INDEX = 1;
  exports.transformArguments = transformArguments;
});

// node_modules/@redis/client/dist/lib/commands/RPOP.js
var require_RPOP = __commonJS((exports) => {
  var transformArguments = function(key) {
    return ["RPOP", key];
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.transformArguments = exports.FIRST_KEY_INDEX = undefined;
  exports.FIRST_KEY_INDEX = 1;
  exports.transformArguments = transformArguments;
});

// node_modules/@redis/client/dist/lib/commands/RPOPLPUSH.js
var require_RPOPLPUSH = __commonJS((exports) => {
  var transformArguments = function(source, destination) {
    return ["RPOPLPUSH", source, destination];
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.transformArguments = exports.FIRST_KEY_INDEX = undefined;
  exports.FIRST_KEY_INDEX = 1;
  exports.transformArguments = transformArguments;
});

// node_modules/@redis/client/dist/lib/commands/RPUSH.js
var require_RPUSH = __commonJS((exports) => {
  var transformArguments = function(key, element) {
    return (0, generic_transformers_1.pushVerdictArguments)(["RPUSH", key], element);
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.transformArguments = exports.FIRST_KEY_INDEX = undefined;
  var generic_transformers_1 = require_generic_transformers();
  exports.FIRST_KEY_INDEX = 1;
  exports.transformArguments = transformArguments;
});

// node_modules/@redis/client/dist/lib/commands/RPUSHX.js
var require_RPUSHX = __commonJS((exports) => {
  var transformArguments = function(key, element) {
    return (0, generic_transformers_1.pushVerdictArguments)(["RPUSHX", key], element);
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.transformArguments = exports.FIRST_KEY_INDEX = undefined;
  var generic_transformers_1 = require_generic_transformers();
  exports.FIRST_KEY_INDEX = 1;
  exports.transformArguments = transformArguments;
});

// node_modules/@redis/client/dist/lib/commands/SADD.js
var require_SADD = __commonJS((exports) => {
  var transformArguments = function(key, members) {
    return (0, generic_transformers_1.pushVerdictArguments)(["SADD", key], members);
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.transformArguments = exports.FIRST_KEY_INDEX = undefined;
  var generic_transformers_1 = require_generic_transformers();
  exports.FIRST_KEY_INDEX = 1;
  exports.transformArguments = transformArguments;
});

// node_modules/@redis/client/dist/lib/commands/SCARD.js
var require_SCARD = __commonJS((exports) => {
  var transformArguments = function(key) {
    return ["SCARD", key];
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.transformArguments = exports.FIRST_KEY_INDEX = undefined;
  exports.FIRST_KEY_INDEX = 1;
  exports.transformArguments = transformArguments;
});

// node_modules/@redis/client/dist/lib/commands/SDIFF.js
var require_SDIFF = __commonJS((exports) => {
  var transformArguments = function(keys) {
    return (0, generic_transformers_1.pushVerdictArguments)(["SDIFF"], keys);
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.transformArguments = exports.IS_READ_ONLY = exports.FIRST_KEY_INDEX = undefined;
  var generic_transformers_1 = require_generic_transformers();
  exports.FIRST_KEY_INDEX = 1;
  exports.IS_READ_ONLY = true;
  exports.transformArguments = transformArguments;
});

// node_modules/@redis/client/dist/lib/commands/SDIFFSTORE.js
var require_SDIFFSTORE = __commonJS((exports) => {
  var transformArguments = function(destination, keys) {
    return (0, generic_transformers_1.pushVerdictArguments)(["SDIFFSTORE", destination], keys);
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.transformArguments = exports.FIRST_KEY_INDEX = undefined;
  var generic_transformers_1 = require_generic_transformers();
  exports.FIRST_KEY_INDEX = 1;
  exports.transformArguments = transformArguments;
});

// node_modules/@redis/client/dist/lib/commands/SET.js
var require_SET = __commonJS((exports) => {
  var transformArguments = function(key, value, options) {
    const args = [
      "SET",
      key,
      typeof value === "number" ? value.toString() : value
    ];
    if (options?.EX !== undefined) {
      args.push("EX", options.EX.toString());
    } else if (options?.PX !== undefined) {
      args.push("PX", options.PX.toString());
    } else if (options?.EXAT !== undefined) {
      args.push("EXAT", options.EXAT.toString());
    } else if (options?.PXAT !== undefined) {
      args.push("PXAT", options.PXAT.toString());
    } else if (options?.KEEPTTL) {
      args.push("KEEPTTL");
    }
    if (options?.NX) {
      args.push("NX");
    } else if (options?.XX) {
      args.push("XX");
    }
    if (options?.GET) {
      args.push("GET");
    }
    return args;
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.transformArguments = exports.FIRST_KEY_INDEX = undefined;
  exports.FIRST_KEY_INDEX = 1;
  exports.transformArguments = transformArguments;
});

// node_modules/@redis/client/dist/lib/commands/SETBIT.js
var require_SETBIT = __commonJS((exports) => {
  var transformArguments = function(key, offset, value) {
    return ["SETBIT", key, offset.toString(), value.toString()];
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.transformArguments = exports.FIRST_KEY_INDEX = undefined;
  exports.FIRST_KEY_INDEX = 1;
  exports.transformArguments = transformArguments;
});

// node_modules/@redis/client/dist/lib/commands/SETEX.js
var require_SETEX = __commonJS((exports) => {
  var transformArguments = function(key, seconds, value) {
    return [
      "SETEX",
      key,
      seconds.toString(),
      value
    ];
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.transformArguments = exports.FIRST_KEY_INDEX = undefined;
  exports.FIRST_KEY_INDEX = 1;
  exports.transformArguments = transformArguments;
});

// node_modules/@redis/client/dist/lib/commands/SETNX.js
var require_SETNX = __commonJS((exports) => {
  var transformArguments = function(key, value) {
    return ["SETNX", key, value];
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.transformReply = exports.transformArguments = exports.FIRST_KEY_INDEX = undefined;
  exports.FIRST_KEY_INDEX = 1;
  exports.transformArguments = transformArguments;
  var generic_transformers_1 = require_generic_transformers();
  Object.defineProperty(exports, "transformReply", { enumerable: true, get: function() {
    return generic_transformers_1.transformBooleanReply;
  } });
});

// node_modules/@redis/client/dist/lib/commands/SETRANGE.js
var require_SETRANGE = __commonJS((exports) => {
  var transformArguments = function(key, offset, value) {
    return ["SETRANGE", key, offset.toString(), value];
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.transformArguments = exports.FIRST_KEY_INDEX = undefined;
  exports.FIRST_KEY_INDEX = 1;
  exports.transformArguments = transformArguments;
});

// node_modules/@redis/client/dist/lib/commands/SINTER.js
var require_SINTER = __commonJS((exports) => {
  var transformArguments = function(keys) {
    return (0, generic_transformers_1.pushVerdictArguments)(["SINTER"], keys);
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.transformArguments = exports.IS_READ_ONLY = exports.FIRST_KEY_INDEX = undefined;
  var generic_transformers_1 = require_generic_transformers();
  exports.FIRST_KEY_INDEX = 1;
  exports.IS_READ_ONLY = true;
  exports.transformArguments = transformArguments;
});

// node_modules/@redis/client/dist/lib/commands/SINTERCARD.js
var require_SINTERCARD = __commonJS((exports) => {
  var transformArguments = function(keys, limit) {
    const args = (0, generic_transformers_1.pushVerdictArgument)(["SINTERCARD"], keys);
    if (limit) {
      args.push("LIMIT", limit.toString());
    }
    return args;
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.transformArguments = exports.IS_READ_ONLY = exports.FIRST_KEY_INDEX = undefined;
  var generic_transformers_1 = require_generic_transformers();
  exports.FIRST_KEY_INDEX = 2;
  exports.IS_READ_ONLY = true;
  exports.transformArguments = transformArguments;
});

// node_modules/@redis/client/dist/lib/commands/SINTERSTORE.js
var require_SINTERSTORE = __commonJS((exports) => {
  var transformArguments = function(destination, keys) {
    return (0, generic_transformers_1.pushVerdictArguments)(["SINTERSTORE", destination], keys);
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.transformArguments = exports.FIRST_KEY_INDEX = undefined;
  var generic_transformers_1 = require_generic_transformers();
  exports.FIRST_KEY_INDEX = 1;
  exports.transformArguments = transformArguments;
});

// node_modules/@redis/client/dist/lib/commands/SISMEMBER.js
var require_SISMEMBER = __commonJS((exports) => {
  var transformArguments = function(key, member) {
    return ["SISMEMBER", key, member];
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.transformReply = exports.transformArguments = exports.FIRST_KEY_INDEX = undefined;
  exports.FIRST_KEY_INDEX = 1;
  exports.transformArguments = transformArguments;
  var generic_transformers_1 = require_generic_transformers();
  Object.defineProperty(exports, "transformReply", { enumerable: true, get: function() {
    return generic_transformers_1.transformBooleanReply;
  } });
});

// node_modules/@redis/client/dist/lib/commands/SMEMBERS.js
var require_SMEMBERS = __commonJS((exports) => {
  var transformArguments = function(key) {
    return ["SMEMBERS", key];
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.transformArguments = exports.FIRST_KEY_INDEX = undefined;
  exports.FIRST_KEY_INDEX = 1;
  exports.transformArguments = transformArguments;
});

// node_modules/@redis/client/dist/lib/commands/SMISMEMBER.js
var require_SMISMEMBER = __commonJS((exports) => {
  var transformArguments = function(key, members) {
    return ["SMISMEMBER", key, ...members];
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.transformReply = exports.transformArguments = exports.FIRST_KEY_INDEX = undefined;
  exports.FIRST_KEY_INDEX = 1;
  exports.transformArguments = transformArguments;
  var generic_transformers_1 = require_generic_transformers();
  Object.defineProperty(exports, "transformReply", { enumerable: true, get: function() {
    return generic_transformers_1.transformBooleanArrayReply;
  } });
});

// node_modules/@redis/client/dist/lib/commands/SMOVE.js
var require_SMOVE = __commonJS((exports) => {
  var transformArguments = function(source, destination, member) {
    return ["SMOVE", source, destination, member];
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.transformReply = exports.transformArguments = exports.FIRST_KEY_INDEX = undefined;
  exports.FIRST_KEY_INDEX = 1;
  exports.transformArguments = transformArguments;
  var generic_transformers_1 = require_generic_transformers();
  Object.defineProperty(exports, "transformReply", { enumerable: true, get: function() {
    return generic_transformers_1.transformBooleanReply;
  } });
});

// node_modules/@redis/client/dist/lib/commands/SORT_RO.js
var require_SORT_RO = __commonJS((exports) => {
  var transformArguments = function(key, options) {
    return (0, generic_transformers_1.pushSortArguments)(["SORT_RO", key], options);
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.transformArguments = exports.IS_READ_ONLY = exports.FIRST_KEY_INDEX = undefined;
  var generic_transformers_1 = require_generic_transformers();
  exports.FIRST_KEY_INDEX = 1;
  exports.IS_READ_ONLY = true;
  exports.transformArguments = transformArguments;
});

// node_modules/@redis/client/dist/lib/commands/SORT.js
var require_SORT = __commonJS((exports) => {
  var transformArguments = function(key, options) {
    return (0, generic_transformers_1.pushSortArguments)(["SORT", key], options);
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.transformArguments = exports.FIRST_KEY_INDEX = undefined;
  var generic_transformers_1 = require_generic_transformers();
  exports.FIRST_KEY_INDEX = 1;
  exports.transformArguments = transformArguments;
});

// node_modules/@redis/client/dist/lib/commands/SORT_STORE.js
var require_SORT_STORE = __commonJS((exports) => {
  var transformArguments = function(source, destination, options) {
    const args = (0, SORT_1.transformArguments)(source, options);
    args.push("STORE", destination);
    return args;
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.transformArguments = exports.FIRST_KEY_INDEX = undefined;
  var SORT_1 = require_SORT();
  exports.FIRST_KEY_INDEX = 1;
  exports.transformArguments = transformArguments;
});

// node_modules/@redis/client/dist/lib/commands/SPOP.js
var require_SPOP = __commonJS((exports) => {
  var transformArguments = function(key, count) {
    const args = ["SPOP", key];
    if (typeof count === "number") {
      args.push(count.toString());
    }
    return args;
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.transformArguments = exports.FIRST_KEY_INDEX = undefined;
  exports.FIRST_KEY_INDEX = 1;
  exports.transformArguments = transformArguments;
});

// node_modules/@redis/client/dist/lib/commands/SPUBLISH.js
var require_SPUBLISH = __commonJS((exports) => {
  var transformArguments = function(channel, message2) {
    return ["SPUBLISH", channel, message2];
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.transformArguments = exports.FIRST_KEY_INDEX = exports.IS_READ_ONLY = undefined;
  exports.IS_READ_ONLY = true;
  exports.FIRST_KEY_INDEX = 1;
  exports.transformArguments = transformArguments;
});

// node_modules/@redis/client/dist/lib/commands/SRANDMEMBER.js
var require_SRANDMEMBER = __commonJS((exports) => {
  var transformArguments = function(key) {
    return ["SRANDMEMBER", key];
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.transformArguments = exports.FIRST_KEY_INDEX = undefined;
  exports.FIRST_KEY_INDEX = 1;
  exports.transformArguments = transformArguments;
});

// node_modules/@redis/client/dist/lib/commands/SRANDMEMBER_COUNT.js
var require_SRANDMEMBER_COUNT = __commonJS((exports) => {
  var transformArguments = function(key, count) {
    return [
      ...(0, SRANDMEMBER_1.transformArguments)(key),
      count.toString()
    ];
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.transformArguments = exports.FIRST_KEY_INDEX = undefined;
  var SRANDMEMBER_1 = require_SRANDMEMBER();
  var SRANDMEMBER_2 = require_SRANDMEMBER();
  Object.defineProperty(exports, "FIRST_KEY_INDEX", { enumerable: true, get: function() {
    return SRANDMEMBER_2.FIRST_KEY_INDEX;
  } });
  exports.transformArguments = transformArguments;
});

// node_modules/@redis/client/dist/lib/commands/SREM.js
var require_SREM = __commonJS((exports) => {
  var transformArguments = function(key, members) {
    return (0, generic_transformers_1.pushVerdictArguments)(["SREM", key], members);
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.transformArguments = exports.FIRST_KEY_INDEX = undefined;
  var generic_transformers_1 = require_generic_transformers();
  exports.FIRST_KEY_INDEX = 1;
  exports.transformArguments = transformArguments;
});

// node_modules/@redis/client/dist/lib/commands/SSCAN.js
var require_SSCAN = __commonJS((exports) => {
  var transformArguments = function(key, cursor, options) {
    return (0, generic_transformers_1.pushScanArguments)([
      "SSCAN",
      key
    ], cursor, options);
  };
  var transformReply = function([cursor, members]) {
    return {
      cursor: Number(cursor),
      members
    };
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.transformReply = exports.transformArguments = exports.IS_READ_ONLY = exports.FIRST_KEY_INDEX = undefined;
  var generic_transformers_1 = require_generic_transformers();
  exports.FIRST_KEY_INDEX = 1;
  exports.IS_READ_ONLY = true;
  exports.transformArguments = transformArguments;
  exports.transformReply = transformReply;
});

// node_modules/@redis/client/dist/lib/commands/STRLEN.js
var require_STRLEN = __commonJS((exports) => {
  var transformArguments = function(key) {
    return ["STRLEN", key];
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.transformArguments = exports.IS_READ_ONLY = exports.FIRST_KEY_INDEX = undefined;
  exports.FIRST_KEY_INDEX = 1;
  exports.IS_READ_ONLY = true;
  exports.transformArguments = transformArguments;
});

// node_modules/@redis/client/dist/lib/commands/SUNION.js
var require_SUNION = __commonJS((exports) => {
  var transformArguments = function(keys) {
    return (0, generic_transformers_1.pushVerdictArguments)(["SUNION"], keys);
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.transformArguments = exports.IS_READ_ONLY = exports.FIRST_KEY_INDEX = undefined;
  var generic_transformers_1 = require_generic_transformers();
  exports.FIRST_KEY_INDEX = 1;
  exports.IS_READ_ONLY = true;
  exports.transformArguments = transformArguments;
});

// node_modules/@redis/client/dist/lib/commands/SUNIONSTORE.js
var require_SUNIONSTORE = __commonJS((exports) => {
  var transformArguments = function(destination, keys) {
    return (0, generic_transformers_1.pushVerdictArguments)(["SUNIONSTORE", destination], keys);
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.transformArguments = exports.FIRST_KEY_INDEX = undefined;
  var generic_transformers_1 = require_generic_transformers();
  exports.FIRST_KEY_INDEX = 1;
  exports.transformArguments = transformArguments;
});

// node_modules/@redis/client/dist/lib/commands/TOUCH.js
var require_TOUCH = __commonJS((exports) => {
  var transformArguments = function(key) {
    return (0, generic_transformers_1.pushVerdictArguments)(["TOUCH"], key);
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.transformArguments = exports.FIRST_KEY_INDEX = undefined;
  var generic_transformers_1 = require_generic_transformers();
  exports.FIRST_KEY_INDEX = 1;
  exports.transformArguments = transformArguments;
});

// node_modules/@redis/client/dist/lib/commands/TTL.js
var require_TTL = __commonJS((exports) => {
  var transformArguments = function(key) {
    return ["TTL", key];
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.transformArguments = exports.IS_READ_ONLY = exports.FIRST_KEY_INDEX = undefined;
  exports.FIRST_KEY_INDEX = 1;
  exports.IS_READ_ONLY = true;
  exports.transformArguments = transformArguments;
});

// node_modules/@redis/client/dist/lib/commands/TYPE.js
var require_TYPE = __commonJS((exports) => {
  var transformArguments = function(key) {
    return ["TYPE", key];
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.transformArguments = exports.IS_READ_ONLY = exports.FIRST_KEY_INDEX = undefined;
  exports.FIRST_KEY_INDEX = 1;
  exports.IS_READ_ONLY = true;
  exports.transformArguments = transformArguments;
});

// node_modules/@redis/client/dist/lib/commands/UNLINK.js
var require_UNLINK = __commonJS((exports) => {
  var transformArguments = function(key) {
    return (0, generic_transformers_1.pushVerdictArguments)(["UNLINK"], key);
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.transformArguments = exports.FIRST_KEY_INDEX = undefined;
  var generic_transformers_1 = require_generic_transformers();
  exports.FIRST_KEY_INDEX = 1;
  exports.transformArguments = transformArguments;
});

// node_modules/@redis/client/dist/lib/commands/WATCH.js
var require_WATCH = __commonJS((exports) => {
  var transformArguments = function(key) {
    return (0, generic_transformers_1.pushVerdictArguments)(["WATCH"], key);
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.transformArguments = exports.FIRST_KEY_INDEX = undefined;
  var generic_transformers_1 = require_generic_transformers();
  exports.FIRST_KEY_INDEX = 1;
  exports.transformArguments = transformArguments;
});

// node_modules/@redis/client/dist/lib/commands/XACK.js
var require_XACK = __commonJS((exports) => {
  var transformArguments = function(key, group, id) {
    return (0, generic_transformers_1.pushVerdictArguments)(["XACK", key, group], id);
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.transformArguments = exports.FIRST_KEY_INDEX = undefined;
  var generic_transformers_1 = require_generic_transformers();
  exports.FIRST_KEY_INDEX = 1;
  exports.transformArguments = transformArguments;
});

// node_modules/@redis/client/dist/lib/commands/XADD.js
var require_XADD = __commonJS((exports) => {
  var transformArguments = function(key, id, message2, options) {
    const args = ["XADD", key];
    if (options?.NOMKSTREAM) {
      args.push("NOMKSTREAM");
    }
    if (options?.TRIM) {
      if (options.TRIM.strategy) {
        args.push(options.TRIM.strategy);
      }
      if (options.TRIM.strategyModifier) {
        args.push(options.TRIM.strategyModifier);
      }
      args.push(options.TRIM.threshold.toString());
      if (options.TRIM.limit) {
        args.push("LIMIT", options.TRIM.limit.toString());
      }
    }
    args.push(id);
    for (const [key2, value] of Object.entries(message2)) {
      args.push(key2, value);
    }
    return args;
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.transformArguments = exports.FIRST_KEY_INDEX = undefined;
  exports.FIRST_KEY_INDEX = 1;
  exports.transformArguments = transformArguments;
});

// node_modules/@redis/client/dist/lib/commands/XAUTOCLAIM.js
var require_XAUTOCLAIM = __commonJS((exports) => {
  var transformArguments = function(key, group, consumer, minIdleTime, start, options) {
    const args = ["XAUTOCLAIM", key, group, consumer, minIdleTime.toString(), start];
    if (options?.COUNT) {
      args.push("COUNT", options.COUNT.toString());
    }
    return args;
  };
  var transformReply = function(reply) {
    return {
      nextId: reply[0],
      messages: (0, generic_transformers_1.transformStreamMessagesReply)(reply[1])
    };
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.transformReply = exports.transformArguments = exports.FIRST_KEY_INDEX = undefined;
  var generic_transformers_1 = require_generic_transformers();
  exports.FIRST_KEY_INDEX = 1;
  exports.transformArguments = transformArguments;
  exports.transformReply = transformReply;
});

// node_modules/@redis/client/dist/lib/commands/XAUTOCLAIM_JUSTID.js
var require_XAUTOCLAIM_JUSTID = __commonJS((exports) => {
  var transformArguments = function(...args) {
    return [
      ...(0, XAUTOCLAIM_1.transformArguments)(...args),
      "JUSTID"
    ];
  };
  var transformReply = function(reply) {
    return {
      nextId: reply[0],
      messages: reply[1]
    };
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.transformReply = exports.transformArguments = exports.FIRST_KEY_INDEX = undefined;
  var XAUTOCLAIM_1 = require_XAUTOCLAIM();
  var XAUTOCLAIM_2 = require_XAUTOCLAIM();
  Object.defineProperty(exports, "FIRST_KEY_INDEX", { enumerable: true, get: function() {
    return XAUTOCLAIM_2.FIRST_KEY_INDEX;
  } });
  exports.transformArguments = transformArguments;
  exports.transformReply = transformReply;
});

// node_modules/@redis/client/dist/lib/commands/XCLAIM.js
var require_XCLAIM = __commonJS((exports) => {
  var transformArguments = function(key, group, consumer, minIdleTime, id, options) {
    const args = (0, generic_transformers_1.pushVerdictArguments)(["XCLAIM", key, group, consumer, minIdleTime.toString()], id);
    if (options?.IDLE) {
      args.push("IDLE", options.IDLE.toString());
    }
    if (options?.TIME) {
      args.push("TIME", (typeof options.TIME === "number" ? options.TIME : options.TIME.getTime()).toString());
    }
    if (options?.RETRYCOUNT) {
      args.push("RETRYCOUNT", options.RETRYCOUNT.toString());
    }
    if (options?.FORCE) {
      args.push("FORCE");
    }
    return args;
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.transformReply = exports.transformArguments = exports.FIRST_KEY_INDEX = undefined;
  var generic_transformers_1 = require_generic_transformers();
  exports.FIRST_KEY_INDEX = 1;
  exports.transformArguments = transformArguments;
  var generic_transformers_2 = require_generic_transformers();
  Object.defineProperty(exports, "transformReply", { enumerable: true, get: function() {
    return generic_transformers_2.transformStreamMessagesReply;
  } });
});

// node_modules/@redis/client/dist/lib/commands/XCLAIM_JUSTID.js
var require_XCLAIM_JUSTID = __commonJS((exports) => {
  var transformArguments = function(...args) {
    return [
      ...(0, XCLAIM_1.transformArguments)(...args),
      "JUSTID"
    ];
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.transformArguments = exports.FIRST_KEY_INDEX = undefined;
  var XCLAIM_1 = require_XCLAIM();
  var XCLAIM_2 = require_XCLAIM();
  Object.defineProperty(exports, "FIRST_KEY_INDEX", { enumerable: true, get: function() {
    return XCLAIM_2.FIRST_KEY_INDEX;
  } });
  exports.transformArguments = transformArguments;
});

// node_modules/@redis/client/dist/lib/commands/XDEL.js
var require_XDEL = __commonJS((exports) => {
  var transformArguments = function(key, id) {
    return (0, generic_transformers_1.pushVerdictArguments)(["XDEL", key], id);
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.transformArguments = exports.FIRST_KEY_INDEX = undefined;
  var generic_transformers_1 = require_generic_transformers();
  exports.FIRST_KEY_INDEX = 1;
  exports.transformArguments = transformArguments;
});

// node_modules/@redis/client/dist/lib/commands/XGROUP_CREATE.js
var require_XGROUP_CREATE = __commonJS((exports) => {
  var transformArguments = function(key, group, id, options) {
    const args = ["XGROUP", "CREATE", key, group, id];
    if (options?.MKSTREAM) {
      args.push("MKSTREAM");
    }
    return args;
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.transformArguments = exports.FIRST_KEY_INDEX = undefined;
  exports.FIRST_KEY_INDEX = 2;
  exports.transformArguments = transformArguments;
});

// node_modules/@redis/client/dist/lib/commands/XGROUP_CREATECONSUMER.js
var require_XGROUP_CREATECONSUMER = __commonJS((exports) => {
  var transformArguments = function(key, group, consumer) {
    return ["XGROUP", "CREATECONSUMER", key, group, consumer];
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.transformReply = exports.transformArguments = exports.FIRST_KEY_INDEX = undefined;
  exports.FIRST_KEY_INDEX = 2;
  exports.transformArguments = transformArguments;
  var generic_transformers_1 = require_generic_transformers();
  Object.defineProperty(exports, "transformReply", { enumerable: true, get: function() {
    return generic_transformers_1.transformBooleanReply;
  } });
});

// node_modules/@redis/client/dist/lib/commands/XGROUP_DELCONSUMER.js
var require_XGROUP_DELCONSUMER = __commonJS((exports) => {
  var transformArguments = function(key, group, consumer) {
    return ["XGROUP", "DELCONSUMER", key, group, consumer];
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.transformArguments = exports.FIRST_KEY_INDEX = undefined;
  exports.FIRST_KEY_INDEX = 2;
  exports.transformArguments = transformArguments;
});

// node_modules/@redis/client/dist/lib/commands/XGROUP_DESTROY.js
var require_XGROUP_DESTROY = __commonJS((exports) => {
  var transformArguments = function(key, group) {
    return ["XGROUP", "DESTROY", key, group];
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.transformReply = exports.transformArguments = exports.FIRST_KEY_INDEX = undefined;
  exports.FIRST_KEY_INDEX = 2;
  exports.transformArguments = transformArguments;
  var generic_transformers_1 = require_generic_transformers();
  Object.defineProperty(exports, "transformReply", { enumerable: true, get: function() {
    return generic_transformers_1.transformBooleanReply;
  } });
});

// node_modules/@redis/client/dist/lib/commands/XGROUP_SETID.js
var require_XGROUP_SETID = __commonJS((exports) => {
  var transformArguments = function(key, group, id) {
    return ["XGROUP", "SETID", key, group, id];
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.transformArguments = exports.FIRST_KEY_INDEX = undefined;
  exports.FIRST_KEY_INDEX = 2;
  exports.transformArguments = transformArguments;
});

// node_modules/@redis/client/dist/lib/commands/XINFO_CONSUMERS.js
var require_XINFO_CONSUMERS = __commonJS((exports) => {
  var transformArguments = function(key, group) {
    return ["XINFO", "CONSUMERS", key, group];
  };
  var transformReply = function(rawReply) {
    return rawReply.map((consumer) => ({
      name: consumer[1],
      pending: consumer[3],
      idle: consumer[5],
      inactive: consumer[7]
    }));
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.transformReply = exports.transformArguments = exports.IS_READ_ONLY = exports.FIRST_KEY_INDEX = undefined;
  exports.FIRST_KEY_INDEX = 2;
  exports.IS_READ_ONLY = true;
  exports.transformArguments = transformArguments;
  exports.transformReply = transformReply;
});

// node_modules/@redis/client/dist/lib/commands/XINFO_GROUPS.js
var require_XINFO_GROUPS = __commonJS((exports) => {
  var transformArguments = function(key) {
    return ["XINFO", "GROUPS", key];
  };
  var transformReply = function(rawReply) {
    return rawReply.map((group) => ({
      name: group[1],
      consumers: group[3],
      pending: group[5],
      lastDeliveredId: group[7]
    }));
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.transformReply = exports.transformArguments = exports.IS_READ_ONLY = exports.FIRST_KEY_INDEX = undefined;
  exports.FIRST_KEY_INDEX = 2;
  exports.IS_READ_ONLY = true;
  exports.transformArguments = transformArguments;
  exports.transformReply = transformReply;
});

// node_modules/@redis/client/dist/lib/commands/XINFO_STREAM.js
var require_XINFO_STREAM = __commonJS((exports) => {
  var transformArguments = function(key) {
    return ["XINFO", "STREAM", key];
  };
  var transformReply = function(rawReply) {
    const parsedReply = {};
    for (let i = 0;i < rawReply.length; i += 2) {
      switch (rawReply[i]) {
        case "length":
          parsedReply.length = rawReply[i + 1];
          break;
        case "radix-tree-keys":
          parsedReply.radixTreeKeys = rawReply[i + 1];
          break;
        case "radix-tree-nodes":
          parsedReply.radixTreeNodes = rawReply[i + 1];
          break;
        case "groups":
          parsedReply.groups = rawReply[i + 1];
          break;
        case "last-generated-id":
          parsedReply.lastGeneratedId = rawReply[i + 1];
          break;
        case "first-entry":
          parsedReply.firstEntry = rawReply[i + 1] ? {
            id: rawReply[i + 1][0],
            message: (0, generic_transformers_1.transformTuplesReply)(rawReply[i + 1][1])
          } : null;
          break;
        case "last-entry":
          parsedReply.lastEntry = rawReply[i + 1] ? {
            id: rawReply[i + 1][0],
            message: (0, generic_transformers_1.transformTuplesReply)(rawReply[i + 1][1])
          } : null;
          break;
      }
    }
    return parsedReply;
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.transformReply = exports.transformArguments = exports.IS_READ_ONLY = exports.FIRST_KEY_INDEX = undefined;
  var generic_transformers_1 = require_generic_transformers();
  exports.FIRST_KEY_INDEX = 2;
  exports.IS_READ_ONLY = true;
  exports.transformArguments = transformArguments;
  exports.transformReply = transformReply;
});

// node_modules/@redis/client/dist/lib/commands/XLEN.js
var require_XLEN = __commonJS((exports) => {
  var transformArguments = function(key) {
    return ["XLEN", key];
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.transformArguments = exports.IS_READ_ONLY = exports.FIRST_KEY_INDEX = undefined;
  exports.FIRST_KEY_INDEX = 1;
  exports.IS_READ_ONLY = true;
  exports.transformArguments = transformArguments;
});

// node_modules/@redis/client/dist/lib/commands/XPENDING_RANGE.js
var require_XPENDING_RANGE = __commonJS((exports) => {
  var transformArguments = function(key, group, start, end, count, options) {
    const args = ["XPENDING", key, group];
    if (options?.IDLE) {
      args.push("IDLE", options.IDLE.toString());
    }
    args.push(start, end, count.toString());
    if (options?.consumer) {
      args.push(options.consumer);
    }
    return args;
  };
  var transformReply = function(reply) {
    return reply.map(([id, owner, millisecondsSinceLastDelivery, deliveriesCounter]) => ({
      id,
      owner,
      millisecondsSinceLastDelivery,
      deliveriesCounter
    }));
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.transformReply = exports.transformArguments = exports.IS_READ_ONLY = exports.FIRST_KEY_INDEX = undefined;
  exports.FIRST_KEY_INDEX = 1;
  exports.IS_READ_ONLY = true;
  exports.transformArguments = transformArguments;
  exports.transformReply = transformReply;
});

// node_modules/@redis/client/dist/lib/commands/XPENDING.js
var require_XPENDING = __commonJS((exports) => {
  var transformArguments = function(key, group) {
    return ["XPENDING", key, group];
  };
  var transformReply = function(reply) {
    return {
      pending: reply[0],
      firstId: reply[1],
      lastId: reply[2],
      consumers: reply[3] === null ? null : reply[3].map(([name, deliveriesCounter]) => ({
        name,
        deliveriesCounter: Number(deliveriesCounter)
      }))
    };
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.transformReply = exports.transformArguments = exports.IS_READ_ONLY = exports.FIRST_KEY_INDEX = undefined;
  exports.FIRST_KEY_INDEX = 1;
  exports.IS_READ_ONLY = true;
  exports.transformArguments = transformArguments;
  exports.transformReply = transformReply;
});

// node_modules/@redis/client/dist/lib/commands/XRANGE.js
var require_XRANGE = __commonJS((exports) => {
  var transformArguments = function(key, start, end, options) {
    const args = ["XRANGE", key, start, end];
    if (options?.COUNT) {
      args.push("COUNT", options.COUNT.toString());
    }
    return args;
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.transformReply = exports.transformArguments = exports.IS_READ_ONLY = exports.FIRST_KEY_INDEX = undefined;
  exports.FIRST_KEY_INDEX = 1;
  exports.IS_READ_ONLY = true;
  exports.transformArguments = transformArguments;
  var generic_transformers_1 = require_generic_transformers();
  Object.defineProperty(exports, "transformReply", { enumerable: true, get: function() {
    return generic_transformers_1.transformStreamMessagesReply;
  } });
});

// node_modules/@redis/client/dist/lib/commands/XREAD.js
var require_XREAD = __commonJS((exports) => {
  var transformArguments = function(streams, options) {
    const args = ["XREAD"];
    if (options?.COUNT) {
      args.push("COUNT", options.COUNT.toString());
    }
    if (typeof options?.BLOCK === "number") {
      args.push("BLOCK", options.BLOCK.toString());
    }
    args.push("STREAMS");
    const streamsArray = Array.isArray(streams) ? streams : [streams], argsLength = args.length;
    for (let i = 0;i < streamsArray.length; i++) {
      const stream = streamsArray[i];
      args[argsLength + i] = stream.key;
      args[argsLength + streamsArray.length + i] = stream.id;
    }
    return args;
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.transformReply = exports.transformArguments = exports.IS_READ_ONLY = exports.FIRST_KEY_INDEX = undefined;
  var FIRST_KEY_INDEX = (streams) => {
    return Array.isArray(streams) ? streams[0].key : streams.key;
  };
  exports.FIRST_KEY_INDEX = FIRST_KEY_INDEX;
  exports.IS_READ_ONLY = true;
  exports.transformArguments = transformArguments;
  var generic_transformers_1 = require_generic_transformers();
  Object.defineProperty(exports, "transformReply", { enumerable: true, get: function() {
    return generic_transformers_1.transformStreamsMessagesReply;
  } });
});

// node_modules/@redis/client/dist/lib/commands/XREADGROUP.js
var require_XREADGROUP = __commonJS((exports) => {
  var transformArguments = function(group, consumer, streams, options) {
    const args = ["XREADGROUP", "GROUP", group, consumer];
    if (options?.COUNT) {
      args.push("COUNT", options.COUNT.toString());
    }
    if (typeof options?.BLOCK === "number") {
      args.push("BLOCK", options.BLOCK.toString());
    }
    if (options?.NOACK) {
      args.push("NOACK");
    }
    args.push("STREAMS");
    const streamsArray = Array.isArray(streams) ? streams : [streams], argsLength = args.length;
    for (let i = 0;i < streamsArray.length; i++) {
      const stream = streamsArray[i];
      args[argsLength + i] = stream.key;
      args[argsLength + streamsArray.length + i] = stream.id;
    }
    return args;
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.transformReply = exports.transformArguments = exports.IS_READ_ONLY = exports.FIRST_KEY_INDEX = undefined;
  var FIRST_KEY_INDEX = (_group, _consumer, streams) => {
    return Array.isArray(streams) ? streams[0].key : streams.key;
  };
  exports.FIRST_KEY_INDEX = FIRST_KEY_INDEX;
  exports.IS_READ_ONLY = true;
  exports.transformArguments = transformArguments;
  var generic_transformers_1 = require_generic_transformers();
  Object.defineProperty(exports, "transformReply", { enumerable: true, get: function() {
    return generic_transformers_1.transformStreamsMessagesReply;
  } });
});

// node_modules/@redis/client/dist/lib/commands/XREVRANGE.js
var require_XREVRANGE = __commonJS((exports) => {
  var transformArguments = function(key, start, end, options) {
    const args = ["XREVRANGE", key, start, end];
    if (options?.COUNT) {
      args.push("COUNT", options.COUNT.toString());
    }
    return args;
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.transformReply = exports.transformArguments = exports.IS_READ_ONLY = exports.FIRST_KEY_INDEX = undefined;
  exports.FIRST_KEY_INDEX = 1;
  exports.IS_READ_ONLY = true;
  exports.transformArguments = transformArguments;
  var generic_transformers_1 = require_generic_transformers();
  Object.defineProperty(exports, "transformReply", { enumerable: true, get: function() {
    return generic_transformers_1.transformStreamMessagesReply;
  } });
});

// node_modules/@redis/client/dist/lib/commands/XSETID.js
var require_XSETID = __commonJS((exports) => {
  var transformArguments = function(key, lastId, options) {
    const args = ["XSETID", key, lastId];
    if (options?.ENTRIESADDED) {
      args.push("ENTRIESADDED", options.ENTRIESADDED.toString());
    }
    if (options?.MAXDELETEDID) {
      args.push("MAXDELETEDID", options.MAXDELETEDID);
    }
    return args;
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.transformArguments = exports.FIRST_KEY_INDEX = undefined;
  exports.FIRST_KEY_INDEX = 1;
  exports.transformArguments = transformArguments;
});

// node_modules/@redis/client/dist/lib/commands/XTRIM.js
var require_XTRIM = __commonJS((exports) => {
  var transformArguments = function(key, strategy, threshold, options) {
    const args = ["XTRIM", key, strategy];
    if (options?.strategyModifier) {
      args.push(options.strategyModifier);
    }
    args.push(threshold.toString());
    if (options?.LIMIT) {
      args.push("LIMIT", options.LIMIT.toString());
    }
    return args;
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.transformArguments = exports.FIRST_KEY_INDEX = undefined;
  exports.FIRST_KEY_INDEX = 1;
  exports.transformArguments = transformArguments;
});

// node_modules/@redis/client/dist/lib/commands/ZADD.js
var require_ZADD = __commonJS((exports) => {
  var transformArguments = function(key, members, options) {
    const args = ["ZADD", key];
    if (options?.NX) {
      args.push("NX");
    } else {
      if (options?.XX) {
        args.push("XX");
      }
      if (options?.GT) {
        args.push("GT");
      } else if (options?.LT) {
        args.push("LT");
      }
    }
    if (options?.CH) {
      args.push("CH");
    }
    if (options?.INCR) {
      args.push("INCR");
    }
    for (const { score, value } of Array.isArray(members) ? members : [members]) {
      args.push((0, generic_transformers_1.transformNumberInfinityArgument)(score), value);
    }
    return args;
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.transformReply = exports.transformArguments = exports.FIRST_KEY_INDEX = undefined;
  var generic_transformers_1 = require_generic_transformers();
  exports.FIRST_KEY_INDEX = 1;
  exports.transformArguments = transformArguments;
  var generic_transformers_2 = require_generic_transformers();
  Object.defineProperty(exports, "transformReply", { enumerable: true, get: function() {
    return generic_transformers_2.transformNumberInfinityReply;
  } });
});

// node_modules/@redis/client/dist/lib/commands/ZCARD.js
var require_ZCARD = __commonJS((exports) => {
  var transformArguments = function(key) {
    return ["ZCARD", key];
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.transformArguments = exports.IS_READ_ONLY = exports.FIRST_KEY_INDEX = undefined;
  exports.FIRST_KEY_INDEX = 1;
  exports.IS_READ_ONLY = true;
  exports.transformArguments = transformArguments;
});

// node_modules/@redis/client/dist/lib/commands/ZCOUNT.js
var require_ZCOUNT = __commonJS((exports) => {
  var transformArguments = function(key, min, max) {
    return [
      "ZCOUNT",
      key,
      (0, generic_transformers_1.transformStringNumberInfinityArgument)(min),
      (0, generic_transformers_1.transformStringNumberInfinityArgument)(max)
    ];
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.transformArguments = exports.IS_READ_ONLY = exports.FIRST_KEY_INDEX = undefined;
  var generic_transformers_1 = require_generic_transformers();
  exports.FIRST_KEY_INDEX = 1;
  exports.IS_READ_ONLY = true;
  exports.transformArguments = transformArguments;
});

// node_modules/@redis/client/dist/lib/commands/ZDIFF.js
var require_ZDIFF = __commonJS((exports) => {
  var transformArguments = function(keys) {
    return (0, generic_transformers_1.pushVerdictArgument)(["ZDIFF"], keys);
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.transformArguments = exports.IS_READ_ONLY = exports.FIRST_KEY_INDEX = undefined;
  var generic_transformers_1 = require_generic_transformers();
  exports.FIRST_KEY_INDEX = 2;
  exports.IS_READ_ONLY = true;
  exports.transformArguments = transformArguments;
});

// node_modules/@redis/client/dist/lib/commands/ZDIFF_WITHSCORES.js
var require_ZDIFF_WITHSCORES = __commonJS((exports) => {
  var transformArguments = function(...args) {
    return [
      ...(0, ZDIFF_1.transformArguments)(...args),
      "WITHSCORES"
    ];
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.transformReply = exports.transformArguments = exports.IS_READ_ONLY = exports.FIRST_KEY_INDEX = undefined;
  var ZDIFF_1 = require_ZDIFF();
  var ZDIFF_2 = require_ZDIFF();
  Object.defineProperty(exports, "FIRST_KEY_INDEX", { enumerable: true, get: function() {
    return ZDIFF_2.FIRST_KEY_INDEX;
  } });
  Object.defineProperty(exports, "IS_READ_ONLY", { enumerable: true, get: function() {
    return ZDIFF_2.IS_READ_ONLY;
  } });
  exports.transformArguments = transformArguments;
  var generic_transformers_1 = require_generic_transformers();
  Object.defineProperty(exports, "transformReply", { enumerable: true, get: function() {
    return generic_transformers_1.transformSortedSetWithScoresReply;
  } });
});

// node_modules/@redis/client/dist/lib/commands/ZDIFFSTORE.js
var require_ZDIFFSTORE = __commonJS((exports) => {
  var transformArguments = function(destination, keys) {
    return (0, generic_transformers_1.pushVerdictArgument)(["ZDIFFSTORE", destination], keys);
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.transformArguments = exports.FIRST_KEY_INDEX = undefined;
  var generic_transformers_1 = require_generic_transformers();
  exports.FIRST_KEY_INDEX = 1;
  exports.transformArguments = transformArguments;
});

// node_modules/@redis/client/dist/lib/commands/ZINCRBY.js
var require_ZINCRBY = __commonJS((exports) => {
  var transformArguments = function(key, increment, member) {
    return [
      "ZINCRBY",
      key,
      (0, generic_transformers_1.transformNumberInfinityArgument)(increment),
      member
    ];
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.transformReply = exports.transformArguments = exports.FIRST_KEY_INDEX = undefined;
  var generic_transformers_1 = require_generic_transformers();
  exports.FIRST_KEY_INDEX = 1;
  exports.transformArguments = transformArguments;
  var generic_transformers_2 = require_generic_transformers();
  Object.defineProperty(exports, "transformReply", { enumerable: true, get: function() {
    return generic_transformers_2.transformNumberInfinityReply;
  } });
});

// node_modules/@redis/client/dist/lib/commands/ZINTER.js
var require_ZINTER = __commonJS((exports) => {
  var transformArguments = function(keys, options) {
    const args = (0, generic_transformers_1.pushVerdictArgument)(["ZINTER"], keys);
    if (options?.WEIGHTS) {
      args.push("WEIGHTS", ...options.WEIGHTS.map((weight) => weight.toString()));
    }
    if (options?.AGGREGATE) {
      args.push("AGGREGATE", options.AGGREGATE);
    }
    return args;
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.transformArguments = exports.IS_READ_ONLY = exports.FIRST_KEY_INDEX = undefined;
  var generic_transformers_1 = require_generic_transformers();
  exports.FIRST_KEY_INDEX = 2;
  exports.IS_READ_ONLY = true;
  exports.transformArguments = transformArguments;
});

// node_modules/@redis/client/dist/lib/commands/ZINTER_WITHSCORES.js
var require_ZINTER_WITHSCORES = __commonJS((exports) => {
  var transformArguments = function(...args) {
    return [
      ...(0, ZINTER_1.transformArguments)(...args),
      "WITHSCORES"
    ];
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.transformReply = exports.transformArguments = exports.IS_READ_ONLY = exports.FIRST_KEY_INDEX = undefined;
  var ZINTER_1 = require_ZINTER();
  var ZINTER_2 = require_ZINTER();
  Object.defineProperty(exports, "FIRST_KEY_INDEX", { enumerable: true, get: function() {
    return ZINTER_2.FIRST_KEY_INDEX;
  } });
  Object.defineProperty(exports, "IS_READ_ONLY", { enumerable: true, get: function() {
    return ZINTER_2.IS_READ_ONLY;
  } });
  exports.transformArguments = transformArguments;
  var generic_transformers_1 = require_generic_transformers();
  Object.defineProperty(exports, "transformReply", { enumerable: true, get: function() {
    return generic_transformers_1.transformSortedSetWithScoresReply;
  } });
});

// node_modules/@redis/client/dist/lib/commands/ZINTERCARD.js
var require_ZINTERCARD = __commonJS((exports) => {
  var transformArguments = function(keys, limit) {
    const args = (0, generic_transformers_1.pushVerdictArgument)(["ZINTERCARD"], keys);
    if (limit) {
      args.push("LIMIT", limit.toString());
    }
    return args;
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.transformArguments = exports.IS_READ_ONLY = exports.FIRST_KEY_INDEX = undefined;
  var generic_transformers_1 = require_generic_transformers();
  exports.FIRST_KEY_INDEX = 2;
  exports.IS_READ_ONLY = true;
  exports.transformArguments = transformArguments;
});

// node_modules/@redis/client/dist/lib/commands/ZINTERSTORE.js
var require_ZINTERSTORE = __commonJS((exports) => {
  var transformArguments = function(destination, keys, options) {
    const args = (0, generic_transformers_1.pushVerdictArgument)(["ZINTERSTORE", destination], keys);
    if (options?.WEIGHTS) {
      args.push("WEIGHTS", ...options.WEIGHTS.map((weight) => weight.toString()));
    }
    if (options?.AGGREGATE) {
      args.push("AGGREGATE", options.AGGREGATE);
    }
    return args;
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.transformArguments = exports.FIRST_KEY_INDEX = undefined;
  var generic_transformers_1 = require_generic_transformers();
  exports.FIRST_KEY_INDEX = 1;
  exports.transformArguments = transformArguments;
});

// node_modules/@redis/client/dist/lib/commands/ZLEXCOUNT.js
var require_ZLEXCOUNT = __commonJS((exports) => {
  var transformArguments = function(key, min, max) {
    return [
      "ZLEXCOUNT",
      key,
      min,
      max
    ];
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.transformArguments = exports.IS_READ_ONLY = exports.FIRST_KEY_INDEX = undefined;
  exports.FIRST_KEY_INDEX = 1;
  exports.IS_READ_ONLY = true;
  exports.transformArguments = transformArguments;
});

// node_modules/@redis/client/dist/lib/commands/ZMSCORE.js
var require_ZMSCORE = __commonJS((exports) => {
  var transformArguments = function(key, member) {
    return (0, generic_transformers_1.pushVerdictArguments)(["ZMSCORE", key], member);
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.transformReply = exports.transformArguments = exports.IS_READ_ONLY = exports.FIRST_KEY_INDEX = undefined;
  var generic_transformers_1 = require_generic_transformers();
  exports.FIRST_KEY_INDEX = 1;
  exports.IS_READ_ONLY = true;
  exports.transformArguments = transformArguments;
  var generic_transformers_2 = require_generic_transformers();
  Object.defineProperty(exports, "transformReply", { enumerable: true, get: function() {
    return generic_transformers_2.transformNumberInfinityNullArrayReply;
  } });
});

// node_modules/@redis/client/dist/lib/commands/ZPOPMAX.js
var require_ZPOPMAX = __commonJS((exports) => {
  var transformArguments = function(key) {
    return [
      "ZPOPMAX",
      key
    ];
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.transformReply = exports.transformArguments = exports.FIRST_KEY_INDEX = undefined;
  exports.FIRST_KEY_INDEX = 1;
  exports.transformArguments = transformArguments;
  var generic_transformers_1 = require_generic_transformers();
  Object.defineProperty(exports, "transformReply", { enumerable: true, get: function() {
    return generic_transformers_1.transformSortedSetMemberNullReply;
  } });
});

// node_modules/@redis/client/dist/lib/commands/ZPOPMAX_COUNT.js
var require_ZPOPMAX_COUNT = __commonJS((exports) => {
  var transformArguments = function(key, count) {
    return [
      ...(0, ZPOPMAX_1.transformArguments)(key),
      count.toString()
    ];
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.transformReply = exports.transformArguments = exports.FIRST_KEY_INDEX = undefined;
  var ZPOPMAX_1 = require_ZPOPMAX();
  var ZPOPMAX_2 = require_ZPOPMAX();
  Object.defineProperty(exports, "FIRST_KEY_INDEX", { enumerable: true, get: function() {
    return ZPOPMAX_2.FIRST_KEY_INDEX;
  } });
  exports.transformArguments = transformArguments;
  var generic_transformers_1 = require_generic_transformers();
  Object.defineProperty(exports, "transformReply", { enumerable: true, get: function() {
    return generic_transformers_1.transformSortedSetWithScoresReply;
  } });
});

// node_modules/@redis/client/dist/lib/commands/ZPOPMIN.js
var require_ZPOPMIN = __commonJS((exports) => {
  var transformArguments = function(key) {
    return [
      "ZPOPMIN",
      key
    ];
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.transformReply = exports.transformArguments = exports.FIRST_KEY_INDEX = undefined;
  exports.FIRST_KEY_INDEX = 1;
  exports.transformArguments = transformArguments;
  var generic_transformers_1 = require_generic_transformers();
  Object.defineProperty(exports, "transformReply", { enumerable: true, get: function() {
    return generic_transformers_1.transformSortedSetMemberNullReply;
  } });
});

// node_modules/@redis/client/dist/lib/commands/ZPOPMIN_COUNT.js
var require_ZPOPMIN_COUNT = __commonJS((exports) => {
  var transformArguments = function(key, count) {
    return [
      ...(0, ZPOPMIN_1.transformArguments)(key),
      count.toString()
    ];
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.transformReply = exports.transformArguments = exports.FIRST_KEY_INDEX = undefined;
  var ZPOPMIN_1 = require_ZPOPMIN();
  var ZPOPMIN_2 = require_ZPOPMIN();
  Object.defineProperty(exports, "FIRST_KEY_INDEX", { enumerable: true, get: function() {
    return ZPOPMIN_2.FIRST_KEY_INDEX;
  } });
  exports.transformArguments = transformArguments;
  var generic_transformers_1 = require_generic_transformers();
  Object.defineProperty(exports, "transformReply", { enumerable: true, get: function() {
    return generic_transformers_1.transformSortedSetWithScoresReply;
  } });
});

// node_modules/@redis/client/dist/lib/commands/ZRANDMEMBER.js
var require_ZRANDMEMBER = __commonJS((exports) => {
  var transformArguments = function(key) {
    return ["ZRANDMEMBER", key];
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.transformArguments = exports.IS_READ_ONLY = exports.FIRST_KEY_INDEX = undefined;
  exports.FIRST_KEY_INDEX = 1;
  exports.IS_READ_ONLY = true;
  exports.transformArguments = transformArguments;
});

// node_modules/@redis/client/dist/lib/commands/ZRANDMEMBER_COUNT.js
var require_ZRANDMEMBER_COUNT = __commonJS((exports) => {
  var transformArguments = function(key, count) {
    return [
      ...(0, ZRANDMEMBER_1.transformArguments)(key),
      count.toString()
    ];
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.transformArguments = exports.IS_READ_ONLY = exports.FIRST_KEY_INDEX = undefined;
  var ZRANDMEMBER_1 = require_ZRANDMEMBER();
  var ZRANDMEMBER_2 = require_ZRANDMEMBER();
  Object.defineProperty(exports, "FIRST_KEY_INDEX", { enumerable: true, get: function() {
    return ZRANDMEMBER_2.FIRST_KEY_INDEX;
  } });
  Object.defineProperty(exports, "IS_READ_ONLY", { enumerable: true, get: function() {
    return ZRANDMEMBER_2.IS_READ_ONLY;
  } });
  exports.transformArguments = transformArguments;
});

// node_modules/@redis/client/dist/lib/commands/ZRANDMEMBER_COUNT_WITHSCORES.js
var require_ZRANDMEMBER_COUNT_WITHSCORES = __commonJS((exports) => {
  var transformArguments = function(...args) {
    return [
      ...(0, ZRANDMEMBER_COUNT_1.transformArguments)(...args),
      "WITHSCORES"
    ];
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.transformReply = exports.transformArguments = exports.IS_READ_ONLY = exports.FIRST_KEY_INDEX = undefined;
  var ZRANDMEMBER_COUNT_1 = require_ZRANDMEMBER_COUNT();
  var ZRANDMEMBER_COUNT_2 = require_ZRANDMEMBER_COUNT();
  Object.defineProperty(exports, "FIRST_KEY_INDEX", { enumerable: true, get: function() {
    return ZRANDMEMBER_COUNT_2.FIRST_KEY_INDEX;
  } });
  Object.defineProperty(exports, "IS_READ_ONLY", { enumerable: true, get: function() {
    return ZRANDMEMBER_COUNT_2.IS_READ_ONLY;
  } });
  exports.transformArguments = transformArguments;
  var generic_transformers_1 = require_generic_transformers();
  Object.defineProperty(exports, "transformReply", { enumerable: true, get: function() {
    return generic_transformers_1.transformSortedSetWithScoresReply;
  } });
});

// node_modules/@redis/client/dist/lib/commands/ZRANGE.js
var require_ZRANGE = __commonJS((exports) => {
  var transformArguments = function(key, min, max, options) {
    const args = [
      "ZRANGE",
      key,
      (0, generic_transformers_1.transformStringNumberInfinityArgument)(min),
      (0, generic_transformers_1.transformStringNumberInfinityArgument)(max)
    ];
    switch (options?.BY) {
      case "SCORE":
        args.push("BYSCORE");
        break;
      case "LEX":
        args.push("BYLEX");
        break;
    }
    if (options?.REV) {
      args.push("REV");
    }
    if (options?.LIMIT) {
      args.push("LIMIT", options.LIMIT.offset.toString(), options.LIMIT.count.toString());
    }
    return args;
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.transformArguments = exports.IS_READ_ONLY = exports.FIRST_KEY_INDEX = undefined;
  var generic_transformers_1 = require_generic_transformers();
  exports.FIRST_KEY_INDEX = 1;
  exports.IS_READ_ONLY = true;
  exports.transformArguments = transformArguments;
});

// node_modules/@redis/client/dist/lib/commands/ZRANGE_WITHSCORES.js
var require_ZRANGE_WITHSCORES = __commonJS((exports) => {
  var transformArguments = function(...args) {
    return [
      ...(0, ZRANGE_1.transformArguments)(...args),
      "WITHSCORES"
    ];
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.transformReply = exports.transformArguments = exports.IS_READ_ONLY = exports.FIRST_KEY_INDEX = undefined;
  var ZRANGE_1 = require_ZRANGE();
  var ZRANGE_2 = require_ZRANGE();
  Object.defineProperty(exports, "FIRST_KEY_INDEX", { enumerable: true, get: function() {
    return ZRANGE_2.FIRST_KEY_INDEX;
  } });
  Object.defineProperty(exports, "IS_READ_ONLY", { enumerable: true, get: function() {
    return ZRANGE_2.IS_READ_ONLY;
  } });
  exports.transformArguments = transformArguments;
  var generic_transformers_1 = require_generic_transformers();
  Object.defineProperty(exports, "transformReply", { enumerable: true, get: function() {
    return generic_transformers_1.transformSortedSetWithScoresReply;
  } });
});

// node_modules/@redis/client/dist/lib/commands/ZRANGEBYLEX.js
var require_ZRANGEBYLEX = __commonJS((exports) => {
  var transformArguments = function(key, min, max, options) {
    const args = [
      "ZRANGEBYLEX",
      key,
      (0, generic_transformers_1.transformStringNumberInfinityArgument)(min),
      (0, generic_transformers_1.transformStringNumberInfinityArgument)(max)
    ];
    if (options?.LIMIT) {
      args.push("LIMIT", options.LIMIT.offset.toString(), options.LIMIT.count.toString());
    }
    return args;
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.transformArguments = exports.IS_READ_ONLY = exports.FIRST_KEY_INDEX = undefined;
  var generic_transformers_1 = require_generic_transformers();
  exports.FIRST_KEY_INDEX = 1;
  exports.IS_READ_ONLY = true;
  exports.transformArguments = transformArguments;
});

// node_modules/@redis/client/dist/lib/commands/ZRANGEBYSCORE.js
var require_ZRANGEBYSCORE = __commonJS((exports) => {
  var transformArguments = function(key, min, max, options) {
    const args = [
      "ZRANGEBYSCORE",
      key,
      (0, generic_transformers_1.transformStringNumberInfinityArgument)(min),
      (0, generic_transformers_1.transformStringNumberInfinityArgument)(max)
    ];
    if (options?.LIMIT) {
      args.push("LIMIT", options.LIMIT.offset.toString(), options.LIMIT.count.toString());
    }
    return args;
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.transformArguments = exports.IS_READ_ONLY = exports.FIRST_KEY_INDEX = undefined;
  var generic_transformers_1 = require_generic_transformers();
  exports.FIRST_KEY_INDEX = 1;
  exports.IS_READ_ONLY = true;
  exports.transformArguments = transformArguments;
});

// node_modules/@redis/client/dist/lib/commands/ZRANGEBYSCORE_WITHSCORES.js
var require_ZRANGEBYSCORE_WITHSCORES = __commonJS((exports) => {
  var transformArguments = function(key, min, max, options) {
    return [
      ...(0, ZRANGEBYSCORE_1.transformArguments)(key, min, max, options),
      "WITHSCORES"
    ];
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.transformReply = exports.transformArguments = exports.IS_READ_ONLY = exports.FIRST_KEY_INDEX = undefined;
  var ZRANGEBYSCORE_1 = require_ZRANGEBYSCORE();
  var ZRANGEBYSCORE_2 = require_ZRANGEBYSCORE();
  Object.defineProperty(exports, "FIRST_KEY_INDEX", { enumerable: true, get: function() {
    return ZRANGEBYSCORE_2.FIRST_KEY_INDEX;
  } });
  Object.defineProperty(exports, "IS_READ_ONLY", { enumerable: true, get: function() {
    return ZRANGEBYSCORE_2.IS_READ_ONLY;
  } });
  exports.transformArguments = transformArguments;
  var generic_transformers_1 = require_generic_transformers();
  Object.defineProperty(exports, "transformReply", { enumerable: true, get: function() {
    return generic_transformers_1.transformSortedSetWithScoresReply;
  } });
});

// node_modules/@redis/client/dist/lib/commands/ZRANGESTORE.js
var require_ZRANGESTORE = __commonJS((exports) => {
  var transformArguments = function(dst, src, min, max, options) {
    const args = [
      "ZRANGESTORE",
      dst,
      src,
      (0, generic_transformers_1.transformStringNumberInfinityArgument)(min),
      (0, generic_transformers_1.transformStringNumberInfinityArgument)(max)
    ];
    switch (options?.BY) {
      case "SCORE":
        args.push("BYSCORE");
        break;
      case "LEX":
        args.push("BYLEX");
        break;
    }
    if (options?.REV) {
      args.push("REV");
    }
    if (options?.LIMIT) {
      args.push("LIMIT", options.LIMIT.offset.toString(), options.LIMIT.count.toString());
    }
    if (options?.WITHSCORES) {
      args.push("WITHSCORES");
    }
    return args;
  };
  var transformReply = function(reply) {
    if (typeof reply !== "number") {
      throw new TypeError(`Upgrade to Redis 6.2.5 and up (https://github.com/redis/redis/pull/9089)`);
    }
    return reply;
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.transformReply = exports.transformArguments = exports.FIRST_KEY_INDEX = undefined;
  var generic_transformers_1 = require_generic_transformers();
  exports.FIRST_KEY_INDEX = 1;
  exports.transformArguments = transformArguments;
  exports.transformReply = transformReply;
});

// node_modules/@redis/client/dist/lib/commands/ZRANK.js
var require_ZRANK = __commonJS((exports) => {
  var transformArguments = function(key, member) {
    return ["ZRANK", key, member];
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.transformArguments = exports.IS_READ_ONLY = exports.FIRST_KEY_INDEX = undefined;
  exports.FIRST_KEY_INDEX = 1;
  exports.IS_READ_ONLY = true;
  exports.transformArguments = transformArguments;
});

// node_modules/@redis/client/dist/lib/commands/ZREM.js
var require_ZREM = __commonJS((exports) => {
  var transformArguments = function(key, member) {
    return (0, generic_transformers_1.pushVerdictArguments)(["ZREM", key], member);
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.transformArguments = exports.FIRST_KEY_INDEX = undefined;
  var generic_transformers_1 = require_generic_transformers();
  exports.FIRST_KEY_INDEX = 1;
  exports.transformArguments = transformArguments;
});

// node_modules/@redis/client/dist/lib/commands/ZREMRANGEBYLEX.js
var require_ZREMRANGEBYLEX = __commonJS((exports) => {
  var transformArguments = function(key, min, max) {
    return [
      "ZREMRANGEBYLEX",
      key,
      (0, generic_transformers_1.transformStringNumberInfinityArgument)(min),
      (0, generic_transformers_1.transformStringNumberInfinityArgument)(max)
    ];
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.transformArguments = exports.FIRST_KEY_INDEX = undefined;
  var generic_transformers_1 = require_generic_transformers();
  exports.FIRST_KEY_INDEX = 1;
  exports.transformArguments = transformArguments;
});

// node_modules/@redis/client/dist/lib/commands/ZREMRANGEBYRANK.js
var require_ZREMRANGEBYRANK = __commonJS((exports) => {
  var transformArguments = function(key, start, stop) {
    return ["ZREMRANGEBYRANK", key, start.toString(), stop.toString()];
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.transformArguments = exports.FIRST_KEY_INDEX = undefined;
  exports.FIRST_KEY_INDEX = 1;
  exports.transformArguments = transformArguments;
});

// node_modules/@redis/client/dist/lib/commands/ZREMRANGEBYSCORE.js
var require_ZREMRANGEBYSCORE = __commonJS((exports) => {
  var transformArguments = function(key, min, max) {
    return [
      "ZREMRANGEBYSCORE",
      key,
      (0, generic_transformers_1.transformStringNumberInfinityArgument)(min),
      (0, generic_transformers_1.transformStringNumberInfinityArgument)(max)
    ];
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.transformArguments = exports.FIRST_KEY_INDEX = undefined;
  var generic_transformers_1 = require_generic_transformers();
  exports.FIRST_KEY_INDEX = 1;
  exports.transformArguments = transformArguments;
});

// node_modules/@redis/client/dist/lib/commands/ZREVRANK.js
var require_ZREVRANK = __commonJS((exports) => {
  var transformArguments = function(key, member) {
    return ["ZREVRANK", key, member];
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.transformArguments = exports.IS_READ_ONLY = exports.FIRST_KEY_INDEX = undefined;
  exports.FIRST_KEY_INDEX = 1;
  exports.IS_READ_ONLY = true;
  exports.transformArguments = transformArguments;
});

// node_modules/@redis/client/dist/lib/commands/ZSCAN.js
var require_ZSCAN = __commonJS((exports) => {
  var transformArguments = function(key, cursor, options) {
    return (0, generic_transformers_1.pushScanArguments)([
      "ZSCAN",
      key
    ], cursor, options);
  };
  var transformReply = function([cursor, rawMembers]) {
    const parsedMembers = [];
    for (let i = 0;i < rawMembers.length; i += 2) {
      parsedMembers.push({
        value: rawMembers[i],
        score: (0, generic_transformers_1.transformNumberInfinityReply)(rawMembers[i + 1])
      });
    }
    return {
      cursor: Number(cursor),
      members: parsedMembers
    };
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.transformReply = exports.transformArguments = exports.IS_READ_ONLY = exports.FIRST_KEY_INDEX = undefined;
  var generic_transformers_1 = require_generic_transformers();
  exports.FIRST_KEY_INDEX = 1;
  exports.IS_READ_ONLY = true;
  exports.transformArguments = transformArguments;
  exports.transformReply = transformReply;
});

// node_modules/@redis/client/dist/lib/commands/ZSCORE.js
var require_ZSCORE = __commonJS((exports) => {
  var transformArguments = function(key, member) {
    return ["ZSCORE", key, member];
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.transformReply = exports.transformArguments = exports.IS_READ_ONLY = exports.FIRST_KEY_INDEX = undefined;
  exports.FIRST_KEY_INDEX = 1;
  exports.IS_READ_ONLY = true;
  exports.transformArguments = transformArguments;
  var generic_transformers_1 = require_generic_transformers();
  Object.defineProperty(exports, "transformReply", { enumerable: true, get: function() {
    return generic_transformers_1.transformNumberInfinityNullReply;
  } });
});

// node_modules/@redis/client/dist/lib/commands/ZUNION.js
var require_ZUNION = __commonJS((exports) => {
  var transformArguments = function(keys, options) {
    const args = (0, generic_transformers_1.pushVerdictArgument)(["ZUNION"], keys);
    if (options?.WEIGHTS) {
      args.push("WEIGHTS", ...options.WEIGHTS.map((weight) => weight.toString()));
    }
    if (options?.AGGREGATE) {
      args.push("AGGREGATE", options.AGGREGATE);
    }
    return args;
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.transformArguments = exports.IS_READ_ONLY = exports.FIRST_KEY_INDEX = undefined;
  var generic_transformers_1 = require_generic_transformers();
  exports.FIRST_KEY_INDEX = 2;
  exports.IS_READ_ONLY = true;
  exports.transformArguments = transformArguments;
});

// node_modules/@redis/client/dist/lib/commands/ZUNION_WITHSCORES.js
var require_ZUNION_WITHSCORES = __commonJS((exports) => {
  var transformArguments = function(...args) {
    return [
      ...(0, ZUNION_1.transformArguments)(...args),
      "WITHSCORES"
    ];
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.transformReply = exports.transformArguments = exports.IS_READ_ONLY = exports.FIRST_KEY_INDEX = undefined;
  var ZUNION_1 = require_ZUNION();
  var ZUNION_2 = require_ZUNION();
  Object.defineProperty(exports, "FIRST_KEY_INDEX", { enumerable: true, get: function() {
    return ZUNION_2.FIRST_KEY_INDEX;
  } });
  Object.defineProperty(exports, "IS_READ_ONLY", { enumerable: true, get: function() {
    return ZUNION_2.IS_READ_ONLY;
  } });
  exports.transformArguments = transformArguments;
  var generic_transformers_1 = require_generic_transformers();
  Object.defineProperty(exports, "transformReply", { enumerable: true, get: function() {
    return generic_transformers_1.transformSortedSetWithScoresReply;
  } });
});

// node_modules/@redis/client/dist/lib/commands/ZUNIONSTORE.js
var require_ZUNIONSTORE = __commonJS((exports) => {
  var transformArguments = function(destination, keys, options) {
    const args = (0, generic_transformers_1.pushVerdictArgument)(["ZUNIONSTORE", destination], keys);
    if (options?.WEIGHTS) {
      args.push("WEIGHTS", ...options.WEIGHTS.map((weight) => weight.toString()));
    }
    if (options?.AGGREGATE) {
      args.push("AGGREGATE", options.AGGREGATE);
    }
    return args;
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.transformArguments = exports.FIRST_KEY_INDEX = undefined;
  var generic_transformers_1 = require_generic_transformers();
  exports.FIRST_KEY_INDEX = 1;
  exports.transformArguments = transformArguments;
});

// node_modules/@redis/client/dist/lib/cluster/commands.js
var require_commands2 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  var APPEND = require_APPEND();
  var BITCOUNT = require_BITCOUNT();
  var BITFIELD_RO = require_BITFIELD_RO();
  var BITFIELD = require_BITFIELD();
  var BITOP = require_BITOP();
  var BITPOS = require_BITPOS();
  var BLMOVE = require_BLMOVE();
  var BLMPOP = require_BLMPOP();
  var BLPOP = require_BLPOP();
  var BRPOP = require_BRPOP();
  var BRPOPLPUSH = require_BRPOPLPUSH();
  var BZMPOP = require_BZMPOP();
  var BZPOPMAX = require_BZPOPMAX();
  var BZPOPMIN = require_BZPOPMIN();
  var COPY = require_COPY();
  var DECR = require_DECR();
  var DECRBY = require_DECRBY();
  var DEL = require_DEL();
  var DUMP = require_DUMP();
  var EVAL_RO = require_EVAL_RO();
  var EVAL = require_EVAL();
  var EVALSHA_RO = require_EVALSHA_RO();
  var EVALSHA = require_EVALSHA();
  var EXISTS = require_EXISTS();
  var EXPIRE = require_EXPIRE();
  var EXPIREAT = require_EXPIREAT();
  var EXPIRETIME = require_EXPIRETIME();
  var FCALL_RO = require_FCALL_RO();
  var FCALL = require_FCALL();
  var GEOADD = require_GEOADD();
  var GEODIST = require_GEODIST();
  var GEOHASH = require_GEOHASH();
  var GEOPOS = require_GEOPOS();
  var GEORADIUS_RO_WITH = require_GEORADIUS_RO_WITH();
  var GEORADIUS_RO = require_GEORADIUS_RO();
  var GEORADIUS_WITH = require_GEORADIUS_WITH();
  var GEORADIUS = require_GEORADIUS();
  var GEORADIUSBYMEMBER_RO_WITH = require_GEORADIUSBYMEMBER_RO_WITH();
  var GEORADIUSBYMEMBER_RO = require_GEORADIUSBYMEMBER_RO();
  var GEORADIUSBYMEMBER_WITH = require_GEORADIUSBYMEMBER_WITH();
  var GEORADIUSBYMEMBER = require_GEORADIUSBYMEMBER();
  var GEORADIUSBYMEMBERSTORE = require_GEORADIUSBYMEMBERSTORE();
  var GEORADIUSSTORE = require_GEORADIUSSTORE();
  var GEOSEARCH_WITH = require_GEOSEARCH_WITH();
  var GEOSEARCH = require_GEOSEARCH();
  var GEOSEARCHSTORE = require_GEOSEARCHSTORE();
  var GET = require_GET();
  var GETBIT = require_GETBIT();
  var GETDEL = require_GETDEL();
  var GETEX = require_GETEX();
  var GETRANGE = require_GETRANGE();
  var GETSET = require_GETSET();
  var HDEL = require_HDEL();
  var HEXISTS = require_HEXISTS();
  var HGET = require_HGET();
  var HGETALL = require_HGETALL();
  var HINCRBY = require_HINCRBY();
  var HINCRBYFLOAT = require_HINCRBYFLOAT();
  var HKEYS = require_HKEYS();
  var HLEN = require_HLEN();
  var HMGET = require_HMGET();
  var HRANDFIELD_COUNT_WITHVALUES = require_HRANDFIELD_COUNT_WITHVALUES();
  var HRANDFIELD_COUNT = require_HRANDFIELD_COUNT();
  var HRANDFIELD = require_HRANDFIELD();
  var HSCAN = require_HSCAN();
  var HSET = require_HSET();
  var HSETNX = require_HSETNX();
  var HSTRLEN = require_HSTRLEN();
  var HVALS = require_HVALS();
  var INCR = require_INCR();
  var INCRBY = require_INCRBY();
  var INCRBYFLOAT = require_INCRBYFLOAT();
  var LCS_IDX_WITHMATCHLEN = require_LCS_IDX_WITHMATCHLEN();
  var LCS_IDX = require_LCS_IDX();
  var LCS_LEN = require_LCS_LEN();
  var LCS = require_LCS();
  var LINDEX = require_LINDEX();
  var LINSERT = require_LINSERT();
  var LLEN = require_LLEN();
  var LMOVE = require_LMOVE();
  var LMPOP = require_LMPOP();
  var LPOP_COUNT = require_LPOP_COUNT();
  var LPOP = require_LPOP();
  var LPOS_COUNT = require_LPOS_COUNT();
  var LPOS = require_LPOS();
  var LPUSH = require_LPUSH();
  var LPUSHX = require_LPUSHX();
  var LRANGE = require_LRANGE();
  var LREM = require_LREM();
  var LSET = require_LSET();
  var LTRIM = require_LTRIM();
  var MGET = require_MGET();
  var MIGRATE = require_MIGRATE();
  var MSET = require_MSET();
  var MSETNX = require_MSETNX();
  var OBJECT_ENCODING = require_OBJECT_ENCODING();
  var OBJECT_FREQ = require_OBJECT_FREQ();
  var OBJECT_IDLETIME = require_OBJECT_IDLETIME();
  var OBJECT_REFCOUNT = require_OBJECT_REFCOUNT();
  var PERSIST = require_PERSIST();
  var PEXPIRE = require_PEXPIRE();
  var PEXPIREAT = require_PEXPIREAT();
  var PEXPIRETIME = require_PEXPIRETIME();
  var PFADD = require_PFADD();
  var PFCOUNT = require_PFCOUNT();
  var PFMERGE = require_PFMERGE();
  var PSETEX = require_PSETEX();
  var PTTL = require_PTTL();
  var PUBLISH = require_PUBLISH();
  var RENAME = require_RENAME();
  var RENAMENX = require_RENAMENX();
  var RPOP_COUNT = require_RPOP_COUNT();
  var RPOP = require_RPOP();
  var RPOPLPUSH = require_RPOPLPUSH();
  var RPUSH = require_RPUSH();
  var RPUSHX = require_RPUSHX();
  var SADD = require_SADD();
  var SCARD = require_SCARD();
  var SDIFF = require_SDIFF();
  var SDIFFSTORE = require_SDIFFSTORE();
  var SET = require_SET();
  var SETBIT = require_SETBIT();
  var SETEX = require_SETEX();
  var SETNX = require_SETNX();
  var SETRANGE = require_SETRANGE();
  var SINTER = require_SINTER();
  var SINTERCARD = require_SINTERCARD();
  var SINTERSTORE = require_SINTERSTORE();
  var SISMEMBER = require_SISMEMBER();
  var SMEMBERS = require_SMEMBERS();
  var SMISMEMBER = require_SMISMEMBER();
  var SMOVE = require_SMOVE();
  var SORT_RO = require_SORT_RO();
  var SORT_STORE = require_SORT_STORE();
  var SORT = require_SORT();
  var SPOP = require_SPOP();
  var SPUBLISH = require_SPUBLISH();
  var SRANDMEMBER_COUNT = require_SRANDMEMBER_COUNT();
  var SRANDMEMBER = require_SRANDMEMBER();
  var SREM = require_SREM();
  var SSCAN = require_SSCAN();
  var STRLEN = require_STRLEN();
  var SUNION = require_SUNION();
  var SUNIONSTORE = require_SUNIONSTORE();
  var TOUCH = require_TOUCH();
  var TTL = require_TTL();
  var TYPE = require_TYPE();
  var UNLINK = require_UNLINK();
  var WATCH = require_WATCH();
  var XACK = require_XACK();
  var XADD = require_XADD();
  var XAUTOCLAIM_JUSTID = require_XAUTOCLAIM_JUSTID();
  var XAUTOCLAIM = require_XAUTOCLAIM();
  var XCLAIM_JUSTID = require_XCLAIM_JUSTID();
  var XCLAIM = require_XCLAIM();
  var XDEL = require_XDEL();
  var XGROUP_CREATE = require_XGROUP_CREATE();
  var XGROUP_CREATECONSUMER = require_XGROUP_CREATECONSUMER();
  var XGROUP_DELCONSUMER = require_XGROUP_DELCONSUMER();
  var XGROUP_DESTROY = require_XGROUP_DESTROY();
  var XGROUP_SETID = require_XGROUP_SETID();
  var XINFO_CONSUMERS = require_XINFO_CONSUMERS();
  var XINFO_GROUPS = require_XINFO_GROUPS();
  var XINFO_STREAM = require_XINFO_STREAM();
  var XLEN = require_XLEN();
  var XPENDING_RANGE = require_XPENDING_RANGE();
  var XPENDING = require_XPENDING();
  var XRANGE = require_XRANGE();
  var XREAD = require_XREAD();
  var XREADGROUP = require_XREADGROUP();
  var XREVRANGE = require_XREVRANGE();
  var XSETID = require_XSETID();
  var XTRIM = require_XTRIM();
  var ZADD = require_ZADD();
  var ZCARD = require_ZCARD();
  var ZCOUNT = require_ZCOUNT();
  var ZDIFF_WITHSCORES = require_ZDIFF_WITHSCORES();
  var ZDIFF = require_ZDIFF();
  var ZDIFFSTORE = require_ZDIFFSTORE();
  var ZINCRBY = require_ZINCRBY();
  var ZINTER_WITHSCORES = require_ZINTER_WITHSCORES();
  var ZINTER = require_ZINTER();
  var ZINTERCARD = require_ZINTERCARD();
  var ZINTERSTORE = require_ZINTERSTORE();
  var ZLEXCOUNT = require_ZLEXCOUNT();
  var ZMPOP = require_ZMPOP();
  var ZMSCORE = require_ZMSCORE();
  var ZPOPMAX_COUNT = require_ZPOPMAX_COUNT();
  var ZPOPMAX = require_ZPOPMAX();
  var ZPOPMIN_COUNT = require_ZPOPMIN_COUNT();
  var ZPOPMIN = require_ZPOPMIN();
  var ZRANDMEMBER_COUNT_WITHSCORES = require_ZRANDMEMBER_COUNT_WITHSCORES();
  var ZRANDMEMBER_COUNT = require_ZRANDMEMBER_COUNT();
  var ZRANDMEMBER = require_ZRANDMEMBER();
  var ZRANGE_WITHSCORES = require_ZRANGE_WITHSCORES();
  var ZRANGE = require_ZRANGE();
  var ZRANGEBYLEX = require_ZRANGEBYLEX();
  var ZRANGEBYSCORE_WITHSCORES = require_ZRANGEBYSCORE_WITHSCORES();
  var ZRANGEBYSCORE = require_ZRANGEBYSCORE();
  var ZRANGESTORE = require_ZRANGESTORE();
  var ZRANK = require_ZRANK();
  var ZREM = require_ZREM();
  var ZREMRANGEBYLEX = require_ZREMRANGEBYLEX();
  var ZREMRANGEBYRANK = require_ZREMRANGEBYRANK();
  var ZREMRANGEBYSCORE = require_ZREMRANGEBYSCORE();
  var ZREVRANK = require_ZREVRANK();
  var ZSCAN = require_ZSCAN();
  var ZSCORE = require_ZSCORE();
  var ZUNION_WITHSCORES = require_ZUNION_WITHSCORES();
  var ZUNION = require_ZUNION();
  var ZUNIONSTORE = require_ZUNIONSTORE();
  exports.default = {
    APPEND,
    append: APPEND,
    BITCOUNT,
    bitCount: BITCOUNT,
    BITFIELD_RO,
    bitFieldRo: BITFIELD_RO,
    BITFIELD,
    bitField: BITFIELD,
    BITOP,
    bitOp: BITOP,
    BITPOS,
    bitPos: BITPOS,
    BLMOVE,
    blMove: BLMOVE,
    BLMPOP,
    blmPop: BLMPOP,
    BLPOP,
    blPop: BLPOP,
    BRPOP,
    brPop: BRPOP,
    BRPOPLPUSH,
    brPopLPush: BRPOPLPUSH,
    BZMPOP,
    bzmPop: BZMPOP,
    BZPOPMAX,
    bzPopMax: BZPOPMAX,
    BZPOPMIN,
    bzPopMin: BZPOPMIN,
    COPY,
    copy: COPY,
    DECR,
    decr: DECR,
    DECRBY,
    decrBy: DECRBY,
    DEL,
    del: DEL,
    DUMP,
    dump: DUMP,
    EVAL_RO,
    evalRo: EVAL_RO,
    EVAL,
    eval: EVAL,
    EVALSHA,
    evalSha: EVALSHA,
    EVALSHA_RO,
    evalShaRo: EVALSHA_RO,
    EXISTS,
    exists: EXISTS,
    EXPIRE,
    expire: EXPIRE,
    EXPIREAT,
    expireAt: EXPIREAT,
    EXPIRETIME,
    expireTime: EXPIRETIME,
    FCALL_RO,
    fCallRo: FCALL_RO,
    FCALL,
    fCall: FCALL,
    GEOADD,
    geoAdd: GEOADD,
    GEODIST,
    geoDist: GEODIST,
    GEOHASH,
    geoHash: GEOHASH,
    GEOPOS,
    geoPos: GEOPOS,
    GEORADIUS_RO_WITH,
    geoRadiusRoWith: GEORADIUS_RO_WITH,
    GEORADIUS_RO,
    geoRadiusRo: GEORADIUS_RO,
    GEORADIUS_WITH,
    geoRadiusWith: GEORADIUS_WITH,
    GEORADIUS,
    geoRadius: GEORADIUS,
    GEORADIUSBYMEMBER_RO_WITH,
    geoRadiusByMemberRoWith: GEORADIUSBYMEMBER_RO_WITH,
    GEORADIUSBYMEMBER_RO,
    geoRadiusByMemberRo: GEORADIUSBYMEMBER_RO,
    GEORADIUSBYMEMBER_WITH,
    geoRadiusByMemberWith: GEORADIUSBYMEMBER_WITH,
    GEORADIUSBYMEMBER,
    geoRadiusByMember: GEORADIUSBYMEMBER,
    GEORADIUSBYMEMBERSTORE,
    geoRadiusByMemberStore: GEORADIUSBYMEMBERSTORE,
    GEORADIUSSTORE,
    geoRadiusStore: GEORADIUSSTORE,
    GEOSEARCH_WITH,
    geoSearchWith: GEOSEARCH_WITH,
    GEOSEARCH,
    geoSearch: GEOSEARCH,
    GEOSEARCHSTORE,
    geoSearchStore: GEOSEARCHSTORE,
    GET,
    get: GET,
    GETBIT,
    getBit: GETBIT,
    GETDEL,
    getDel: GETDEL,
    GETEX,
    getEx: GETEX,
    GETRANGE,
    getRange: GETRANGE,
    GETSET,
    getSet: GETSET,
    HDEL,
    hDel: HDEL,
    HEXISTS,
    hExists: HEXISTS,
    HGET,
    hGet: HGET,
    HGETALL,
    hGetAll: HGETALL,
    HINCRBY,
    hIncrBy: HINCRBY,
    HINCRBYFLOAT,
    hIncrByFloat: HINCRBYFLOAT,
    HKEYS,
    hKeys: HKEYS,
    HLEN,
    hLen: HLEN,
    HMGET,
    hmGet: HMGET,
    HRANDFIELD_COUNT_WITHVALUES,
    hRandFieldCountWithValues: HRANDFIELD_COUNT_WITHVALUES,
    HRANDFIELD_COUNT,
    hRandFieldCount: HRANDFIELD_COUNT,
    HRANDFIELD,
    hRandField: HRANDFIELD,
    HSCAN,
    hScan: HSCAN,
    HSET,
    hSet: HSET,
    HSETNX,
    hSetNX: HSETNX,
    HSTRLEN,
    hStrLen: HSTRLEN,
    HVALS,
    hVals: HVALS,
    INCR,
    incr: INCR,
    INCRBY,
    incrBy: INCRBY,
    INCRBYFLOAT,
    incrByFloat: INCRBYFLOAT,
    LCS_IDX_WITHMATCHLEN,
    lcsIdxWithMatchLen: LCS_IDX_WITHMATCHLEN,
    LCS_IDX,
    lcsIdx: LCS_IDX,
    LCS_LEN,
    lcsLen: LCS_LEN,
    LCS,
    lcs: LCS,
    LINDEX,
    lIndex: LINDEX,
    LINSERT,
    lInsert: LINSERT,
    LLEN,
    lLen: LLEN,
    LMOVE,
    lMove: LMOVE,
    LMPOP,
    lmPop: LMPOP,
    LPOP_COUNT,
    lPopCount: LPOP_COUNT,
    LPOP,
    lPop: LPOP,
    LPOS_COUNT,
    lPosCount: LPOS_COUNT,
    LPOS,
    lPos: LPOS,
    LPUSH,
    lPush: LPUSH,
    LPUSHX,
    lPushX: LPUSHX,
    LRANGE,
    lRange: LRANGE,
    LREM,
    lRem: LREM,
    LSET,
    lSet: LSET,
    LTRIM,
    lTrim: LTRIM,
    MGET,
    mGet: MGET,
    MIGRATE,
    migrate: MIGRATE,
    MSET,
    mSet: MSET,
    MSETNX,
    mSetNX: MSETNX,
    OBJECT_ENCODING,
    objectEncoding: OBJECT_ENCODING,
    OBJECT_FREQ,
    objectFreq: OBJECT_FREQ,
    OBJECT_IDLETIME,
    objectIdleTime: OBJECT_IDLETIME,
    OBJECT_REFCOUNT,
    objectRefCount: OBJECT_REFCOUNT,
    PERSIST,
    persist: PERSIST,
    PEXPIRE,
    pExpire: PEXPIRE,
    PEXPIREAT,
    pExpireAt: PEXPIREAT,
    PEXPIRETIME,
    pExpireTime: PEXPIRETIME,
    PFADD,
    pfAdd: PFADD,
    PFCOUNT,
    pfCount: PFCOUNT,
    PFMERGE,
    pfMerge: PFMERGE,
    PSETEX,
    pSetEx: PSETEX,
    PTTL,
    pTTL: PTTL,
    PUBLISH,
    publish: PUBLISH,
    RENAME,
    rename: RENAME,
    RENAMENX,
    renameNX: RENAMENX,
    RPOP_COUNT,
    rPopCount: RPOP_COUNT,
    RPOP,
    rPop: RPOP,
    RPOPLPUSH,
    rPopLPush: RPOPLPUSH,
    RPUSH,
    rPush: RPUSH,
    RPUSHX,
    rPushX: RPUSHX,
    SADD,
    sAdd: SADD,
    SCARD,
    sCard: SCARD,
    SDIFF,
    sDiff: SDIFF,
    SDIFFSTORE,
    sDiffStore: SDIFFSTORE,
    SINTER,
    sInter: SINTER,
    SINTERCARD,
    sInterCard: SINTERCARD,
    SINTERSTORE,
    sInterStore: SINTERSTORE,
    SET,
    set: SET,
    SETBIT,
    setBit: SETBIT,
    SETEX,
    setEx: SETEX,
    SETNX,
    setNX: SETNX,
    SETRANGE,
    setRange: SETRANGE,
    SISMEMBER,
    sIsMember: SISMEMBER,
    SMEMBERS,
    sMembers: SMEMBERS,
    SMISMEMBER,
    smIsMember: SMISMEMBER,
    SMOVE,
    sMove: SMOVE,
    SORT_RO,
    sortRo: SORT_RO,
    SORT_STORE,
    sortStore: SORT_STORE,
    SORT,
    sort: SORT,
    SPOP,
    sPop: SPOP,
    SPUBLISH,
    sPublish: SPUBLISH,
    SRANDMEMBER_COUNT,
    sRandMemberCount: SRANDMEMBER_COUNT,
    SRANDMEMBER,
    sRandMember: SRANDMEMBER,
    SREM,
    sRem: SREM,
    SSCAN,
    sScan: SSCAN,
    STRLEN,
    strLen: STRLEN,
    SUNION,
    sUnion: SUNION,
    SUNIONSTORE,
    sUnionStore: SUNIONSTORE,
    TOUCH,
    touch: TOUCH,
    TTL,
    ttl: TTL,
    TYPE,
    type: TYPE,
    UNLINK,
    unlink: UNLINK,
    WATCH,
    watch: WATCH,
    XACK,
    xAck: XACK,
    XADD,
    xAdd: XADD,
    XAUTOCLAIM_JUSTID,
    xAutoClaimJustId: XAUTOCLAIM_JUSTID,
    XAUTOCLAIM,
    xAutoClaim: XAUTOCLAIM,
    XCLAIM,
    xClaim: XCLAIM,
    XCLAIM_JUSTID,
    xClaimJustId: XCLAIM_JUSTID,
    XDEL,
    xDel: XDEL,
    XGROUP_CREATE,
    xGroupCreate: XGROUP_CREATE,
    XGROUP_CREATECONSUMER,
    xGroupCreateConsumer: XGROUP_CREATECONSUMER,
    XGROUP_DELCONSUMER,
    xGroupDelConsumer: XGROUP_DELCONSUMER,
    XGROUP_DESTROY,
    xGroupDestroy: XGROUP_DESTROY,
    XGROUP_SETID,
    xGroupSetId: XGROUP_SETID,
    XINFO_CONSUMERS,
    xInfoConsumers: XINFO_CONSUMERS,
    XINFO_GROUPS,
    xInfoGroups: XINFO_GROUPS,
    XINFO_STREAM,
    xInfoStream: XINFO_STREAM,
    XLEN,
    xLen: XLEN,
    XPENDING_RANGE,
    xPendingRange: XPENDING_RANGE,
    XPENDING,
    xPending: XPENDING,
    XRANGE,
    xRange: XRANGE,
    XREAD,
    xRead: XREAD,
    XREADGROUP,
    xReadGroup: XREADGROUP,
    XREVRANGE,
    xRevRange: XREVRANGE,
    XSETID,
    xSetId: XSETID,
    XTRIM,
    xTrim: XTRIM,
    ZADD,
    zAdd: ZADD,
    ZCARD,
    zCard: ZCARD,
    ZCOUNT,
    zCount: ZCOUNT,
    ZDIFF_WITHSCORES,
    zDiffWithScores: ZDIFF_WITHSCORES,
    ZDIFF,
    zDiff: ZDIFF,
    ZDIFFSTORE,
    zDiffStore: ZDIFFSTORE,
    ZINCRBY,
    zIncrBy: ZINCRBY,
    ZINTER_WITHSCORES,
    zInterWithScores: ZINTER_WITHSCORES,
    ZINTER,
    zInter: ZINTER,
    ZINTERCARD,
    zInterCard: ZINTERCARD,
    ZINTERSTORE,
    zInterStore: ZINTERSTORE,
    ZLEXCOUNT,
    zLexCount: ZLEXCOUNT,
    ZMPOP,
    zmPop: ZMPOP,
    ZMSCORE,
    zmScore: ZMSCORE,
    ZPOPMAX_COUNT,
    zPopMaxCount: ZPOPMAX_COUNT,
    ZPOPMAX,
    zPopMax: ZPOPMAX,
    ZPOPMIN_COUNT,
    zPopMinCount: ZPOPMIN_COUNT,
    ZPOPMIN,
    zPopMin: ZPOPMIN,
    ZRANDMEMBER_COUNT_WITHSCORES,
    zRandMemberCountWithScores: ZRANDMEMBER_COUNT_WITHSCORES,
    ZRANDMEMBER_COUNT,
    zRandMemberCount: ZRANDMEMBER_COUNT,
    ZRANDMEMBER,
    zRandMember: ZRANDMEMBER,
    ZRANGE_WITHSCORES,
    zRangeWithScores: ZRANGE_WITHSCORES,
    ZRANGE,
    zRange: ZRANGE,
    ZRANGEBYLEX,
    zRangeByLex: ZRANGEBYLEX,
    ZRANGEBYSCORE_WITHSCORES,
    zRangeByScoreWithScores: ZRANGEBYSCORE_WITHSCORES,
    ZRANGEBYSCORE,
    zRangeByScore: ZRANGEBYSCORE,
    ZRANGESTORE,
    zRangeStore: ZRANGESTORE,
    ZRANK,
    zRank: ZRANK,
    ZREM,
    zRem: ZREM,
    ZREMRANGEBYLEX,
    zRemRangeByLex: ZREMRANGEBYLEX,
    ZREMRANGEBYRANK,
    zRemRangeByRank: ZREMRANGEBYRANK,
    ZREMRANGEBYSCORE,
    zRemRangeByScore: ZREMRANGEBYSCORE,
    ZREVRANK,
    zRevRank: ZREVRANK,
    ZSCAN,
    zScan: ZSCAN,
    ZSCORE,
    zScore: ZSCORE,
    ZUNION_WITHSCORES,
    zUnionWithScores: ZUNION_WITHSCORES,
    ZUNION,
    zUnion: ZUNION,
    ZUNIONSTORE,
    zUnionStore: ZUNIONSTORE
  };
});

// node_modules/@redis/client/dist/lib/commands/ACL_CAT.js
var require_ACL_CAT = __commonJS((exports) => {
  var transformArguments = function(categoryName) {
    const args = ["ACL", "CAT"];
    if (categoryName) {
      args.push(categoryName);
    }
    return args;
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.transformArguments = undefined;
  exports.transformArguments = transformArguments;
});

// node_modules/@redis/client/dist/lib/commands/ACL_DELUSER.js
var require_ACL_DELUSER = __commonJS((exports) => {
  var transformArguments = function(username) {
    return (0, generic_transformers_1.pushVerdictArguments)(["ACL", "DELUSER"], username);
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.transformArguments = undefined;
  var generic_transformers_1 = require_generic_transformers();
  exports.transformArguments = transformArguments;
});

// node_modules/@redis/client/dist/lib/commands/ACL_DRYRUN.js
var require_ACL_DRYRUN = __commonJS((exports) => {
  var transformArguments = function(username, command) {
    return [
      "ACL",
      "DRYRUN",
      username,
      ...command
    ];
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.transformArguments = exports.IS_READ_ONLY = undefined;
  exports.IS_READ_ONLY = true;
  exports.transformArguments = transformArguments;
});

// node_modules/@redis/client/dist/lib/commands/ACL_GENPASS.js
var require_ACL_GENPASS = __commonJS((exports) => {
  var transformArguments = function(bits) {
    const args = ["ACL", "GENPASS"];
    if (bits) {
      args.push(bits.toString());
    }
    return args;
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.transformArguments = undefined;
  exports.transformArguments = transformArguments;
});

// node_modules/@redis/client/dist/lib/commands/ACL_GETUSER.js
var require_ACL_GETUSER = __commonJS((exports) => {
  var transformArguments = function(username) {
    return ["ACL", "GETUSER", username];
  };
  var transformReply = function(reply) {
    return {
      flags: reply[1],
      passwords: reply[3],
      commands: reply[5],
      keys: reply[7],
      channels: reply[9],
      selectors: reply[11]
    };
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.transformReply = exports.transformArguments = undefined;
  exports.transformArguments = transformArguments;
  exports.transformReply = transformReply;
});

// node_modules/@redis/client/dist/lib/commands/ACL_LIST.js
var require_ACL_LIST = __commonJS((exports) => {
  var transformArguments = function() {
    return ["ACL", "LIST"];
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.transformArguments = undefined;
  exports.transformArguments = transformArguments;
});

// node_modules/@redis/client/dist/lib/commands/ACL_LOAD.js
var require_ACL_LOAD = __commonJS((exports) => {
  var transformArguments = function() {
    return ["ACL", "LOAD"];
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.transformArguments = undefined;
  exports.transformArguments = transformArguments;
});

// node_modules/@redis/client/dist/lib/commands/ACL_LOG_RESET.js
var require_ACL_LOG_RESET = __commonJS((exports) => {
  var transformArguments = function() {
    return ["ACL", "LOG", "RESET"];
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.transformArguments = undefined;
  exports.transformArguments = transformArguments;
});

// node_modules/@redis/client/dist/lib/commands/ACL_LOG.js
var require_ACL_LOG = __commonJS((exports) => {
  var transformArguments = function(count) {
    const args = ["ACL", "LOG"];
    if (count) {
      args.push(count.toString());
    }
    return args;
  };
  var transformReply = function(reply) {
    return reply.map((log) => ({
      count: log[1],
      reason: log[3],
      context: log[5],
      object: log[7],
      username: log[9],
      ageSeconds: Number(log[11]),
      clientInfo: log[13]
    }));
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.transformReply = exports.transformArguments = undefined;
  exports.transformArguments = transformArguments;
  exports.transformReply = transformReply;
});

// node_modules/@redis/client/dist/lib/commands/ACL_SAVE.js
var require_ACL_SAVE = __commonJS((exports) => {
  var transformArguments = function() {
    return ["ACL", "SAVE"];
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.transformArguments = undefined;
  exports.transformArguments = transformArguments;
});

// node_modules/@redis/client/dist/lib/commands/ACL_SETUSER.js
var require_ACL_SETUSER = __commonJS((exports) => {
  var transformArguments = function(username, rule) {
    return (0, generic_transformers_1.pushVerdictArguments)(["ACL", "SETUSER", username], rule);
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.transformArguments = undefined;
  var generic_transformers_1 = require_generic_transformers();
  exports.transformArguments = transformArguments;
});

// node_modules/@redis/client/dist/lib/commands/ACL_USERS.js
var require_ACL_USERS = __commonJS((exports) => {
  var transformArguments = function() {
    return ["ACL", "USERS"];
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.transformArguments = undefined;
  exports.transformArguments = transformArguments;
});

// node_modules/@redis/client/dist/lib/commands/ACL_WHOAMI.js
var require_ACL_WHOAMI = __commonJS((exports) => {
  var transformArguments = function() {
    return ["ACL", "WHOAMI"];
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.transformArguments = undefined;
  exports.transformArguments = transformArguments;
});

// node_modules/@redis/client/dist/lib/commands/ASKING.js
var require_ASKING = __commonJS((exports) => {
  var transformArguments = function() {
    return ["ASKING"];
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.transformArguments = undefined;
  exports.transformArguments = transformArguments;
});

// node_modules/@redis/client/dist/lib/commands/AUTH.js
var require_AUTH = __commonJS((exports) => {
  var transformArguments = function({ username, password }) {
    if (!username) {
      return ["AUTH", password];
    }
    return ["AUTH", username, password];
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.transformArguments = undefined;
  exports.transformArguments = transformArguments;
});

// node_modules/@redis/client/dist/lib/commands/BGREWRITEAOF.js
var require_BGREWRITEAOF = __commonJS((exports) => {
  var transformArguments = function() {
    return ["BGREWRITEAOF"];
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.transformArguments = undefined;
  exports.transformArguments = transformArguments;
});

// node_modules/@redis/client/dist/lib/commands/BGSAVE.js
var require_BGSAVE = __commonJS((exports) => {
  var transformArguments = function(options) {
    const args = ["BGSAVE"];
    if (options?.SCHEDULE) {
      args.push("SCHEDULE");
    }
    return args;
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.transformArguments = undefined;
  exports.transformArguments = transformArguments;
});

// node_modules/@redis/client/dist/lib/commands/CLIENT_CACHING.js
var require_CLIENT_CACHING = __commonJS((exports) => {
  var transformArguments = function(value) {
    return [
      "CLIENT",
      "CACHING",
      value ? "YES" : "NO"
    ];
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.transformArguments = undefined;
  exports.transformArguments = transformArguments;
});

// node_modules/@redis/client/dist/lib/commands/CLIENT_GETNAME.js
var require_CLIENT_GETNAME = __commonJS((exports) => {
  var transformArguments = function() {
    return ["CLIENT", "GETNAME"];
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.transformArguments = undefined;
  exports.transformArguments = transformArguments;
});

// node_modules/@redis/client/dist/lib/commands/CLIENT_GETREDIR.js
var require_CLIENT_GETREDIR = __commonJS((exports) => {
  var transformArguments = function() {
    return ["CLIENT", "GETREDIR"];
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.transformArguments = undefined;
  exports.transformArguments = transformArguments;
});

// node_modules/@redis/client/dist/lib/commands/CLIENT_ID.js
var require_CLIENT_ID = __commonJS((exports) => {
  var transformArguments = function() {
    return ["CLIENT", "ID"];
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.transformArguments = exports.IS_READ_ONLY = undefined;
  exports.IS_READ_ONLY = true;
  exports.transformArguments = transformArguments;
});

// node_modules/@redis/client/dist/lib/commands/CLIENT_KILL.js
var require_CLIENT_KILL = __commonJS((exports) => {
  var transformArguments = function(filters) {
    const args = ["CLIENT", "KILL"];
    if (Array.isArray(filters)) {
      for (const filter of filters) {
        pushFilter(args, filter);
      }
    } else {
      pushFilter(args, filters);
    }
    return args;
  };
  var pushFilter = function(args, filter) {
    if (filter === ClientKillFilters.SKIP_ME) {
      args.push("SKIPME");
      return;
    }
    args.push(filter.filter);
    switch (filter.filter) {
      case ClientKillFilters.ADDRESS:
        args.push(filter.address);
        break;
      case ClientKillFilters.LOCAL_ADDRESS:
        args.push(filter.localAddress);
        break;
      case ClientKillFilters.ID:
        args.push(typeof filter.id === "number" ? filter.id.toString() : filter.id);
        break;
      case ClientKillFilters.TYPE:
        args.push(filter.type);
        break;
      case ClientKillFilters.USER:
        args.push(filter.username);
        break;
      case ClientKillFilters.SKIP_ME:
        args.push(filter.skipMe ? "yes" : "no");
        break;
    }
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.transformArguments = exports.ClientKillFilters = undefined;
  var ClientKillFilters;
  (function(ClientKillFilters2) {
    ClientKillFilters2["ADDRESS"] = "ADDR";
    ClientKillFilters2["LOCAL_ADDRESS"] = "LADDR";
    ClientKillFilters2["ID"] = "ID";
    ClientKillFilters2["TYPE"] = "TYPE";
    ClientKillFilters2["USER"] = "USER";
    ClientKillFilters2["SKIP_ME"] = "SKIPME";
  })(ClientKillFilters || (exports.ClientKillFilters = ClientKillFilters = {}));
  exports.transformArguments = transformArguments;
});

// node_modules/@redis/client/dist/lib/commands/CLIENT_INFO.js
var require_CLIENT_INFO = __commonJS((exports) => {
  var transformArguments = function() {
    return ["CLIENT", "INFO"];
  };
  var transformReply = function(rawReply) {
    const map = {};
    for (const item of rawReply.matchAll(CLIENT_INFO_REGEX)) {
      map[item[1]] = item[2];
    }
    const reply = {
      id: Number(map.id),
      addr: map.addr,
      fd: Number(map.fd),
      name: map.name,
      age: Number(map.age),
      idle: Number(map.idle),
      flags: map.flags,
      db: Number(map.db),
      sub: Number(map.sub),
      psub: Number(map.psub),
      multi: Number(map.multi),
      qbuf: Number(map.qbuf),
      qbufFree: Number(map["qbuf-free"]),
      argvMem: Number(map["argv-mem"]),
      obl: Number(map.obl),
      oll: Number(map.oll),
      omem: Number(map.omem),
      totMem: Number(map["tot-mem"]),
      events: map.events,
      cmd: map.cmd,
      user: map.user
    };
    if (map.laddr !== undefined) {
      reply.laddr = map.laddr;
    }
    if (map.redir !== undefined) {
      reply.redir = Number(map.redir);
    }
    if (map.ssub !== undefined) {
      reply.ssub = Number(map.ssub);
    }
    if (map["multi-mem"] !== undefined) {
      reply.multiMem = Number(map["multi-mem"]);
    }
    if (map.resp !== undefined) {
      reply.resp = Number(map.resp);
    }
    return reply;
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.transformReply = exports.transformArguments = exports.IS_READ_ONLY = undefined;
  exports.IS_READ_ONLY = true;
  exports.transformArguments = transformArguments;
  var CLIENT_INFO_REGEX = /([^\s=]+)=([^\s]*)/g;
  exports.transformReply = transformReply;
});

// node_modules/@redis/client/dist/lib/commands/CLIENT_LIST.js
var require_CLIENT_LIST = __commonJS((exports) => {
  var transformArguments = function(filter) {
    let args = ["CLIENT", "LIST"];
    if (filter) {
      if (filter.TYPE !== undefined) {
        args.push("TYPE", filter.TYPE);
      } else {
        args.push("ID");
        args = (0, generic_transformers_1.pushVerdictArguments)(args, filter.ID);
      }
    }
    return args;
  };
  var transformReply = function(rawReply) {
    const split = rawReply.split("\n"), length = split.length - 1, reply = [];
    for (let i = 0;i < length; i++) {
      reply.push((0, CLIENT_INFO_1.transformReply)(split[i]));
    }
    return reply;
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.transformReply = exports.transformArguments = exports.IS_READ_ONLY = undefined;
  var generic_transformers_1 = require_generic_transformers();
  var CLIENT_INFO_1 = require_CLIENT_INFO();
  exports.IS_READ_ONLY = true;
  exports.transformArguments = transformArguments;
  exports.transformReply = transformReply;
});

// node_modules/@redis/client/dist/lib/commands/CLIENT_NO-EVICT.js
var require_CLIENT_NO_EVICT = __commonJS((exports) => {
  var transformArguments = function(value) {
    return [
      "CLIENT",
      "NO-EVICT",
      value ? "ON" : "OFF"
    ];
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.transformArguments = undefined;
  exports.transformArguments = transformArguments;
});

// node_modules/@redis/client/dist/lib/commands/CLIENT_PAUSE.js
var require_CLIENT_PAUSE = __commonJS((exports) => {
  var transformArguments = function(timeout, mode) {
    const args = [
      "CLIENT",
      "PAUSE",
      timeout.toString()
    ];
    if (mode) {
      args.push(mode);
    }
    return args;
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.transformArguments = undefined;
  exports.transformArguments = transformArguments;
});

// node_modules/@redis/client/dist/lib/commands/CLIENT_SETNAME.js
var require_CLIENT_SETNAME = __commonJS((exports) => {
  var transformArguments = function(name) {
    return ["CLIENT", "SETNAME", name];
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.transformArguments = undefined;
  exports.transformArguments = transformArguments;
});

// node_modules/@redis/client/dist/lib/commands/CLIENT_TRACKING.js
var require_CLIENT_TRACKING = __commonJS((exports) => {
  var transformArguments = function(mode, options) {
    const args = [
      "CLIENT",
      "TRACKING",
      mode ? "ON" : "OFF"
    ];
    if (mode) {
      if (options?.REDIRECT) {
        args.push("REDIRECT", options.REDIRECT.toString());
      }
      if (isBroadcast(options)) {
        args.push("BCAST");
        if (options?.PREFIX) {
          if (Array.isArray(options.PREFIX)) {
            for (const prefix of options.PREFIX) {
              args.push("PREFIX", prefix);
            }
          } else {
            args.push("PREFIX", options.PREFIX);
          }
        }
      } else if (isOptIn(options)) {
        args.push("OPTIN");
      } else if (isOptOut(options)) {
        args.push("OPTOUT");
      }
      if (options?.NOLOOP) {
        args.push("NOLOOP");
      }
    }
    return args;
  };
  var isBroadcast = function(options) {
    return options?.BCAST === true;
  };
  var isOptIn = function(options) {
    return options?.OPTIN === true;
  };
  var isOptOut = function(options) {
    return options?.OPTOUT === true;
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.transformArguments = undefined;
  exports.transformArguments = transformArguments;
});

// node_modules/@redis/client/dist/lib/commands/CLIENT_TRACKINGINFO.js
var require_CLIENT_TRACKINGINFO = __commonJS((exports) => {
  var transformArguments = function() {
    return ["CLIENT", "TRACKINGINFO"];
  };
  var transformReply = function(reply) {
    return {
      flags: new Set(reply[1]),
      redirect: reply[3],
      prefixes: reply[5]
    };
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.transformReply = exports.transformArguments = undefined;
  exports.transformArguments = transformArguments;
  exports.transformReply = transformReply;
});

// node_modules/@redis/client/dist/lib/commands/CLIENT_UNPAUSE.js
var require_CLIENT_UNPAUSE = __commonJS((exports) => {
  var transformArguments = function() {
    return ["CLIENT", "UNPAUSE"];
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.transformArguments = undefined;
  exports.transformArguments = transformArguments;
});

// node_modules/@redis/client/dist/lib/commands/CLUSTER_ADDSLOTS.js
var require_CLUSTER_ADDSLOTS = __commonJS((exports) => {
  var transformArguments = function(slots) {
    return (0, generic_transformers_1.pushVerdictNumberArguments)(["CLUSTER", "ADDSLOTS"], slots);
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.transformArguments = undefined;
  var generic_transformers_1 = require_generic_transformers();
  exports.transformArguments = transformArguments;
});

// node_modules/@redis/client/dist/lib/commands/CLUSTER_ADDSLOTSRANGE.js
var require_CLUSTER_ADDSLOTSRANGE = __commonJS((exports) => {
  var transformArguments = function(ranges) {
    return (0, generic_transformers_1.pushSlotRangesArguments)(["CLUSTER", "ADDSLOTSRANGE"], ranges);
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.transformArguments = undefined;
  var generic_transformers_1 = require_generic_transformers();
  exports.transformArguments = transformArguments;
});

// node_modules/@redis/client/dist/lib/commands/CLUSTER_BUMPEPOCH.js
var require_CLUSTER_BUMPEPOCH = __commonJS((exports) => {
  var transformArguments = function() {
    return ["CLUSTER", "BUMPEPOCH"];
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.transformArguments = undefined;
  exports.transformArguments = transformArguments;
});

// node_modules/@redis/client/dist/lib/commands/CLUSTER_COUNT-FAILURE-REPORTS.js
var require_CLUSTER_COUNT_FAILURE_REPORTS = __commonJS((exports) => {
  var transformArguments = function(nodeId) {
    return ["CLUSTER", "COUNT-FAILURE-REPORTS", nodeId];
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.transformArguments = undefined;
  exports.transformArguments = transformArguments;
});

// node_modules/@redis/client/dist/lib/commands/CLUSTER_COUNTKEYSINSLOT.js
var require_CLUSTER_COUNTKEYSINSLOT = __commonJS((exports) => {
  var transformArguments = function(slot) {
    return ["CLUSTER", "COUNTKEYSINSLOT", slot.toString()];
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.transformArguments = undefined;
  exports.transformArguments = transformArguments;
});

// node_modules/@redis/client/dist/lib/commands/CLUSTER_DELSLOTS.js
var require_CLUSTER_DELSLOTS = __commonJS((exports) => {
  var transformArguments = function(slots) {
    return (0, generic_transformers_1.pushVerdictNumberArguments)(["CLUSTER", "DELSLOTS"], slots);
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.transformArguments = undefined;
  var generic_transformers_1 = require_generic_transformers();
  exports.transformArguments = transformArguments;
});

// node_modules/@redis/client/dist/lib/commands/CLUSTER_DELSLOTSRANGE.js
var require_CLUSTER_DELSLOTSRANGE = __commonJS((exports) => {
  var transformArguments = function(ranges) {
    return (0, generic_transformers_1.pushSlotRangesArguments)(["CLUSTER", "DELSLOTSRANGE"], ranges);
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.transformArguments = undefined;
  var generic_transformers_1 = require_generic_transformers();
  exports.transformArguments = transformArguments;
});

// node_modules/@redis/client/dist/lib/commands/CLUSTER_FAILOVER.js
var require_CLUSTER_FAILOVER = __commonJS((exports) => {
  var transformArguments = function(mode) {
    const args = ["CLUSTER", "FAILOVER"];
    if (mode) {
      args.push(mode);
    }
    return args;
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.transformArguments = exports.FailoverModes = undefined;
  var FailoverModes;
  (function(FailoverModes2) {
    FailoverModes2["FORCE"] = "FORCE";
    FailoverModes2["TAKEOVER"] = "TAKEOVER";
  })(FailoverModes || (exports.FailoverModes = FailoverModes = {}));
  exports.transformArguments = transformArguments;
});

// node_modules/@redis/client/dist/lib/commands/CLUSTER_FLUSHSLOTS.js
var require_CLUSTER_FLUSHSLOTS = __commonJS((exports) => {
  var transformArguments = function() {
    return ["CLUSTER", "FLUSHSLOTS"];
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.transformArguments = undefined;
  exports.transformArguments = transformArguments;
});

// node_modules/@redis/client/dist/lib/commands/CLUSTER_FORGET.js
var require_CLUSTER_FORGET = __commonJS((exports) => {
  var transformArguments = function(nodeId) {
    return ["CLUSTER", "FORGET", nodeId];
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.transformArguments = undefined;
  exports.transformArguments = transformArguments;
});

// node_modules/@redis/client/dist/lib/commands/CLUSTER_GETKEYSINSLOT.js
var require_CLUSTER_GETKEYSINSLOT = __commonJS((exports) => {
  var transformArguments = function(slot, count) {
    return ["CLUSTER", "GETKEYSINSLOT", slot.toString(), count.toString()];
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.transformArguments = undefined;
  exports.transformArguments = transformArguments;
});

// node_modules/@redis/client/dist/lib/commands/CLUSTER_INFO.js
var require_CLUSTER_INFO = __commonJS((exports) => {
  var transformArguments = function() {
    return ["CLUSTER", "INFO"];
  };
  var transformReply = function(reply) {
    const lines = reply.split("\r\n");
    return {
      state: extractLineValue(lines[0]),
      slots: {
        assigned: Number(extractLineValue(lines[1])),
        ok: Number(extractLineValue(lines[2])),
        pfail: Number(extractLineValue(lines[3])),
        fail: Number(extractLineValue(lines[4]))
      },
      knownNodes: Number(extractLineValue(lines[5])),
      size: Number(extractLineValue(lines[6])),
      currentEpoch: Number(extractLineValue(lines[7])),
      myEpoch: Number(extractLineValue(lines[8])),
      stats: {
        messagesSent: Number(extractLineValue(lines[9])),
        messagesReceived: Number(extractLineValue(lines[10]))
      }
    };
  };
  var extractLineValue = function(line) {
    return line.substring(line.indexOf(":") + 1);
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.extractLineValue = exports.transformReply = exports.transformArguments = undefined;
  exports.transformArguments = transformArguments;
  exports.transformReply = transformReply;
  exports.extractLineValue = extractLineValue;
});

// node_modules/@redis/client/dist/lib/commands/CLUSTER_KEYSLOT.js
var require_CLUSTER_KEYSLOT = __commonJS((exports) => {
  var transformArguments = function(key) {
    return ["CLUSTER", "KEYSLOT", key];
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.transformArguments = undefined;
  exports.transformArguments = transformArguments;
});

// node_modules/@redis/client/dist/lib/commands/CLUSTER_LINKS.js
var require_CLUSTER_LINKS = __commonJS((exports) => {
  var transformArguments = function() {
    return ["CLUSTER", "LINKS"];
  };
  var transformReply = function(reply) {
    return reply.map((peerLink) => ({
      direction: peerLink[1],
      node: peerLink[3],
      createTime: Number(peerLink[5]),
      events: peerLink[7],
      sendBufferAllocated: Number(peerLink[9]),
      sendBufferUsed: Number(peerLink[11])
    }));
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.transformReply = exports.transformArguments = undefined;
  exports.transformArguments = transformArguments;
  exports.transformReply = transformReply;
});

// node_modules/@redis/client/dist/lib/commands/CLUSTER_MEET.js
var require_CLUSTER_MEET = __commonJS((exports) => {
  var transformArguments = function(ip, port) {
    return ["CLUSTER", "MEET", ip, port.toString()];
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.transformArguments = undefined;
  exports.transformArguments = transformArguments;
});

// node_modules/@redis/client/dist/lib/commands/CLUSTER_MYID.js
var require_CLUSTER_MYID = __commonJS((exports) => {
  var transformArguments = function() {
    return ["CLUSTER", "MYID"];
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.transformArguments = undefined;
  exports.transformArguments = transformArguments;
});

// node_modules/@redis/client/dist/lib/commands/CLUSTER_NODES.js
var require_CLUSTER_NODES = __commonJS((exports) => {
  var transformArguments = function() {
    return ["CLUSTER", "NODES"];
  };
  var transformReply = function(reply) {
    const lines = reply.split("\n");
    lines.pop();
    const mastersMap = new Map, replicasMap = new Map;
    for (const line of lines) {
      const [id, address, flags3, masterId, pingSent, pongRecv, configEpoch, linkState, ...slots] = line.split(" "), node4 = {
        id,
        address,
        ...transformNodeAddress(address),
        flags: flags3.split(","),
        pingSent: Number(pingSent),
        pongRecv: Number(pongRecv),
        configEpoch: Number(configEpoch),
        linkState
      };
      if (masterId === "-") {
        let replicas = replicasMap.get(id);
        if (!replicas) {
          replicas = [];
          replicasMap.set(id, replicas);
        }
        mastersMap.set(id, {
          ...node4,
          slots: slots.map((slot) => {
            const [fromString, toString] = slot.split("-", 2), from = Number(fromString);
            return {
              from,
              to: toString ? Number(toString) : from
            };
          }),
          replicas
        });
      } else {
        const replicas = replicasMap.get(masterId);
        if (!replicas) {
          replicasMap.set(masterId, [node4]);
        } else {
          replicas.push(node4);
        }
      }
    }
    return [...mastersMap.values()];
  };
  var transformNodeAddress = function(address) {
    const indexOfColon = address.lastIndexOf(":"), indexOfAt = address.indexOf("@", indexOfColon), host = address.substring(0, indexOfColon);
    if (indexOfAt === -1) {
      return {
        host,
        port: Number(address.substring(indexOfColon + 1)),
        cport: null
      };
    }
    return {
      host: address.substring(0, indexOfColon),
      port: Number(address.substring(indexOfColon + 1, indexOfAt)),
      cport: Number(address.substring(indexOfAt + 1))
    };
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.transformReply = exports.RedisClusterNodeLinkStates = exports.transformArguments = undefined;
  exports.transformArguments = transformArguments;
  var RedisClusterNodeLinkStates;
  (function(RedisClusterNodeLinkStates2) {
    RedisClusterNodeLinkStates2["CONNECTED"] = "connected";
    RedisClusterNodeLinkStates2["DISCONNECTED"] = "disconnected";
  })(RedisClusterNodeLinkStates || (exports.RedisClusterNodeLinkStates = RedisClusterNodeLinkStates = {}));
  exports.transformReply = transformReply;
});

// node_modules/@redis/client/dist/lib/commands/CLUSTER_REPLICAS.js
var require_CLUSTER_REPLICAS = __commonJS((exports) => {
  var transformArguments = function(nodeId) {
    return ["CLUSTER", "REPLICAS", nodeId];
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.transformReply = exports.transformArguments = undefined;
  exports.transformArguments = transformArguments;
  var CLUSTER_NODES_1 = require_CLUSTER_NODES();
  Object.defineProperty(exports, "transformReply", { enumerable: true, get: function() {
    return CLUSTER_NODES_1.transformReply;
  } });
});

// node_modules/@redis/client/dist/lib/commands/CLUSTER_REPLICATE.js
var require_CLUSTER_REPLICATE = __commonJS((exports) => {
  var transformArguments = function(nodeId) {
    return ["CLUSTER", "REPLICATE", nodeId];
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.transformArguments = undefined;
  exports.transformArguments = transformArguments;
});

// node_modules/@redis/client/dist/lib/commands/CLUSTER_RESET.js
var require_CLUSTER_RESET = __commonJS((exports) => {
  var transformArguments = function(mode) {
    const args = ["CLUSTER", "RESET"];
    if (mode) {
      args.push(mode);
    }
    return args;
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.transformArguments = undefined;
  exports.transformArguments = transformArguments;
});

// node_modules/@redis/client/dist/lib/commands/CLUSTER_SAVECONFIG.js
var require_CLUSTER_SAVECONFIG = __commonJS((exports) => {
  var transformArguments = function() {
    return ["CLUSTER", "SAVECONFIG"];
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.transformArguments = undefined;
  exports.transformArguments = transformArguments;
});

// node_modules/@redis/client/dist/lib/commands/CLUSTER_SET-CONFIG-EPOCH.js
var require_CLUSTER_SET_CONFIG_EPOCH = __commonJS((exports) => {
  var transformArguments = function(configEpoch) {
    return ["CLUSTER", "SET-CONFIG-EPOCH", configEpoch.toString()];
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.transformArguments = undefined;
  exports.transformArguments = transformArguments;
});

// node_modules/@redis/client/dist/lib/commands/CLUSTER_SETSLOT.js
var require_CLUSTER_SETSLOT = __commonJS((exports) => {
  var transformArguments = function(slot, state, nodeId) {
    const args = ["CLUSTER", "SETSLOT", slot.toString(), state];
    if (nodeId) {
      args.push(nodeId);
    }
    return args;
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.transformArguments = exports.ClusterSlotStates = undefined;
  var ClusterSlotStates;
  (function(ClusterSlotStates2) {
    ClusterSlotStates2["IMPORTING"] = "IMPORTING";
    ClusterSlotStates2["MIGRATING"] = "MIGRATING";
    ClusterSlotStates2["STABLE"] = "STABLE";
    ClusterSlotStates2["NODE"] = "NODE";
  })(ClusterSlotStates || (exports.ClusterSlotStates = ClusterSlotStates = {}));
  exports.transformArguments = transformArguments;
});

// node_modules/@redis/client/dist/lib/commands/CLUSTER_SLOTS.js
var require_CLUSTER_SLOTS = __commonJS((exports) => {
  var transformArguments = function() {
    return ["CLUSTER", "SLOTS"];
  };
  var transformReply = function(reply) {
    return reply.map(([from, to, master, ...replicas]) => {
      return {
        from,
        to,
        master: transformNode(master),
        replicas: replicas.map(transformNode)
      };
    });
  };
  var transformNode = function([ip, port, id]) {
    return {
      ip,
      port,
      id
    };
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.transformReply = exports.transformArguments = undefined;
  exports.transformArguments = transformArguments;
  exports.transformReply = transformReply;
});

// node_modules/@redis/client/dist/lib/commands/COMMAND_COUNT.js
var require_COMMAND_COUNT = __commonJS((exports) => {
  var transformArguments = function() {
    return ["COMMAND", "COUNT"];
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.transformArguments = exports.IS_READ_ONLY = undefined;
  exports.IS_READ_ONLY = true;
  exports.transformArguments = transformArguments;
});

// node_modules/@redis/client/dist/lib/commands/COMMAND_GETKEYS.js
var require_COMMAND_GETKEYS = __commonJS((exports) => {
  var transformArguments = function(args) {
    return ["COMMAND", "GETKEYS", ...args];
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.transformArguments = exports.IS_READ_ONLY = undefined;
  exports.IS_READ_ONLY = true;
  exports.transformArguments = transformArguments;
});

// node_modules/@redis/client/dist/lib/commands/COMMAND_GETKEYSANDFLAGS.js
var require_COMMAND_GETKEYSANDFLAGS = __commonJS((exports) => {
  var transformArguments = function(args) {
    return ["COMMAND", "GETKEYSANDFLAGS", ...args];
  };
  var transformReply = function(reply) {
    return reply.map(([key, flags3]) => ({
      key,
      flags: flags3
    }));
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.transformReply = exports.transformArguments = exports.IS_READ_ONLY = undefined;
  exports.IS_READ_ONLY = true;
  exports.transformArguments = transformArguments;
  exports.transformReply = transformReply;
});

// node_modules/@redis/client/dist/lib/commands/COMMAND_INFO.js
var require_COMMAND_INFO = __commonJS((exports) => {
  var transformArguments = function(commands) {
    return ["COMMAND", "INFO", ...commands];
  };
  var transformReply = function(reply) {
    return reply.map((command) => command ? (0, generic_transformers_1.transformCommandReply)(command) : null);
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.transformReply = exports.transformArguments = exports.IS_READ_ONLY = undefined;
  var generic_transformers_1 = require_generic_transformers();
  exports.IS_READ_ONLY = true;
  exports.transformArguments = transformArguments;
  exports.transformReply = transformReply;
});

// node_modules/@redis/client/dist/lib/commands/COMMAND_LIST.js
var require_COMMAND_LIST = __commonJS((exports) => {
  var transformArguments = function(filter) {
    const args = ["COMMAND", "LIST"];
    if (filter) {
      args.push("FILTERBY", filter.filterBy, filter.value);
    }
    return args;
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.transformArguments = exports.FilterBy = exports.IS_READ_ONLY = undefined;
  exports.IS_READ_ONLY = true;
  var FilterBy;
  (function(FilterBy2) {
    FilterBy2["MODULE"] = "MODULE";
    FilterBy2["ACLCAT"] = "ACLCAT";
    FilterBy2["PATTERN"] = "PATTERN";
  })(FilterBy || (exports.FilterBy = FilterBy = {}));
  exports.transformArguments = transformArguments;
});

// node_modules/@redis/client/dist/lib/commands/COMMAND.js
var require_COMMAND = __commonJS((exports) => {
  var transformArguments = function() {
    return ["COMMAND"];
  };
  var transformReply = function(reply) {
    return reply.map(generic_transformers_1.transformCommandReply);
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.transformReply = exports.transformArguments = exports.IS_READ_ONLY = undefined;
  var generic_transformers_1 = require_generic_transformers();
  exports.IS_READ_ONLY = true;
  exports.transformArguments = transformArguments;
  exports.transformReply = transformReply;
});

// node_modules/@redis/client/dist/lib/commands/CONFIG_GET.js
var require_CONFIG_GET = __commonJS((exports) => {
  var transformArguments = function(parameter) {
    return ["CONFIG", "GET", parameter];
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.transformReply = exports.transformArguments = undefined;
  exports.transformArguments = transformArguments;
  var generic_transformers_1 = require_generic_transformers();
  Object.defineProperty(exports, "transformReply", { enumerable: true, get: function() {
    return generic_transformers_1.transformTuplesReply;
  } });
});

// node_modules/@redis/client/dist/lib/commands/CONFIG_RESETSTAT.js
var require_CONFIG_RESETSTAT = __commonJS((exports) => {
  var transformArguments = function() {
    return ["CONFIG", "RESETSTAT"];
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.transformArguments = undefined;
  exports.transformArguments = transformArguments;
});

// node_modules/@redis/client/dist/lib/commands/CONFIG_REWRITE.js
var require_CONFIG_REWRITE = __commonJS((exports) => {
  var transformArguments = function() {
    return ["CONFIG", "REWRITE"];
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.transformArguments = undefined;
  exports.transformArguments = transformArguments;
});

// node_modules/@redis/client/dist/lib/commands/CONFIG_SET.js
var require_CONFIG_SET = __commonJS((exports) => {
  var transformArguments = function(...[parameterOrConfig, value]) {
    const args = ["CONFIG", "SET"];
    if (typeof parameterOrConfig === "string") {
      args.push(parameterOrConfig, value);
    } else {
      for (const [key, value2] of Object.entries(parameterOrConfig)) {
        args.push(key, value2);
      }
    }
    return args;
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.transformArguments = undefined;
  exports.transformArguments = transformArguments;
});

// node_modules/@redis/client/dist/lib/commands/DBSIZE.js
var require_DBSIZE = __commonJS((exports) => {
  var transformArguments = function() {
    return ["DBSIZE"];
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.transformArguments = exports.IS_READ_ONLY = undefined;
  exports.IS_READ_ONLY = true;
  exports.transformArguments = transformArguments;
});

// node_modules/@redis/client/dist/lib/commands/DISCARD.js
var require_DISCARD = __commonJS((exports) => {
  var transformArguments = function() {
    return ["DISCARD"];
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.transformArguments = undefined;
  exports.transformArguments = transformArguments;
});

// node_modules/@redis/client/dist/lib/commands/ECHO.js
var require_ECHO = __commonJS((exports) => {
  var transformArguments = function(message2) {
    return ["ECHO", message2];
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.transformArguments = exports.IS_READ_ONLY = undefined;
  exports.IS_READ_ONLY = true;
  exports.transformArguments = transformArguments;
});

// node_modules/@redis/client/dist/lib/commands/FAILOVER.js
var require_FAILOVER = __commonJS((exports) => {
  var transformArguments = function(options) {
    const args = ["FAILOVER"];
    if (options?.TO) {
      args.push("TO", options.TO.host, options.TO.port.toString());
      if (options.TO.FORCE) {
        args.push("FORCE");
      }
    }
    if (options?.ABORT) {
      args.push("ABORT");
    }
    if (options?.TIMEOUT) {
      args.push("TIMEOUT", options.TIMEOUT.toString());
    }
    return args;
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.transformArguments = undefined;
  exports.transformArguments = transformArguments;
});

// node_modules/@redis/client/dist/lib/commands/FLUSHALL.js
var require_FLUSHALL = __commonJS((exports) => {
  var transformArguments = function(mode) {
    const args = ["FLUSHALL"];
    if (mode) {
      args.push(mode);
    }
    return args;
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.transformArguments = exports.RedisFlushModes = undefined;
  var RedisFlushModes;
  (function(RedisFlushModes2) {
    RedisFlushModes2["ASYNC"] = "ASYNC";
    RedisFlushModes2["SYNC"] = "SYNC";
  })(RedisFlushModes || (exports.RedisFlushModes = RedisFlushModes = {}));
  exports.transformArguments = transformArguments;
});

// node_modules/@redis/client/dist/lib/commands/FLUSHDB.js
var require_FLUSHDB = __commonJS((exports) => {
  var transformArguments = function(mode) {
    const args = ["FLUSHDB"];
    if (mode) {
      args.push(mode);
    }
    return args;
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.transformArguments = undefined;
  exports.transformArguments = transformArguments;
});

// node_modules/@redis/client/dist/lib/commands/FUNCTION_DELETE.js
var require_FUNCTION_DELETE = __commonJS((exports) => {
  var transformArguments = function(library) {
    return ["FUNCTION", "DELETE", library];
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.transformArguments = undefined;
  exports.transformArguments = transformArguments;
});

// node_modules/@redis/client/dist/lib/commands/FUNCTION_DUMP.js
var require_FUNCTION_DUMP = __commonJS((exports) => {
  var transformArguments = function() {
    return ["FUNCTION", "DUMP"];
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.transformArguments = undefined;
  exports.transformArguments = transformArguments;
});

// node_modules/@redis/client/dist/lib/commands/FUNCTION_FLUSH.js
var require_FUNCTION_FLUSH = __commonJS((exports) => {
  var transformArguments = function(mode) {
    const args = ["FUNCTION", "FLUSH"];
    if (mode) {
      args.push(mode);
    }
    return args;
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.transformArguments = undefined;
  exports.transformArguments = transformArguments;
});

// node_modules/@redis/client/dist/lib/commands/FUNCTION_KILL.js
var require_FUNCTION_KILL = __commonJS((exports) => {
  var transformArguments = function() {
    return ["FUNCTION", "KILL"];
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.transformArguments = undefined;
  exports.transformArguments = transformArguments;
});

// node_modules/@redis/client/dist/lib/commands/FUNCTION_LIST.js
var require_FUNCTION_LIST = __commonJS((exports) => {
  var transformArguments = function(pattern) {
    const args = ["FUNCTION", "LIST"];
    if (pattern) {
      args.push(pattern);
    }
    return args;
  };
  var transformReply = function(reply) {
    return reply.map(generic_transformers_1.transformFunctionListItemReply);
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.transformReply = exports.transformArguments = undefined;
  var generic_transformers_1 = require_generic_transformers();
  exports.transformArguments = transformArguments;
  exports.transformReply = transformReply;
});

// node_modules/@redis/client/dist/lib/commands/FUNCTION_LIST_WITHCODE.js
var require_FUNCTION_LIST_WITHCODE = __commonJS((exports) => {
  var transformArguments = function(pattern) {
    const args = (0, FUNCTION_LIST_1.transformArguments)(pattern);
    args.push("WITHCODE");
    return args;
  };
  var transformReply = function(reply) {
    return reply.map((library) => ({
      ...(0, generic_transformers_1.transformFunctionListItemReply)(library),
      libraryCode: library[7]
    }));
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.transformReply = exports.transformArguments = undefined;
  var FUNCTION_LIST_1 = require_FUNCTION_LIST();
  var generic_transformers_1 = require_generic_transformers();
  exports.transformArguments = transformArguments;
  exports.transformReply = transformReply;
});

// node_modules/@redis/client/dist/lib/commands/FUNCTION_LOAD.js
var require_FUNCTION_LOAD = __commonJS((exports) => {
  var transformArguments = function(code, options) {
    const args = ["FUNCTION", "LOAD"];
    if (options?.REPLACE) {
      args.push("REPLACE");
    }
    args.push(code);
    return args;
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.transformArguments = undefined;
  exports.transformArguments = transformArguments;
});

// node_modules/@redis/client/dist/lib/commands/FUNCTION_RESTORE.js
var require_FUNCTION_RESTORE = __commonJS((exports) => {
  var transformArguments = function(dump, mode) {
    const args = ["FUNCTION", "RESTORE", dump];
    if (mode) {
      args.push(mode);
    }
    return args;
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.transformArguments = undefined;
  exports.transformArguments = transformArguments;
});

// node_modules/@redis/client/dist/lib/commands/FUNCTION_STATS.js
var require_FUNCTION_STATS = __commonJS((exports) => {
  var transformArguments = function() {
    return ["FUNCTION", "STATS"];
  };
  var transformReply = function(reply) {
    const engines = Object.create(null);
    for (let i = 0;i < reply[3].length; i++) {
      engines[reply[3][i]] = {
        librariesCount: reply[3][++i][1],
        functionsCount: reply[3][i][3]
      };
    }
    return {
      runningScript: reply[1] === null ? null : {
        name: reply[1][1],
        command: reply[1][3],
        durationMs: reply[1][5]
      },
      engines
    };
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.transformReply = exports.transformArguments = undefined;
  exports.transformArguments = transformArguments;
  exports.transformReply = transformReply;
});

// node_modules/@redis/client/dist/lib/commands/HELLO.js
var require_HELLO = __commonJS((exports) => {
  var transformArguments = function(options) {
    const args = ["HELLO"];
    if (options) {
      args.push(options.protover.toString());
      if (options.auth) {
        args.push("AUTH", options.auth.username, options.auth.password);
      }
      if (options.clientName) {
        args.push("SETNAME", options.clientName);
      }
    }
    return args;
  };
  var transformReply = function(reply) {
    return {
      server: reply[1],
      version: reply[3],
      proto: reply[5],
      id: reply[7],
      mode: reply[9],
      role: reply[11],
      modules: reply[13]
    };
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.transformReply = exports.transformArguments = undefined;
  exports.transformArguments = transformArguments;
  exports.transformReply = transformReply;
});

// node_modules/@redis/client/dist/lib/commands/INFO.js
var require_INFO = __commonJS((exports) => {
  var transformArguments = function(section) {
    const args = ["INFO"];
    if (section) {
      args.push(section);
    }
    return args;
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.transformArguments = exports.IS_READ_ONLY = undefined;
  exports.IS_READ_ONLY = true;
  exports.transformArguments = transformArguments;
});

// node_modules/@redis/client/dist/lib/commands/KEYS.js
var require_KEYS = __commonJS((exports) => {
  var transformArguments = function(pattern) {
    return ["KEYS", pattern];
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.transformArguments = undefined;
  exports.transformArguments = transformArguments;
});

// node_modules/@redis/client/dist/lib/commands/LASTSAVE.js
var require_LASTSAVE = __commonJS((exports) => {
  var transformArguments = function() {
    return ["LASTSAVE"];
  };
  var transformReply = function(reply) {
    return new Date(reply);
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.transformReply = exports.transformArguments = exports.IS_READ_ONLY = undefined;
  exports.IS_READ_ONLY = true;
  exports.transformArguments = transformArguments;
  exports.transformReply = transformReply;
});

// node_modules/@redis/client/dist/lib/commands/LATENCY_DOCTOR.js
var require_LATENCY_DOCTOR = __commonJS((exports) => {
  var transformArguments = function() {
    return ["LATENCY", "DOCTOR"];
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.transformArguments = undefined;
  exports.transformArguments = transformArguments;
});

// node_modules/@redis/client/dist/lib/commands/LATENCY_GRAPH.js
var require_LATENCY_GRAPH = __commonJS((exports) => {
  var transformArguments = function(event) {
    return ["LATENCY", "GRAPH", event];
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.transformArguments = undefined;
  exports.transformArguments = transformArguments;
});

// node_modules/@redis/client/dist/lib/commands/LATENCY_LATEST.js
var require_LATENCY_LATEST = __commonJS((exports) => {
  var transformArguments = function() {
    return ["LATENCY", "LATEST"];
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.transformArguments = undefined;
  exports.transformArguments = transformArguments;
});

// node_modules/@redis/client/dist/lib/commands/LOLWUT.js
var require_LOLWUT = __commonJS((exports) => {
  var transformArguments = function(version2, ...optionalArguments) {
    const args = ["LOLWUT"];
    if (version2) {
      args.push("VERSION", version2.toString(), ...optionalArguments.map(String));
    }
    return args;
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.transformArguments = exports.IS_READ_ONLY = undefined;
  exports.IS_READ_ONLY = true;
  exports.transformArguments = transformArguments;
});

// node_modules/@redis/client/dist/lib/commands/MEMORY_DOCTOR.js
var require_MEMORY_DOCTOR = __commonJS((exports) => {
  var transformArguments = function() {
    return ["MEMORY", "DOCTOR"];
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.transformArguments = undefined;
  exports.transformArguments = transformArguments;
});

// node_modules/@redis/client/dist/lib/commands/MEMORY_MALLOC-STATS.js
var require_MEMORY_MALLOC_STATS = __commonJS((exports) => {
  var transformArguments = function() {
    return ["MEMORY", "MALLOC-STATS"];
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.transformArguments = undefined;
  exports.transformArguments = transformArguments;
});

// node_modules/@redis/client/dist/lib/commands/MEMORY_PURGE.js
var require_MEMORY_PURGE = __commonJS((exports) => {
  var transformArguments = function() {
    return ["MEMORY", "PURGE"];
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.transformArguments = undefined;
  exports.transformArguments = transformArguments;
});

// node_modules/@redis/client/dist/lib/commands/MEMORY_STATS.js
var require_MEMORY_STATS = __commonJS((exports) => {
  var transformArguments = function() {
    return ["MEMORY", "STATS"];
  };
  var transformReply = function(rawReply) {
    const reply = {
      db: {}
    };
    for (let i = 0;i < rawReply.length; i += 2) {
      const key = rawReply[i];
      if (key.startsWith("db.")) {
        const dbTuples = rawReply[i + 1], db2 = {};
        for (let j = 0;j < dbTuples.length; j += 2) {
          db2[DB_FIELDS_MAPPING[dbTuples[j]]] = dbTuples[j + 1];
        }
        reply.db[key.substring(3)] = db2;
        continue;
      }
      reply[FIELDS_MAPPING[key]] = Number(rawReply[i + 1]);
    }
    return reply;
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.transformReply = exports.transformArguments = undefined;
  exports.transformArguments = transformArguments;
  var FIELDS_MAPPING = {
    "peak.allocated": "peakAllocated",
    "total.allocated": "totalAllocated",
    "startup.allocated": "startupAllocated",
    "replication.backlog": "replicationBacklog",
    "clients.slaves": "clientsReplicas",
    "clients.normal": "clientsNormal",
    "aof.buffer": "aofBuffer",
    "lua.caches": "luaCaches",
    "overhead.total": "overheadTotal",
    "keys.count": "keysCount",
    "keys.bytes-per-key": "keysBytesPerKey",
    "dataset.bytes": "datasetBytes",
    "dataset.percentage": "datasetPercentage",
    "peak.percentage": "peakPercentage",
    "allocator.allocated": "allocatorAllocated",
    "allocator.active": "allocatorActive",
    "allocator.resident": "allocatorResident",
    "allocator-fragmentation.ratio": "allocatorFragmentationRatio",
    "allocator-fragmentation.bytes": "allocatorFragmentationBytes",
    "allocator-rss.ratio": "allocatorRssRatio",
    "allocator-rss.bytes": "allocatorRssBytes",
    "rss-overhead.ratio": "rssOverheadRatio",
    "rss-overhead.bytes": "rssOverheadBytes",
    fragmentation: "fragmentation",
    "fragmentation.bytes": "fragmentationBytes"
  };
  var DB_FIELDS_MAPPING = {
    "overhead.hashtable.main": "overheadHashtableMain",
    "overhead.hashtable.expires": "overheadHashtableExpires"
  };
  exports.transformReply = transformReply;
});

// node_modules/@redis/client/dist/lib/commands/MEMORY_USAGE.js
var require_MEMORY_USAGE = __commonJS((exports) => {
  var transformArguments = function(key, options) {
    const args = ["MEMORY", "USAGE", key];
    if (options?.SAMPLES) {
      args.push("SAMPLES", options.SAMPLES.toString());
    }
    return args;
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.transformArguments = exports.IS_READ_ONLY = exports.FIRST_KEY_INDEX = undefined;
  exports.FIRST_KEY_INDEX = 1;
  exports.IS_READ_ONLY = true;
  exports.transformArguments = transformArguments;
});

// node_modules/@redis/client/dist/lib/commands/MODULE_LIST.js
var require_MODULE_LIST = __commonJS((exports) => {
  var transformArguments = function() {
    return ["MODULE", "LIST"];
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.transformArguments = undefined;
  exports.transformArguments = transformArguments;
});

// node_modules/@redis/client/dist/lib/commands/MODULE_LOAD.js
var require_MODULE_LOAD = __commonJS((exports) => {
  var transformArguments = function(path, moduleArgs) {
    const args = ["MODULE", "LOAD", path];
    if (moduleArgs) {
      args.push(...moduleArgs);
    }
    return args;
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.transformArguments = undefined;
  exports.transformArguments = transformArguments;
});

// node_modules/@redis/client/dist/lib/commands/MODULE_UNLOAD.js
var require_MODULE_UNLOAD = __commonJS((exports) => {
  var transformArguments = function(name) {
    return ["MODULE", "UNLOAD", name];
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.transformArguments = undefined;
  exports.transformArguments = transformArguments;
});

// node_modules/@redis/client/dist/lib/commands/MOVE.js
var require_MOVE = __commonJS((exports) => {
  var transformArguments = function(key, db2) {
    return ["MOVE", key, db2.toString()];
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.transformReply = exports.transformArguments = exports.FIRST_KEY_INDEX = undefined;
  exports.FIRST_KEY_INDEX = 1;
  exports.transformArguments = transformArguments;
  var generic_transformers_1 = require_generic_transformers();
  Object.defineProperty(exports, "transformReply", { enumerable: true, get: function() {
    return generic_transformers_1.transformBooleanReply;
  } });
});

// node_modules/@redis/client/dist/lib/commands/PING.js
var require_PING = __commonJS((exports) => {
  var transformArguments = function(message2) {
    const args = ["PING"];
    if (message2) {
      args.push(message2);
    }
    return args;
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.transformArguments = undefined;
  exports.transformArguments = transformArguments;
});

// node_modules/@redis/client/dist/lib/commands/PUBSUB_CHANNELS.js
var require_PUBSUB_CHANNELS = __commonJS((exports) => {
  var transformArguments = function(pattern) {
    const args = ["PUBSUB", "CHANNELS"];
    if (pattern) {
      args.push(pattern);
    }
    return args;
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.transformArguments = exports.IS_READ_ONLY = undefined;
  exports.IS_READ_ONLY = true;
  exports.transformArguments = transformArguments;
});

// node_modules/@redis/client/dist/lib/commands/PUBSUB_NUMPAT.js
var require_PUBSUB_NUMPAT = __commonJS((exports) => {
  var transformArguments = function() {
    return ["PUBSUB", "NUMPAT"];
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.transformArguments = exports.IS_READ_ONLY = undefined;
  exports.IS_READ_ONLY = true;
  exports.transformArguments = transformArguments;
});

// node_modules/@redis/client/dist/lib/commands/PUBSUB_NUMSUB.js
var require_PUBSUB_NUMSUB = __commonJS((exports) => {
  var transformArguments = function(channels) {
    const args = ["PUBSUB", "NUMSUB"];
    if (channels)
      return (0, generic_transformers_1.pushVerdictArguments)(args, channels);
    return args;
  };
  var transformReply = function(rawReply) {
    const transformedReply = Object.create(null);
    for (let i = 0;i < rawReply.length; i += 2) {
      transformedReply[rawReply[i]] = rawReply[i + 1];
    }
    return transformedReply;
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.transformReply = exports.transformArguments = exports.IS_READ_ONLY = undefined;
  var generic_transformers_1 = require_generic_transformers();
  exports.IS_READ_ONLY = true;
  exports.transformArguments = transformArguments;
  exports.transformReply = transformReply;
});

// node_modules/@redis/client/dist/lib/commands/PUBSUB_SHARDCHANNELS.js
var require_PUBSUB_SHARDCHANNELS = __commonJS((exports) => {
  var transformArguments = function(pattern) {
    const args = ["PUBSUB", "SHARDCHANNELS"];
    if (pattern)
      args.push(pattern);
    return args;
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.transformArguments = exports.IS_READ_ONLY = undefined;
  exports.IS_READ_ONLY = true;
  exports.transformArguments = transformArguments;
});

// node_modules/@redis/client/dist/lib/commands/RANDOMKEY.js
var require_RANDOMKEY = __commonJS((exports) => {
  var transformArguments = function() {
    return ["RANDOMKEY"];
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.transformArguments = exports.IS_READ_ONLY = undefined;
  exports.IS_READ_ONLY = true;
  exports.transformArguments = transformArguments;
});

// node_modules/@redis/client/dist/lib/commands/READONLY.js
var require_READONLY = __commonJS((exports) => {
  var transformArguments = function() {
    return ["READONLY"];
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.transformArguments = undefined;
  exports.transformArguments = transformArguments;
});

// node_modules/@redis/client/dist/lib/commands/READWRITE.js
var require_READWRITE = __commonJS((exports) => {
  var transformArguments = function() {
    return ["READWRITE"];
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.transformArguments = undefined;
  exports.transformArguments = transformArguments;
});

// node_modules/@redis/client/dist/lib/commands/REPLICAOF.js
var require_REPLICAOF = __commonJS((exports) => {
  var transformArguments = function(host, port) {
    return ["REPLICAOF", host, port.toString()];
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.transformArguments = undefined;
  exports.transformArguments = transformArguments;
});

// node_modules/@redis/client/dist/lib/commands/RESTORE-ASKING.js
var require_RESTORE_ASKING = __commonJS((exports) => {
  var transformArguments = function() {
    return ["RESTORE-ASKING"];
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.transformArguments = undefined;
  exports.transformArguments = transformArguments;
});

// node_modules/@redis/client/dist/lib/commands/ROLE.js
var require_ROLE = __commonJS((exports) => {
  var transformArguments = function() {
    return ["ROLE"];
  };
  var transformReply = function(reply) {
    switch (reply[0]) {
      case "master":
        return {
          role: "master",
          replicationOffest: reply[1],
          replicas: reply[2].map(([ip, port, replicationOffest]) => ({
            ip,
            port: Number(port),
            replicationOffest: Number(replicationOffest)
          }))
        };
      case "slave":
        return {
          role: "slave",
          master: {
            ip: reply[1],
            port: reply[2]
          },
          state: reply[3],
          dataReceived: reply[4]
        };
      case "sentinel":
        return {
          role: "sentinel",
          masterNames: reply[1]
        };
    }
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.transformReply = exports.transformArguments = exports.IS_READ_ONLY = undefined;
  exports.IS_READ_ONLY = true;
  exports.transformArguments = transformArguments;
  exports.transformReply = transformReply;
});

// node_modules/@redis/client/dist/lib/commands/SAVE.js
var require_SAVE = __commonJS((exports) => {
  var transformArguments = function() {
    return ["SAVE"];
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.transformArguments = undefined;
  exports.transformArguments = transformArguments;
});

// node_modules/@redis/client/dist/lib/commands/SCAN.js
var require_SCAN = __commonJS((exports) => {
  var transformArguments = function(cursor, options) {
    const args = (0, generic_transformers_1.pushScanArguments)(["SCAN"], cursor, options);
    if (options?.TYPE) {
      args.push("TYPE", options.TYPE);
    }
    return args;
  };
  var transformReply = function([cursor, keys]) {
    return {
      cursor: Number(cursor),
      keys
    };
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.transformReply = exports.transformArguments = exports.IS_READ_ONLY = undefined;
  var generic_transformers_1 = require_generic_transformers();
  exports.IS_READ_ONLY = true;
  exports.transformArguments = transformArguments;
  exports.transformReply = transformReply;
});

// node_modules/@redis/client/dist/lib/commands/SCRIPT_DEBUG.js
var require_SCRIPT_DEBUG = __commonJS((exports) => {
  var transformArguments = function(mode) {
    return ["SCRIPT", "DEBUG", mode];
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.transformArguments = undefined;
  exports.transformArguments = transformArguments;
});

// node_modules/@redis/client/dist/lib/commands/SCRIPT_EXISTS.js
var require_SCRIPT_EXISTS = __commonJS((exports) => {
  var transformArguments = function(sha1) {
    return (0, generic_transformers_1.pushVerdictArguments)(["SCRIPT", "EXISTS"], sha1);
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.transformReply = exports.transformArguments = undefined;
  var generic_transformers_1 = require_generic_transformers();
  exports.transformArguments = transformArguments;
  var generic_transformers_2 = require_generic_transformers();
  Object.defineProperty(exports, "transformReply", { enumerable: true, get: function() {
    return generic_transformers_2.transformBooleanArrayReply;
  } });
});

// node_modules/@redis/client/dist/lib/commands/SCRIPT_FLUSH.js
var require_SCRIPT_FLUSH = __commonJS((exports) => {
  var transformArguments = function(mode) {
    const args = ["SCRIPT", "FLUSH"];
    if (mode) {
      args.push(mode);
    }
    return args;
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.transformArguments = undefined;
  exports.transformArguments = transformArguments;
});

// node_modules/@redis/client/dist/lib/commands/SCRIPT_KILL.js
var require_SCRIPT_KILL = __commonJS((exports) => {
  var transformArguments = function() {
    return ["SCRIPT", "KILL"];
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.transformArguments = undefined;
  exports.transformArguments = transformArguments;
});

// node_modules/@redis/client/dist/lib/commands/SCRIPT_LOAD.js
var require_SCRIPT_LOAD = __commonJS((exports) => {
  var transformArguments = function(script) {
    return ["SCRIPT", "LOAD", script];
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.transformArguments = undefined;
  exports.transformArguments = transformArguments;
});

// node_modules/@redis/client/dist/lib/commands/SHUTDOWN.js
var require_SHUTDOWN = __commonJS((exports) => {
  var transformArguments = function(mode) {
    const args = ["SHUTDOWN"];
    if (mode) {
      args.push(mode);
    }
    return args;
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.transformArguments = undefined;
  exports.transformArguments = transformArguments;
});

// node_modules/@redis/client/dist/lib/commands/SWAPDB.js
var require_SWAPDB = __commonJS((exports) => {
  var transformArguments = function(index1, index2) {
    return ["SWAPDB", index1.toString(), index2.toString()];
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.transformArguments = undefined;
  exports.transformArguments = transformArguments;
});

// node_modules/@redis/client/dist/lib/commands/TIME.js
var require_TIME = __commonJS((exports) => {
  var transformArguments = function() {
    return ["TIME"];
  };
  var transformReply = function(reply) {
    const seconds = Number(reply[0]), microseconds = Number(reply[1]), d = new Date(seconds * 1000 + microseconds / 1000);
    d.microseconds = microseconds;
    return d;
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.transformReply = exports.transformArguments = undefined;
  exports.transformArguments = transformArguments;
  exports.transformReply = transformReply;
});

// node_modules/@redis/client/dist/lib/commands/UNWATCH.js
var require_UNWATCH = __commonJS((exports) => {
  var transformArguments = function() {
    return ["UNWATCH"];
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.transformArguments = undefined;
  exports.transformArguments = transformArguments;
});

// node_modules/@redis/client/dist/lib/commands/WAIT.js
var require_WAIT = __commonJS((exports) => {
  var transformArguments = function(numberOfReplicas, timeout) {
    return ["WAIT", numberOfReplicas.toString(), timeout.toString()];
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.transformArguments = exports.FIRST_KEY_INDEX = undefined;
  exports.FIRST_KEY_INDEX = 1;
  exports.transformArguments = transformArguments;
});

// node_modules/@redis/client/dist/lib/client/commands.js
var require_commands3 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  var commands_1 = require_commands2();
  var ACL_CAT = require_ACL_CAT();
  var ACL_DELUSER = require_ACL_DELUSER();
  var ACL_DRYRUN = require_ACL_DRYRUN();
  var ACL_GENPASS = require_ACL_GENPASS();
  var ACL_GETUSER = require_ACL_GETUSER();
  var ACL_LIST = require_ACL_LIST();
  var ACL_LOAD = require_ACL_LOAD();
  var ACL_LOG_RESET = require_ACL_LOG_RESET();
  var ACL_LOG = require_ACL_LOG();
  var ACL_SAVE = require_ACL_SAVE();
  var ACL_SETUSER = require_ACL_SETUSER();
  var ACL_USERS = require_ACL_USERS();
  var ACL_WHOAMI = require_ACL_WHOAMI();
  var ASKING = require_ASKING();
  var AUTH = require_AUTH();
  var BGREWRITEAOF = require_BGREWRITEAOF();
  var BGSAVE = require_BGSAVE();
  var CLIENT_CACHING = require_CLIENT_CACHING();
  var CLIENT_GETNAME = require_CLIENT_GETNAME();
  var CLIENT_GETREDIR = require_CLIENT_GETREDIR();
  var CLIENT_ID = require_CLIENT_ID();
  var CLIENT_KILL = require_CLIENT_KILL();
  var CLIENT_LIST = require_CLIENT_LIST();
  var CLIENT_NO_EVICT = require_CLIENT_NO_EVICT();
  var CLIENT_PAUSE = require_CLIENT_PAUSE();
  var CLIENT_SETNAME = require_CLIENT_SETNAME();
  var CLIENT_TRACKING = require_CLIENT_TRACKING();
  var CLIENT_TRACKINGINFO = require_CLIENT_TRACKINGINFO();
  var CLIENT_UNPAUSE = require_CLIENT_UNPAUSE();
  var CLIENT_INFO = require_CLIENT_INFO();
  var CLUSTER_ADDSLOTS = require_CLUSTER_ADDSLOTS();
  var CLUSTER_ADDSLOTSRANGE = require_CLUSTER_ADDSLOTSRANGE();
  var CLUSTER_BUMPEPOCH = require_CLUSTER_BUMPEPOCH();
  var CLUSTER_COUNT_FAILURE_REPORTS = require_CLUSTER_COUNT_FAILURE_REPORTS();
  var CLUSTER_COUNTKEYSINSLOT = require_CLUSTER_COUNTKEYSINSLOT();
  var CLUSTER_DELSLOTS = require_CLUSTER_DELSLOTS();
  var CLUSTER_DELSLOTSRANGE = require_CLUSTER_DELSLOTSRANGE();
  var CLUSTER_FAILOVER = require_CLUSTER_FAILOVER();
  var CLUSTER_FLUSHSLOTS = require_CLUSTER_FLUSHSLOTS();
  var CLUSTER_FORGET = require_CLUSTER_FORGET();
  var CLUSTER_GETKEYSINSLOT = require_CLUSTER_GETKEYSINSLOT();
  var CLUSTER_INFO = require_CLUSTER_INFO();
  var CLUSTER_KEYSLOT = require_CLUSTER_KEYSLOT();
  var CLUSTER_LINKS = require_CLUSTER_LINKS();
  var CLUSTER_MEET = require_CLUSTER_MEET();
  var CLUSTER_MYID = require_CLUSTER_MYID();
  var CLUSTER_NODES = require_CLUSTER_NODES();
  var CLUSTER_REPLICAS = require_CLUSTER_REPLICAS();
  var CLUSTER_REPLICATE = require_CLUSTER_REPLICATE();
  var CLUSTER_RESET = require_CLUSTER_RESET();
  var CLUSTER_SAVECONFIG = require_CLUSTER_SAVECONFIG();
  var CLUSTER_SET_CONFIG_EPOCH = require_CLUSTER_SET_CONFIG_EPOCH();
  var CLUSTER_SETSLOT = require_CLUSTER_SETSLOT();
  var CLUSTER_SLOTS = require_CLUSTER_SLOTS();
  var COMMAND_COUNT = require_COMMAND_COUNT();
  var COMMAND_GETKEYS = require_COMMAND_GETKEYS();
  var COMMAND_GETKEYSANDFLAGS = require_COMMAND_GETKEYSANDFLAGS();
  var COMMAND_INFO = require_COMMAND_INFO();
  var COMMAND_LIST = require_COMMAND_LIST();
  var COMMAND = require_COMMAND();
  var CONFIG_GET = require_CONFIG_GET();
  var CONFIG_RESETASTAT = require_CONFIG_RESETSTAT();
  var CONFIG_REWRITE = require_CONFIG_REWRITE();
  var CONFIG_SET = require_CONFIG_SET();
  var DBSIZE = require_DBSIZE();
  var DISCARD = require_DISCARD();
  var ECHO = require_ECHO();
  var FAILOVER = require_FAILOVER();
  var FLUSHALL = require_FLUSHALL();
  var FLUSHDB = require_FLUSHDB();
  var FUNCTION_DELETE = require_FUNCTION_DELETE();
  var FUNCTION_DUMP = require_FUNCTION_DUMP();
  var FUNCTION_FLUSH = require_FUNCTION_FLUSH();
  var FUNCTION_KILL = require_FUNCTION_KILL();
  var FUNCTION_LIST_WITHCODE = require_FUNCTION_LIST_WITHCODE();
  var FUNCTION_LIST = require_FUNCTION_LIST();
  var FUNCTION_LOAD = require_FUNCTION_LOAD();
  var FUNCTION_RESTORE = require_FUNCTION_RESTORE();
  var FUNCTION_STATS = require_FUNCTION_STATS();
  var HELLO = require_HELLO();
  var INFO = require_INFO();
  var KEYS = require_KEYS();
  var LASTSAVE = require_LASTSAVE();
  var LATENCY_DOCTOR = require_LATENCY_DOCTOR();
  var LATENCY_GRAPH = require_LATENCY_GRAPH();
  var LATENCY_LATEST = require_LATENCY_LATEST();
  var LOLWUT = require_LOLWUT();
  var MEMORY_DOCTOR = require_MEMORY_DOCTOR();
  var MEMORY_MALLOC_STATS = require_MEMORY_MALLOC_STATS();
  var MEMORY_PURGE = require_MEMORY_PURGE();
  var MEMORY_STATS = require_MEMORY_STATS();
  var MEMORY_USAGE = require_MEMORY_USAGE();
  var MODULE_LIST = require_MODULE_LIST();
  var MODULE_LOAD = require_MODULE_LOAD();
  var MODULE_UNLOAD = require_MODULE_UNLOAD();
  var MOVE = require_MOVE();
  var PING = require_PING();
  var PUBSUB_CHANNELS = require_PUBSUB_CHANNELS();
  var PUBSUB_NUMPAT = require_PUBSUB_NUMPAT();
  var PUBSUB_NUMSUB = require_PUBSUB_NUMSUB();
  var PUBSUB_SHARDCHANNELS = require_PUBSUB_SHARDCHANNELS();
  var RANDOMKEY = require_RANDOMKEY();
  var READONLY = require_READONLY();
  var READWRITE = require_READWRITE();
  var REPLICAOF = require_REPLICAOF();
  var RESTORE_ASKING = require_RESTORE_ASKING();
  var ROLE = require_ROLE();
  var SAVE = require_SAVE();
  var SCAN = require_SCAN();
  var SCRIPT_DEBUG = require_SCRIPT_DEBUG();
  var SCRIPT_EXISTS = require_SCRIPT_EXISTS();
  var SCRIPT_FLUSH = require_SCRIPT_FLUSH();
  var SCRIPT_KILL = require_SCRIPT_KILL();
  var SCRIPT_LOAD = require_SCRIPT_LOAD();
  var SHUTDOWN = require_SHUTDOWN();
  var SWAPDB = require_SWAPDB();
  var TIME = require_TIME();
  var UNWATCH = require_UNWATCH();
  var WAIT = require_WAIT();
  exports.default = {
    ...commands_1.default,
    ACL_CAT,
    aclCat: ACL_CAT,
    ACL_DELUSER,
    aclDelUser: ACL_DELUSER,
    ACL_DRYRUN,
    aclDryRun: ACL_DRYRUN,
    ACL_GENPASS,
    aclGenPass: ACL_GENPASS,
    ACL_GETUSER,
    aclGetUser: ACL_GETUSER,
    ACL_LIST,
    aclList: ACL_LIST,
    ACL_LOAD,
    aclLoad: ACL_LOAD,
    ACL_LOG_RESET,
    aclLogReset: ACL_LOG_RESET,
    ACL_LOG,
    aclLog: ACL_LOG,
    ACL_SAVE,
    aclSave: ACL_SAVE,
    ACL_SETUSER,
    aclSetUser: ACL_SETUSER,
    ACL_USERS,
    aclUsers: ACL_USERS,
    ACL_WHOAMI,
    aclWhoAmI: ACL_WHOAMI,
    ASKING,
    asking: ASKING,
    AUTH,
    auth: AUTH,
    BGREWRITEAOF,
    bgRewriteAof: BGREWRITEAOF,
    BGSAVE,
    bgSave: BGSAVE,
    CLIENT_CACHING,
    clientCaching: CLIENT_CACHING,
    CLIENT_GETNAME,
    clientGetName: CLIENT_GETNAME,
    CLIENT_GETREDIR,
    clientGetRedir: CLIENT_GETREDIR,
    CLIENT_ID,
    clientId: CLIENT_ID,
    CLIENT_KILL,
    clientKill: CLIENT_KILL,
    "CLIENT_NO-EVICT": CLIENT_NO_EVICT,
    clientNoEvict: CLIENT_NO_EVICT,
    CLIENT_LIST,
    clientList: CLIENT_LIST,
    CLIENT_PAUSE,
    clientPause: CLIENT_PAUSE,
    CLIENT_SETNAME,
    clientSetName: CLIENT_SETNAME,
    CLIENT_TRACKING,
    clientTracking: CLIENT_TRACKING,
    CLIENT_TRACKINGINFO,
    clientTrackingInfo: CLIENT_TRACKINGINFO,
    CLIENT_UNPAUSE,
    clientUnpause: CLIENT_UNPAUSE,
    CLIENT_INFO,
    clientInfo: CLIENT_INFO,
    CLUSTER_ADDSLOTS,
    clusterAddSlots: CLUSTER_ADDSLOTS,
    CLUSTER_ADDSLOTSRANGE,
    clusterAddSlotsRange: CLUSTER_ADDSLOTSRANGE,
    CLUSTER_BUMPEPOCH,
    clusterBumpEpoch: CLUSTER_BUMPEPOCH,
    CLUSTER_COUNT_FAILURE_REPORTS,
    clusterCountFailureReports: CLUSTER_COUNT_FAILURE_REPORTS,
    CLUSTER_COUNTKEYSINSLOT,
    clusterCountKeysInSlot: CLUSTER_COUNTKEYSINSLOT,
    CLUSTER_DELSLOTS,
    clusterDelSlots: CLUSTER_DELSLOTS,
    CLUSTER_DELSLOTSRANGE,
    clusterDelSlotsRange: CLUSTER_DELSLOTSRANGE,
    CLUSTER_FAILOVER,
    clusterFailover: CLUSTER_FAILOVER,
    CLUSTER_FLUSHSLOTS,
    clusterFlushSlots: CLUSTER_FLUSHSLOTS,
    CLUSTER_FORGET,
    clusterForget: CLUSTER_FORGET,
    CLUSTER_GETKEYSINSLOT,
    clusterGetKeysInSlot: CLUSTER_GETKEYSINSLOT,
    CLUSTER_INFO,
    clusterInfo: CLUSTER_INFO,
    CLUSTER_KEYSLOT,
    clusterKeySlot: CLUSTER_KEYSLOT,
    CLUSTER_LINKS,
    clusterLinks: CLUSTER_LINKS,
    CLUSTER_MEET,
    clusterMeet: CLUSTER_MEET,
    CLUSTER_MYID,
    clusterMyId: CLUSTER_MYID,
    CLUSTER_NODES,
    clusterNodes: CLUSTER_NODES,
    CLUSTER_REPLICAS,
    clusterReplicas: CLUSTER_REPLICAS,
    CLUSTER_REPLICATE,
    clusterReplicate: CLUSTER_REPLICATE,
    CLUSTER_RESET,
    clusterReset: CLUSTER_RESET,
    CLUSTER_SAVECONFIG,
    clusterSaveConfig: CLUSTER_SAVECONFIG,
    CLUSTER_SET_CONFIG_EPOCH,
    clusterSetConfigEpoch: CLUSTER_SET_CONFIG_EPOCH,
    CLUSTER_SETSLOT,
    clusterSetSlot: CLUSTER_SETSLOT,
    CLUSTER_SLOTS,
    clusterSlots: CLUSTER_SLOTS,
    COMMAND_COUNT,
    commandCount: COMMAND_COUNT,
    COMMAND_GETKEYS,
    commandGetKeys: COMMAND_GETKEYS,
    COMMAND_GETKEYSANDFLAGS,
    commandGetKeysAndFlags: COMMAND_GETKEYSANDFLAGS,
    COMMAND_INFO,
    commandInfo: COMMAND_INFO,
    COMMAND_LIST,
    commandList: COMMAND_LIST,
    COMMAND,
    command: COMMAND,
    CONFIG_GET,
    configGet: CONFIG_GET,
    CONFIG_RESETASTAT,
    configResetStat: CONFIG_RESETASTAT,
    CONFIG_REWRITE,
    configRewrite: CONFIG_REWRITE,
    CONFIG_SET,
    configSet: CONFIG_SET,
    DBSIZE,
    dbSize: DBSIZE,
    DISCARD,
    discard: DISCARD,
    ECHO,
    echo: ECHO,
    FAILOVER,
    failover: FAILOVER,
    FLUSHALL,
    flushAll: FLUSHALL,
    FLUSHDB,
    flushDb: FLUSHDB,
    FUNCTION_DELETE,
    functionDelete: FUNCTION_DELETE,
    FUNCTION_DUMP,
    functionDump: FUNCTION_DUMP,
    FUNCTION_FLUSH,
    functionFlush: FUNCTION_FLUSH,
    FUNCTION_KILL,
    functionKill: FUNCTION_KILL,
    FUNCTION_LIST_WITHCODE,
    functionListWithCode: FUNCTION_LIST_WITHCODE,
    FUNCTION_LIST,
    functionList: FUNCTION_LIST,
    FUNCTION_LOAD,
    functionLoad: FUNCTION_LOAD,
    FUNCTION_RESTORE,
    functionRestore: FUNCTION_RESTORE,
    FUNCTION_STATS,
    functionStats: FUNCTION_STATS,
    HELLO,
    hello: HELLO,
    INFO,
    info: INFO,
    KEYS,
    keys: KEYS,
    LASTSAVE,
    lastSave: LASTSAVE,
    LATENCY_DOCTOR,
    latencyDoctor: LATENCY_DOCTOR,
    LATENCY_GRAPH,
    latencyGraph: LATENCY_GRAPH,
    LATENCY_LATEST,
    latencyLatest: LATENCY_LATEST,
    LOLWUT,
    lolwut: LOLWUT,
    MEMORY_DOCTOR,
    memoryDoctor: MEMORY_DOCTOR,
    "MEMORY_MALLOC-STATS": MEMORY_MALLOC_STATS,
    memoryMallocStats: MEMORY_MALLOC_STATS,
    MEMORY_PURGE,
    memoryPurge: MEMORY_PURGE,
    MEMORY_STATS,
    memoryStats: MEMORY_STATS,
    MEMORY_USAGE,
    memoryUsage: MEMORY_USAGE,
    MODULE_LIST,
    moduleList: MODULE_LIST,
    MODULE_LOAD,
    moduleLoad: MODULE_LOAD,
    MODULE_UNLOAD,
    moduleUnload: MODULE_UNLOAD,
    MOVE,
    move: MOVE,
    PING,
    ping: PING,
    PUBSUB_CHANNELS,
    pubSubChannels: PUBSUB_CHANNELS,
    PUBSUB_NUMPAT,
    pubSubNumPat: PUBSUB_NUMPAT,
    PUBSUB_NUMSUB,
    pubSubNumSub: PUBSUB_NUMSUB,
    PUBSUB_SHARDCHANNELS,
    pubSubShardChannels: PUBSUB_SHARDCHANNELS,
    RANDOMKEY,
    randomKey: RANDOMKEY,
    READONLY,
    readonly: READONLY,
    READWRITE,
    readwrite: READWRITE,
    REPLICAOF,
    replicaOf: REPLICAOF,
    "RESTORE-ASKING": RESTORE_ASKING,
    restoreAsking: RESTORE_ASKING,
    ROLE,
    role: ROLE,
    SAVE,
    save: SAVE,
    SCAN,
    scan: SCAN,
    SCRIPT_DEBUG,
    scriptDebug: SCRIPT_DEBUG,
    SCRIPT_EXISTS,
    scriptExists: SCRIPT_EXISTS,
    SCRIPT_FLUSH,
    scriptFlush: SCRIPT_FLUSH,
    SCRIPT_KILL,
    scriptKill: SCRIPT_KILL,
    SCRIPT_LOAD,
    scriptLoad: SCRIPT_LOAD,
    SHUTDOWN,
    shutdown: SHUTDOWN,
    SWAPDB,
    swapDb: SWAPDB,
    TIME,
    time: TIME,
    UNWATCH,
    unwatch: UNWATCH,
    WAIT,
    wait: WAIT
  };
});

// node_modules/@redis/client/dist/lib/errors.js
var require_errors3 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.ErrorReply = exports.ReconnectStrategyError = exports.RootNodesUnavailableError = exports.SocketClosedUnexpectedlyError = exports.DisconnectsClientError = exports.ClientOfflineError = exports.ClientClosedError = exports.ConnectionTimeoutError = exports.WatchError = exports.AbortError = undefined;

  class AbortError extends Error {
    constructor() {
      super("The command was aborted");
    }
  }
  exports.AbortError = AbortError;

  class WatchError extends Error {
    constructor() {
      super("One (or more) of the watched keys has been changed");
    }
  }
  exports.WatchError = WatchError;

  class ConnectionTimeoutError extends Error {
    constructor() {
      super("Connection timeout");
    }
  }
  exports.ConnectionTimeoutError = ConnectionTimeoutError;

  class ClientClosedError extends Error {
    constructor() {
      super("The client is closed");
    }
  }
  exports.ClientClosedError = ClientClosedError;

  class ClientOfflineError extends Error {
    constructor() {
      super("The client is offline");
    }
  }
  exports.ClientOfflineError = ClientOfflineError;

  class DisconnectsClientError extends Error {
    constructor() {
      super("Disconnects client");
    }
  }
  exports.DisconnectsClientError = DisconnectsClientError;

  class SocketClosedUnexpectedlyError extends Error {
    constructor() {
      super("Socket closed unexpectedly");
    }
  }
  exports.SocketClosedUnexpectedlyError = SocketClosedUnexpectedlyError;

  class RootNodesUnavailableError extends Error {
    constructor() {
      super("All the root nodes are unavailable");
    }
  }
  exports.RootNodesUnavailableError = RootNodesUnavailableError;

  class ReconnectStrategyError extends Error {
    constructor(originalError, socketError) {
      super(originalError.message);
      Object.defineProperty(this, "originalError", {
        enumerable: true,
        configurable: true,
        writable: true,
        value: undefined
      });
      Object.defineProperty(this, "socketError", {
        enumerable: true,
        configurable: true,
        writable: true,
        value: undefined
      });
      this.originalError = originalError;
      this.socketError = socketError;
    }
  }
  exports.ReconnectStrategyError = ReconnectStrategyError;

  class ErrorReply extends Error {
    constructor(message2) {
      super(message2);
      this.stack = undefined;
    }
  }
  exports.ErrorReply = ErrorReply;
});

// node_modules/@redis/client/dist/lib/utils.js
var require_utils3 = __commonJS((exports) => {
  var promiseTimeout = function(ms) {
    return new Promise((resolve) => setTimeout(resolve, ms));
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.promiseTimeout = undefined;
  exports.promiseTimeout = promiseTimeout;
});

// node_modules/@redis/client/dist/lib/client/socket.js
var require_socket = __commonJS((exports) => {
  var __classPrivateFieldGet = exports && exports.__classPrivateFieldGet || function(receiver, state, kind, f) {
    if (kind === "a" && !f)
      throw new TypeError("Private accessor was defined without a getter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver))
      throw new TypeError("Cannot read private member from an object whose class did not declare it");
    return kind === "m" ? f : kind === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
  };
  var __classPrivateFieldSet = exports && exports.__classPrivateFieldSet || function(receiver, state, value, kind, f) {
    if (kind === "m")
      throw new TypeError("Private method is not writable");
    if (kind === "a" && !f)
      throw new TypeError("Private accessor was defined without a setter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver))
      throw new TypeError("Cannot write private member to an object whose class did not declare it");
    return kind === "a" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value), value;
  };
  var _RedisSocket_instances;
  var _a;
  var _RedisSocket_initiateOptions;
  var _RedisSocket_isTlsSocket;
  var _RedisSocket_initiator;
  var _RedisSocket_options;
  var _RedisSocket_socket;
  var _RedisSocket_isOpen;
  var _RedisSocket_isReady;
  var _RedisSocket_writableNeedDrain;
  var _RedisSocket_isSocketUnrefed;
  var _RedisSocket_reconnectStrategy;
  var _RedisSocket_shouldReconnect;
  var _RedisSocket_connect;
  var _RedisSocket_createSocket;
  var _RedisSocket_createNetSocket;
  var _RedisSocket_createTlsSocket;
  var _RedisSocket_onSocketError;
  var _RedisSocket_disconnect;
  var _RedisSocket_isCorked;
  Object.defineProperty(exports, "__esModule", { value: true });
  var events_1 = __require("events");
  var net2 = __require("net");
  var tls2 = __require("tls");
  var errors_1 = require_errors3();
  var utils_1 = require_utils3();

  class RedisSocket extends events_1.EventEmitter {
    get isOpen() {
      return __classPrivateFieldGet(this, _RedisSocket_isOpen, "f");
    }
    get isReady() {
      return __classPrivateFieldGet(this, _RedisSocket_isReady, "f");
    }
    get writableNeedDrain() {
      return __classPrivateFieldGet(this, _RedisSocket_writableNeedDrain, "f");
    }
    constructor(initiator, options) {
      super();
      _RedisSocket_instances.add(this);
      _RedisSocket_initiator.set(this, undefined);
      _RedisSocket_options.set(this, undefined);
      _RedisSocket_socket.set(this, undefined);
      _RedisSocket_isOpen.set(this, false);
      _RedisSocket_isReady.set(this, false);
      _RedisSocket_writableNeedDrain.set(this, false);
      _RedisSocket_isSocketUnrefed.set(this, false);
      _RedisSocket_isCorked.set(this, false);
      __classPrivateFieldSet(this, _RedisSocket_initiator, initiator, "f");
      __classPrivateFieldSet(this, _RedisSocket_options, __classPrivateFieldGet(RedisSocket, _a, "m", _RedisSocket_initiateOptions).call(RedisSocket, options), "f");
    }
    async connect() {
      if (__classPrivateFieldGet(this, _RedisSocket_isOpen, "f")) {
        throw new Error("Socket already opened");
      }
      __classPrivateFieldSet(this, _RedisSocket_isOpen, true, "f");
      return __classPrivateFieldGet(this, _RedisSocket_instances, "m", _RedisSocket_connect).call(this);
    }
    writeCommand(args) {
      if (!__classPrivateFieldGet(this, _RedisSocket_socket, "f")) {
        throw new errors_1.ClientClosedError;
      }
      for (const toWrite of args) {
        __classPrivateFieldSet(this, _RedisSocket_writableNeedDrain, !__classPrivateFieldGet(this, _RedisSocket_socket, "f").write(toWrite), "f");
      }
    }
    disconnect() {
      if (!__classPrivateFieldGet(this, _RedisSocket_isOpen, "f")) {
        throw new errors_1.ClientClosedError;
      }
      __classPrivateFieldSet(this, _RedisSocket_isOpen, false, "f");
      __classPrivateFieldGet(this, _RedisSocket_instances, "m", _RedisSocket_disconnect).call(this);
    }
    async quit(fn) {
      if (!__classPrivateFieldGet(this, _RedisSocket_isOpen, "f")) {
        throw new errors_1.ClientClosedError;
      }
      __classPrivateFieldSet(this, _RedisSocket_isOpen, false, "f");
      const reply = await fn();
      __classPrivateFieldGet(this, _RedisSocket_instances, "m", _RedisSocket_disconnect).call(this);
      return reply;
    }
    cork() {
      if (!__classPrivateFieldGet(this, _RedisSocket_socket, "f") || __classPrivateFieldGet(this, _RedisSocket_isCorked, "f")) {
        return;
      }
      __classPrivateFieldGet(this, _RedisSocket_socket, "f").cork();
      __classPrivateFieldSet(this, _RedisSocket_isCorked, true, "f");
      setImmediate(() => {
        __classPrivateFieldGet(this, _RedisSocket_socket, "f")?.uncork();
        __classPrivateFieldSet(this, _RedisSocket_isCorked, false, "f");
      });
    }
    ref() {
      __classPrivateFieldSet(this, _RedisSocket_isSocketUnrefed, false, "f");
      __classPrivateFieldGet(this, _RedisSocket_socket, "f")?.ref();
    }
    unref() {
      __classPrivateFieldSet(this, _RedisSocket_isSocketUnrefed, true, "f");
      __classPrivateFieldGet(this, _RedisSocket_socket, "f")?.unref();
    }
  }
  _a = RedisSocket, _RedisSocket_initiator = new WeakMap, _RedisSocket_options = new WeakMap, _RedisSocket_socket = new WeakMap, _RedisSocket_isOpen = new WeakMap, _RedisSocket_isReady = new WeakMap, _RedisSocket_writableNeedDrain = new WeakMap, _RedisSocket_isSocketUnrefed = new WeakMap, _RedisSocket_isCorked = new WeakMap, _RedisSocket_instances = new WeakSet, _RedisSocket_initiateOptions = function _RedisSocket_initiateOptions(options) {
    var _b, _c;
    options ?? (options = {});
    if (!options.path) {
      (_b = options).port ?? (_b.port = 6379);
      (_c = options).host ?? (_c.host = "localhost");
    }
    options.connectTimeout ?? (options.connectTimeout = 5000);
    options.keepAlive ?? (options.keepAlive = 5000);
    options.noDelay ?? (options.noDelay = true);
    return options;
  }, _RedisSocket_isTlsSocket = function _RedisSocket_isTlsSocket(options) {
    return options.tls === true;
  }, _RedisSocket_reconnectStrategy = function _RedisSocket_reconnectStrategy(retries, cause) {
    if (__classPrivateFieldGet(this, _RedisSocket_options, "f").reconnectStrategy === false) {
      return false;
    } else if (typeof __classPrivateFieldGet(this, _RedisSocket_options, "f").reconnectStrategy === "number") {
      return __classPrivateFieldGet(this, _RedisSocket_options, "f").reconnectStrategy;
    } else if (__classPrivateFieldGet(this, _RedisSocket_options, "f").reconnectStrategy) {
      try {
        const retryIn = __classPrivateFieldGet(this, _RedisSocket_options, "f").reconnectStrategy(retries, cause);
        if (retryIn !== false && !(retryIn instanceof Error) && typeof retryIn !== "number") {
          throw new TypeError(`Reconnect strategy should return \`false | Error | number\`, got ${retryIn} instead`);
        }
        return retryIn;
      } catch (err) {
        this.emit("error", err);
      }
    }
    return Math.min(retries * 50, 500);
  }, _RedisSocket_shouldReconnect = function _RedisSocket_shouldReconnect(retries, cause) {
    const retryIn = __classPrivateFieldGet(this, _RedisSocket_instances, "m", _RedisSocket_reconnectStrategy).call(this, retries, cause);
    if (retryIn === false) {
      __classPrivateFieldSet(this, _RedisSocket_isOpen, false, "f");
      this.emit("error", cause);
      return cause;
    } else if (retryIn instanceof Error) {
      __classPrivateFieldSet(this, _RedisSocket_isOpen, false, "f");
      this.emit("error", cause);
      return new errors_1.ReconnectStrategyError(retryIn, cause);
    }
    return retryIn;
  }, _RedisSocket_connect = async function _RedisSocket_connect() {
    let retries = 0;
    do {
      try {
        __classPrivateFieldSet(this, _RedisSocket_socket, await __classPrivateFieldGet(this, _RedisSocket_instances, "m", _RedisSocket_createSocket).call(this), "f");
        __classPrivateFieldSet(this, _RedisSocket_writableNeedDrain, false, "f");
        this.emit("connect");
        try {
          await __classPrivateFieldGet(this, _RedisSocket_initiator, "f").call(this);
        } catch (err) {
          __classPrivateFieldGet(this, _RedisSocket_socket, "f").destroy();
          __classPrivateFieldSet(this, _RedisSocket_socket, undefined, "f");
          throw err;
        }
        __classPrivateFieldSet(this, _RedisSocket_isReady, true, "f");
        this.emit("ready");
      } catch (err) {
        const retryIn = __classPrivateFieldGet(this, _RedisSocket_instances, "m", _RedisSocket_shouldReconnect).call(this, retries++, err);
        if (typeof retryIn !== "number") {
          throw retryIn;
        }
        this.emit("error", err);
        await (0, utils_1.promiseTimeout)(retryIn);
        this.emit("reconnecting");
      }
    } while (__classPrivateFieldGet(this, _RedisSocket_isOpen, "f") && !__classPrivateFieldGet(this, _RedisSocket_isReady, "f"));
  }, _RedisSocket_createSocket = function _RedisSocket_createSocket() {
    return new Promise((resolve, reject) => {
      const { connectEvent, socket } = __classPrivateFieldGet(RedisSocket, _a, "m", _RedisSocket_isTlsSocket).call(RedisSocket, __classPrivateFieldGet(this, _RedisSocket_options, "f")) ? __classPrivateFieldGet(this, _RedisSocket_instances, "m", _RedisSocket_createTlsSocket).call(this) : __classPrivateFieldGet(this, _RedisSocket_instances, "m", _RedisSocket_createNetSocket).call(this);
      if (__classPrivateFieldGet(this, _RedisSocket_options, "f").connectTimeout) {
        socket.setTimeout(__classPrivateFieldGet(this, _RedisSocket_options, "f").connectTimeout, () => socket.destroy(new errors_1.ConnectionTimeoutError));
      }
      if (__classPrivateFieldGet(this, _RedisSocket_isSocketUnrefed, "f")) {
        socket.unref();
      }
      socket.setNoDelay(__classPrivateFieldGet(this, _RedisSocket_options, "f").noDelay).once("error", reject).once(connectEvent, () => {
        socket.setTimeout(0).setKeepAlive(__classPrivateFieldGet(this, _RedisSocket_options, "f").keepAlive !== false, __classPrivateFieldGet(this, _RedisSocket_options, "f").keepAlive || 0).off("error", reject).once("error", (err) => __classPrivateFieldGet(this, _RedisSocket_instances, "m", _RedisSocket_onSocketError).call(this, err)).once("close", (hadError) => {
          if (!hadError && __classPrivateFieldGet(this, _RedisSocket_isReady, "f") && __classPrivateFieldGet(this, _RedisSocket_socket, "f") === socket) {
            __classPrivateFieldGet(this, _RedisSocket_instances, "m", _RedisSocket_onSocketError).call(this, new errors_1.SocketClosedUnexpectedlyError);
          }
        }).on("drain", () => {
          __classPrivateFieldSet(this, _RedisSocket_writableNeedDrain, false, "f");
          this.emit("drain");
        }).on("data", (data) => this.emit("data", data));
        resolve(socket);
      });
    });
  }, _RedisSocket_createNetSocket = function _RedisSocket_createNetSocket() {
    return {
      connectEvent: "connect",
      socket: net2.connect(__classPrivateFieldGet(this, _RedisSocket_options, "f"))
    };
  }, _RedisSocket_createTlsSocket = function _RedisSocket_createTlsSocket() {
    return {
      connectEvent: "secureConnect",
      socket: tls2.connect(__classPrivateFieldGet(this, _RedisSocket_options, "f"))
    };
  }, _RedisSocket_onSocketError = function _RedisSocket_onSocketError(err) {
    __classPrivateFieldSet(this, _RedisSocket_isReady, false, "f");
    this.emit("error", err);
    if (!__classPrivateFieldGet(this, _RedisSocket_isOpen, "f") || typeof __classPrivateFieldGet(this, _RedisSocket_instances, "m", _RedisSocket_shouldReconnect).call(this, 0, err) !== "number")
      return;
    this.emit("reconnecting");
    __classPrivateFieldGet(this, _RedisSocket_instances, "m", _RedisSocket_connect).call(this).catch(() => {
    });
  }, _RedisSocket_disconnect = function _RedisSocket_disconnect() {
    __classPrivateFieldSet(this, _RedisSocket_isReady, false, "f");
    if (__classPrivateFieldGet(this, _RedisSocket_socket, "f")) {
      __classPrivateFieldGet(this, _RedisSocket_socket, "f").destroy();
      __classPrivateFieldSet(this, _RedisSocket_socket, undefined, "f");
    }
    this.emit("end");
  };
  exports.default = RedisSocket;
});

// node_modules/yallist/iterator.js
var require_iterator = __commonJS((exports, module) => {
  module.exports = function(Yallist) {
    Yallist.prototype[Symbol.iterator] = function* () {
      for (let walker = this.head;walker; walker = walker.next) {
        yield walker.value;
      }
    };
  };
});

// node_modules/yallist/yallist.js
var require_yallist = __commonJS((exports, module) => {
  var Yallist = function(list) {
    var self2 = this;
    if (!(self2 instanceof Yallist)) {
      self2 = new Yallist;
    }
    self2.tail = null;
    self2.head = null;
    self2.length = 0;
    if (list && typeof list.forEach === "function") {
      list.forEach(function(item) {
        self2.push(item);
      });
    } else if (arguments.length > 0) {
      for (var i = 0, l = arguments.length;i < l; i++) {
        self2.push(arguments[i]);
      }
    }
    return self2;
  };
  var insert = function(self2, node4, value) {
    var inserted = node4 === self2.head ? new Node3(value, null, node4, self2) : new Node3(value, node4, node4.next, self2);
    if (inserted.next === null) {
      self2.tail = inserted;
    }
    if (inserted.prev === null) {
      self2.head = inserted;
    }
    self2.length++;
    return inserted;
  };
  var push = function(self2, item) {
    self2.tail = new Node3(item, self2.tail, null, self2);
    if (!self2.head) {
      self2.head = self2.tail;
    }
    self2.length++;
  };
  var unshift = function(self2, item) {
    self2.head = new Node3(item, null, self2.head, self2);
    if (!self2.tail) {
      self2.tail = self2.head;
    }
    self2.length++;
  };
  var Node3 = function(value, prev, next, list) {
    if (!(this instanceof Node3)) {
      return new Node3(value, prev, next, list);
    }
    this.list = list;
    this.value = value;
    if (prev) {
      prev.next = this;
      this.prev = prev;
    } else {
      this.prev = null;
    }
    if (next) {
      next.prev = this;
      this.next = next;
    } else {
      this.next = null;
    }
  };
  module.exports = Yallist;
  Yallist.Node = Node3;
  Yallist.create = Yallist;
  Yallist.prototype.removeNode = function(node4) {
    if (node4.list !== this) {
      throw new Error("removing node which does not belong to this list");
    }
    var next = node4.next;
    var prev = node4.prev;
    if (next) {
      next.prev = prev;
    }
    if (prev) {
      prev.next = next;
    }
    if (node4 === this.head) {
      this.head = next;
    }
    if (node4 === this.tail) {
      this.tail = prev;
    }
    node4.list.length--;
    node4.next = null;
    node4.prev = null;
    node4.list = null;
    return next;
  };
  Yallist.prototype.unshiftNode = function(node4) {
    if (node4 === this.head) {
      return;
    }
    if (node4.list) {
      node4.list.removeNode(node4);
    }
    var head = this.head;
    node4.list = this;
    node4.next = head;
    if (head) {
      head.prev = node4;
    }
    this.head = node4;
    if (!this.tail) {
      this.tail = node4;
    }
    this.length++;
  };
  Yallist.prototype.pushNode = function(node4) {
    if (node4 === this.tail) {
      return;
    }
    if (node4.list) {
      node4.list.removeNode(node4);
    }
    var tail = this.tail;
    node4.list = this;
    node4.prev = tail;
    if (tail) {
      tail.next = node4;
    }
    this.tail = node4;
    if (!this.head) {
      this.head = node4;
    }
    this.length++;
  };
  Yallist.prototype.push = function() {
    for (var i = 0, l = arguments.length;i < l; i++) {
      push(this, arguments[i]);
    }
    return this.length;
  };
  Yallist.prototype.unshift = function() {
    for (var i = 0, l = arguments.length;i < l; i++) {
      unshift(this, arguments[i]);
    }
    return this.length;
  };
  Yallist.prototype.pop = function() {
    if (!this.tail) {
      return;
    }
    var res = this.tail.value;
    this.tail = this.tail.prev;
    if (this.tail) {
      this.tail.next = null;
    } else {
      this.head = null;
    }
    this.length--;
    return res;
  };
  Yallist.prototype.shift = function() {
    if (!this.head) {
      return;
    }
    var res = this.head.value;
    this.head = this.head.next;
    if (this.head) {
      this.head.prev = null;
    } else {
      this.tail = null;
    }
    this.length--;
    return res;
  };
  Yallist.prototype.forEach = function(fn, thisp) {
    thisp = thisp || this;
    for (var walker = this.head, i = 0;walker !== null; i++) {
      fn.call(thisp, walker.value, i, this);
      walker = walker.next;
    }
  };
  Yallist.prototype.forEachReverse = function(fn, thisp) {
    thisp = thisp || this;
    for (var walker = this.tail, i = this.length - 1;walker !== null; i--) {
      fn.call(thisp, walker.value, i, this);
      walker = walker.prev;
    }
  };
  Yallist.prototype.get = function(n) {
    for (var i = 0, walker = this.head;walker !== null && i < n; i++) {
      walker = walker.next;
    }
    if (i === n && walker !== null) {
      return walker.value;
    }
  };
  Yallist.prototype.getReverse = function(n) {
    for (var i = 0, walker = this.tail;walker !== null && i < n; i++) {
      walker = walker.prev;
    }
    if (i === n && walker !== null) {
      return walker.value;
    }
  };
  Yallist.prototype.map = function(fn, thisp) {
    thisp = thisp || this;
    var res = new Yallist;
    for (var walker = this.head;walker !== null; ) {
      res.push(fn.call(thisp, walker.value, this));
      walker = walker.next;
    }
    return res;
  };
  Yallist.prototype.mapReverse = function(fn, thisp) {
    thisp = thisp || this;
    var res = new Yallist;
    for (var walker = this.tail;walker !== null; ) {
      res.push(fn.call(thisp, walker.value, this));
      walker = walker.prev;
    }
    return res;
  };
  Yallist.prototype.reduce = function(fn, initial) {
    var acc;
    var walker = this.head;
    if (arguments.length > 1) {
      acc = initial;
    } else if (this.head) {
      walker = this.head.next;
      acc = this.head.value;
    } else {
      throw new TypeError("Reduce of empty list with no initial value");
    }
    for (var i = 0;walker !== null; i++) {
      acc = fn(acc, walker.value, i);
      walker = walker.next;
    }
    return acc;
  };
  Yallist.prototype.reduceReverse = function(fn, initial) {
    var acc;
    var walker = this.tail;
    if (arguments.length > 1) {
      acc = initial;
    } else if (this.tail) {
      walker = this.tail.prev;
      acc = this.tail.value;
    } else {
      throw new TypeError("Reduce of empty list with no initial value");
    }
    for (var i = this.length - 1;walker !== null; i--) {
      acc = fn(acc, walker.value, i);
      walker = walker.prev;
    }
    return acc;
  };
  Yallist.prototype.toArray = function() {
    var arr = new Array(this.length);
    for (var i = 0, walker = this.head;walker !== null; i++) {
      arr[i] = walker.value;
      walker = walker.next;
    }
    return arr;
  };
  Yallist.prototype.toArrayReverse = function() {
    var arr = new Array(this.length);
    for (var i = 0, walker = this.tail;walker !== null; i++) {
      arr[i] = walker.value;
      walker = walker.prev;
    }
    return arr;
  };
  Yallist.prototype.slice = function(from, to) {
    to = to || this.length;
    if (to < 0) {
      to += this.length;
    }
    from = from || 0;
    if (from < 0) {
      from += this.length;
    }
    var ret = new Yallist;
    if (to < from || to < 0) {
      return ret;
    }
    if (from < 0) {
      from = 0;
    }
    if (to > this.length) {
      to = this.length;
    }
    for (var i = 0, walker = this.head;walker !== null && i < from; i++) {
      walker = walker.next;
    }
    for (;walker !== null && i < to; i++, walker = walker.next) {
      ret.push(walker.value);
    }
    return ret;
  };
  Yallist.prototype.sliceReverse = function(from, to) {
    to = to || this.length;
    if (to < 0) {
      to += this.length;
    }
    from = from || 0;
    if (from < 0) {
      from += this.length;
    }
    var ret = new Yallist;
    if (to < from || to < 0) {
      return ret;
    }
    if (from < 0) {
      from = 0;
    }
    if (to > this.length) {
      to = this.length;
    }
    for (var i = this.length, walker = this.tail;walker !== null && i > to; i--) {
      walker = walker.prev;
    }
    for (;walker !== null && i > from; i--, walker = walker.prev) {
      ret.push(walker.value);
    }
    return ret;
  };
  Yallist.prototype.splice = function(start, deleteCount, ...nodes) {
    if (start > this.length) {
      start = this.length - 1;
    }
    if (start < 0) {
      start = this.length + start;
    }
    for (var i = 0, walker = this.head;walker !== null && i < start; i++) {
      walker = walker.next;
    }
    var ret = [];
    for (var i = 0;walker && i < deleteCount; i++) {
      ret.push(walker.value);
      walker = this.removeNode(walker);
    }
    if (walker === null) {
      walker = this.tail;
    }
    if (walker !== this.head && walker !== this.tail) {
      walker = walker.prev;
    }
    for (var i = 0;i < nodes.length; i++) {
      walker = insert(this, walker, nodes[i]);
    }
    return ret;
  };
  Yallist.prototype.reverse = function() {
    var head = this.head;
    var tail = this.tail;
    for (var walker = head;walker !== null; walker = walker.prev) {
      var p = walker.prev;
      walker.prev = walker.next;
      walker.next = p;
    }
    this.head = tail;
    this.tail = head;
    return this;
  };
  try {
    require_iterator()(Yallist);
  } catch (er) {
  }
});

// node_modules/@redis/client/dist/lib/client/RESP2/composers/buffer.js
var require_buffer = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });

  class BufferComposer {
    constructor() {
      Object.defineProperty(this, "chunks", {
        enumerable: true,
        configurable: true,
        writable: true,
        value: []
      });
    }
    write(buffer2) {
      this.chunks.push(buffer2);
    }
    end(buffer2) {
      this.write(buffer2);
      return Buffer.concat(this.chunks.splice(0));
    }
    reset() {
      this.chunks = [];
    }
  }
  exports.default = BufferComposer;
});

// node_modules/@redis/client/dist/lib/client/RESP2/composers/string.js
var require_string = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  var string_decoder_1 = __require("string_decoder");

  class StringComposer {
    constructor() {
      Object.defineProperty(this, "decoder", {
        enumerable: true,
        configurable: true,
        writable: true,
        value: new string_decoder_1.StringDecoder
      });
      Object.defineProperty(this, "string", {
        enumerable: true,
        configurable: true,
        writable: true,
        value: ""
      });
    }
    write(buffer2) {
      this.string += this.decoder.write(buffer2);
    }
    end(buffer2) {
      const string = this.string + this.decoder.end(buffer2);
      this.string = "";
      return string;
    }
    reset() {
      this.string = "";
    }
  }
  exports.default = StringComposer;
});

// node_modules/@redis/client/dist/lib/client/RESP2/decoder.js
var require_decoder = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  var errors_1 = require_errors3();
  var buffer_1 = require_buffer();
  var string_1 = require_string();
  var Types;
  (function(Types2) {
    Types2[Types2["SIMPLE_STRING"] = 43] = "SIMPLE_STRING";
    Types2[Types2["ERROR"] = 45] = "ERROR";
    Types2[Types2["INTEGER"] = 58] = "INTEGER";
    Types2[Types2["BULK_STRING"] = 36] = "BULK_STRING";
    Types2[Types2["ARRAY"] = 42] = "ARRAY";
  })(Types || (Types = {}));
  var ASCII;
  (function(ASCII2) {
    ASCII2[ASCII2["CR"] = 13] = "CR";
    ASCII2[ASCII2["ZERO"] = 48] = "ZERO";
    ASCII2[ASCII2["MINUS"] = 45] = "MINUS";
  })(ASCII || (ASCII = {}));

  class RESP2Decoder {
    constructor(options) {
      Object.defineProperty(this, "options", {
        enumerable: true,
        configurable: true,
        writable: true,
        value: options
      });
      Object.defineProperty(this, "cursor", {
        enumerable: true,
        configurable: true,
        writable: true,
        value: 0
      });
      Object.defineProperty(this, "type", {
        enumerable: true,
        configurable: true,
        writable: true,
        value: undefined
      });
      Object.defineProperty(this, "bufferComposer", {
        enumerable: true,
        configurable: true,
        writable: true,
        value: new buffer_1.default
      });
      Object.defineProperty(this, "stringComposer", {
        enumerable: true,
        configurable: true,
        writable: true,
        value: new string_1.default
      });
      Object.defineProperty(this, "currentStringComposer", {
        enumerable: true,
        configurable: true,
        writable: true,
        value: this.stringComposer
      });
      Object.defineProperty(this, "integer", {
        enumerable: true,
        configurable: true,
        writable: true,
        value: 0
      });
      Object.defineProperty(this, "isNegativeInteger", {
        enumerable: true,
        configurable: true,
        writable: true,
        value: undefined
      });
      Object.defineProperty(this, "bulkStringRemainingLength", {
        enumerable: true,
        configurable: true,
        writable: true,
        value: undefined
      });
      Object.defineProperty(this, "arraysInProcess", {
        enumerable: true,
        configurable: true,
        writable: true,
        value: []
      });
      Object.defineProperty(this, "initializeArray", {
        enumerable: true,
        configurable: true,
        writable: true,
        value: false
      });
      Object.defineProperty(this, "arrayItemType", {
        enumerable: true,
        configurable: true,
        writable: true,
        value: undefined
      });
    }
    reset() {
      this.cursor = 0;
      this.type = undefined;
      this.bufferComposer.reset();
      this.stringComposer.reset();
      this.currentStringComposer = this.stringComposer;
    }
    write(chunk) {
      while (this.cursor < chunk.length) {
        if (!this.type) {
          this.currentStringComposer = this.options.returnStringsAsBuffers() ? this.bufferComposer : this.stringComposer;
          this.type = chunk[this.cursor];
          if (++this.cursor >= chunk.length)
            break;
        }
        const reply = this.parseType(chunk, this.type);
        if (reply === undefined)
          break;
        this.type = undefined;
        this.options.onReply(reply);
      }
      this.cursor -= chunk.length;
    }
    parseType(chunk, type, arraysToKeep) {
      switch (type) {
        case Types.SIMPLE_STRING:
          return this.parseSimpleString(chunk);
        case Types.ERROR:
          return this.parseError(chunk);
        case Types.INTEGER:
          return this.parseInteger(chunk);
        case Types.BULK_STRING:
          return this.parseBulkString(chunk);
        case Types.ARRAY:
          return this.parseArray(chunk, arraysToKeep);
      }
    }
    compose(chunk, composer) {
      for (let i = this.cursor;i < chunk.length; i++) {
        if (chunk[i] === ASCII.CR) {
          const reply = composer.end(chunk.subarray(this.cursor, i));
          this.cursor = i + 2;
          return reply;
        }
      }
      const toWrite = chunk.subarray(this.cursor);
      composer.write(toWrite);
      this.cursor = chunk.length;
    }
    parseSimpleString(chunk) {
      return this.compose(chunk, this.currentStringComposer);
    }
    parseError(chunk) {
      const message2 = this.compose(chunk, this.stringComposer);
      if (message2 !== undefined) {
        return new errors_1.ErrorReply(message2);
      }
    }
    parseInteger(chunk) {
      if (this.isNegativeInteger === undefined) {
        this.isNegativeInteger = chunk[this.cursor] === ASCII.MINUS;
        if (this.isNegativeInteger && ++this.cursor === chunk.length)
          return;
      }
      do {
        const byte = chunk[this.cursor];
        if (byte === ASCII.CR) {
          const integer = this.isNegativeInteger ? -this.integer : this.integer;
          this.integer = 0;
          this.isNegativeInteger = undefined;
          this.cursor += 2;
          return integer;
        }
        this.integer = this.integer * 10 + byte - ASCII.ZERO;
      } while (++this.cursor < chunk.length);
    }
    parseBulkString(chunk) {
      if (this.bulkStringRemainingLength === undefined) {
        const length = this.parseInteger(chunk);
        if (length === undefined)
          return;
        if (length === -1)
          return null;
        this.bulkStringRemainingLength = length;
        if (this.cursor >= chunk.length)
          return;
      }
      const end = this.cursor + this.bulkStringRemainingLength;
      if (chunk.length >= end) {
        const reply = this.currentStringComposer.end(chunk.subarray(this.cursor, end));
        this.bulkStringRemainingLength = undefined;
        this.cursor = end + 2;
        return reply;
      }
      const toWrite = chunk.subarray(this.cursor);
      this.currentStringComposer.write(toWrite);
      this.bulkStringRemainingLength -= toWrite.length;
      this.cursor = chunk.length;
    }
    parseArray(chunk, arraysToKeep = 0) {
      if (this.initializeArray || this.arraysInProcess.length === arraysToKeep) {
        const length = this.parseInteger(chunk);
        if (length === undefined) {
          this.initializeArray = true;
          return;
        }
        this.initializeArray = false;
        this.arrayItemType = undefined;
        if (length === -1) {
          return this.returnArrayReply(null, arraysToKeep, chunk);
        } else if (length === 0) {
          return this.returnArrayReply([], arraysToKeep, chunk);
        }
        this.arraysInProcess.push({
          array: new Array(length),
          pushCounter: 0
        });
      }
      while (this.cursor < chunk.length) {
        if (!this.arrayItemType) {
          this.arrayItemType = chunk[this.cursor];
          if (++this.cursor >= chunk.length)
            break;
        }
        const item = this.parseType(chunk, this.arrayItemType, arraysToKeep + 1);
        if (item === undefined)
          break;
        this.arrayItemType = undefined;
        const reply = this.pushArrayItem(item, arraysToKeep);
        if (reply !== undefined)
          return reply;
      }
    }
    returnArrayReply(reply, arraysToKeep, chunk) {
      if (this.arraysInProcess.length <= arraysToKeep)
        return reply;
      return this.pushArrayItem(reply, arraysToKeep, chunk);
    }
    pushArrayItem(item, arraysToKeep, chunk) {
      const to = this.arraysInProcess[this.arraysInProcess.length - 1];
      to.array[to.pushCounter] = item;
      if (++to.pushCounter === to.array.length) {
        return this.returnArrayReply(this.arraysInProcess.pop().array, arraysToKeep, chunk);
      } else if (chunk && chunk.length > this.cursor) {
        return this.parseArray(chunk, arraysToKeep);
      }
    }
  }
  exports.default = RESP2Decoder;
});

// node_modules/@redis/client/dist/lib/client/RESP2/encoder.js
var require_encoder = __commonJS((exports) => {
  var encodeCommand = function(args) {
    const toWrite = [];
    let strings = "*" + args.length + CRLF;
    for (let i = 0;i < args.length; i++) {
      const arg = args[i];
      if (typeof arg === "string") {
        strings += "$" + Buffer.byteLength(arg) + CRLF + arg + CRLF;
      } else if (arg instanceof Buffer) {
        toWrite.push(strings + "$" + arg.length.toString() + CRLF, arg);
        strings = CRLF;
      } else {
        throw new TypeError("Invalid argument type");
      }
    }
    toWrite.push(strings);
    return toWrite;
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  var CRLF = "\r\n";
  exports.default = encodeCommand;
});

// node_modules/@redis/client/dist/lib/client/pub-sub.js
var require_pub_sub = __commonJS((exports) => {
  var __classPrivateFieldGet = exports && exports.__classPrivateFieldGet || function(receiver, state, kind, f) {
    if (kind === "a" && !f)
      throw new TypeError("Private accessor was defined without a getter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver))
      throw new TypeError("Cannot read private member from an object whose class did not declare it");
    return kind === "m" ? f : kind === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
  };
  var __classPrivateFieldSet = exports && exports.__classPrivateFieldSet || function(receiver, state, value, kind, f) {
    if (kind === "m")
      throw new TypeError("Private method is not writable");
    if (kind === "a" && !f)
      throw new TypeError("Private accessor was defined without a setter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver))
      throw new TypeError("Cannot write private member to an object whose class did not declare it");
    return kind === "a" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value), value;
  };
  var _PubSub_instances;
  var _a;
  var _PubSub_channelsArray;
  var _PubSub_listenersSet;
  var _PubSub_subscribing;
  var _PubSub_isActive;
  var _PubSub_listeners;
  var _PubSub_extendChannelListeners;
  var _PubSub_unsubscribeCommand;
  var _PubSub_updateIsActive;
  var _PubSub_emitPubSubMessage;
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.PubSub = exports.PubSubType = undefined;
  var PubSubType;
  (function(PubSubType2) {
    PubSubType2["CHANNELS"] = "CHANNELS";
    PubSubType2["PATTERNS"] = "PATTERNS";
    PubSubType2["SHARDED"] = "SHARDED";
  })(PubSubType || (exports.PubSubType = PubSubType = {}));
  var COMMANDS = {
    [PubSubType.CHANNELS]: {
      subscribe: Buffer.from("subscribe"),
      unsubscribe: Buffer.from("unsubscribe"),
      message: Buffer.from("message")
    },
    [PubSubType.PATTERNS]: {
      subscribe: Buffer.from("psubscribe"),
      unsubscribe: Buffer.from("punsubscribe"),
      message: Buffer.from("pmessage")
    },
    [PubSubType.SHARDED]: {
      subscribe: Buffer.from("ssubscribe"),
      unsubscribe: Buffer.from("sunsubscribe"),
      message: Buffer.from("smessage")
    }
  };

  class PubSub {
    constructor() {
      _PubSub_instances.add(this);
      _PubSub_subscribing.set(this, 0);
      _PubSub_isActive.set(this, false);
      _PubSub_listeners.set(this, {
        [PubSubType.CHANNELS]: new Map,
        [PubSubType.PATTERNS]: new Map,
        [PubSubType.SHARDED]: new Map
      });
    }
    static isStatusReply(reply) {
      return COMMANDS[PubSubType.CHANNELS].subscribe.equals(reply[0]) || COMMANDS[PubSubType.CHANNELS].unsubscribe.equals(reply[0]) || COMMANDS[PubSubType.PATTERNS].subscribe.equals(reply[0]) || COMMANDS[PubSubType.PATTERNS].unsubscribe.equals(reply[0]) || COMMANDS[PubSubType.SHARDED].subscribe.equals(reply[0]);
    }
    static isShardedUnsubscribe(reply) {
      return COMMANDS[PubSubType.SHARDED].unsubscribe.equals(reply[0]);
    }
    get isActive() {
      return __classPrivateFieldGet(this, _PubSub_isActive, "f");
    }
    subscribe(type, channels, listener, returnBuffers) {
      var _b;
      const args = [COMMANDS[type].subscribe], channelsArray = __classPrivateFieldGet(PubSub, _a, "m", _PubSub_channelsArray).call(PubSub, channels);
      for (const channel of channelsArray) {
        let channelListeners = __classPrivateFieldGet(this, _PubSub_listeners, "f")[type].get(channel);
        if (!channelListeners || channelListeners.unsubscribing) {
          args.push(channel);
        }
      }
      if (args.length === 1) {
        for (const channel of channelsArray) {
          __classPrivateFieldGet(PubSub, _a, "m", _PubSub_listenersSet).call(PubSub, __classPrivateFieldGet(this, _PubSub_listeners, "f")[type].get(channel), returnBuffers).add(listener);
        }
        return;
      }
      __classPrivateFieldSet(this, _PubSub_isActive, true, "f");
      __classPrivateFieldSet(this, _PubSub_subscribing, (_b = __classPrivateFieldGet(this, _PubSub_subscribing, "f"), _b++, _b), "f");
      return {
        args,
        channelsCounter: args.length - 1,
        resolve: () => {
          var _b2;
          __classPrivateFieldSet(this, _PubSub_subscribing, (_b2 = __classPrivateFieldGet(this, _PubSub_subscribing, "f"), _b2--, _b2), "f");
          for (const channel of channelsArray) {
            let listeners = __classPrivateFieldGet(this, _PubSub_listeners, "f")[type].get(channel);
            if (!listeners) {
              listeners = {
                unsubscribing: false,
                buffers: new Set,
                strings: new Set
              };
              __classPrivateFieldGet(this, _PubSub_listeners, "f")[type].set(channel, listeners);
            }
            __classPrivateFieldGet(PubSub, _a, "m", _PubSub_listenersSet).call(PubSub, listeners, returnBuffers).add(listener);
          }
        },
        reject: () => {
          var _b2;
          __classPrivateFieldSet(this, _PubSub_subscribing, (_b2 = __classPrivateFieldGet(this, _PubSub_subscribing, "f"), _b2--, _b2), "f");
          __classPrivateFieldGet(this, _PubSub_instances, "m", _PubSub_updateIsActive).call(this);
        }
      };
    }
    extendChannelListeners(type, channel, listeners) {
      var _b;
      if (!__classPrivateFieldGet(this, _PubSub_instances, "m", _PubSub_extendChannelListeners).call(this, type, channel, listeners))
        return;
      __classPrivateFieldSet(this, _PubSub_isActive, true, "f");
      __classPrivateFieldSet(this, _PubSub_subscribing, (_b = __classPrivateFieldGet(this, _PubSub_subscribing, "f"), _b++, _b), "f");
      return {
        args: [
          COMMANDS[type].subscribe,
          channel
        ],
        channelsCounter: 1,
        resolve: () => {
          var _b2, _c;
          return __classPrivateFieldSet(this, _PubSub_subscribing, (_c = __classPrivateFieldGet(this, _PubSub_subscribing, "f"), _b2 = _c--, _c), "f"), _b2;
        },
        reject: () => {
          var _b2;
          __classPrivateFieldSet(this, _PubSub_subscribing, (_b2 = __classPrivateFieldGet(this, _PubSub_subscribing, "f"), _b2--, _b2), "f");
          __classPrivateFieldGet(this, _PubSub_instances, "m", _PubSub_updateIsActive).call(this);
        }
      };
    }
    extendTypeListeners(type, listeners) {
      var _b;
      const args = [COMMANDS[type].subscribe];
      for (const [channel, channelListeners] of listeners) {
        if (__classPrivateFieldGet(this, _PubSub_instances, "m", _PubSub_extendChannelListeners).call(this, type, channel, channelListeners)) {
          args.push(channel);
        }
      }
      if (args.length === 1)
        return;
      __classPrivateFieldSet(this, _PubSub_isActive, true, "f");
      __classPrivateFieldSet(this, _PubSub_subscribing, (_b = __classPrivateFieldGet(this, _PubSub_subscribing, "f"), _b++, _b), "f");
      return {
        args,
        channelsCounter: args.length - 1,
        resolve: () => {
          var _b2, _c;
          return __classPrivateFieldSet(this, _PubSub_subscribing, (_c = __classPrivateFieldGet(this, _PubSub_subscribing, "f"), _b2 = _c--, _c), "f"), _b2;
        },
        reject: () => {
          var _b2;
          __classPrivateFieldSet(this, _PubSub_subscribing, (_b2 = __classPrivateFieldGet(this, _PubSub_subscribing, "f"), _b2--, _b2), "f");
          __classPrivateFieldGet(this, _PubSub_instances, "m", _PubSub_updateIsActive).call(this);
        }
      };
    }
    unsubscribe(type, channels, listener, returnBuffers) {
      const listeners = __classPrivateFieldGet(this, _PubSub_listeners, "f")[type];
      if (!channels) {
        return __classPrivateFieldGet(this, _PubSub_instances, "m", _PubSub_unsubscribeCommand).call(this, [COMMANDS[type].unsubscribe], NaN, () => listeners.clear());
      }
      const channelsArray = __classPrivateFieldGet(PubSub, _a, "m", _PubSub_channelsArray).call(PubSub, channels);
      if (!listener) {
        return __classPrivateFieldGet(this, _PubSub_instances, "m", _PubSub_unsubscribeCommand).call(this, [COMMANDS[type].unsubscribe, ...channelsArray], channelsArray.length, () => {
          for (const channel of channelsArray) {
            listeners.delete(channel);
          }
        });
      }
      const args = [COMMANDS[type].unsubscribe];
      for (const channel of channelsArray) {
        const sets = listeners.get(channel);
        if (sets) {
          let current, other;
          if (returnBuffers) {
            current = sets.buffers;
            other = sets.strings;
          } else {
            current = sets.strings;
            other = sets.buffers;
          }
          const currentSize = current.has(listener) ? current.size - 1 : current.size;
          if (currentSize !== 0 || other.size !== 0)
            continue;
          sets.unsubscribing = true;
        }
        args.push(channel);
      }
      if (args.length === 1) {
        for (const channel of channelsArray) {
          __classPrivateFieldGet(PubSub, _a, "m", _PubSub_listenersSet).call(PubSub, listeners.get(channel), returnBuffers).delete(listener);
        }
        return;
      }
      return __classPrivateFieldGet(this, _PubSub_instances, "m", _PubSub_unsubscribeCommand).call(this, args, args.length - 1, () => {
        for (const channel of channelsArray) {
          const sets = listeners.get(channel);
          if (!sets)
            continue;
          (returnBuffers ? sets.buffers : sets.strings).delete(listener);
          if (sets.buffers.size === 0 && sets.strings.size === 0) {
            listeners.delete(channel);
          }
        }
      });
    }
    reset() {
      __classPrivateFieldSet(this, _PubSub_isActive, false, "f");
      __classPrivateFieldSet(this, _PubSub_subscribing, 0, "f");
    }
    resubscribe() {
      var _b;
      const commands = [];
      for (const [type, listeners] of Object.entries(__classPrivateFieldGet(this, _PubSub_listeners, "f"))) {
        if (!listeners.size)
          continue;
        __classPrivateFieldSet(this, _PubSub_isActive, true, "f");
        __classPrivateFieldSet(this, _PubSub_subscribing, (_b = __classPrivateFieldGet(this, _PubSub_subscribing, "f"), _b++, _b), "f");
        const callback = () => {
          var _b2, _c;
          return __classPrivateFieldSet(this, _PubSub_subscribing, (_c = __classPrivateFieldGet(this, _PubSub_subscribing, "f"), _b2 = _c--, _c), "f"), _b2;
        };
        commands.push({
          args: [
            COMMANDS[type].subscribe,
            ...listeners.keys()
          ],
          channelsCounter: listeners.size,
          resolve: callback,
          reject: callback
        });
      }
      return commands;
    }
    handleMessageReply(reply) {
      if (COMMANDS[PubSubType.CHANNELS].message.equals(reply[0])) {
        __classPrivateFieldGet(this, _PubSub_instances, "m", _PubSub_emitPubSubMessage).call(this, PubSubType.CHANNELS, reply[2], reply[1]);
        return true;
      } else if (COMMANDS[PubSubType.PATTERNS].message.equals(reply[0])) {
        __classPrivateFieldGet(this, _PubSub_instances, "m", _PubSub_emitPubSubMessage).call(this, PubSubType.PATTERNS, reply[3], reply[2], reply[1]);
        return true;
      } else if (COMMANDS[PubSubType.SHARDED].message.equals(reply[0])) {
        __classPrivateFieldGet(this, _PubSub_instances, "m", _PubSub_emitPubSubMessage).call(this, PubSubType.SHARDED, reply[2], reply[1]);
        return true;
      }
      return false;
    }
    removeShardedListeners(channel) {
      const listeners = __classPrivateFieldGet(this, _PubSub_listeners, "f")[PubSubType.SHARDED].get(channel);
      __classPrivateFieldGet(this, _PubSub_listeners, "f")[PubSubType.SHARDED].delete(channel);
      __classPrivateFieldGet(this, _PubSub_instances, "m", _PubSub_updateIsActive).call(this);
      return listeners;
    }
    getTypeListeners(type) {
      return __classPrivateFieldGet(this, _PubSub_listeners, "f")[type];
    }
  }
  exports.PubSub = PubSub;
  _a = PubSub, _PubSub_subscribing = new WeakMap, _PubSub_isActive = new WeakMap, _PubSub_listeners = new WeakMap, _PubSub_instances = new WeakSet, _PubSub_channelsArray = function _PubSub_channelsArray(channels) {
    return Array.isArray(channels) ? channels : [channels];
  }, _PubSub_listenersSet = function _PubSub_listenersSet(listeners, returnBuffers) {
    return returnBuffers ? listeners.buffers : listeners.strings;
  }, _PubSub_extendChannelListeners = function _PubSub_extendChannelListeners(type, channel, listeners) {
    const existingListeners = __classPrivateFieldGet(this, _PubSub_listeners, "f")[type].get(channel);
    if (!existingListeners) {
      __classPrivateFieldGet(this, _PubSub_listeners, "f")[type].set(channel, listeners);
      return true;
    }
    for (const listener of listeners.buffers) {
      existingListeners.buffers.add(listener);
    }
    for (const listener of listeners.strings) {
      existingListeners.strings.add(listener);
    }
    return false;
  }, _PubSub_unsubscribeCommand = function _PubSub_unsubscribeCommand(args, channelsCounter, removeListeners) {
    return {
      args,
      channelsCounter,
      resolve: () => {
        removeListeners();
        __classPrivateFieldGet(this, _PubSub_instances, "m", _PubSub_updateIsActive).call(this);
      },
      reject: undefined
    };
  }, _PubSub_updateIsActive = function _PubSub_updateIsActive() {
    __classPrivateFieldSet(this, _PubSub_isActive, __classPrivateFieldGet(this, _PubSub_listeners, "f")[PubSubType.CHANNELS].size !== 0 || __classPrivateFieldGet(this, _PubSub_listeners, "f")[PubSubType.PATTERNS].size !== 0 || __classPrivateFieldGet(this, _PubSub_listeners, "f")[PubSubType.SHARDED].size !== 0 || __classPrivateFieldGet(this, _PubSub_subscribing, "f") !== 0, "f");
  }, _PubSub_emitPubSubMessage = function _PubSub_emitPubSubMessage(type, message2, channel, pattern) {
    const keyString = (pattern ?? channel).toString(), listeners = __classPrivateFieldGet(this, _PubSub_listeners, "f")[type].get(keyString);
    if (!listeners)
      return;
    for (const listener of listeners.buffers) {
      listener(message2, channel);
    }
    if (!listeners.strings.size)
      return;
    const channelString = pattern ? channel.toString() : keyString, messageString = channelString === "__redis__:invalidate" ? message2 === null ? null : message2.map((x) => x.toString()) : message2.toString();
    for (const listener of listeners.strings) {
      listener(messageString, channelString);
    }
  };
});

// node_modules/@redis/client/dist/lib/client/commands-queue.js
var require_commands_queue = __commonJS((exports) => {
  var __classPrivateFieldGet = exports && exports.__classPrivateFieldGet || function(receiver, state, kind, f) {
    if (kind === "a" && !f)
      throw new TypeError("Private accessor was defined without a getter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver))
      throw new TypeError("Cannot read private member from an object whose class did not declare it");
    return kind === "m" ? f : kind === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
  };
  var __classPrivateFieldSet = exports && exports.__classPrivateFieldSet || function(receiver, state, value, kind, f) {
    if (kind === "m")
      throw new TypeError("Private method is not writable");
    if (kind === "a" && !f)
      throw new TypeError("Private accessor was defined without a setter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver))
      throw new TypeError("Cannot write private member to an object whose class did not declare it");
    return kind === "a" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value), value;
  };
  var _RedisCommandsQueue_instances;
  var _a;
  var _RedisCommandsQueue_flushQueue;
  var _RedisCommandsQueue_maxLength;
  var _RedisCommandsQueue_waitingToBeSent;
  var _RedisCommandsQueue_waitingForReply;
  var _RedisCommandsQueue_onShardedChannelMoved;
  var _RedisCommandsQueue_pubSub;
  var _RedisCommandsQueue_chainInExecution;
  var _RedisCommandsQueue_decoder;
  var _RedisCommandsQueue_pushPubSubCommand;
  Object.defineProperty(exports, "__esModule", { value: true });
  var LinkedList = require_yallist();
  var errors_1 = require_errors3();
  var decoder_1 = require_decoder();
  var encoder_1 = require_encoder();
  var pub_sub_1 = require_pub_sub();
  var PONG = Buffer.from("pong");

  class RedisCommandsQueue {
    get isPubSubActive() {
      return __classPrivateFieldGet(this, _RedisCommandsQueue_pubSub, "f").isActive;
    }
    constructor(maxLength, onShardedChannelMoved) {
      _RedisCommandsQueue_instances.add(this);
      _RedisCommandsQueue_maxLength.set(this, undefined);
      _RedisCommandsQueue_waitingToBeSent.set(this, new LinkedList);
      _RedisCommandsQueue_waitingForReply.set(this, new LinkedList);
      _RedisCommandsQueue_onShardedChannelMoved.set(this, undefined);
      _RedisCommandsQueue_pubSub.set(this, new pub_sub_1.PubSub);
      _RedisCommandsQueue_chainInExecution.set(this, undefined);
      _RedisCommandsQueue_decoder.set(this, new decoder_1.default({
        returnStringsAsBuffers: () => {
          return !!__classPrivateFieldGet(this, _RedisCommandsQueue_waitingForReply, "f").head?.value.returnBuffers || __classPrivateFieldGet(this, _RedisCommandsQueue_pubSub, "f").isActive;
        },
        onReply: (reply) => {
          if (__classPrivateFieldGet(this, _RedisCommandsQueue_pubSub, "f").isActive && Array.isArray(reply)) {
            if (__classPrivateFieldGet(this, _RedisCommandsQueue_pubSub, "f").handleMessageReply(reply))
              return;
            const isShardedUnsubscribe = pub_sub_1.PubSub.isShardedUnsubscribe(reply);
            if (isShardedUnsubscribe && !__classPrivateFieldGet(this, _RedisCommandsQueue_waitingForReply, "f").length) {
              const channel = reply[1].toString();
              __classPrivateFieldGet(this, _RedisCommandsQueue_onShardedChannelMoved, "f").call(this, channel, __classPrivateFieldGet(this, _RedisCommandsQueue_pubSub, "f").removeShardedListeners(channel));
              return;
            } else if (isShardedUnsubscribe || pub_sub_1.PubSub.isStatusReply(reply)) {
              const head = __classPrivateFieldGet(this, _RedisCommandsQueue_waitingForReply, "f").head.value;
              if (Number.isNaN(head.channelsCounter) && reply[2] === 0 || --head.channelsCounter === 0) {
                __classPrivateFieldGet(this, _RedisCommandsQueue_waitingForReply, "f").shift().resolve();
              }
              return;
            }
            if (PONG.equals(reply[0])) {
              const { resolve: resolve2, returnBuffers } = __classPrivateFieldGet(this, _RedisCommandsQueue_waitingForReply, "f").shift(), buffer2 = reply[1].length === 0 ? reply[0] : reply[1];
              resolve2(returnBuffers ? buffer2 : buffer2.toString());
              return;
            }
          }
          const { resolve, reject } = __classPrivateFieldGet(this, _RedisCommandsQueue_waitingForReply, "f").shift();
          if (reply instanceof errors_1.ErrorReply) {
            reject(reply);
          } else {
            resolve(reply);
          }
        }
      }));
      __classPrivateFieldSet(this, _RedisCommandsQueue_maxLength, maxLength, "f");
      __classPrivateFieldSet(this, _RedisCommandsQueue_onShardedChannelMoved, onShardedChannelMoved, "f");
    }
    addCommand(args, options) {
      if (__classPrivateFieldGet(this, _RedisCommandsQueue_maxLength, "f") && __classPrivateFieldGet(this, _RedisCommandsQueue_waitingToBeSent, "f").length + __classPrivateFieldGet(this, _RedisCommandsQueue_waitingForReply, "f").length >= __classPrivateFieldGet(this, _RedisCommandsQueue_maxLength, "f")) {
        return Promise.reject(new Error("The queue is full"));
      } else if (options?.signal?.aborted) {
        return Promise.reject(new errors_1.AbortError);
      }
      return new Promise((resolve, reject) => {
        const node4 = new LinkedList.Node({
          args,
          chainId: options?.chainId,
          returnBuffers: options?.returnBuffers,
          resolve,
          reject
        });
        if (options?.signal) {
          const listener = () => {
            __classPrivateFieldGet(this, _RedisCommandsQueue_waitingToBeSent, "f").removeNode(node4);
            node4.value.reject(new errors_1.AbortError);
          };
          node4.value.abort = {
            signal: options.signal,
            listener
          };
          options.signal.addEventListener("abort", listener, {
            once: true
          });
        }
        if (options?.asap) {
          __classPrivateFieldGet(this, _RedisCommandsQueue_waitingToBeSent, "f").unshiftNode(node4);
        } else {
          __classPrivateFieldGet(this, _RedisCommandsQueue_waitingToBeSent, "f").pushNode(node4);
        }
      });
    }
    subscribe(type, channels, listener, returnBuffers) {
      return __classPrivateFieldGet(this, _RedisCommandsQueue_instances, "m", _RedisCommandsQueue_pushPubSubCommand).call(this, __classPrivateFieldGet(this, _RedisCommandsQueue_pubSub, "f").subscribe(type, channels, listener, returnBuffers));
    }
    unsubscribe(type, channels, listener, returnBuffers) {
      return __classPrivateFieldGet(this, _RedisCommandsQueue_instances, "m", _RedisCommandsQueue_pushPubSubCommand).call(this, __classPrivateFieldGet(this, _RedisCommandsQueue_pubSub, "f").unsubscribe(type, channels, listener, returnBuffers));
    }
    resubscribe() {
      const commands = __classPrivateFieldGet(this, _RedisCommandsQueue_pubSub, "f").resubscribe();
      if (!commands.length)
        return;
      return Promise.all(commands.map((command) => __classPrivateFieldGet(this, _RedisCommandsQueue_instances, "m", _RedisCommandsQueue_pushPubSubCommand).call(this, command)));
    }
    extendPubSubChannelListeners(type, channel, listeners) {
      return __classPrivateFieldGet(this, _RedisCommandsQueue_instances, "m", _RedisCommandsQueue_pushPubSubCommand).call(this, __classPrivateFieldGet(this, _RedisCommandsQueue_pubSub, "f").extendChannelListeners(type, channel, listeners));
    }
    extendPubSubListeners(type, listeners) {
      return __classPrivateFieldGet(this, _RedisCommandsQueue_instances, "m", _RedisCommandsQueue_pushPubSubCommand).call(this, __classPrivateFieldGet(this, _RedisCommandsQueue_pubSub, "f").extendTypeListeners(type, listeners));
    }
    getPubSubListeners(type) {
      return __classPrivateFieldGet(this, _RedisCommandsQueue_pubSub, "f").getTypeListeners(type);
    }
    getCommandToSend() {
      const toSend = __classPrivateFieldGet(this, _RedisCommandsQueue_waitingToBeSent, "f").shift();
      if (!toSend)
        return;
      let encoded;
      try {
        encoded = (0, encoder_1.default)(toSend.args);
      } catch (err) {
        toSend.reject(err);
        return;
      }
      __classPrivateFieldGet(this, _RedisCommandsQueue_waitingForReply, "f").push({
        resolve: toSend.resolve,
        reject: toSend.reject,
        channelsCounter: toSend.channelsCounter,
        returnBuffers: toSend.returnBuffers
      });
      __classPrivateFieldSet(this, _RedisCommandsQueue_chainInExecution, toSend.chainId, "f");
      return encoded;
    }
    onReplyChunk(chunk) {
      __classPrivateFieldGet(this, _RedisCommandsQueue_decoder, "f").write(chunk);
    }
    flushWaitingForReply(err) {
      __classPrivateFieldGet(this, _RedisCommandsQueue_decoder, "f").reset();
      __classPrivateFieldGet(this, _RedisCommandsQueue_pubSub, "f").reset();
      __classPrivateFieldGet(RedisCommandsQueue, _a, "m", _RedisCommandsQueue_flushQueue).call(RedisCommandsQueue, __classPrivateFieldGet(this, _RedisCommandsQueue_waitingForReply, "f"), err);
      if (!__classPrivateFieldGet(this, _RedisCommandsQueue_chainInExecution, "f"))
        return;
      while (__classPrivateFieldGet(this, _RedisCommandsQueue_waitingToBeSent, "f").head?.value.chainId === __classPrivateFieldGet(this, _RedisCommandsQueue_chainInExecution, "f")) {
        __classPrivateFieldGet(this, _RedisCommandsQueue_waitingToBeSent, "f").shift();
      }
      __classPrivateFieldSet(this, _RedisCommandsQueue_chainInExecution, undefined, "f");
    }
    flushAll(err) {
      __classPrivateFieldGet(this, _RedisCommandsQueue_decoder, "f").reset();
      __classPrivateFieldGet(this, _RedisCommandsQueue_pubSub, "f").reset();
      __classPrivateFieldGet(RedisCommandsQueue, _a, "m", _RedisCommandsQueue_flushQueue).call(RedisCommandsQueue, __classPrivateFieldGet(this, _RedisCommandsQueue_waitingForReply, "f"), err);
      __classPrivateFieldGet(RedisCommandsQueue, _a, "m", _RedisCommandsQueue_flushQueue).call(RedisCommandsQueue, __classPrivateFieldGet(this, _RedisCommandsQueue_waitingToBeSent, "f"), err);
    }
  }
  _a = RedisCommandsQueue, _RedisCommandsQueue_maxLength = new WeakMap, _RedisCommandsQueue_waitingToBeSent = new WeakMap, _RedisCommandsQueue_waitingForReply = new WeakMap, _RedisCommandsQueue_onShardedChannelMoved = new WeakMap, _RedisCommandsQueue_pubSub = new WeakMap, _RedisCommandsQueue_chainInExecution = new WeakMap, _RedisCommandsQueue_decoder = new WeakMap, _RedisCommandsQueue_instances = new WeakSet, _RedisCommandsQueue_flushQueue = function _RedisCommandsQueue_flushQueue(queue3, err) {
    while (queue3.length) {
      queue3.shift().reject(err);
    }
  }, _RedisCommandsQueue_pushPubSubCommand = function _RedisCommandsQueue_pushPubSubCommand(command) {
    if (command === undefined)
      return;
    return new Promise((resolve, reject) => {
      __classPrivateFieldGet(this, _RedisCommandsQueue_waitingToBeSent, "f").push({
        args: command.args,
        channelsCounter: command.channelsCounter,
        returnBuffers: true,
        resolve: () => {
          command.resolve();
          resolve();
        },
        reject: (err) => {
          command.reject?.();
          reject(err);
        }
      });
    });
  };
  exports.default = RedisCommandsQueue;
});

// node_modules/@redis/client/dist/lib/command-options.js
var require_command_options = __commonJS((exports) => {
  var commandOptions = function(options) {
    options[symbol] = true;
    return options;
  };
  var isCommandOptions = function(options) {
    return options?.[symbol] === true;
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.isCommandOptions = exports.commandOptions = undefined;
  var symbol = Symbol("Command Options");
  exports.commandOptions = commandOptions;
  exports.isCommandOptions = isCommandOptions;
});

// node_modules/@redis/client/dist/lib/commander.js
var require_commander2 = __commonJS((exports) => {
  var attachCommands = function({ BaseClass, commands, executor }) {
    for (const [name, command] of Object.entries(commands)) {
      BaseClass.prototype[name] = function(...args) {
        return executor.call(this, command, args, name);
      };
    }
  };
  var attachExtensions = function(config) {
    let Commander;
    if (config.modules) {
      Commander = attachWithNamespaces({
        BaseClass: config.BaseClass,
        namespaces: config.modules,
        executor: config.modulesExecutor
      });
    }
    if (config.functions) {
      Commander = attachWithNamespaces({
        BaseClass: Commander ?? config.BaseClass,
        namespaces: config.functions,
        executor: config.functionsExecutor
      });
    }
    if (config.scripts) {
      Commander ?? (Commander = class extends config.BaseClass {
      });
      attachCommands({
        BaseClass: Commander,
        commands: config.scripts,
        executor: config.scriptsExecutor
      });
    }
    return Commander ?? config.BaseClass;
  };
  var attachWithNamespaces = function({ BaseClass, namespaces, executor }) {
    const Commander = class extends BaseClass {
      constructor(...args) {
        super(...args);
        for (const namespace of Object.keys(namespaces)) {
          this[namespace] = Object.create(this[namespace], {
            self: {
              value: this
            }
          });
        }
      }
    };
    for (const [namespace, commands] of Object.entries(namespaces)) {
      Commander.prototype[namespace] = {};
      for (const [name, command] of Object.entries(commands)) {
        Commander.prototype[namespace][name] = function(...args) {
          return executor.call(this.self, command, args, name);
        };
      }
    }
    return Commander;
  };
  var transformCommandArguments = function(command, args) {
    let options;
    if ((0, command_options_1.isCommandOptions)(args[0])) {
      options = args[0];
      args = args.slice(1);
    }
    return {
      jsArgs: args,
      args: command.transformArguments(...args),
      options
    };
  };
  var transformLegacyCommandArguments = function(args) {
    return args.flat().map((arg) => {
      return typeof arg === "number" || arg instanceof Date ? arg.toString() : arg;
    });
  };
  var transformCommandReply = function(command, rawReply, preserved) {
    if (!command.transformReply) {
      return rawReply;
    }
    return command.transformReply(rawReply, preserved);
  };
  var fCallArguments = function(name, fn, args) {
    const actualArgs = [
      fn.IS_READ_ONLY ? "FCALL_RO" : "FCALL",
      name
    ];
    if (fn.NUMBER_OF_KEYS !== undefined) {
      actualArgs.push(fn.NUMBER_OF_KEYS.toString());
    }
    actualArgs.push(...args);
    return actualArgs;
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.fCallArguments = exports.transformCommandReply = exports.transformLegacyCommandArguments = exports.transformCommandArguments = exports.attachExtensions = exports.attachCommands = undefined;
  var command_options_1 = require_command_options();
  exports.attachCommands = attachCommands;
  exports.attachExtensions = attachExtensions;
  exports.transformCommandArguments = transformCommandArguments;
  exports.transformLegacyCommandArguments = transformLegacyCommandArguments;
  exports.transformCommandReply = transformCommandReply;
  exports.fCallArguments = fCallArguments;
});

// node_modules/@redis/client/dist/lib/multi-command.js
var require_multi_command = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  var commander_1 = require_commander2();
  var errors_1 = require_errors3();

  class RedisMultiCommand {
    constructor() {
      Object.defineProperty(this, "queue", {
        enumerable: true,
        configurable: true,
        writable: true,
        value: []
      });
      Object.defineProperty(this, "scriptsInUse", {
        enumerable: true,
        configurable: true,
        writable: true,
        value: new Set
      });
    }
    static generateChainId() {
      return Symbol("RedisMultiCommand Chain Id");
    }
    addCommand(args, transformReply) {
      this.queue.push({
        args,
        transformReply
      });
    }
    addFunction(name, fn, args) {
      const transformedArguments = (0, commander_1.fCallArguments)(name, fn, fn.transformArguments(...args));
      this.queue.push({
        args: transformedArguments,
        transformReply: fn.transformReply
      });
      return transformedArguments;
    }
    addScript(script, args) {
      const transformedArguments = [];
      if (this.scriptsInUse.has(script.SHA1)) {
        transformedArguments.push("EVALSHA", script.SHA1);
      } else {
        this.scriptsInUse.add(script.SHA1);
        transformedArguments.push("EVAL", script.SCRIPT);
      }
      if (script.NUMBER_OF_KEYS !== undefined) {
        transformedArguments.push(script.NUMBER_OF_KEYS.toString());
      }
      const scriptArguments = script.transformArguments(...args);
      transformedArguments.push(...scriptArguments);
      if (scriptArguments.preserve) {
        transformedArguments.preserve = scriptArguments.preserve;
      }
      this.addCommand(transformedArguments, script.transformReply);
      return transformedArguments;
    }
    handleExecReplies(rawReplies) {
      const execReply = rawReplies[rawReplies.length - 1];
      if (execReply === null) {
        throw new errors_1.WatchError;
      }
      return this.transformReplies(execReply);
    }
    transformReplies(rawReplies) {
      return rawReplies.map((reply, i) => {
        const { transformReply, args } = this.queue[i];
        return transformReply ? transformReply(reply, args.preserve) : reply;
      });
    }
  }
  exports.default = RedisMultiCommand;
});

// node_modules/@redis/client/dist/lib/client/multi-command.js
var require_multi_command2 = __commonJS((exports) => {
  var __classPrivateFieldSet = exports && exports.__classPrivateFieldSet || function(receiver, state, value, kind, f) {
    if (kind === "m")
      throw new TypeError("Private method is not writable");
    if (kind === "a" && !f)
      throw new TypeError("Private accessor was defined without a setter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver))
      throw new TypeError("Cannot write private member to an object whose class did not declare it");
    return kind === "a" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value), value;
  };
  var __classPrivateFieldGet = exports && exports.__classPrivateFieldGet || function(receiver, state, kind, f) {
    if (kind === "a" && !f)
      throw new TypeError("Private accessor was defined without a getter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver))
      throw new TypeError("Cannot read private member from an object whose class did not declare it");
    return kind === "m" ? f : kind === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
  };
  var _RedisClientMultiCommand_instances;
  var _RedisClientMultiCommand_multi;
  var _RedisClientMultiCommand_executor;
  var _RedisClientMultiCommand_selectedDB;
  var _RedisClientMultiCommand_legacyMode;
  var _RedisClientMultiCommand_defineLegacyCommand;
  Object.defineProperty(exports, "__esModule", { value: true });
  var commands_1 = require_commands3();
  var multi_command_1 = require_multi_command();
  var commander_1 = require_commander2();

  class RedisClientMultiCommand {
    static extend(extensions) {
      return (0, commander_1.attachExtensions)({
        BaseClass: RedisClientMultiCommand,
        modulesExecutor: RedisClientMultiCommand.prototype.commandsExecutor,
        modules: extensions?.modules,
        functionsExecutor: RedisClientMultiCommand.prototype.functionsExecutor,
        functions: extensions?.functions,
        scriptsExecutor: RedisClientMultiCommand.prototype.scriptsExecutor,
        scripts: extensions?.scripts
      });
    }
    constructor(executor, legacyMode = false) {
      _RedisClientMultiCommand_instances.add(this);
      _RedisClientMultiCommand_multi.set(this, new multi_command_1.default);
      _RedisClientMultiCommand_executor.set(this, undefined);
      Object.defineProperty(this, "v4", {
        enumerable: true,
        configurable: true,
        writable: true,
        value: {}
      });
      _RedisClientMultiCommand_selectedDB.set(this, undefined);
      Object.defineProperty(this, "select", {
        enumerable: true,
        configurable: true,
        writable: true,
        value: this.SELECT
      });
      Object.defineProperty(this, "EXEC", {
        enumerable: true,
        configurable: true,
        writable: true,
        value: this.exec
      });
      __classPrivateFieldSet(this, _RedisClientMultiCommand_executor, executor, "f");
      if (legacyMode) {
        __classPrivateFieldGet(this, _RedisClientMultiCommand_instances, "m", _RedisClientMultiCommand_legacyMode).call(this);
      }
    }
    commandsExecutor(command, args) {
      return this.addCommand(command.transformArguments(...args), command.transformReply);
    }
    SELECT(db2, transformReply) {
      __classPrivateFieldSet(this, _RedisClientMultiCommand_selectedDB, db2, "f");
      return this.addCommand(["SELECT", db2.toString()], transformReply);
    }
    addCommand(args, transformReply) {
      __classPrivateFieldGet(this, _RedisClientMultiCommand_multi, "f").addCommand(args, transformReply);
      return this;
    }
    functionsExecutor(fn, args, name) {
      __classPrivateFieldGet(this, _RedisClientMultiCommand_multi, "f").addFunction(name, fn, args);
      return this;
    }
    scriptsExecutor(script, args) {
      __classPrivateFieldGet(this, _RedisClientMultiCommand_multi, "f").addScript(script, args);
      return this;
    }
    async exec(execAsPipeline = false) {
      if (execAsPipeline) {
        return this.execAsPipeline();
      }
      return __classPrivateFieldGet(this, _RedisClientMultiCommand_multi, "f").handleExecReplies(await __classPrivateFieldGet(this, _RedisClientMultiCommand_executor, "f").call(this, __classPrivateFieldGet(this, _RedisClientMultiCommand_multi, "f").queue, __classPrivateFieldGet(this, _RedisClientMultiCommand_selectedDB, "f"), multi_command_1.default.generateChainId()));
    }
    async execAsPipeline() {
      if (__classPrivateFieldGet(this, _RedisClientMultiCommand_multi, "f").queue.length === 0)
        return [];
      return __classPrivateFieldGet(this, _RedisClientMultiCommand_multi, "f").transformReplies(await __classPrivateFieldGet(this, _RedisClientMultiCommand_executor, "f").call(this, __classPrivateFieldGet(this, _RedisClientMultiCommand_multi, "f").queue, __classPrivateFieldGet(this, _RedisClientMultiCommand_selectedDB, "f")));
    }
  }
  _RedisClientMultiCommand_multi = new WeakMap, _RedisClientMultiCommand_executor = new WeakMap, _RedisClientMultiCommand_selectedDB = new WeakMap, _RedisClientMultiCommand_instances = new WeakSet, _RedisClientMultiCommand_legacyMode = function _RedisClientMultiCommand_legacyMode() {
    var _a, _b;
    this.v4.addCommand = this.addCommand.bind(this);
    this.addCommand = (...args) => {
      __classPrivateFieldGet(this, _RedisClientMultiCommand_multi, "f").addCommand((0, commander_1.transformLegacyCommandArguments)(args));
      return this;
    };
    this.v4.exec = this.exec.bind(this);
    this.exec = (callback) => {
      this.v4.exec().then((reply) => {
        if (!callback)
          return;
        callback(null, reply);
      }).catch((err) => {
        if (!callback) {
          return;
        }
        callback(err);
      });
    };
    for (const [name, command] of Object.entries(commands_1.default)) {
      __classPrivateFieldGet(this, _RedisClientMultiCommand_instances, "m", _RedisClientMultiCommand_defineLegacyCommand).call(this, name, command);
      (_a = this)[_b = name.toLowerCase()] ?? (_a[_b] = this[name]);
    }
  }, _RedisClientMultiCommand_defineLegacyCommand = function _RedisClientMultiCommand_defineLegacyCommand(name, command) {
    this.v4[name] = this[name].bind(this.v4);
    this[name] = command && command.TRANSFORM_LEGACY_REPLY && command.transformReply ? (...args) => {
      __classPrivateFieldGet(this, _RedisClientMultiCommand_multi, "f").addCommand([name, ...(0, commander_1.transformLegacyCommandArguments)(args)], command.transformReply);
      return this;
    } : (...args) => this.addCommand(name, ...args);
  };
  exports.default = RedisClientMultiCommand;
  (0, commander_1.attachCommands)({
    BaseClass: RedisClientMultiCommand,
    commands: commands_1.default,
    executor: RedisClientMultiCommand.prototype.commandsExecutor
  });
});

// node_modules/generic-pool/lib/factoryValidator.js
var require_factoryValidator = __commonJS((exports, module) => {
  module.exports = function(factory) {
    if (typeof factory.create !== "function") {
      throw new TypeError("factory.create must be a function");
    }
    if (typeof factory.destroy !== "function") {
      throw new TypeError("factory.destroy must be a function");
    }
    if (typeof factory.validate !== "undefined" && typeof factory.validate !== "function") {
      throw new TypeError("factory.validate must be a function");
    }
  };
});

// node_modules/generic-pool/lib/PoolDefaults.js
var require_PoolDefaults = __commonJS((exports, module) => {
  class PoolDefaults {
    constructor() {
      this.fifo = true;
      this.priorityRange = 1;
      this.testOnBorrow = false;
      this.testOnReturn = false;
      this.autostart = true;
      this.evictionRunIntervalMillis = 0;
      this.numTestsPerEvictionRun = 3;
      this.softIdleTimeoutMillis = -1;
      this.idleTimeoutMillis = 30000;
      this.acquireTimeoutMillis = null;
      this.destroyTimeoutMillis = null;
      this.maxWaitingClients = null;
      this.min = null;
      this.max = null;
      this.Promise = Promise;
    }
  }
  module.exports = PoolDefaults;
});

// node_modules/generic-pool/lib/PoolOptions.js
var require_PoolOptions = __commonJS((exports, module) => {
  var PoolDefaults = require_PoolDefaults();

  class PoolOptions {
    constructor(opts) {
      const poolDefaults = new PoolDefaults;
      opts = opts || {};
      this.fifo = typeof opts.fifo === "boolean" ? opts.fifo : poolDefaults.fifo;
      this.priorityRange = opts.priorityRange || poolDefaults.priorityRange;
      this.testOnBorrow = typeof opts.testOnBorrow === "boolean" ? opts.testOnBorrow : poolDefaults.testOnBorrow;
      this.testOnReturn = typeof opts.testOnReturn === "boolean" ? opts.testOnReturn : poolDefaults.testOnReturn;
      this.autostart = typeof opts.autostart === "boolean" ? opts.autostart : poolDefaults.autostart;
      if (opts.acquireTimeoutMillis) {
        this.acquireTimeoutMillis = parseInt(opts.acquireTimeoutMillis, 10);
      }
      if (opts.destroyTimeoutMillis) {
        this.destroyTimeoutMillis = parseInt(opts.destroyTimeoutMillis, 10);
      }
      if (opts.maxWaitingClients !== undefined) {
        this.maxWaitingClients = parseInt(opts.maxWaitingClients, 10);
      }
      this.max = parseInt(opts.max, 10);
      this.min = parseInt(opts.min, 10);
      this.max = Math.max(isNaN(this.max) ? 1 : this.max, 1);
      this.min = Math.min(isNaN(this.min) ? 0 : this.min, this.max);
      this.evictionRunIntervalMillis = opts.evictionRunIntervalMillis || poolDefaults.evictionRunIntervalMillis;
      this.numTestsPerEvictionRun = opts.numTestsPerEvictionRun || poolDefaults.numTestsPerEvictionRun;
      this.softIdleTimeoutMillis = opts.softIdleTimeoutMillis || poolDefaults.softIdleTimeoutMillis;
      this.idleTimeoutMillis = opts.idleTimeoutMillis || poolDefaults.idleTimeoutMillis;
      this.Promise = opts.Promise != null ? opts.Promise : poolDefaults.Promise;
    }
  }
  module.exports = PoolOptions;
});

// node_modules/generic-pool/lib/Deferred.js
var require_Deferred = __commonJS((exports, module) => {
  class Deferred {
    constructor(Promise2) {
      this._state = Deferred.PENDING;
      this._resolve = undefined;
      this._reject = undefined;
      this._promise = new Promise2((resolve, reject) => {
        this._resolve = resolve;
        this._reject = reject;
      });
    }
    get state() {
      return this._state;
    }
    get promise() {
      return this._promise;
    }
    reject(reason) {
      if (this._state !== Deferred.PENDING) {
        return;
      }
      this._state = Deferred.REJECTED;
      this._reject(reason);
    }
    resolve(value) {
      if (this._state !== Deferred.PENDING) {
        return;
      }
      this._state = Deferred.FULFILLED;
      this._resolve(value);
    }
  }
  Deferred.PENDING = "PENDING";
  Deferred.FULFILLED = "FULFILLED";
  Deferred.REJECTED = "REJECTED";
  module.exports = Deferred;
});

// node_modules/generic-pool/lib/errors.js
var require_errors4 = __commonJS((exports, module) => {
  class ExtendableError extends Error {
    constructor(message2) {
      super(message2);
      this.name = this.constructor.name;
      this.message = message2;
      if (typeof Error.captureStackTrace === "function") {
        Error.captureStackTrace(this, this.constructor);
      } else {
        this.stack = new Error(message2).stack;
      }
    }
  }

  class TimeoutError extends ExtendableError {
    constructor(m) {
      super(m);
    }
  }
  module.exports = {
    TimeoutError
  };
});

// node_modules/generic-pool/lib/ResourceRequest.js
var require_ResourceRequest = __commonJS((exports, module) => {
  var fbind = function(fn, ctx) {
    return function bound() {
      return fn.apply(ctx, arguments);
    };
  };
  var Deferred = require_Deferred();
  var errors15 = require_errors4();

  class ResourceRequest extends Deferred {
    constructor(ttl, Promise2) {
      super(Promise2);
      this._creationTimestamp = Date.now();
      this._timeout = null;
      if (ttl !== undefined) {
        this.setTimeout(ttl);
      }
    }
    setTimeout(delay) {
      if (this._state !== ResourceRequest.PENDING) {
        return;
      }
      const ttl = parseInt(delay, 10);
      if (isNaN(ttl) || ttl <= 0) {
        throw new Error("delay must be a positive int");
      }
      const age = Date.now() - this._creationTimestamp;
      if (this._timeout) {
        this.removeTimeout();
      }
      this._timeout = setTimeout(fbind(this._fireTimeout, this), Math.max(ttl - age, 0));
    }
    removeTimeout() {
      if (this._timeout) {
        clearTimeout(this._timeout);
      }
      this._timeout = null;
    }
    _fireTimeout() {
      this.reject(new errors15.TimeoutError("ResourceRequest timed out"));
    }
    reject(reason) {
      this.removeTimeout();
      super.reject(reason);
    }
    resolve(value) {
      this.removeTimeout();
      super.resolve(value);
    }
  }
  module.exports = ResourceRequest;
});

// node_modules/generic-pool/lib/ResourceLoan.js
var require_ResourceLoan = __commonJS((exports, module) => {
  var Deferred = require_Deferred();

  class ResourceLoan extends Deferred {
    constructor(pooledResource, Promise2) {
      super(Promise2);
      this._creationTimestamp = Date.now();
      this.pooledResource = pooledResource;
    }
    reject() {
    }
  }
  module.exports = ResourceLoan;
});

// node_modules/generic-pool/lib/PooledResourceStateEnum.js
var require_PooledResourceStateEnum = __commonJS((exports, module) => {
  var PooledResourceStateEnum = {
    ALLOCATED: "ALLOCATED",
    IDLE: "IDLE",
    INVALID: "INVALID",
    RETURNING: "RETURNING",
    VALIDATION: "VALIDATION"
  };
  module.exports = PooledResourceStateEnum;
});

// node_modules/generic-pool/lib/PooledResource.js
var require_PooledResource = __commonJS((exports, module) => {
  var PooledResourceStateEnum = require_PooledResourceStateEnum();

  class PooledResource {
    constructor(resource) {
      this.creationTime = Date.now();
      this.lastReturnTime = null;
      this.lastBorrowTime = null;
      this.lastIdleTime = null;
      this.obj = resource;
      this.state = PooledResourceStateEnum.IDLE;
    }
    allocate() {
      this.lastBorrowTime = Date.now();
      this.state = PooledResourceStateEnum.ALLOCATED;
    }
    deallocate() {
      this.lastReturnTime = Date.now();
      this.state = PooledResourceStateEnum.IDLE;
    }
    invalidate() {
      this.state = PooledResourceStateEnum.INVALID;
    }
    test() {
      this.state = PooledResourceStateEnum.VALIDATION;
    }
    idle() {
      this.lastIdleTime = Date.now();
      this.state = PooledResourceStateEnum.IDLE;
    }
    returning() {
      this.state = PooledResourceStateEnum.RETURNING;
    }
  }
  module.exports = PooledResource;
});

// node_modules/generic-pool/lib/DefaultEvictor.js
var require_DefaultEvictor = __commonJS((exports, module) => {
  class DefaultEvictor {
    evict(config, pooledResource, availableObjectsCount) {
      const idleTime = Date.now() - pooledResource.lastIdleTime;
      if (config.softIdleTimeoutMillis > 0 && config.softIdleTimeoutMillis < idleTime && config.min < availableObjectsCount) {
        return true;
      }
      if (config.idleTimeoutMillis < idleTime) {
        return true;
      }
      return false;
    }
  }
  module.exports = DefaultEvictor;
});

// node_modules/generic-pool/lib/DoublyLinkedList.js
var require_DoublyLinkedList = __commonJS((exports, module) => {
  class DoublyLinkedList {
    constructor() {
      this.head = null;
      this.tail = null;
      this.length = 0;
    }
    insertBeginning(node4) {
      if (this.head === null) {
        this.head = node4;
        this.tail = node4;
        node4.prev = null;
        node4.next = null;
        this.length++;
      } else {
        this.insertBefore(this.head, node4);
      }
    }
    insertEnd(node4) {
      if (this.tail === null) {
        this.insertBeginning(node4);
      } else {
        this.insertAfter(this.tail, node4);
      }
    }
    insertAfter(node4, newNode) {
      newNode.prev = node4;
      newNode.next = node4.next;
      if (node4.next === null) {
        this.tail = newNode;
      } else {
        node4.next.prev = newNode;
      }
      node4.next = newNode;
      this.length++;
    }
    insertBefore(node4, newNode) {
      newNode.prev = node4.prev;
      newNode.next = node4;
      if (node4.prev === null) {
        this.head = newNode;
      } else {
        node4.prev.next = newNode;
      }
      node4.prev = newNode;
      this.length++;
    }
    remove(node4) {
      if (node4.prev === null) {
        this.head = node4.next;
      } else {
        node4.prev.next = node4.next;
      }
      if (node4.next === null) {
        this.tail = node4.prev;
      } else {
        node4.next.prev = node4.prev;
      }
      node4.prev = null;
      node4.next = null;
      this.length--;
    }
    static createNode(data) {
      return {
        prev: null,
        next: null,
        data
      };
    }
  }
  module.exports = DoublyLinkedList;
});

// node_modules/generic-pool/lib/DoublyLinkedListIterator.js
var require_DoublyLinkedListIterator = __commonJS((exports, module) => {
  class DoublyLinkedListIterator {
    constructor(doublyLinkedList, reverse) {
      this._list = doublyLinkedList;
      this._direction = reverse === true ? "prev" : "next";
      this._startPosition = reverse === true ? "tail" : "head";
      this._started = false;
      this._cursor = null;
      this._done = false;
    }
    _start() {
      this._cursor = this._list[this._startPosition];
      this._started = true;
    }
    _advanceCursor() {
      if (this._started === false) {
        this._started = true;
        this._cursor = this._list[this._startPosition];
        return;
      }
      this._cursor = this._cursor[this._direction];
    }
    reset() {
      this._done = false;
      this._started = false;
      this._cursor = null;
    }
    remove() {
      if (this._started === false || this._done === true || this._isCursorDetached()) {
        return false;
      }
      this._list.remove(this._cursor);
    }
    next() {
      if (this._done === true) {
        return { done: true };
      }
      this._advanceCursor();
      if (this._cursor === null || this._isCursorDetached()) {
        this._done = true;
        return { done: true };
      }
      return {
        value: this._cursor,
        done: false
      };
    }
    _isCursorDetached() {
      return this._cursor.prev === null && this._cursor.next === null && this._list.tail !== this._cursor && this._list.head !== this._cursor;
    }
  }
  module.exports = DoublyLinkedListIterator;
});

// node_modules/generic-pool/lib/DequeIterator.js
var require_DequeIterator = __commonJS((exports, module) => {
  var DoublyLinkedListIterator = require_DoublyLinkedListIterator();

  class DequeIterator extends DoublyLinkedListIterator {
    next() {
      const result2 = super.next();
      if (result2.value) {
        result2.value = result2.value.data;
      }
      return result2;
    }
  }
  module.exports = DequeIterator;
});

// node_modules/generic-pool/lib/Deque.js
var require_Deque = __commonJS((exports, module) => {
  var DoublyLinkedList = require_DoublyLinkedList();
  var DequeIterator = require_DequeIterator();

  class Deque {
    constructor() {
      this._list = new DoublyLinkedList;
    }
    shift() {
      if (this.length === 0) {
        return;
      }
      const node4 = this._list.head;
      this._list.remove(node4);
      return node4.data;
    }
    unshift(element) {
      const node4 = DoublyLinkedList.createNode(element);
      this._list.insertBeginning(node4);
    }
    push(element) {
      const node4 = DoublyLinkedList.createNode(element);
      this._list.insertEnd(node4);
    }
    pop() {
      if (this.length === 0) {
        return;
      }
      const node4 = this._list.tail;
      this._list.remove(node4);
      return node4.data;
    }
    [Symbol.iterator]() {
      return new DequeIterator(this._list);
    }
    iterator() {
      return new DequeIterator(this._list);
    }
    reverseIterator() {
      return new DequeIterator(this._list, true);
    }
    get head() {
      if (this.length === 0) {
        return;
      }
      const node4 = this._list.head;
      return node4.data;
    }
    get tail() {
      if (this.length === 0) {
        return;
      }
      const node4 = this._list.tail;
      return node4.data;
    }
    get length() {
      return this._list.length;
    }
  }
  module.exports = Deque;
});

// node_modules/generic-pool/lib/Queue.js
var require_Queue = __commonJS((exports, module) => {
  var DoublyLinkedList = require_DoublyLinkedList();
  var Deque = require_Deque();

  class Queue2 extends Deque {
    push(resourceRequest) {
      const node4 = DoublyLinkedList.createNode(resourceRequest);
      resourceRequest.promise.catch(this._createTimeoutRejectionHandler(node4));
      this._list.insertEnd(node4);
    }
    _createTimeoutRejectionHandler(node4) {
      return (reason) => {
        if (reason.name === "TimeoutError") {
          this._list.remove(node4);
        }
      };
    }
  }
  module.exports = Queue2;
});

// node_modules/generic-pool/lib/PriorityQueue.js
var require_PriorityQueue = __commonJS((exports, module) => {
  var Queue2 = require_Queue();

  class PriorityQueue {
    constructor(size2) {
      this._size = Math.max(+size2 | 0, 1);
      this._slots = [];
      for (let i = 0;i < this._size; i++) {
        this._slots.push(new Queue2);
      }
    }
    get length() {
      let _length = 0;
      for (let i = 0, slots = this._slots.length;i < slots; i++) {
        _length += this._slots[i].length;
      }
      return _length;
    }
    enqueue(obj, priority) {
      priority = priority && +priority | 0 || 0;
      if (priority) {
        if (priority < 0 || priority >= this._size) {
          priority = this._size - 1;
        }
      }
      this._slots[priority].push(obj);
    }
    dequeue() {
      for (let i = 0, sl = this._slots.length;i < sl; i += 1) {
        if (this._slots[i].length) {
          return this._slots[i].shift();
        }
      }
      return;
    }
    get head() {
      for (let i = 0, sl = this._slots.length;i < sl; i += 1) {
        if (this._slots[i].length > 0) {
          return this._slots[i].head;
        }
      }
      return;
    }
    get tail() {
      for (let i = this._slots.length - 1;i >= 0; i--) {
        if (this._slots[i].length > 0) {
          return this._slots[i].tail;
        }
      }
      return;
    }
  }
  module.exports = PriorityQueue;
});

// node_modules/generic-pool/lib/utils.js
var require_utils4 = __commonJS((exports) => {
  var noop3 = function() {
  };
  exports.reflector = function(promise) {
    return promise.then(noop3, noop3);
  };
});

// node_modules/generic-pool/lib/Pool.js
var require_Pool = __commonJS((exports, module) => {
  var EventEmitter = __require("events").EventEmitter;
  var factoryValidator = require_factoryValidator();
  var PoolOptions = require_PoolOptions();
  var ResourceRequest = require_ResourceRequest();
  var ResourceLoan = require_ResourceLoan();
  var PooledResource = require_PooledResource();
  var DefaultEvictor = require_DefaultEvictor();
  var Deque = require_Deque();
  var Deferred = require_Deferred();
  var PriorityQueue = require_PriorityQueue();
  var DequeIterator = require_DequeIterator();
  var reflector = require_utils4().reflector;
  var FACTORY_CREATE_ERROR = "factoryCreateError";
  var FACTORY_DESTROY_ERROR = "factoryDestroyError";

  class Pool extends EventEmitter {
    constructor(Evictor, Deque2, PriorityQueue2, factory, options) {
      super();
      factoryValidator(factory);
      this._config = new PoolOptions(options);
      this._Promise = this._config.Promise;
      this._factory = factory;
      this._draining = false;
      this._started = false;
      this._waitingClientsQueue = new PriorityQueue2(this._config.priorityRange);
      this._factoryCreateOperations = new Set;
      this._factoryDestroyOperations = new Set;
      this._availableObjects = new Deque2;
      this._testOnBorrowResources = new Set;
      this._testOnReturnResources = new Set;
      this._validationOperations = new Set;
      this._allObjects = new Set;
      this._resourceLoans = new Map;
      this._evictionIterator = this._availableObjects.iterator();
      this._evictor = new Evictor;
      this._scheduledEviction = null;
      if (this._config.autostart === true) {
        this.start();
      }
    }
    _destroy(pooledResource) {
      pooledResource.invalidate();
      this._allObjects.delete(pooledResource);
      const destroyPromise = this._factory.destroy(pooledResource.obj);
      const wrappedDestroyPromise = this._config.destroyTimeoutMillis ? this._Promise.resolve(this._applyDestroyTimeout(destroyPromise)) : this._Promise.resolve(destroyPromise);
      this._trackOperation(wrappedDestroyPromise, this._factoryDestroyOperations).catch((reason) => {
        this.emit(FACTORY_DESTROY_ERROR, reason);
      });
      this._ensureMinimum();
    }
    _applyDestroyTimeout(promise) {
      const timeoutPromise = new this._Promise((resolve, reject) => {
        setTimeout(() => {
          reject(new Error("destroy timed out"));
        }, this._config.destroyTimeoutMillis).unref();
      });
      return this._Promise.race([timeoutPromise, promise]);
    }
    _testOnBorrow() {
      if (this._availableObjects.length < 1) {
        return false;
      }
      const pooledResource = this._availableObjects.shift();
      pooledResource.test();
      this._testOnBorrowResources.add(pooledResource);
      const validationPromise = this._factory.validate(pooledResource.obj);
      const wrappedValidationPromise = this._Promise.resolve(validationPromise);
      this._trackOperation(wrappedValidationPromise, this._validationOperations).then((isValid) => {
        this._testOnBorrowResources.delete(pooledResource);
        if (isValid === false) {
          pooledResource.invalidate();
          this._destroy(pooledResource);
          this._dispense();
          return;
        }
        this._dispatchPooledResourceToNextWaitingClient(pooledResource);
      });
      return true;
    }
    _dispatchResource() {
      if (this._availableObjects.length < 1) {
        return false;
      }
      const pooledResource = this._availableObjects.shift();
      this._dispatchPooledResourceToNextWaitingClient(pooledResource);
      return false;
    }
    _dispense() {
      const numWaitingClients = this._waitingClientsQueue.length;
      if (numWaitingClients < 1) {
        return;
      }
      const resourceShortfall = numWaitingClients - this._potentiallyAllocableResourceCount;
      const actualNumberOfResourcesToCreate = Math.min(this.spareResourceCapacity, resourceShortfall);
      for (let i = 0;actualNumberOfResourcesToCreate > i; i++) {
        this._createResource();
      }
      if (this._config.testOnBorrow === true) {
        const desiredNumberOfResourcesToMoveIntoTest = numWaitingClients - this._testOnBorrowResources.size;
        const actualNumberOfResourcesToMoveIntoTest = Math.min(this._availableObjects.length, desiredNumberOfResourcesToMoveIntoTest);
        for (let i = 0;actualNumberOfResourcesToMoveIntoTest > i; i++) {
          this._testOnBorrow();
        }
      }
      if (this._config.testOnBorrow === false) {
        const actualNumberOfResourcesToDispatch = Math.min(this._availableObjects.length, numWaitingClients);
        for (let i = 0;actualNumberOfResourcesToDispatch > i; i++) {
          this._dispatchResource();
        }
      }
    }
    _dispatchPooledResourceToNextWaitingClient(pooledResource) {
      const clientResourceRequest = this._waitingClientsQueue.dequeue();
      if (clientResourceRequest === undefined || clientResourceRequest.state !== Deferred.PENDING) {
        this._addPooledResourceToAvailableObjects(pooledResource);
        return false;
      }
      const loan = new ResourceLoan(pooledResource, this._Promise);
      this._resourceLoans.set(pooledResource.obj, loan);
      pooledResource.allocate();
      clientResourceRequest.resolve(pooledResource.obj);
      return true;
    }
    _trackOperation(operation, set) {
      set.add(operation);
      return operation.then((v) => {
        set.delete(operation);
        return this._Promise.resolve(v);
      }, (e) => {
        set.delete(operation);
        return this._Promise.reject(e);
      });
    }
    _createResource() {
      const factoryPromise = this._factory.create();
      const wrappedFactoryPromise = this._Promise.resolve(factoryPromise).then((resource) => {
        const pooledResource = new PooledResource(resource);
        this._allObjects.add(pooledResource);
        this._addPooledResourceToAvailableObjects(pooledResource);
      });
      this._trackOperation(wrappedFactoryPromise, this._factoryCreateOperations).then(() => {
        this._dispense();
        return null;
      }).catch((reason) => {
        this.emit(FACTORY_CREATE_ERROR, reason);
        this._dispense();
      });
    }
    _ensureMinimum() {
      if (this._draining === true) {
        return;
      }
      const minShortfall = this._config.min - this._count;
      for (let i = 0;i < minShortfall; i++) {
        this._createResource();
      }
    }
    _evict() {
      const testsToRun = Math.min(this._config.numTestsPerEvictionRun, this._availableObjects.length);
      const evictionConfig = {
        softIdleTimeoutMillis: this._config.softIdleTimeoutMillis,
        idleTimeoutMillis: this._config.idleTimeoutMillis,
        min: this._config.min
      };
      for (let testsHaveRun = 0;testsHaveRun < testsToRun; ) {
        const iterationResult = this._evictionIterator.next();
        if (iterationResult.done === true && this._availableObjects.length < 1) {
          this._evictionIterator.reset();
          return;
        }
        if (iterationResult.done === true && this._availableObjects.length > 0) {
          this._evictionIterator.reset();
          continue;
        }
        const resource = iterationResult.value;
        const shouldEvict = this._evictor.evict(evictionConfig, resource, this._availableObjects.length);
        testsHaveRun++;
        if (shouldEvict === true) {
          this._evictionIterator.remove();
          this._destroy(resource);
        }
      }
    }
    _scheduleEvictorRun() {
      if (this._config.evictionRunIntervalMillis > 0) {
        this._scheduledEviction = setTimeout(() => {
          this._evict();
          this._scheduleEvictorRun();
        }, this._config.evictionRunIntervalMillis).unref();
      }
    }
    _descheduleEvictorRun() {
      if (this._scheduledEviction) {
        clearTimeout(this._scheduledEviction);
      }
      this._scheduledEviction = null;
    }
    start() {
      if (this._draining === true) {
        return;
      }
      if (this._started === true) {
        return;
      }
      this._started = true;
      this._scheduleEvictorRun();
      this._ensureMinimum();
    }
    acquire(priority) {
      if (this._started === false && this._config.autostart === false) {
        this.start();
      }
      if (this._draining) {
        return this._Promise.reject(new Error("pool is draining and cannot accept work"));
      }
      if (this.spareResourceCapacity < 1 && this._availableObjects.length < 1 && this._config.maxWaitingClients !== undefined && this._waitingClientsQueue.length >= this._config.maxWaitingClients) {
        return this._Promise.reject(new Error("max waitingClients count exceeded"));
      }
      const resourceRequest = new ResourceRequest(this._config.acquireTimeoutMillis, this._Promise);
      this._waitingClientsQueue.enqueue(resourceRequest, priority);
      this._dispense();
      return resourceRequest.promise;
    }
    use(fn, priority) {
      return this.acquire(priority).then((resource) => {
        return fn(resource).then((result2) => {
          this.release(resource);
          return result2;
        }, (err) => {
          this.destroy(resource);
          throw err;
        });
      });
    }
    isBorrowedResource(resource) {
      return this._resourceLoans.has(resource);
    }
    release(resource) {
      const loan = this._resourceLoans.get(resource);
      if (loan === undefined) {
        return this._Promise.reject(new Error("Resource not currently part of this pool"));
      }
      this._resourceLoans.delete(resource);
      loan.resolve();
      const pooledResource = loan.pooledResource;
      pooledResource.deallocate();
      this._addPooledResourceToAvailableObjects(pooledResource);
      this._dispense();
      return this._Promise.resolve();
    }
    destroy(resource) {
      const loan = this._resourceLoans.get(resource);
      if (loan === undefined) {
        return this._Promise.reject(new Error("Resource not currently part of this pool"));
      }
      this._resourceLoans.delete(resource);
      loan.resolve();
      const pooledResource = loan.pooledResource;
      pooledResource.deallocate();
      this._destroy(pooledResource);
      this._dispense();
      return this._Promise.resolve();
    }
    _addPooledResourceToAvailableObjects(pooledResource) {
      pooledResource.idle();
      if (this._config.fifo === true) {
        this._availableObjects.push(pooledResource);
      } else {
        this._availableObjects.unshift(pooledResource);
      }
    }
    drain() {
      this._draining = true;
      return this.__allResourceRequestsSettled().then(() => {
        return this.__allResourcesReturned();
      }).then(() => {
        this._descheduleEvictorRun();
      });
    }
    __allResourceRequestsSettled() {
      if (this._waitingClientsQueue.length > 0) {
        return reflector(this._waitingClientsQueue.tail.promise);
      }
      return this._Promise.resolve();
    }
    __allResourcesReturned() {
      const ps = Array.from(this._resourceLoans.values()).map((loan) => loan.promise).map(reflector);
      return this._Promise.all(ps);
    }
    clear() {
      const reflectedCreatePromises = Array.from(this._factoryCreateOperations).map(reflector);
      return this._Promise.all(reflectedCreatePromises).then(() => {
        for (const resource of this._availableObjects) {
          this._destroy(resource);
        }
        const reflectedDestroyPromises = Array.from(this._factoryDestroyOperations).map(reflector);
        return reflector(this._Promise.all(reflectedDestroyPromises));
      });
    }
    ready() {
      return new this._Promise((resolve) => {
        const isReady = () => {
          if (this.available >= this.min) {
            resolve();
          } else {
            setTimeout(isReady, 100);
          }
        };
        isReady();
      });
    }
    get _potentiallyAllocableResourceCount() {
      return this._availableObjects.length + this._testOnBorrowResources.size + this._testOnReturnResources.size + this._factoryCreateOperations.size;
    }
    get _count() {
      return this._allObjects.size + this._factoryCreateOperations.size;
    }
    get spareResourceCapacity() {
      return this._config.max - (this._allObjects.size + this._factoryCreateOperations.size);
    }
    get size() {
      return this._count;
    }
    get available() {
      return this._availableObjects.length;
    }
    get borrowed() {
      return this._resourceLoans.size;
    }
    get pending() {
      return this._waitingClientsQueue.length;
    }
    get max() {
      return this._config.max;
    }
    get min() {
      return this._config.min;
    }
  }
  module.exports = Pool;
});

// node_modules/generic-pool/index.js
var require_generic_pool = __commonJS((exports, module) => {
  var Pool = require_Pool();
  var Deque = require_Deque();
  var PriorityQueue = require_PriorityQueue();
  var DefaultEvictor = require_DefaultEvictor();
  module.exports = {
    Pool,
    Deque,
    PriorityQueue,
    DefaultEvictor,
    createPool: function(factory, config) {
      return new Pool(DefaultEvictor, Deque, PriorityQueue, factory, config);
    }
  };
});

// node_modules/@redis/client/dist/lib/client/index.js
var require_client2 = __commonJS((exports) => {
  var __classPrivateFieldGet = exports && exports.__classPrivateFieldGet || function(receiver, state, kind, f) {
    if (kind === "a" && !f)
      throw new TypeError("Private accessor was defined without a getter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver))
      throw new TypeError("Cannot read private member from an object whose class did not declare it");
    return kind === "m" ? f : kind === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
  };
  var __classPrivateFieldSet = exports && exports.__classPrivateFieldSet || function(receiver, state, value, kind, f) {
    if (kind === "m")
      throw new TypeError("Private method is not writable");
    if (kind === "a" && !f)
      throw new TypeError("Private accessor was defined without a setter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver))
      throw new TypeError("Cannot write private member to an object whose class did not declare it");
    return kind === "a" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value), value;
  };
  var _RedisClient_instances;
  var _RedisClient_options;
  var _RedisClient_socket;
  var _RedisClient_queue;
  var _RedisClient_isolationPool;
  var _RedisClient_v4;
  var _RedisClient_selectedDB;
  var _RedisClient_initiateOptions;
  var _RedisClient_initiateQueue;
  var _RedisClient_initiateSocket;
  var _RedisClient_initiateIsolationPool;
  var _RedisClient_legacyMode;
  var _RedisClient_legacySendCommand;
  var _RedisClient_defineLegacyCommand;
  var _RedisClient_pingTimer;
  var _RedisClient_setPingTimer;
  var _RedisClient_sendCommand;
  var _RedisClient_pubSubCommand;
  var _RedisClient_tick;
  var _RedisClient_addMultiCommands;
  var _RedisClient_destroyIsolationPool;
  Object.defineProperty(exports, "__esModule", { value: true });
  var commands_1 = require_commands3();
  var socket_1 = require_socket();
  var commands_queue_1 = require_commands_queue();
  var multi_command_1 = require_multi_command2();
  var events_1 = __require("events");
  var command_options_1 = require_command_options();
  var commander_1 = require_commander2();
  var generic_pool_1 = require_generic_pool();
  var errors_1 = require_errors3();
  var url_1 = __require("url");
  var pub_sub_1 = require_pub_sub();

  class RedisClient extends events_1.EventEmitter {
    static commandOptions(options) {
      return (0, command_options_1.commandOptions)(options);
    }
    static extend(extensions) {
      const Client = (0, commander_1.attachExtensions)({
        BaseClass: RedisClient,
        modulesExecutor: RedisClient.prototype.commandsExecutor,
        modules: extensions?.modules,
        functionsExecutor: RedisClient.prototype.functionsExecuter,
        functions: extensions?.functions,
        scriptsExecutor: RedisClient.prototype.scriptsExecuter,
        scripts: extensions?.scripts
      });
      if (Client !== RedisClient) {
        Client.prototype.Multi = multi_command_1.default.extend(extensions);
      }
      return Client;
    }
    static create(options) {
      return new (RedisClient.extend(options))(options);
    }
    static parseURL(url7) {
      const { hostname, port, protocol, username, password, pathname } = new url_1.URL(url7), parsed = {
        socket: {
          host: hostname
        }
      };
      if (protocol === "rediss:") {
        parsed.socket.tls = true;
      } else if (protocol !== "redis:") {
        throw new TypeError("Invalid protocol");
      }
      if (port) {
        parsed.socket.port = Number(port);
      }
      if (username) {
        parsed.username = decodeURIComponent(username);
      }
      if (password) {
        parsed.password = decodeURIComponent(password);
      }
      if (pathname.length > 1) {
        const database = Number(pathname.substring(1));
        if (isNaN(database)) {
          throw new TypeError("Invalid pathname");
        }
        parsed.database = database;
      }
      return parsed;
    }
    get options() {
      return __classPrivateFieldGet(this, _RedisClient_options, "f");
    }
    get isOpen() {
      return __classPrivateFieldGet(this, _RedisClient_socket, "f").isOpen;
    }
    get isReady() {
      return __classPrivateFieldGet(this, _RedisClient_socket, "f").isReady;
    }
    get isPubSubActive() {
      return __classPrivateFieldGet(this, _RedisClient_queue, "f").isPubSubActive;
    }
    get v4() {
      if (!__classPrivateFieldGet(this, _RedisClient_options, "f")?.legacyMode) {
        throw new Error('the client is not in "legacy mode"');
      }
      return __classPrivateFieldGet(this, _RedisClient_v4, "f");
    }
    constructor(options) {
      super();
      _RedisClient_instances.add(this);
      Object.defineProperty(this, "commandOptions", {
        enumerable: true,
        configurable: true,
        writable: true,
        value: RedisClient.commandOptions
      });
      _RedisClient_options.set(this, undefined);
      _RedisClient_socket.set(this, undefined);
      _RedisClient_queue.set(this, undefined);
      _RedisClient_isolationPool.set(this, undefined);
      _RedisClient_v4.set(this, {});
      _RedisClient_selectedDB.set(this, 0);
      _RedisClient_pingTimer.set(this, undefined);
      Object.defineProperty(this, "select", {
        enumerable: true,
        configurable: true,
        writable: true,
        value: this.SELECT
      });
      Object.defineProperty(this, "subscribe", {
        enumerable: true,
        configurable: true,
        writable: true,
        value: this.SUBSCRIBE
      });
      Object.defineProperty(this, "unsubscribe", {
        enumerable: true,
        configurable: true,
        writable: true,
        value: this.UNSUBSCRIBE
      });
      Object.defineProperty(this, "pSubscribe", {
        enumerable: true,
        configurable: true,
        writable: true,
        value: this.PSUBSCRIBE
      });
      Object.defineProperty(this, "pUnsubscribe", {
        enumerable: true,
        configurable: true,
        writable: true,
        value: this.PUNSUBSCRIBE
      });
      Object.defineProperty(this, "sSubscribe", {
        enumerable: true,
        configurable: true,
        writable: true,
        value: this.SSUBSCRIBE
      });
      Object.defineProperty(this, "sUnsubscribe", {
        enumerable: true,
        configurable: true,
        writable: true,
        value: this.SUNSUBSCRIBE
      });
      Object.defineProperty(this, "quit", {
        enumerable: true,
        configurable: true,
        writable: true,
        value: this.QUIT
      });
      Object.defineProperty(this, "multi", {
        enumerable: true,
        configurable: true,
        writable: true,
        value: this.MULTI
      });
      __classPrivateFieldSet(this, _RedisClient_options, __classPrivateFieldGet(this, _RedisClient_instances, "m", _RedisClient_initiateOptions).call(this, options), "f");
      __classPrivateFieldSet(this, _RedisClient_queue, __classPrivateFieldGet(this, _RedisClient_instances, "m", _RedisClient_initiateQueue).call(this), "f");
      __classPrivateFieldSet(this, _RedisClient_socket, __classPrivateFieldGet(this, _RedisClient_instances, "m", _RedisClient_initiateSocket).call(this), "f");
      __classPrivateFieldSet(this, _RedisClient_isolationPool, __classPrivateFieldGet(this, _RedisClient_instances, "m", _RedisClient_initiateIsolationPool).call(this), "f");
      __classPrivateFieldGet(this, _RedisClient_instances, "m", _RedisClient_legacyMode).call(this);
    }
    duplicate(overrides) {
      return new (Object.getPrototypeOf(this)).constructor({
        ...__classPrivateFieldGet(this, _RedisClient_options, "f"),
        ...overrides
      });
    }
    connect() {
      __classPrivateFieldSet(this, _RedisClient_isolationPool, __classPrivateFieldGet(this, _RedisClient_isolationPool, "f") ?? __classPrivateFieldGet(this, _RedisClient_instances, "m", _RedisClient_initiateIsolationPool).call(this), "f");
      return __classPrivateFieldGet(this, _RedisClient_socket, "f").connect();
    }
    async commandsExecutor(command, args) {
      const { args: redisArgs, options } = (0, commander_1.transformCommandArguments)(command, args);
      return (0, commander_1.transformCommandReply)(command, await __classPrivateFieldGet(this, _RedisClient_instances, "m", _RedisClient_sendCommand).call(this, redisArgs, options), redisArgs.preserve);
    }
    sendCommand(args, options) {
      return __classPrivateFieldGet(this, _RedisClient_instances, "m", _RedisClient_sendCommand).call(this, args, options);
    }
    async functionsExecuter(fn, args, name) {
      const { args: redisArgs, options } = (0, commander_1.transformCommandArguments)(fn, args);
      return (0, commander_1.transformCommandReply)(fn, await this.executeFunction(name, fn, redisArgs, options), redisArgs.preserve);
    }
    executeFunction(name, fn, args, options) {
      return __classPrivateFieldGet(this, _RedisClient_instances, "m", _RedisClient_sendCommand).call(this, (0, commander_1.fCallArguments)(name, fn, args), options);
    }
    async scriptsExecuter(script, args) {
      const { args: redisArgs, options } = (0, commander_1.transformCommandArguments)(script, args);
      return (0, commander_1.transformCommandReply)(script, await this.executeScript(script, redisArgs, options), redisArgs.preserve);
    }
    async executeScript(script, args, options) {
      const redisArgs = ["EVALSHA", script.SHA1];
      if (script.NUMBER_OF_KEYS !== undefined) {
        redisArgs.push(script.NUMBER_OF_KEYS.toString());
      }
      redisArgs.push(...args);
      try {
        return await __classPrivateFieldGet(this, _RedisClient_instances, "m", _RedisClient_sendCommand).call(this, redisArgs, options);
      } catch (err) {
        if (!err?.message?.startsWith?.("NOSCRIPT")) {
          throw err;
        }
        redisArgs[0] = "EVAL";
        redisArgs[1] = script.SCRIPT;
        return __classPrivateFieldGet(this, _RedisClient_instances, "m", _RedisClient_sendCommand).call(this, redisArgs, options);
      }
    }
    async SELECT(options, db2) {
      if (!(0, command_options_1.isCommandOptions)(options)) {
        db2 = options;
        options = null;
      }
      await __classPrivateFieldGet(this, _RedisClient_instances, "m", _RedisClient_sendCommand).call(this, ["SELECT", db2.toString()], options);
      __classPrivateFieldSet(this, _RedisClient_selectedDB, db2, "f");
    }
    SUBSCRIBE(channels, listener, bufferMode) {
      return __classPrivateFieldGet(this, _RedisClient_instances, "m", _RedisClient_pubSubCommand).call(this, __classPrivateFieldGet(this, _RedisClient_queue, "f").subscribe(pub_sub_1.PubSubType.CHANNELS, channels, listener, bufferMode));
    }
    UNSUBSCRIBE(channels, listener, bufferMode) {
      return __classPrivateFieldGet(this, _RedisClient_instances, "m", _RedisClient_pubSubCommand).call(this, __classPrivateFieldGet(this, _RedisClient_queue, "f").unsubscribe(pub_sub_1.PubSubType.CHANNELS, channels, listener, bufferMode));
    }
    PSUBSCRIBE(patterns, listener, bufferMode) {
      return __classPrivateFieldGet(this, _RedisClient_instances, "m", _RedisClient_pubSubCommand).call(this, __classPrivateFieldGet(this, _RedisClient_queue, "f").subscribe(pub_sub_1.PubSubType.PATTERNS, patterns, listener, bufferMode));
    }
    PUNSUBSCRIBE(patterns, listener, bufferMode) {
      return __classPrivateFieldGet(this, _RedisClient_instances, "m", _RedisClient_pubSubCommand).call(this, __classPrivateFieldGet(this, _RedisClient_queue, "f").unsubscribe(pub_sub_1.PubSubType.PATTERNS, patterns, listener, bufferMode));
    }
    SSUBSCRIBE(channels, listener, bufferMode) {
      return __classPrivateFieldGet(this, _RedisClient_instances, "m", _RedisClient_pubSubCommand).call(this, __classPrivateFieldGet(this, _RedisClient_queue, "f").subscribe(pub_sub_1.PubSubType.SHARDED, channels, listener, bufferMode));
    }
    SUNSUBSCRIBE(channels, listener, bufferMode) {
      return __classPrivateFieldGet(this, _RedisClient_instances, "m", _RedisClient_pubSubCommand).call(this, __classPrivateFieldGet(this, _RedisClient_queue, "f").unsubscribe(pub_sub_1.PubSubType.SHARDED, channels, listener, bufferMode));
    }
    getPubSubListeners(type) {
      return __classPrivateFieldGet(this, _RedisClient_queue, "f").getPubSubListeners(type);
    }
    extendPubSubChannelListeners(type, channel, listeners) {
      return __classPrivateFieldGet(this, _RedisClient_instances, "m", _RedisClient_pubSubCommand).call(this, __classPrivateFieldGet(this, _RedisClient_queue, "f").extendPubSubChannelListeners(type, channel, listeners));
    }
    extendPubSubListeners(type, listeners) {
      return __classPrivateFieldGet(this, _RedisClient_instances, "m", _RedisClient_pubSubCommand).call(this, __classPrivateFieldGet(this, _RedisClient_queue, "f").extendPubSubListeners(type, listeners));
    }
    QUIT() {
      return __classPrivateFieldGet(this, _RedisClient_socket, "f").quit(async () => {
        if (__classPrivateFieldGet(this, _RedisClient_pingTimer, "f"))
          clearTimeout(__classPrivateFieldGet(this, _RedisClient_pingTimer, "f"));
        const quitPromise = __classPrivateFieldGet(this, _RedisClient_queue, "f").addCommand(["QUIT"]);
        __classPrivateFieldGet(this, _RedisClient_instances, "m", _RedisClient_tick).call(this);
        const [reply] = await Promise.all([
          quitPromise,
          __classPrivateFieldGet(this, _RedisClient_instances, "m", _RedisClient_destroyIsolationPool).call(this)
        ]);
        return reply;
      });
    }
    executeIsolated(fn) {
      if (!__classPrivateFieldGet(this, _RedisClient_isolationPool, "f"))
        return Promise.reject(new errors_1.ClientClosedError);
      return __classPrivateFieldGet(this, _RedisClient_isolationPool, "f").use(fn);
    }
    MULTI() {
      return new this.Multi(this.multiExecutor.bind(this), __classPrivateFieldGet(this, _RedisClient_options, "f")?.legacyMode);
    }
    async multiExecutor(commands, selectedDB, chainId) {
      if (!__classPrivateFieldGet(this, _RedisClient_socket, "f").isOpen) {
        return Promise.reject(new errors_1.ClientClosedError);
      }
      const promise = chainId ? Promise.all([
        __classPrivateFieldGet(this, _RedisClient_queue, "f").addCommand(["MULTI"], { chainId }),
        __classPrivateFieldGet(this, _RedisClient_instances, "m", _RedisClient_addMultiCommands).call(this, commands, chainId),
        __classPrivateFieldGet(this, _RedisClient_queue, "f").addCommand(["EXEC"], { chainId })
      ]) : __classPrivateFieldGet(this, _RedisClient_instances, "m", _RedisClient_addMultiCommands).call(this, commands);
      __classPrivateFieldGet(this, _RedisClient_instances, "m", _RedisClient_tick).call(this);
      const results = await promise;
      if (selectedDB !== undefined) {
        __classPrivateFieldSet(this, _RedisClient_selectedDB, selectedDB, "f");
      }
      return results;
    }
    async* scanIterator(options) {
      let cursor = 0;
      do {
        const reply = await this.scan(cursor, options);
        cursor = reply.cursor;
        for (const key of reply.keys) {
          yield key;
        }
      } while (cursor !== 0);
    }
    async* hScanIterator(key, options) {
      let cursor = 0;
      do {
        const reply = await this.hScan(key, cursor, options);
        cursor = reply.cursor;
        for (const tuple of reply.tuples) {
          yield tuple;
        }
      } while (cursor !== 0);
    }
    async* sScanIterator(key, options) {
      let cursor = 0;
      do {
        const reply = await this.sScan(key, cursor, options);
        cursor = reply.cursor;
        for (const member of reply.members) {
          yield member;
        }
      } while (cursor !== 0);
    }
    async* zScanIterator(key, options) {
      let cursor = 0;
      do {
        const reply = await this.zScan(key, cursor, options);
        cursor = reply.cursor;
        for (const member of reply.members) {
          yield member;
        }
      } while (cursor !== 0);
    }
    async disconnect() {
      if (__classPrivateFieldGet(this, _RedisClient_pingTimer, "f"))
        clearTimeout(__classPrivateFieldGet(this, _RedisClient_pingTimer, "f"));
      __classPrivateFieldGet(this, _RedisClient_queue, "f").flushAll(new errors_1.DisconnectsClientError);
      __classPrivateFieldGet(this, _RedisClient_socket, "f").disconnect();
      await __classPrivateFieldGet(this, _RedisClient_instances, "m", _RedisClient_destroyIsolationPool).call(this);
    }
    ref() {
      __classPrivateFieldGet(this, _RedisClient_socket, "f").ref();
    }
    unref() {
      __classPrivateFieldGet(this, _RedisClient_socket, "f").unref();
    }
  }
  _RedisClient_options = new WeakMap, _RedisClient_socket = new WeakMap, _RedisClient_queue = new WeakMap, _RedisClient_isolationPool = new WeakMap, _RedisClient_v4 = new WeakMap, _RedisClient_selectedDB = new WeakMap, _RedisClient_pingTimer = new WeakMap, _RedisClient_instances = new WeakSet, _RedisClient_initiateOptions = function _RedisClient_initiateOptions(options) {
    if (options?.url) {
      const parsed = RedisClient.parseURL(options.url);
      if (options.socket) {
        parsed.socket = Object.assign(options.socket, parsed.socket);
      }
      Object.assign(options, parsed);
    }
    if (options?.database) {
      __classPrivateFieldSet(this, _RedisClient_selectedDB, options.database, "f");
    }
    return options;
  }, _RedisClient_initiateQueue = function _RedisClient_initiateQueue() {
    return new commands_queue_1.default(__classPrivateFieldGet(this, _RedisClient_options, "f")?.commandsQueueMaxLength, (channel, listeners) => this.emit("sharded-channel-moved", channel, listeners));
  }, _RedisClient_initiateSocket = function _RedisClient_initiateSocket() {
    const socketInitiator = async () => {
      const promises = [];
      if (__classPrivateFieldGet(this, _RedisClient_selectedDB, "f") !== 0) {
        promises.push(__classPrivateFieldGet(this, _RedisClient_queue, "f").addCommand(["SELECT", __classPrivateFieldGet(this, _RedisClient_selectedDB, "f").toString()], { asap: true }));
      }
      if (__classPrivateFieldGet(this, _RedisClient_options, "f")?.readonly) {
        promises.push(__classPrivateFieldGet(this, _RedisClient_queue, "f").addCommand(commands_1.default.READONLY.transformArguments(), { asap: true }));
      }
      if (__classPrivateFieldGet(this, _RedisClient_options, "f")?.name) {
        promises.push(__classPrivateFieldGet(this, _RedisClient_queue, "f").addCommand(commands_1.default.CLIENT_SETNAME.transformArguments(__classPrivateFieldGet(this, _RedisClient_options, "f").name), { asap: true }));
      }
      if (__classPrivateFieldGet(this, _RedisClient_options, "f")?.username || __classPrivateFieldGet(this, _RedisClient_options, "f")?.password) {
        promises.push(__classPrivateFieldGet(this, _RedisClient_queue, "f").addCommand(commands_1.default.AUTH.transformArguments({
          username: __classPrivateFieldGet(this, _RedisClient_options, "f").username,
          password: __classPrivateFieldGet(this, _RedisClient_options, "f").password ?? ""
        }), { asap: true }));
      }
      const resubscribePromise = __classPrivateFieldGet(this, _RedisClient_queue, "f").resubscribe();
      if (resubscribePromise) {
        promises.push(resubscribePromise);
      }
      if (promises.length) {
        __classPrivateFieldGet(this, _RedisClient_instances, "m", _RedisClient_tick).call(this, true);
        await Promise.all(promises);
      }
    };
    return new socket_1.default(socketInitiator, __classPrivateFieldGet(this, _RedisClient_options, "f")?.socket).on("data", (chunk) => __classPrivateFieldGet(this, _RedisClient_queue, "f").onReplyChunk(chunk)).on("error", (err) => {
      this.emit("error", err);
      if (__classPrivateFieldGet(this, _RedisClient_socket, "f").isOpen && !__classPrivateFieldGet(this, _RedisClient_options, "f")?.disableOfflineQueue) {
        __classPrivateFieldGet(this, _RedisClient_queue, "f").flushWaitingForReply(err);
      } else {
        __classPrivateFieldGet(this, _RedisClient_queue, "f").flushAll(err);
      }
    }).on("connect", () => {
      this.emit("connect");
    }).on("ready", () => {
      this.emit("ready");
      __classPrivateFieldGet(this, _RedisClient_instances, "m", _RedisClient_setPingTimer).call(this);
      __classPrivateFieldGet(this, _RedisClient_instances, "m", _RedisClient_tick).call(this);
    }).on("reconnecting", () => this.emit("reconnecting")).on("drain", () => __classPrivateFieldGet(this, _RedisClient_instances, "m", _RedisClient_tick).call(this)).on("end", () => this.emit("end"));
  }, _RedisClient_initiateIsolationPool = function _RedisClient_initiateIsolationPool() {
    return (0, generic_pool_1.createPool)({
      create: async () => {
        const duplicate = this.duplicate({
          isolationPoolOptions: undefined
        }).on("error", (err) => this.emit("error", err));
        await duplicate.connect();
        return duplicate;
      },
      destroy: (client) => client.disconnect()
    }, __classPrivateFieldGet(this, _RedisClient_options, "f")?.isolationPoolOptions);
  }, _RedisClient_legacyMode = function _RedisClient_legacyMode() {
    var _a, _b;
    if (!__classPrivateFieldGet(this, _RedisClient_options, "f")?.legacyMode)
      return;
    __classPrivateFieldGet(this, _RedisClient_v4, "f").sendCommand = __classPrivateFieldGet(this, _RedisClient_instances, "m", _RedisClient_sendCommand).bind(this);
    this.sendCommand = (...args) => {
      const result2 = __classPrivateFieldGet(this, _RedisClient_instances, "m", _RedisClient_legacySendCommand).call(this, ...args);
      if (result2) {
        result2.promise.then((reply) => result2.callback(null, reply)).catch((err) => result2.callback(err));
      }
    };
    for (const [name, command] of Object.entries(commands_1.default)) {
      __classPrivateFieldGet(this, _RedisClient_instances, "m", _RedisClient_defineLegacyCommand).call(this, name, command);
      (_a = this)[_b = name.toLowerCase()] ?? (_a[_b] = this[name]);
    }
    __classPrivateFieldGet(this, _RedisClient_instances, "m", _RedisClient_defineLegacyCommand).call(this, "SELECT");
    __classPrivateFieldGet(this, _RedisClient_instances, "m", _RedisClient_defineLegacyCommand).call(this, "select");
    __classPrivateFieldGet(this, _RedisClient_instances, "m", _RedisClient_defineLegacyCommand).call(this, "SUBSCRIBE");
    __classPrivateFieldGet(this, _RedisClient_instances, "m", _RedisClient_defineLegacyCommand).call(this, "subscribe");
    __classPrivateFieldGet(this, _RedisClient_instances, "m", _RedisClient_defineLegacyCommand).call(this, "PSUBSCRIBE");
    __classPrivateFieldGet(this, _RedisClient_instances, "m", _RedisClient_defineLegacyCommand).call(this, "pSubscribe");
    __classPrivateFieldGet(this, _RedisClient_instances, "m", _RedisClient_defineLegacyCommand).call(this, "UNSUBSCRIBE");
    __classPrivateFieldGet(this, _RedisClient_instances, "m", _RedisClient_defineLegacyCommand).call(this, "unsubscribe");
    __classPrivateFieldGet(this, _RedisClient_instances, "m", _RedisClient_defineLegacyCommand).call(this, "PUNSUBSCRIBE");
    __classPrivateFieldGet(this, _RedisClient_instances, "m", _RedisClient_defineLegacyCommand).call(this, "pUnsubscribe");
    __classPrivateFieldGet(this, _RedisClient_instances, "m", _RedisClient_defineLegacyCommand).call(this, "QUIT");
    __classPrivateFieldGet(this, _RedisClient_instances, "m", _RedisClient_defineLegacyCommand).call(this, "quit");
  }, _RedisClient_legacySendCommand = function _RedisClient_legacySendCommand(...args) {
    const callback = typeof args[args.length - 1] === "function" ? args.pop() : undefined;
    const promise = __classPrivateFieldGet(this, _RedisClient_instances, "m", _RedisClient_sendCommand).call(this, (0, commander_1.transformLegacyCommandArguments)(args));
    if (callback)
      return {
        promise,
        callback
      };
    promise.catch((err) => this.emit("error", err));
  }, _RedisClient_defineLegacyCommand = function _RedisClient_defineLegacyCommand(name, command) {
    __classPrivateFieldGet(this, _RedisClient_v4, "f")[name] = this[name].bind(this);
    this[name] = command && command.TRANSFORM_LEGACY_REPLY && command.transformReply ? (...args) => {
      const result2 = __classPrivateFieldGet(this, _RedisClient_instances, "m", _RedisClient_legacySendCommand).call(this, name, ...args);
      if (result2) {
        result2.promise.then((reply) => result2.callback(null, command.transformReply(reply))).catch((err) => result2.callback(err));
      }
    } : (...args) => this.sendCommand(name, ...args);
  }, _RedisClient_setPingTimer = function _RedisClient_setPingTimer() {
    if (!__classPrivateFieldGet(this, _RedisClient_options, "f")?.pingInterval || !__classPrivateFieldGet(this, _RedisClient_socket, "f").isReady)
      return;
    clearTimeout(__classPrivateFieldGet(this, _RedisClient_pingTimer, "f"));
    __classPrivateFieldSet(this, _RedisClient_pingTimer, setTimeout(() => {
      if (!__classPrivateFieldGet(this, _RedisClient_socket, "f").isReady)
        return;
      __classPrivateFieldGet(this, _RedisClient_instances, "m", _RedisClient_sendCommand).call(this, ["PING"]).then((reply) => this.emit("ping-interval", reply)).catch((err) => this.emit("error", err)).finally(() => __classPrivateFieldGet(this, _RedisClient_instances, "m", _RedisClient_setPingTimer).call(this));
    }, __classPrivateFieldGet(this, _RedisClient_options, "f").pingInterval), "f");
  }, _RedisClient_sendCommand = function _RedisClient_sendCommand(args, options) {
    if (!__classPrivateFieldGet(this, _RedisClient_socket, "f").isOpen) {
      return Promise.reject(new errors_1.ClientClosedError);
    } else if (options?.isolated) {
      return this.executeIsolated((isolatedClient) => isolatedClient.sendCommand(args, {
        ...options,
        isolated: false
      }));
    } else if (!__classPrivateFieldGet(this, _RedisClient_socket, "f").isReady && __classPrivateFieldGet(this, _RedisClient_options, "f")?.disableOfflineQueue) {
      return Promise.reject(new errors_1.ClientOfflineError);
    }
    const promise = __classPrivateFieldGet(this, _RedisClient_queue, "f").addCommand(args, options);
    __classPrivateFieldGet(this, _RedisClient_instances, "m", _RedisClient_tick).call(this);
    return promise;
  }, _RedisClient_pubSubCommand = function _RedisClient_pubSubCommand(promise) {
    if (promise === undefined)
      return Promise.resolve();
    __classPrivateFieldGet(this, _RedisClient_instances, "m", _RedisClient_tick).call(this);
    return promise;
  }, _RedisClient_tick = function _RedisClient_tick(force = false) {
    if (__classPrivateFieldGet(this, _RedisClient_socket, "f").writableNeedDrain || !force && !__classPrivateFieldGet(this, _RedisClient_socket, "f").isReady) {
      return;
    }
    __classPrivateFieldGet(this, _RedisClient_socket, "f").cork();
    while (!__classPrivateFieldGet(this, _RedisClient_socket, "f").writableNeedDrain) {
      const args = __classPrivateFieldGet(this, _RedisClient_queue, "f").getCommandToSend();
      if (args === undefined)
        break;
      __classPrivateFieldGet(this, _RedisClient_socket, "f").writeCommand(args);
    }
  }, _RedisClient_addMultiCommands = function _RedisClient_addMultiCommands(commands, chainId) {
    return Promise.all(commands.map(({ args }) => __classPrivateFieldGet(this, _RedisClient_queue, "f").addCommand(args, { chainId })));
  }, _RedisClient_destroyIsolationPool = async function _RedisClient_destroyIsolationPool() {
    await __classPrivateFieldGet(this, _RedisClient_isolationPool, "f").drain();
    await __classPrivateFieldGet(this, _RedisClient_isolationPool, "f").clear();
    __classPrivateFieldSet(this, _RedisClient_isolationPool, undefined, "f");
  };
  exports.default = RedisClient;
  (0, commander_1.attachCommands)({
    BaseClass: RedisClient,
    commands: commands_1.default,
    executor: RedisClient.prototype.commandsExecutor
  });
  RedisClient.prototype.Multi = multi_command_1.default;
});

// node_modules/@redis/client/dist/lib/cluster/cluster-slots.js
var require_cluster_slots = __commonJS((exports) => {
  var __classPrivateFieldGet = exports && exports.__classPrivateFieldGet || function(receiver, state, kind, f) {
    if (kind === "a" && !f)
      throw new TypeError("Private accessor was defined without a getter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver))
      throw new TypeError("Cannot read private member from an object whose class did not declare it");
    return kind === "m" ? f : kind === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
  };
  var __classPrivateFieldSet = exports && exports.__classPrivateFieldSet || function(receiver, state, value, kind, f) {
    if (kind === "m")
      throw new TypeError("Private method is not writable");
    if (kind === "a" && !f)
      throw new TypeError("Private accessor was defined without a setter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver))
      throw new TypeError("Cannot write private member to an object whose class did not declare it");
    return kind === "a" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value), value;
  };
  var _RedisClusterSlots_instances;
  var _a;
  var _RedisClusterSlots_SLOTS;
  var _RedisClusterSlots_options;
  var _RedisClusterSlots_Client;
  var _RedisClusterSlots_emit;
  var _RedisClusterSlots_isOpen;
  var _RedisClusterSlots_discoverWithRootNodes;
  var _RedisClusterSlots_resetSlots;
  var _RedisClusterSlots_discover;
  var _RedisClusterSlots_getShards;
  var _RedisClusterSlots_getNodeAddress;
  var _RedisClusterSlots_clientOptionsDefaults;
  var _RedisClusterSlots_initiateSlotNode;
  var _RedisClusterSlots_createClient;
  var _RedisClusterSlots_createNodeClient;
  var _RedisClusterSlots_runningRediscoverPromise;
  var _RedisClusterSlots_rediscover;
  var _RedisClusterSlots_destroy;
  var _RedisClusterSlots_execOnNodeClient;
  var _RedisClusterSlots_iterateAllNodes;
  var _RedisClusterSlots_randomNodeIterator;
  var _RedisClusterSlots_slotNodesIterator;
  var _RedisClusterSlots_initiatePubSubClient;
  var _RedisClusterSlots_initiateShardedPubSubClient;
  Object.defineProperty(exports, "__esModule", { value: true });
  var client_1 = require_client2();
  var errors_1 = require_errors3();
  var util_1 = __require("util");
  var pub_sub_1 = require_pub_sub();
  var calculateSlot = require_lib();

  class RedisClusterSlots {
    get isOpen() {
      return __classPrivateFieldGet(this, _RedisClusterSlots_isOpen, "f");
    }
    constructor(options, emit) {
      _RedisClusterSlots_instances.add(this);
      _RedisClusterSlots_options.set(this, undefined);
      _RedisClusterSlots_Client.set(this, undefined);
      _RedisClusterSlots_emit.set(this, undefined);
      Object.defineProperty(this, "slots", {
        enumerable: true,
        configurable: true,
        writable: true,
        value: new Array(__classPrivateFieldGet(RedisClusterSlots, _a, "f", _RedisClusterSlots_SLOTS))
      });
      Object.defineProperty(this, "shards", {
        enumerable: true,
        configurable: true,
        writable: true,
        value: new Array
      });
      Object.defineProperty(this, "masters", {
        enumerable: true,
        configurable: true,
        writable: true,
        value: new Array
      });
      Object.defineProperty(this, "replicas", {
        enumerable: true,
        configurable: true,
        writable: true,
        value: new Array
      });
      Object.defineProperty(this, "nodeByAddress", {
        enumerable: true,
        configurable: true,
        writable: true,
        value: new Map
      });
      Object.defineProperty(this, "pubSubNode", {
        enumerable: true,
        configurable: true,
        writable: true,
        value: undefined
      });
      _RedisClusterSlots_isOpen.set(this, false);
      _RedisClusterSlots_runningRediscoverPromise.set(this, undefined);
      _RedisClusterSlots_randomNodeIterator.set(this, undefined);
      __classPrivateFieldSet(this, _RedisClusterSlots_options, options, "f");
      __classPrivateFieldSet(this, _RedisClusterSlots_Client, client_1.default.extend(options), "f");
      __classPrivateFieldSet(this, _RedisClusterSlots_emit, emit, "f");
    }
    async connect() {
      if (__classPrivateFieldGet(this, _RedisClusterSlots_isOpen, "f")) {
        throw new Error("Cluster already open");
      }
      __classPrivateFieldSet(this, _RedisClusterSlots_isOpen, true, "f");
      try {
        await __classPrivateFieldGet(this, _RedisClusterSlots_instances, "m", _RedisClusterSlots_discoverWithRootNodes).call(this);
      } catch (err) {
        __classPrivateFieldSet(this, _RedisClusterSlots_isOpen, false, "f");
        throw err;
      }
    }
    nodeClient(node4) {
      return node4.client ?? __classPrivateFieldGet(this, _RedisClusterSlots_instances, "m", _RedisClusterSlots_createNodeClient).call(this, node4);
    }
    async rediscover(startWith) {
      __classPrivateFieldSet(this, _RedisClusterSlots_runningRediscoverPromise, __classPrivateFieldGet(this, _RedisClusterSlots_runningRediscoverPromise, "f") ?? __classPrivateFieldGet(this, _RedisClusterSlots_instances, "m", _RedisClusterSlots_rediscover).call(this, startWith).finally(() => __classPrivateFieldSet(this, _RedisClusterSlots_runningRediscoverPromise, undefined, "f")), "f");
      return __classPrivateFieldGet(this, _RedisClusterSlots_runningRediscoverPromise, "f");
    }
    quit() {
      return __classPrivateFieldGet(this, _RedisClusterSlots_instances, "m", _RedisClusterSlots_destroy).call(this, (client) => client.quit());
    }
    disconnect() {
      return __classPrivateFieldGet(this, _RedisClusterSlots_instances, "m", _RedisClusterSlots_destroy).call(this, (client) => client.disconnect());
    }
    getClient(firstKey, isReadonly) {
      if (!firstKey) {
        return this.nodeClient(this.getRandomNode());
      }
      const slotNumber = calculateSlot(firstKey);
      if (!isReadonly) {
        return this.nodeClient(this.slots[slotNumber].master);
      }
      return this.nodeClient(this.getSlotRandomNode(slotNumber));
    }
    getRandomNode() {
      __classPrivateFieldSet(this, _RedisClusterSlots_randomNodeIterator, __classPrivateFieldGet(this, _RedisClusterSlots_randomNodeIterator, "f") ?? __classPrivateFieldGet(this, _RedisClusterSlots_instances, "m", _RedisClusterSlots_iterateAllNodes).call(this), "f");
      return __classPrivateFieldGet(this, _RedisClusterSlots_randomNodeIterator, "f").next().value;
    }
    getSlotRandomNode(slotNumber) {
      const slot = this.slots[slotNumber];
      if (!slot.replicas?.length) {
        return slot.master;
      }
      slot.nodesIterator ?? (slot.nodesIterator = __classPrivateFieldGet(this, _RedisClusterSlots_instances, "m", _RedisClusterSlots_slotNodesIterator).call(this, slot));
      return slot.nodesIterator.next().value;
    }
    getMasterByAddress(address) {
      const master = this.nodeByAddress.get(address);
      if (!master)
        return;
      return this.nodeClient(master);
    }
    getPubSubClient() {
      return this.pubSubNode ? this.pubSubNode.client : __classPrivateFieldGet(this, _RedisClusterSlots_instances, "m", _RedisClusterSlots_initiatePubSubClient).call(this);
    }
    async executeUnsubscribeCommand(unsubscribe) {
      const client = await this.getPubSubClient();
      await unsubscribe(client);
      if (!client.isPubSubActive) {
        await client.disconnect();
        this.pubSubNode = undefined;
      }
    }
    getShardedPubSubClient(channel) {
      const { master } = this.slots[calculateSlot(channel)];
      return master.pubSubClient ?? __classPrivateFieldGet(this, _RedisClusterSlots_instances, "m", _RedisClusterSlots_initiateShardedPubSubClient).call(this, master);
    }
    async executeShardedUnsubscribeCommand(channel, unsubscribe) {
      const { master } = this.slots[calculateSlot(channel)];
      if (!master.pubSubClient)
        return Promise.resolve();
      const client = await master.pubSubClient;
      await unsubscribe(client);
      if (!client.isPubSubActive) {
        await client.disconnect();
        master.pubSubClient = undefined;
      }
    }
  }
  _a = RedisClusterSlots, _RedisClusterSlots_options = new WeakMap, _RedisClusterSlots_Client = new WeakMap, _RedisClusterSlots_emit = new WeakMap, _RedisClusterSlots_isOpen = new WeakMap, _RedisClusterSlots_runningRediscoverPromise = new WeakMap, _RedisClusterSlots_randomNodeIterator = new WeakMap, _RedisClusterSlots_instances = new WeakSet, _RedisClusterSlots_discoverWithRootNodes = async function _RedisClusterSlots_discoverWithRootNodes() {
    let start = Math.floor(Math.random() * __classPrivateFieldGet(this, _RedisClusterSlots_options, "f").rootNodes.length);
    for (let i = start;i < __classPrivateFieldGet(this, _RedisClusterSlots_options, "f").rootNodes.length; i++) {
      if (await __classPrivateFieldGet(this, _RedisClusterSlots_instances, "m", _RedisClusterSlots_discover).call(this, __classPrivateFieldGet(this, _RedisClusterSlots_options, "f").rootNodes[i]))
        return;
    }
    for (let i = 0;i < start; i++) {
      if (await __classPrivateFieldGet(this, _RedisClusterSlots_instances, "m", _RedisClusterSlots_discover).call(this, __classPrivateFieldGet(this, _RedisClusterSlots_options, "f").rootNodes[i]))
        return;
    }
    throw new errors_1.RootNodesUnavailableError;
  }, _RedisClusterSlots_resetSlots = function _RedisClusterSlots_resetSlots() {
    this.slots = new Array(__classPrivateFieldGet(RedisClusterSlots, _a, "f", _RedisClusterSlots_SLOTS));
    this.shards = [];
    this.masters = [];
    this.replicas = [];
    __classPrivateFieldSet(this, _RedisClusterSlots_randomNodeIterator, undefined, "f");
  }, _RedisClusterSlots_discover = async function _RedisClusterSlots_discover(rootNode) {
    __classPrivateFieldGet(this, _RedisClusterSlots_instances, "m", _RedisClusterSlots_resetSlots).call(this);
    const addressesInUse = new Set;
    try {
      const shards = await __classPrivateFieldGet(this, _RedisClusterSlots_instances, "m", _RedisClusterSlots_getShards).call(this, rootNode), promises = [], eagerConnect = __classPrivateFieldGet(this, _RedisClusterSlots_options, "f").minimizeConnections !== true;
      for (const { from, to, master, replicas } of shards) {
        const shard = {
          master: __classPrivateFieldGet(this, _RedisClusterSlots_instances, "m", _RedisClusterSlots_initiateSlotNode).call(this, master, false, eagerConnect, addressesInUse, promises)
        };
        if (__classPrivateFieldGet(this, _RedisClusterSlots_options, "f").useReplicas) {
          shard.replicas = replicas.map((replica) => __classPrivateFieldGet(this, _RedisClusterSlots_instances, "m", _RedisClusterSlots_initiateSlotNode).call(this, replica, true, eagerConnect, addressesInUse, promises));
        }
        this.shards.push(shard);
        for (let i = from;i <= to; i++) {
          this.slots[i] = shard;
        }
      }
      if (this.pubSubNode && !addressesInUse.has(this.pubSubNode.address)) {
        if (util_1.types.isPromise(this.pubSubNode.client)) {
          promises.push(this.pubSubNode.client.then((client) => client.disconnect()));
          this.pubSubNode = undefined;
        } else {
          promises.push(this.pubSubNode.client.disconnect());
          const channelsListeners = this.pubSubNode.client.getPubSubListeners(pub_sub_1.PubSubType.CHANNELS), patternsListeners = this.pubSubNode.client.getPubSubListeners(pub_sub_1.PubSubType.PATTERNS);
          if (channelsListeners.size || patternsListeners.size) {
            promises.push(__classPrivateFieldGet(this, _RedisClusterSlots_instances, "m", _RedisClusterSlots_initiatePubSubClient).call(this, {
              [pub_sub_1.PubSubType.CHANNELS]: channelsListeners,
              [pub_sub_1.PubSubType.PATTERNS]: patternsListeners
            }));
          }
        }
      }
      for (const [address, node4] of this.nodeByAddress.entries()) {
        if (addressesInUse.has(address))
          continue;
        if (node4.client) {
          promises.push(__classPrivateFieldGet(this, _RedisClusterSlots_instances, "m", _RedisClusterSlots_execOnNodeClient).call(this, node4.client, (client) => client.disconnect()));
        }
        const { pubSubClient } = node4;
        if (pubSubClient) {
          promises.push(__classPrivateFieldGet(this, _RedisClusterSlots_instances, "m", _RedisClusterSlots_execOnNodeClient).call(this, pubSubClient, (client) => client.disconnect()));
        }
        this.nodeByAddress.delete(address);
      }
      await Promise.all(promises);
      return true;
    } catch (err) {
      __classPrivateFieldGet(this, _RedisClusterSlots_emit, "f").call(this, "error", err);
      return false;
    }
  }, _RedisClusterSlots_getShards = async function _RedisClusterSlots_getShards(rootNode) {
    const client = new (__classPrivateFieldGet(this, _RedisClusterSlots_Client, "f"))(__classPrivateFieldGet(this, _RedisClusterSlots_instances, "m", _RedisClusterSlots_clientOptionsDefaults).call(this, rootNode, true));
    client.on("error", (err) => __classPrivateFieldGet(this, _RedisClusterSlots_emit, "f").call(this, "error", err));
    await client.connect();
    try {
      return await client.clusterSlots();
    } finally {
      await client.disconnect();
    }
  }, _RedisClusterSlots_getNodeAddress = function _RedisClusterSlots_getNodeAddress(address) {
    switch (typeof __classPrivateFieldGet(this, _RedisClusterSlots_options, "f").nodeAddressMap) {
      case "object":
        return __classPrivateFieldGet(this, _RedisClusterSlots_options, "f").nodeAddressMap[address];
      case "function":
        return __classPrivateFieldGet(this, _RedisClusterSlots_options, "f").nodeAddressMap(address);
    }
  }, _RedisClusterSlots_clientOptionsDefaults = function _RedisClusterSlots_clientOptionsDefaults(options, disableReconnect) {
    let result2;
    if (__classPrivateFieldGet(this, _RedisClusterSlots_options, "f").defaults) {
      let socket;
      if (__classPrivateFieldGet(this, _RedisClusterSlots_options, "f").defaults.socket) {
        socket = options?.socket ? {
          ...__classPrivateFieldGet(this, _RedisClusterSlots_options, "f").defaults.socket,
          ...options.socket
        } : __classPrivateFieldGet(this, _RedisClusterSlots_options, "f").defaults.socket;
      } else {
        socket = options?.socket;
      }
      result2 = {
        ...__classPrivateFieldGet(this, _RedisClusterSlots_options, "f").defaults,
        ...options,
        socket
      };
    } else {
      result2 = options;
    }
    if (disableReconnect) {
      result2 ?? (result2 = {});
      result2.socket ?? (result2.socket = {});
      result2.socket.reconnectStrategy = false;
    }
    return result2;
  }, _RedisClusterSlots_initiateSlotNode = function _RedisClusterSlots_initiateSlotNode({ id, ip, port }, readonly, eagerConnent, addressesInUse, promises) {
    const address = `${ip}:${port}`;
    addressesInUse.add(address);
    let node4 = this.nodeByAddress.get(address);
    if (!node4) {
      node4 = {
        id,
        host: ip,
        port,
        address,
        readonly,
        client: undefined
      };
      if (eagerConnent) {
        promises.push(__classPrivateFieldGet(this, _RedisClusterSlots_instances, "m", _RedisClusterSlots_createNodeClient).call(this, node4));
      }
      this.nodeByAddress.set(address, node4);
    }
    (readonly ? this.replicas : this.masters).push(node4);
    return node4;
  }, _RedisClusterSlots_createClient = async function _RedisClusterSlots_createClient(node4, readonly = node4.readonly) {
    const client = new (__classPrivateFieldGet(this, _RedisClusterSlots_Client, "f"))(__classPrivateFieldGet(this, _RedisClusterSlots_instances, "m", _RedisClusterSlots_clientOptionsDefaults).call(this, {
      socket: __classPrivateFieldGet(this, _RedisClusterSlots_instances, "m", _RedisClusterSlots_getNodeAddress).call(this, node4.address) ?? {
        host: node4.host,
        port: node4.port
      },
      readonly
    }));
    client.on("error", (err) => __classPrivateFieldGet(this, _RedisClusterSlots_emit, "f").call(this, "error", err));
    await client.connect();
    return client;
  }, _RedisClusterSlots_createNodeClient = function _RedisClusterSlots_createNodeClient(node4) {
    const promise = __classPrivateFieldGet(this, _RedisClusterSlots_instances, "m", _RedisClusterSlots_createClient).call(this, node4).then((client) => {
      node4.client = client;
      return client;
    }).catch((err) => {
      node4.client = undefined;
      throw err;
    });
    node4.client = promise;
    return promise;
  }, _RedisClusterSlots_rediscover = async function _RedisClusterSlots_rediscover(startWith) {
    if (await __classPrivateFieldGet(this, _RedisClusterSlots_instances, "m", _RedisClusterSlots_discover).call(this, startWith.options))
      return;
    return __classPrivateFieldGet(this, _RedisClusterSlots_instances, "m", _RedisClusterSlots_discoverWithRootNodes).call(this);
  }, _RedisClusterSlots_destroy = async function _RedisClusterSlots_destroy(fn) {
    __classPrivateFieldSet(this, _RedisClusterSlots_isOpen, false, "f");
    const promises = [];
    for (const { master, replicas } of this.shards) {
      if (master.client) {
        promises.push(__classPrivateFieldGet(this, _RedisClusterSlots_instances, "m", _RedisClusterSlots_execOnNodeClient).call(this, master.client, fn));
      }
      if (master.pubSubClient) {
        promises.push(__classPrivateFieldGet(this, _RedisClusterSlots_instances, "m", _RedisClusterSlots_execOnNodeClient).call(this, master.pubSubClient, fn));
      }
      if (replicas) {
        for (const { client } of replicas) {
          if (client) {
            promises.push(__classPrivateFieldGet(this, _RedisClusterSlots_instances, "m", _RedisClusterSlots_execOnNodeClient).call(this, client, fn));
          }
        }
      }
    }
    if (this.pubSubNode) {
      promises.push(__classPrivateFieldGet(this, _RedisClusterSlots_instances, "m", _RedisClusterSlots_execOnNodeClient).call(this, this.pubSubNode.client, fn));
      this.pubSubNode = undefined;
    }
    __classPrivateFieldGet(this, _RedisClusterSlots_instances, "m", _RedisClusterSlots_resetSlots).call(this);
    this.nodeByAddress.clear();
    await Promise.allSettled(promises);
  }, _RedisClusterSlots_execOnNodeClient = function _RedisClusterSlots_execOnNodeClient(client, fn) {
    return util_1.types.isPromise(client) ? client.then(fn) : fn(client);
  }, _RedisClusterSlots_iterateAllNodes = function* _RedisClusterSlots_iterateAllNodes() {
    let i = Math.floor(Math.random() * (this.masters.length + this.replicas.length));
    if (i < this.masters.length) {
      do {
        yield this.masters[i];
      } while (++i < this.masters.length);
      for (const replica of this.replicas) {
        yield replica;
      }
    } else {
      i -= this.masters.length;
      do {
        yield this.replicas[i];
      } while (++i < this.replicas.length);
    }
    while (true) {
      for (const master of this.masters) {
        yield master;
      }
      for (const replica of this.replicas) {
        yield replica;
      }
    }
  }, _RedisClusterSlots_slotNodesIterator = function* _RedisClusterSlots_slotNodesIterator(slot) {
    let i = Math.floor(Math.random() * (1 + slot.replicas.length));
    if (i < slot.replicas.length) {
      do {
        yield slot.replicas[i];
      } while (++i < slot.replicas.length);
    }
    while (true) {
      yield slot.master;
      for (const replica of slot.replicas) {
        yield replica;
      }
    }
  }, _RedisClusterSlots_initiatePubSubClient = async function _RedisClusterSlots_initiatePubSubClient(toResubscribe) {
    const index = Math.floor(Math.random() * (this.masters.length + this.replicas.length)), node4 = index < this.masters.length ? this.masters[index] : this.replicas[index - this.masters.length];
    this.pubSubNode = {
      address: node4.address,
      client: __classPrivateFieldGet(this, _RedisClusterSlots_instances, "m", _RedisClusterSlots_createClient).call(this, node4, true).then(async (client) => {
        if (toResubscribe) {
          await Promise.all([
            client.extendPubSubListeners(pub_sub_1.PubSubType.CHANNELS, toResubscribe[pub_sub_1.PubSubType.CHANNELS]),
            client.extendPubSubListeners(pub_sub_1.PubSubType.PATTERNS, toResubscribe[pub_sub_1.PubSubType.PATTERNS])
          ]);
        }
        this.pubSubNode.client = client;
        return client;
      }).catch((err) => {
        this.pubSubNode = undefined;
        throw err;
      })
    };
    return this.pubSubNode.client;
  }, _RedisClusterSlots_initiateShardedPubSubClient = function _RedisClusterSlots_initiateShardedPubSubClient(master) {
    const promise = __classPrivateFieldGet(this, _RedisClusterSlots_instances, "m", _RedisClusterSlots_createClient).call(this, master, true).then((client) => {
      client.on("server-sunsubscribe", async (channel, listeners) => {
        try {
          await this.rediscover(client);
          const redirectTo = await this.getShardedPubSubClient(channel);
          redirectTo.extendPubSubChannelListeners(pub_sub_1.PubSubType.SHARDED, channel, listeners);
        } catch (err) {
          __classPrivateFieldGet(this, _RedisClusterSlots_emit, "f").call(this, "sharded-shannel-moved-error", err, channel, listeners);
        }
      });
      master.pubSubClient = client;
      return client;
    }).catch((err) => {
      master.pubSubClient = undefined;
      throw err;
    });
    master.pubSubClient = promise;
    return promise;
  };
  _RedisClusterSlots_SLOTS = { value: 16384 };
  exports.default = RedisClusterSlots;
});

// node_modules/@redis/client/dist/lib/cluster/multi-command.js
var require_multi_command3 = __commonJS((exports) => {
  var __classPrivateFieldSet = exports && exports.__classPrivateFieldSet || function(receiver, state, value, kind, f) {
    if (kind === "m")
      throw new TypeError("Private method is not writable");
    if (kind === "a" && !f)
      throw new TypeError("Private accessor was defined without a setter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver))
      throw new TypeError("Cannot write private member to an object whose class did not declare it");
    return kind === "a" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value), value;
  };
  var __classPrivateFieldGet = exports && exports.__classPrivateFieldGet || function(receiver, state, kind, f) {
    if (kind === "a" && !f)
      throw new TypeError("Private accessor was defined without a getter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver))
      throw new TypeError("Cannot read private member from an object whose class did not declare it");
    return kind === "m" ? f : kind === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
  };
  var _RedisClusterMultiCommand_multi;
  var _RedisClusterMultiCommand_executor;
  var _RedisClusterMultiCommand_firstKey;
  Object.defineProperty(exports, "__esModule", { value: true });
  var commands_1 = require_commands2();
  var multi_command_1 = require_multi_command();
  var commander_1 = require_commander2();
  var _1 = require_cluster2();

  class RedisClusterMultiCommand {
    static extend(extensions) {
      return (0, commander_1.attachExtensions)({
        BaseClass: RedisClusterMultiCommand,
        modulesExecutor: RedisClusterMultiCommand.prototype.commandsExecutor,
        modules: extensions?.modules,
        functionsExecutor: RedisClusterMultiCommand.prototype.functionsExecutor,
        functions: extensions?.functions,
        scriptsExecutor: RedisClusterMultiCommand.prototype.scriptsExecutor,
        scripts: extensions?.scripts
      });
    }
    constructor(executor, firstKey) {
      _RedisClusterMultiCommand_multi.set(this, new multi_command_1.default);
      _RedisClusterMultiCommand_executor.set(this, undefined);
      _RedisClusterMultiCommand_firstKey.set(this, undefined);
      Object.defineProperty(this, "EXEC", {
        enumerable: true,
        configurable: true,
        writable: true,
        value: this.exec
      });
      __classPrivateFieldSet(this, _RedisClusterMultiCommand_executor, executor, "f");
      __classPrivateFieldSet(this, _RedisClusterMultiCommand_firstKey, firstKey, "f");
    }
    commandsExecutor(command, args) {
      const transformedArguments = command.transformArguments(...args);
      __classPrivateFieldSet(this, _RedisClusterMultiCommand_firstKey, __classPrivateFieldGet(this, _RedisClusterMultiCommand_firstKey, "f") ?? _1.default.extractFirstKey(command, args, transformedArguments), "f");
      return this.addCommand(undefined, transformedArguments, command.transformReply);
    }
    addCommand(firstKey, args, transformReply) {
      __classPrivateFieldSet(this, _RedisClusterMultiCommand_firstKey, __classPrivateFieldGet(this, _RedisClusterMultiCommand_firstKey, "f") ?? firstKey, "f");
      __classPrivateFieldGet(this, _RedisClusterMultiCommand_multi, "f").addCommand(args, transformReply);
      return this;
    }
    functionsExecutor(fn, args, name) {
      const transformedArguments = __classPrivateFieldGet(this, _RedisClusterMultiCommand_multi, "f").addFunction(name, fn, args);
      __classPrivateFieldSet(this, _RedisClusterMultiCommand_firstKey, __classPrivateFieldGet(this, _RedisClusterMultiCommand_firstKey, "f") ?? _1.default.extractFirstKey(fn, args, transformedArguments), "f");
      return this;
    }
    scriptsExecutor(script, args) {
      const transformedArguments = __classPrivateFieldGet(this, _RedisClusterMultiCommand_multi, "f").addScript(script, args);
      __classPrivateFieldSet(this, _RedisClusterMultiCommand_firstKey, __classPrivateFieldGet(this, _RedisClusterMultiCommand_firstKey, "f") ?? _1.default.extractFirstKey(script, args, transformedArguments), "f");
      return this;
    }
    async exec(execAsPipeline = false) {
      if (execAsPipeline) {
        return this.execAsPipeline();
      }
      return __classPrivateFieldGet(this, _RedisClusterMultiCommand_multi, "f").handleExecReplies(await __classPrivateFieldGet(this, _RedisClusterMultiCommand_executor, "f").call(this, __classPrivateFieldGet(this, _RedisClusterMultiCommand_multi, "f").queue, __classPrivateFieldGet(this, _RedisClusterMultiCommand_firstKey, "f"), multi_command_1.default.generateChainId()));
    }
    async execAsPipeline() {
      return __classPrivateFieldGet(this, _RedisClusterMultiCommand_multi, "f").transformReplies(await __classPrivateFieldGet(this, _RedisClusterMultiCommand_executor, "f").call(this, __classPrivateFieldGet(this, _RedisClusterMultiCommand_multi, "f").queue, __classPrivateFieldGet(this, _RedisClusterMultiCommand_firstKey, "f")));
    }
  }
  _RedisClusterMultiCommand_multi = new WeakMap, _RedisClusterMultiCommand_executor = new WeakMap, _RedisClusterMultiCommand_firstKey = new WeakMap;
  exports.default = RedisClusterMultiCommand;
  (0, commander_1.attachCommands)({
    BaseClass: RedisClusterMultiCommand,
    commands: commands_1.default,
    executor: RedisClusterMultiCommand.prototype.commandsExecutor
  });
});

// node_modules/@redis/client/dist/lib/cluster/index.js
var require_cluster2 = __commonJS((exports) => {
  var __classPrivateFieldGet = exports && exports.__classPrivateFieldGet || function(receiver, state, kind, f) {
    if (kind === "a" && !f)
      throw new TypeError("Private accessor was defined without a getter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver))
      throw new TypeError("Cannot read private member from an object whose class did not declare it");
    return kind === "m" ? f : kind === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
  };
  var __classPrivateFieldSet = exports && exports.__classPrivateFieldSet || function(receiver, state, value, kind, f) {
    if (kind === "m")
      throw new TypeError("Private method is not writable");
    if (kind === "a" && !f)
      throw new TypeError("Private accessor was defined without a setter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver))
      throw new TypeError("Cannot write private member to an object whose class did not declare it");
    return kind === "a" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value), value;
  };
  var _RedisCluster_instances;
  var _RedisCluster_options;
  var _RedisCluster_slots;
  var _RedisCluster_Multi;
  var _RedisCluster_execute;
  Object.defineProperty(exports, "__esModule", { value: true });
  var commands_1 = require_commands2();
  var cluster_slots_1 = require_cluster_slots();
  var commander_1 = require_commander2();
  var events_1 = __require("events");
  var multi_command_1 = require_multi_command3();
  var errors_1 = require_errors3();

  class RedisCluster extends events_1.EventEmitter {
    static extractFirstKey(command, originalArgs, redisArgs) {
      if (command.FIRST_KEY_INDEX === undefined) {
        return;
      } else if (typeof command.FIRST_KEY_INDEX === "number") {
        return redisArgs[command.FIRST_KEY_INDEX];
      }
      return command.FIRST_KEY_INDEX(...originalArgs);
    }
    static create(options) {
      return new ((0, commander_1.attachExtensions)({
        BaseClass: RedisCluster,
        modulesExecutor: RedisCluster.prototype.commandsExecutor,
        modules: options?.modules,
        functionsExecutor: RedisCluster.prototype.functionsExecutor,
        functions: options?.functions,
        scriptsExecutor: RedisCluster.prototype.scriptsExecutor,
        scripts: options?.scripts
      }))(options);
    }
    get slots() {
      return __classPrivateFieldGet(this, _RedisCluster_slots, "f").slots;
    }
    get shards() {
      return __classPrivateFieldGet(this, _RedisCluster_slots, "f").shards;
    }
    get masters() {
      return __classPrivateFieldGet(this, _RedisCluster_slots, "f").masters;
    }
    get replicas() {
      return __classPrivateFieldGet(this, _RedisCluster_slots, "f").replicas;
    }
    get nodeByAddress() {
      return __classPrivateFieldGet(this, _RedisCluster_slots, "f").nodeByAddress;
    }
    get pubSubNode() {
      return __classPrivateFieldGet(this, _RedisCluster_slots, "f").pubSubNode;
    }
    get isOpen() {
      return __classPrivateFieldGet(this, _RedisCluster_slots, "f").isOpen;
    }
    constructor(options) {
      super();
      _RedisCluster_instances.add(this);
      _RedisCluster_options.set(this, undefined);
      _RedisCluster_slots.set(this, undefined);
      _RedisCluster_Multi.set(this, undefined);
      Object.defineProperty(this, "multi", {
        enumerable: true,
        configurable: true,
        writable: true,
        value: this.MULTI
      });
      Object.defineProperty(this, "subscribe", {
        enumerable: true,
        configurable: true,
        writable: true,
        value: this.SUBSCRIBE
      });
      Object.defineProperty(this, "unsubscribe", {
        enumerable: true,
        configurable: true,
        writable: true,
        value: this.UNSUBSCRIBE
      });
      Object.defineProperty(this, "pSubscribe", {
        enumerable: true,
        configurable: true,
        writable: true,
        value: this.PSUBSCRIBE
      });
      Object.defineProperty(this, "pUnsubscribe", {
        enumerable: true,
        configurable: true,
        writable: true,
        value: this.PUNSUBSCRIBE
      });
      Object.defineProperty(this, "sSubscribe", {
        enumerable: true,
        configurable: true,
        writable: true,
        value: this.SSUBSCRIBE
      });
      Object.defineProperty(this, "sUnsubscribe", {
        enumerable: true,
        configurable: true,
        writable: true,
        value: this.SUNSUBSCRIBE
      });
      __classPrivateFieldSet(this, _RedisCluster_options, options, "f");
      __classPrivateFieldSet(this, _RedisCluster_slots, new cluster_slots_1.default(options, this.emit.bind(this)), "f");
      __classPrivateFieldSet(this, _RedisCluster_Multi, multi_command_1.default.extend(options), "f");
    }
    duplicate(overrides) {
      return new (Object.getPrototypeOf(this)).constructor({
        ...__classPrivateFieldGet(this, _RedisCluster_options, "f"),
        ...overrides
      });
    }
    connect() {
      return __classPrivateFieldGet(this, _RedisCluster_slots, "f").connect();
    }
    async commandsExecutor(command, args) {
      const { jsArgs, args: redisArgs, options } = (0, commander_1.transformCommandArguments)(command, args);
      return (0, commander_1.transformCommandReply)(command, await this.sendCommand(RedisCluster.extractFirstKey(command, jsArgs, redisArgs), command.IS_READ_ONLY, redisArgs, options), redisArgs.preserve);
    }
    async sendCommand(firstKey, isReadonly, args, options) {
      return __classPrivateFieldGet(this, _RedisCluster_instances, "m", _RedisCluster_execute).call(this, firstKey, isReadonly, (client) => client.sendCommand(args, options));
    }
    async functionsExecutor(fn, args, name) {
      const { args: redisArgs, options } = (0, commander_1.transformCommandArguments)(fn, args);
      return (0, commander_1.transformCommandReply)(fn, await this.executeFunction(name, fn, args, redisArgs, options), redisArgs.preserve);
    }
    async executeFunction(name, fn, originalArgs, redisArgs, options) {
      return __classPrivateFieldGet(this, _RedisCluster_instances, "m", _RedisCluster_execute).call(this, RedisCluster.extractFirstKey(fn, originalArgs, redisArgs), fn.IS_READ_ONLY, (client) => client.executeFunction(name, fn, redisArgs, options));
    }
    async scriptsExecutor(script, args) {
      const { args: redisArgs, options } = (0, commander_1.transformCommandArguments)(script, args);
      return (0, commander_1.transformCommandReply)(script, await this.executeScript(script, args, redisArgs, options), redisArgs.preserve);
    }
    async executeScript(script, originalArgs, redisArgs, options) {
      return __classPrivateFieldGet(this, _RedisCluster_instances, "m", _RedisCluster_execute).call(this, RedisCluster.extractFirstKey(script, originalArgs, redisArgs), script.IS_READ_ONLY, (client) => client.executeScript(script, redisArgs, options));
    }
    MULTI(routing) {
      return new (__classPrivateFieldGet(this, _RedisCluster_Multi, "f"))((commands, firstKey, chainId) => {
        return __classPrivateFieldGet(this, _RedisCluster_instances, "m", _RedisCluster_execute).call(this, firstKey, false, (client) => client.multiExecutor(commands, undefined, chainId));
      }, routing);
    }
    async SUBSCRIBE(channels, listener, bufferMode) {
      return (await __classPrivateFieldGet(this, _RedisCluster_slots, "f").getPubSubClient()).SUBSCRIBE(channels, listener, bufferMode);
    }
    async UNSUBSCRIBE(channels, listener, bufferMode) {
      return __classPrivateFieldGet(this, _RedisCluster_slots, "f").executeUnsubscribeCommand((client) => client.UNSUBSCRIBE(channels, listener, bufferMode));
    }
    async PSUBSCRIBE(patterns, listener, bufferMode) {
      return (await __classPrivateFieldGet(this, _RedisCluster_slots, "f").getPubSubClient()).PSUBSCRIBE(patterns, listener, bufferMode);
    }
    async PUNSUBSCRIBE(patterns, listener, bufferMode) {
      return __classPrivateFieldGet(this, _RedisCluster_slots, "f").executeUnsubscribeCommand((client) => client.PUNSUBSCRIBE(patterns, listener, bufferMode));
    }
    async SSUBSCRIBE(channels, listener, bufferMode) {
      const maxCommandRedirections = __classPrivateFieldGet(this, _RedisCluster_options, "f").maxCommandRedirections ?? 16, firstChannel = Array.isArray(channels) ? channels[0] : channels;
      let client = await __classPrivateFieldGet(this, _RedisCluster_slots, "f").getShardedPubSubClient(firstChannel);
      for (let i = 0;; i++) {
        try {
          return await client.SSUBSCRIBE(channels, listener, bufferMode);
        } catch (err) {
          if (++i > maxCommandRedirections || !(err instanceof errors_1.ErrorReply)) {
            throw err;
          }
          if (err.message.startsWith("MOVED")) {
            await __classPrivateFieldGet(this, _RedisCluster_slots, "f").rediscover(client);
            client = await __classPrivateFieldGet(this, _RedisCluster_slots, "f").getShardedPubSubClient(firstChannel);
            continue;
          }
          throw err;
        }
      }
    }
    SUNSUBSCRIBE(channels, listener, bufferMode) {
      return __classPrivateFieldGet(this, _RedisCluster_slots, "f").executeShardedUnsubscribeCommand(Array.isArray(channels) ? channels[0] : channels, (client) => client.SUNSUBSCRIBE(channels, listener, bufferMode));
    }
    quit() {
      return __classPrivateFieldGet(this, _RedisCluster_slots, "f").quit();
    }
    disconnect() {
      return __classPrivateFieldGet(this, _RedisCluster_slots, "f").disconnect();
    }
    nodeClient(node4) {
      return __classPrivateFieldGet(this, _RedisCluster_slots, "f").nodeClient(node4);
    }
    getRandomNode() {
      return __classPrivateFieldGet(this, _RedisCluster_slots, "f").getRandomNode();
    }
    getSlotRandomNode(slot) {
      return __classPrivateFieldGet(this, _RedisCluster_slots, "f").getSlotRandomNode(slot);
    }
    getMasters() {
      return this.masters;
    }
    getSlotMaster(slot) {
      return this.slots[slot].master;
    }
  }
  _RedisCluster_options = new WeakMap, _RedisCluster_slots = new WeakMap, _RedisCluster_Multi = new WeakMap, _RedisCluster_instances = new WeakSet, _RedisCluster_execute = async function _RedisCluster_execute(firstKey, isReadonly, executor) {
    const maxCommandRedirections = __classPrivateFieldGet(this, _RedisCluster_options, "f").maxCommandRedirections ?? 16;
    let client = await __classPrivateFieldGet(this, _RedisCluster_slots, "f").getClient(firstKey, isReadonly);
    for (let i = 0;; i++) {
      try {
        return await executor(client);
      } catch (err) {
        if (++i > maxCommandRedirections || !(err instanceof errors_1.ErrorReply)) {
          throw err;
        }
        if (err.message.startsWith("ASK")) {
          const address = err.message.substring(err.message.lastIndexOf(" ") + 1);
          let redirectTo = await __classPrivateFieldGet(this, _RedisCluster_slots, "f").getMasterByAddress(address);
          if (!redirectTo) {
            await __classPrivateFieldGet(this, _RedisCluster_slots, "f").rediscover(client);
            redirectTo = await __classPrivateFieldGet(this, _RedisCluster_slots, "f").getMasterByAddress(address);
          }
          if (!redirectTo) {
            throw new Error(`Cannot find node ${address}`);
          }
          await redirectTo.asking();
          client = redirectTo;
          continue;
        } else if (err.message.startsWith("MOVED")) {
          await __classPrivateFieldGet(this, _RedisCluster_slots, "f").rediscover(client);
          client = await __classPrivateFieldGet(this, _RedisCluster_slots, "f").getClient(firstKey, isReadonly);
          continue;
        }
        throw err;
      }
    }
  };
  exports.default = RedisCluster;
  (0, commander_1.attachCommands)({
    BaseClass: RedisCluster,
    commands: commands_1.default,
    executor: RedisCluster.prototype.commandsExecutor
  });
});

// node_modules/@redis/client/dist/lib/lua-script.js
var require_lua_script = __commonJS((exports) => {
  var defineScript = function(script) {
    return {
      ...script,
      SHA1: scriptSha1(script.SCRIPT)
    };
  };
  var scriptSha1 = function(script) {
    return (0, crypto_1.createHash)("sha1").update(script).digest("hex");
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.scriptSha1 = exports.defineScript = undefined;
  var crypto_1 = __require("crypto");
  exports.defineScript = defineScript;
  exports.scriptSha1 = scriptSha1;
});

// node_modules/@redis/client/dist/index.js
var require_dist3 = __commonJS((exports) => {
  var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
    if (k2 === undefined)
      k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() {
        return m[k];
      } };
    }
    Object.defineProperty(o, k2, desc);
  } : function(o, m, k, k2) {
    if (k2 === undefined)
      k2 = k;
    o[k2] = m[k];
  });
  var __exportStar = exports && exports.__exportStar || function(m, exports2) {
    for (var p in m)
      if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports2, p))
        __createBinding(exports2, m, p);
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.RedisFlushModes = exports.GeoReplyWith = exports.defineScript = exports.createCluster = exports.commandOptions = exports.createClient = undefined;
  var client_1 = require_client2();
  var cluster_1 = require_cluster2();
  exports.createClient = client_1.default.create;
  exports.commandOptions = client_1.default.commandOptions;
  exports.createCluster = cluster_1.default.create;
  var lua_script_1 = require_lua_script();
  Object.defineProperty(exports, "defineScript", { enumerable: true, get: function() {
    return lua_script_1.defineScript;
  } });
  __exportStar(require_errors3(), exports);
  var generic_transformers_1 = require_generic_transformers();
  Object.defineProperty(exports, "GeoReplyWith", { enumerable: true, get: function() {
    return generic_transformers_1.GeoReplyWith;
  } });
  var FLUSHALL_1 = require_FLUSHALL();
  Object.defineProperty(exports, "RedisFlushModes", { enumerable: true, get: function() {
    return FLUSHALL_1.RedisFlushModes;
  } });
});

// node_modules/@redis/bloom/dist/commands/bloom/ADD.js
var require_ADD = __commonJS((exports) => {
  var transformArguments = function(key, item) {
    return ["BF.ADD", key, item];
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.transformReply = exports.transformArguments = exports.FIRST_KEY_INDEX = undefined;
  exports.FIRST_KEY_INDEX = 1;
  exports.transformArguments = transformArguments;
  var generic_transformers_1 = require_generic_transformers();
  Object.defineProperty(exports, "transformReply", { enumerable: true, get: function() {
    return generic_transformers_1.transformBooleanReply;
  } });
});

// node_modules/@redis/bloom/dist/commands/bloom/CARD.js
var require_CARD = __commonJS((exports) => {
  var transformArguments = function(key) {
    return ["BF.CARD", key];
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.transformArguments = exports.IS_READ_ONLY = exports.FIRST_KEY_INDEX = undefined;
  exports.FIRST_KEY_INDEX = 1;
  exports.IS_READ_ONLY = true;
  exports.transformArguments = transformArguments;
});

// node_modules/@redis/bloom/dist/commands/bloom/EXISTS.js
var require_EXISTS2 = __commonJS((exports) => {
  var transformArguments = function(key, item) {
    return ["BF.EXISTS", key, item];
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.transformReply = exports.transformArguments = exports.IS_READ_ONLY = exports.FIRST_KEY_INDEX = undefined;
  exports.FIRST_KEY_INDEX = 1;
  exports.IS_READ_ONLY = true;
  exports.transformArguments = transformArguments;
  var generic_transformers_1 = require_generic_transformers();
  Object.defineProperty(exports, "transformReply", { enumerable: true, get: function() {
    return generic_transformers_1.transformBooleanReply;
  } });
});

// node_modules/@redis/bloom/dist/commands/bloom/INFO.js
var require_INFO2 = __commonJS((exports) => {
  var transformArguments = function(key) {
    return ["BF.INFO", key];
  };
  var transformReply = function(reply) {
    return {
      capacity: reply[1],
      size: reply[3],
      numberOfFilters: reply[5],
      numberOfInsertedItems: reply[7],
      expansionRate: reply[9]
    };
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.transformReply = exports.transformArguments = exports.IS_READ_ONLY = exports.FIRST_KEY_INDEX = undefined;
  exports.FIRST_KEY_INDEX = 1;
  exports.IS_READ_ONLY = true;
  exports.transformArguments = transformArguments;
  exports.transformReply = transformReply;
});

// node_modules/@redis/bloom/dist/commands/bloom/INSERT.js
var require_INSERT = __commonJS((exports) => {
  var transformArguments = function(key, items, options) {
    const args = ["BF.INSERT", key];
    if (options?.CAPACITY) {
      args.push("CAPACITY", options.CAPACITY.toString());
    }
    if (options?.ERROR) {
      args.push("ERROR", options.ERROR.toString());
    }
    if (options?.EXPANSION) {
      args.push("EXPANSION", options.EXPANSION.toString());
    }
    if (options?.NOCREATE) {
      args.push("NOCREATE");
    }
    if (options?.NONSCALING) {
      args.push("NONSCALING");
    }
    args.push("ITEMS");
    return (0, generic_transformers_1.pushVerdictArguments)(args, items);
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.transformReply = exports.transformArguments = exports.FIRST_KEY_INDEX = undefined;
  var generic_transformers_1 = require_generic_transformers();
  exports.FIRST_KEY_INDEX = 1;
  exports.transformArguments = transformArguments;
  var generic_transformers_2 = require_generic_transformers();
  Object.defineProperty(exports, "transformReply", { enumerable: true, get: function() {
    return generic_transformers_2.transformBooleanArrayReply;
  } });
});

// node_modules/@redis/bloom/dist/commands/bloom/LOADCHUNK.js
var require_LOADCHUNK = __commonJS((exports) => {
  var transformArguments = function(key, iteretor, chunk) {
    return ["BF.LOADCHUNK", key, iteretor.toString(), chunk];
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.transformArguments = exports.FIRST_KEY_INDEX = undefined;
  exports.FIRST_KEY_INDEX = 1;
  exports.transformArguments = transformArguments;
});

// node_modules/@redis/bloom/dist/commands/bloom/MADD.js
var require_MADD = __commonJS((exports) => {
  var transformArguments = function(key, items) {
    return ["BF.MADD", key, ...items];
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.transformReply = exports.transformArguments = exports.FIRST_KEY_INDEX = undefined;
  exports.FIRST_KEY_INDEX = 1;
  exports.transformArguments = transformArguments;
  var generic_transformers_1 = require_generic_transformers();
  Object.defineProperty(exports, "transformReply", { enumerable: true, get: function() {
    return generic_transformers_1.transformBooleanArrayReply;
  } });
});

// node_modules/@redis/bloom/dist/commands/bloom/MEXISTS.js
var require_MEXISTS = __commonJS((exports) => {
  var transformArguments = function(key, items) {
    return ["BF.MEXISTS", key, ...items];
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.transformReply = exports.transformArguments = exports.IS_READ_ONLY = exports.FIRST_KEY_INDEX = undefined;
  exports.FIRST_KEY_INDEX = 1;
  exports.IS_READ_ONLY = true;
  exports.transformArguments = transformArguments;
  var generic_transformers_1 = require_generic_transformers();
  Object.defineProperty(exports, "transformReply", { enumerable: true, get: function() {
    return generic_transformers_1.transformBooleanArrayReply;
  } });
});

// node_modules/@redis/bloom/dist/commands/bloom/RESERVE.js
var require_RESERVE = __commonJS((exports) => {
  var transformArguments = function(key, errorRate, capacity, options) {
    const args = ["BF.RESERVE", key, errorRate.toString(), capacity.toString()];
    if (options?.EXPANSION) {
      args.push("EXPANSION", options.EXPANSION.toString());
    }
    if (options?.NONSCALING) {
      args.push("NONSCALING");
    }
    return args;
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.transformArguments = exports.FIRST_KEY_INDEX = undefined;
  exports.FIRST_KEY_INDEX = 1;
  exports.transformArguments = transformArguments;
});

// node_modules/@redis/bloom/dist/commands/bloom/SCANDUMP.js
var require_SCANDUMP = __commonJS((exports) => {
  var transformArguments = function(key, iterator) {
    return ["BF.SCANDUMP", key, iterator.toString()];
  };
  var transformReply = function([iterator, chunk]) {
    return {
      iterator,
      chunk
    };
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.transformReply = exports.transformArguments = exports.IS_READ_ONLY = exports.FIRST_KEY_INDEX = undefined;
  exports.FIRST_KEY_INDEX = 1;
  exports.IS_READ_ONLY = true;
  exports.transformArguments = transformArguments;
  exports.transformReply = transformReply;
});

// node_modules/@redis/bloom/dist/commands/bloom/index.js
var require_bloom = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  var ADD = require_ADD();
  var CARD = require_CARD();
  var EXISTS = require_EXISTS2();
  var INFO = require_INFO2();
  var INSERT = require_INSERT();
  var LOADCHUNK = require_LOADCHUNK();
  var MADD = require_MADD();
  var MEXISTS = require_MEXISTS();
  var RESERVE = require_RESERVE();
  var SCANDUMP = require_SCANDUMP();
  exports.default = {
    ADD,
    add: ADD,
    CARD,
    card: CARD,
    EXISTS,
    exists: EXISTS,
    INFO,
    info: INFO,
    INSERT,
    insert: INSERT,
    LOADCHUNK,
    loadChunk: LOADCHUNK,
    MADD,
    mAdd: MADD,
    MEXISTS,
    mExists: MEXISTS,
    RESERVE,
    reserve: RESERVE,
    SCANDUMP,
    scanDump: SCANDUMP
  };
});

// node_modules/@redis/bloom/dist/commands/count-min-sketch/INCRBY.js
var require_INCRBY2 = __commonJS((exports) => {
  var transformArguments = function(key, items) {
    const args = ["CMS.INCRBY", key];
    if (Array.isArray(items)) {
      for (const item of items) {
        pushIncrByItem(args, item);
      }
    } else {
      pushIncrByItem(args, items);
    }
    return args;
  };
  var pushIncrByItem = function(args, { item, incrementBy }) {
    args.push(item, incrementBy.toString());
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.transformArguments = exports.FIRST_KEY_INDEX = undefined;
  exports.FIRST_KEY_INDEX = 1;
  exports.transformArguments = transformArguments;
});

// node_modules/@redis/bloom/dist/commands/count-min-sketch/INFO.js
var require_INFO3 = __commonJS((exports) => {
  var transformArguments = function(key) {
    return ["CMS.INFO", key];
  };
  var transformReply = function(reply) {
    return {
      width: reply[1],
      depth: reply[3],
      count: reply[5]
    };
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.transformReply = exports.transformArguments = exports.IS_READ_ONLY = exports.FIRST_KEY_INDEX = undefined;
  exports.FIRST_KEY_INDEX = 1;
  exports.IS_READ_ONLY = true;
  exports.transformArguments = transformArguments;
  exports.transformReply = transformReply;
});

// node_modules/@redis/bloom/dist/commands/count-min-sketch/INITBYDIM.js
var require_INITBYDIM = __commonJS((exports) => {
  var transformArguments = function(key, width, depth) {
    return ["CMS.INITBYDIM", key, width.toString(), depth.toString()];
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.transformArguments = exports.FIRST_KEY_INDEX = undefined;
  exports.FIRST_KEY_INDEX = 1;
  exports.transformArguments = transformArguments;
});

// node_modules/@redis/bloom/dist/commands/count-min-sketch/INITBYPROB.js
var require_INITBYPROB = __commonJS((exports) => {
  var transformArguments = function(key, error, probability) {
    return ["CMS.INITBYPROB", key, error.toString(), probability.toString()];
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.transformArguments = exports.FIRST_KEY_INDEX = undefined;
  exports.FIRST_KEY_INDEX = 1;
  exports.transformArguments = transformArguments;
});

// node_modules/@redis/bloom/dist/commands/count-min-sketch/MERGE.js
var require_MERGE = __commonJS((exports) => {
  var transformArguments = function(dest, src) {
    const args = [
      "CMS.MERGE",
      dest,
      src.length.toString()
    ];
    if (isStringSketches(src)) {
      args.push(...src);
    } else {
      for (const sketch of src) {
        args.push(sketch.name);
      }
      args.push("WEIGHTS");
      for (const sketch of src) {
        args.push(sketch.weight.toString());
      }
    }
    return args;
  };
  var isStringSketches = function(src) {
    return typeof src[0] === "string";
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.transformArguments = exports.FIRST_KEY_INDEX = undefined;
  exports.FIRST_KEY_INDEX = 1;
  exports.transformArguments = transformArguments;
});

// node_modules/@redis/bloom/dist/commands/count-min-sketch/QUERY.js
var require_QUERY = __commonJS((exports) => {
  var transformArguments = function(key, items) {
    return (0, generic_transformers_1.pushVerdictArguments)(["CMS.QUERY", key], items);
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.transformArguments = exports.IS_READ_ONLY = exports.FIRST_KEY_INDEX = undefined;
  var generic_transformers_1 = require_generic_transformers();
  exports.FIRST_KEY_INDEX = 1;
  exports.IS_READ_ONLY = true;
  exports.transformArguments = transformArguments;
});

// node_modules/@redis/bloom/dist/commands/count-min-sketch/index.js
var require_count_min_sketch = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  var INCRBY = require_INCRBY2();
  var INFO = require_INFO3();
  var INITBYDIM = require_INITBYDIM();
  var INITBYPROB = require_INITBYPROB();
  var MERGE = require_MERGE();
  var QUERY = require_QUERY();
  exports.default = {
    INCRBY,
    incrBy: INCRBY,
    INFO,
    info: INFO,
    INITBYDIM,
    initByDim: INITBYDIM,
    INITBYPROB,
    initByProb: INITBYPROB,
    MERGE,
    merge: MERGE,
    QUERY,
    query: QUERY
  };
});

// node_modules/@redis/bloom/dist/commands/cuckoo/ADD.js
var require_ADD2 = __commonJS((exports) => {
  var transformArguments = function(key, item) {
    return ["CF.ADD", key, item];
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.transformReply = exports.transformArguments = exports.FIRST_KEY_INDEX = undefined;
  exports.FIRST_KEY_INDEX = 1;
  exports.transformArguments = transformArguments;
  var generic_transformers_1 = require_generic_transformers();
  Object.defineProperty(exports, "transformReply", { enumerable: true, get: function() {
    return generic_transformers_1.transformBooleanReply;
  } });
});

// node_modules/@redis/bloom/dist/commands/cuckoo/ADDNX.js
var require_ADDNX = __commonJS((exports) => {
  var transformArguments = function(key, item) {
    return ["CF.ADDNX", key, item];
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.transformReply = exports.transformArguments = exports.FIRST_KEY_INDEX = undefined;
  exports.FIRST_KEY_INDEX = 1;
  exports.transformArguments = transformArguments;
  var generic_transformers_1 = require_generic_transformers();
  Object.defineProperty(exports, "transformReply", { enumerable: true, get: function() {
    return generic_transformers_1.transformBooleanReply;
  } });
});

// node_modules/@redis/bloom/dist/commands/cuckoo/COUNT.js
var require_COUNT = __commonJS((exports) => {
  var transformArguments = function(key, item) {
    return ["CF.COUNT", key, item];
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.transformArguments = exports.FIRST_KEY_INDEX = undefined;
  exports.FIRST_KEY_INDEX = 1;
  exports.transformArguments = transformArguments;
});

// node_modules/@redis/bloom/dist/commands/cuckoo/DEL.js
var require_DEL2 = __commonJS((exports) => {
  var transformArguments = function(key, item) {
    return ["CF.DEL", key, item];
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.transformReply = exports.transformArguments = exports.FIRST_KEY_INDEX = undefined;
  exports.FIRST_KEY_INDEX = 1;
  exports.transformArguments = transformArguments;
  var generic_transformers_1 = require_generic_transformers();
  Object.defineProperty(exports, "transformReply", { enumerable: true, get: function() {
    return generic_transformers_1.transformBooleanReply;
  } });
});

// node_modules/@redis/bloom/dist/commands/cuckoo/EXISTS.js
var require_EXISTS3 = __commonJS((exports) => {
  var transformArguments = function(key, item) {
    return ["CF.EXISTS", key, item];
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.transformReply = exports.transformArguments = exports.IS_READ_ONLY = exports.FIRST_KEY_INDEX = undefined;
  exports.FIRST_KEY_INDEX = 1;
  exports.IS_READ_ONLY = true;
  exports.transformArguments = transformArguments;
  var generic_transformers_1 = require_generic_transformers();
  Object.defineProperty(exports, "transformReply", { enumerable: true, get: function() {
    return generic_transformers_1.transformBooleanReply;
  } });
});

// node_modules/@redis/bloom/dist/commands/cuckoo/INFO.js
var require_INFO4 = __commonJS((exports) => {
  var transformArguments = function(key) {
    return ["CF.INFO", key];
  };
  var transformReply = function(reply) {
    return {
      size: reply[1],
      numberOfBuckets: reply[3],
      numberOfFilters: reply[5],
      numberOfInsertedItems: reply[7],
      numberOfDeletedItems: reply[9],
      bucketSize: reply[11],
      expansionRate: reply[13],
      maxIteration: reply[15]
    };
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.transformReply = exports.transformArguments = exports.IS_READ_ONLY = exports.FIRST_KEY_INDEX = undefined;
  exports.FIRST_KEY_INDEX = 1;
  exports.IS_READ_ONLY = true;
  exports.transformArguments = transformArguments;
  exports.transformReply = transformReply;
});

// node_modules/@redis/bloom/dist/commands/cuckoo/INSERT.js
var require_INSERT2 = __commonJS((exports) => {
  var transformArguments = function(key, items, options) {
    return (0, _1.pushInsertOptions)(["CF.INSERT", key], items, options);
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.transformReply = exports.transformArguments = exports.FIRST_KEY_INDEX = undefined;
  var _1 = require_cuckoo();
  exports.FIRST_KEY_INDEX = 1;
  exports.transformArguments = transformArguments;
  var generic_transformers_1 = require_generic_transformers();
  Object.defineProperty(exports, "transformReply", { enumerable: true, get: function() {
    return generic_transformers_1.transformBooleanArrayReply;
  } });
});

// node_modules/@redis/bloom/dist/commands/cuckoo/INSERTNX.js
var require_INSERTNX = __commonJS((exports) => {
  var transformArguments = function(key, items, options) {
    return (0, _1.pushInsertOptions)(["CF.INSERTNX", key], items, options);
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.transformReply = exports.transformArguments = exports.FIRST_KEY_INDEX = undefined;
  var _1 = require_cuckoo();
  exports.FIRST_KEY_INDEX = 1;
  exports.transformArguments = transformArguments;
  var generic_transformers_1 = require_generic_transformers();
  Object.defineProperty(exports, "transformReply", { enumerable: true, get: function() {
    return generic_transformers_1.transformBooleanArrayReply;
  } });
});

// node_modules/@redis/bloom/dist/commands/cuckoo/LOADCHUNK.js
var require_LOADCHUNK2 = __commonJS((exports) => {
  var transformArguments = function(key, iterator, chunk) {
    return ["CF.LOADCHUNK", key, iterator.toString(), chunk];
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.transformArguments = exports.FIRST_KEY_INDEX = undefined;
  exports.FIRST_KEY_INDEX = 1;
  exports.transformArguments = transformArguments;
});

// node_modules/@redis/bloom/dist/commands/cuckoo/RESERVE.js
var require_RESERVE2 = __commonJS((exports) => {
  var transformArguments = function(key, capacity, options) {
    const args = ["CF.RESERVE", key, capacity.toString()];
    if (options?.BUCKETSIZE) {
      args.push("BUCKETSIZE", options.BUCKETSIZE.toString());
    }
    if (options?.MAXITERATIONS) {
      args.push("MAXITERATIONS", options.MAXITERATIONS.toString());
    }
    if (options?.EXPANSION) {
      args.push("EXPANSION", options.EXPANSION.toString());
    }
    return args;
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.transformArguments = exports.FIRST_KEY_INDEX = undefined;
  exports.FIRST_KEY_INDEX = 1;
  exports.transformArguments = transformArguments;
});

// node_modules/@redis/bloom/dist/commands/cuckoo/SCANDUMP.js
var require_SCANDUMP2 = __commonJS((exports) => {
  var transformArguments = function(key, iterator) {
    return ["CF.SCANDUMP", key, iterator.toString()];
  };
  var transformReply = function([iterator, chunk]) {
    return {
      iterator,
      chunk
    };
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.transformReply = exports.transformArguments = exports.FIRST_KEY_INDEX = undefined;
  exports.FIRST_KEY_INDEX = 1;
  exports.transformArguments = transformArguments;
  exports.transformReply = transformReply;
});

// node_modules/@redis/bloom/dist/commands/cuckoo/index.js
var require_cuckoo = __commonJS((exports) => {
  var pushInsertOptions = function(args, items, options) {
    if (options?.CAPACITY) {
      args.push("CAPACITY");
      args.push(options.CAPACITY.toString());
    }
    if (options?.NOCREATE) {
      args.push("NOCREATE");
    }
    args.push("ITEMS");
    return (0, generic_transformers_1.pushVerdictArguments)(args, items);
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.pushInsertOptions = undefined;
  var ADD = require_ADD2();
  var ADDNX = require_ADDNX();
  var COUNT = require_COUNT();
  var DEL = require_DEL2();
  var EXISTS = require_EXISTS3();
  var INFO = require_INFO4();
  var INSERT = require_INSERT2();
  var INSERTNX = require_INSERTNX();
  var LOADCHUNK = require_LOADCHUNK2();
  var RESERVE = require_RESERVE2();
  var SCANDUMP = require_SCANDUMP2();
  var generic_transformers_1 = require_generic_transformers();
  exports.default = {
    ADD,
    add: ADD,
    ADDNX,
    addNX: ADDNX,
    COUNT,
    count: COUNT,
    DEL,
    del: DEL,
    EXISTS,
    exists: EXISTS,
    INFO,
    info: INFO,
    INSERT,
    insert: INSERT,
    INSERTNX,
    insertNX: INSERTNX,
    LOADCHUNK,
    loadChunk: LOADCHUNK,
    RESERVE,
    reserve: RESERVE,
    SCANDUMP,
    scanDump: SCANDUMP
  };
  exports.pushInsertOptions = pushInsertOptions;
});

// node_modules/@redis/bloom/dist/commands/t-digest/ADD.js
var require_ADD3 = __commonJS((exports) => {
  var transformArguments = function(key, values2) {
    const args = ["TDIGEST.ADD", key];
    for (const item of values2) {
      args.push(item.toString());
    }
    return args;
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.transformArguments = exports.FIRST_KEY_INDEX = undefined;
  exports.FIRST_KEY_INDEX = 1;
  exports.transformArguments = transformArguments;
});

// node_modules/@redis/bloom/dist/commands/t-digest/BYRANK.js
var require_BYRANK = __commonJS((exports) => {
  var transformArguments = function(key, ranks) {
    const args = ["TDIGEST.BYRANK", key];
    for (const rank of ranks) {
      args.push(rank.toString());
    }
    return args;
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.transformReply = exports.transformArguments = exports.IS_READ_ONLY = exports.FIRST_KEY_INDEX = undefined;
  exports.FIRST_KEY_INDEX = 1;
  exports.IS_READ_ONLY = true;
  exports.transformArguments = transformArguments;
  var _1 = require_t_digest();
  Object.defineProperty(exports, "transformReply", { enumerable: true, get: function() {
    return _1.transformDoublesReply;
  } });
});

// node_modules/@redis/bloom/dist/commands/t-digest/BYREVRANK.js
var require_BYREVRANK = __commonJS((exports) => {
  var transformArguments = function(key, ranks) {
    const args = ["TDIGEST.BYREVRANK", key];
    for (const rank of ranks) {
      args.push(rank.toString());
    }
    return args;
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.transformReply = exports.transformArguments = exports.IS_READ_ONLY = exports.FIRST_KEY_INDEX = undefined;
  exports.FIRST_KEY_INDEX = 1;
  exports.IS_READ_ONLY = true;
  exports.transformArguments = transformArguments;
  var _1 = require_t_digest();
  Object.defineProperty(exports, "transformReply", { enumerable: true, get: function() {
    return _1.transformDoublesReply;
  } });
});

// node_modules/@redis/bloom/dist/commands/t-digest/CDF.js
var require_CDF = __commonJS((exports) => {
  var transformArguments = function(key, values2) {
    const args = ["TDIGEST.CDF", key];
    for (const item of values2) {
      args.push(item.toString());
    }
    return args;
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.transformReply = exports.transformArguments = exports.IS_READ_ONLY = exports.FIRST_KEY_INDEX = undefined;
  exports.FIRST_KEY_INDEX = 1;
  exports.IS_READ_ONLY = true;
  exports.transformArguments = transformArguments;
  var _1 = require_t_digest();
  Object.defineProperty(exports, "transformReply", { enumerable: true, get: function() {
    return _1.transformDoublesReply;
  } });
});

// node_modules/@redis/bloom/dist/commands/t-digest/CREATE.js
var require_CREATE = __commonJS((exports) => {
  var transformArguments = function(key, options) {
    return (0, _1.pushCompressionArgument)(["TDIGEST.CREATE", key], options);
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.transformArguments = exports.FIRST_KEY_INDEX = undefined;
  var _1 = require_t_digest();
  exports.FIRST_KEY_INDEX = 1;
  exports.transformArguments = transformArguments;
});

// node_modules/@redis/bloom/dist/commands/t-digest/INFO.js
var require_INFO5 = __commonJS((exports) => {
  var transformArguments = function(key) {
    return [
      "TDIGEST.INFO",
      key
    ];
  };
  var transformReply = function(reply) {
    return {
      comperssion: reply[1],
      capacity: reply[3],
      mergedNodes: reply[5],
      unmergedNodes: reply[7],
      mergedWeight: Number(reply[9]),
      unmergedWeight: Number(reply[11]),
      totalCompression: reply[13]
    };
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.transformReply = exports.transformArguments = exports.IS_READ_ONLY = exports.FIRST_KEY_INDEX = undefined;
  exports.FIRST_KEY_INDEX = 1;
  exports.IS_READ_ONLY = true;
  exports.transformArguments = transformArguments;
  exports.transformReply = transformReply;
});

// node_modules/@redis/bloom/dist/commands/t-digest/MAX.js
var require_MAX = __commonJS((exports) => {
  var transformArguments = function(key) {
    return [
      "TDIGEST.MAX",
      key
    ];
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.transformReply = exports.transformArguments = exports.IS_READ_ONLY = exports.FIRST_KEY_INDEX = undefined;
  exports.FIRST_KEY_INDEX = 1;
  exports.IS_READ_ONLY = true;
  exports.transformArguments = transformArguments;
  var _1 = require_t_digest();
  Object.defineProperty(exports, "transformReply", { enumerable: true, get: function() {
    return _1.transformDoubleReply;
  } });
});

// node_modules/@redis/bloom/dist/commands/t-digest/MERGE.js
var require_MERGE2 = __commonJS((exports) => {
  var transformArguments = function(destKey, srcKeys, options) {
    const args = (0, generic_transformers_1.pushVerdictArgument)(["TDIGEST.MERGE", destKey], srcKeys);
    (0, _1.pushCompressionArgument)(args, options);
    if (options?.OVERRIDE) {
      args.push("OVERRIDE");
    }
    return args;
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.transformArguments = exports.FIRST_KEY_INDEX = undefined;
  var generic_transformers_1 = require_generic_transformers();
  var _1 = require_t_digest();
  exports.FIRST_KEY_INDEX = 1;
  exports.transformArguments = transformArguments;
});

// node_modules/@redis/bloom/dist/commands/t-digest/MIN.js
var require_MIN = __commonJS((exports) => {
  var transformArguments = function(key) {
    return [
      "TDIGEST.MIN",
      key
    ];
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.transformReply = exports.transformArguments = exports.IS_READ_ONLY = exports.FIRST_KEY_INDEX = undefined;
  exports.FIRST_KEY_INDEX = 1;
  exports.IS_READ_ONLY = true;
  exports.transformArguments = transformArguments;
  var _1 = require_t_digest();
  Object.defineProperty(exports, "transformReply", { enumerable: true, get: function() {
    return _1.transformDoubleReply;
  } });
});

// node_modules/@redis/bloom/dist/commands/t-digest/QUANTILE.js
var require_QUANTILE = __commonJS((exports) => {
  var transformArguments = function(key, quantiles) {
    const args = [
      "TDIGEST.QUANTILE",
      key
    ];
    for (const quantile of quantiles) {
      args.push(quantile.toString());
    }
    return args;
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.transformReply = exports.transformArguments = exports.IS_READ_ONLY = exports.FIRST_KEY_INDEX = undefined;
  exports.FIRST_KEY_INDEX = 1;
  exports.IS_READ_ONLY = true;
  exports.transformArguments = transformArguments;
  var _1 = require_t_digest();
  Object.defineProperty(exports, "transformReply", { enumerable: true, get: function() {
    return _1.transformDoublesReply;
  } });
});

// node_modules/@redis/bloom/dist/commands/t-digest/RANK.js
var require_RANK = __commonJS((exports) => {
  var transformArguments = function(key, values2) {
    const args = ["TDIGEST.RANK", key];
    for (const item of values2) {
      args.push(item.toString());
    }
    return args;
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.transformArguments = exports.IS_READ_ONLY = exports.FIRST_KEY_INDEX = undefined;
  exports.FIRST_KEY_INDEX = 1;
  exports.IS_READ_ONLY = true;
  exports.transformArguments = transformArguments;
});

// node_modules/@redis/bloom/dist/commands/t-digest/RESET.js
var require_RESET = __commonJS((exports) => {
  var transformArguments = function(key) {
    return ["TDIGEST.RESET", key];
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.transformArguments = exports.FIRST_KEY_INDEX = undefined;
  exports.FIRST_KEY_INDEX = 1;
  exports.transformArguments = transformArguments;
});

// node_modules/@redis/bloom/dist/commands/t-digest/REVRANK.js
var require_REVRANK = __commonJS((exports) => {
  var transformArguments = function(key, values2) {
    const args = ["TDIGEST.REVRANK", key];
    for (const item of values2) {
      args.push(item.toString());
    }
    return args;
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.transformArguments = exports.IS_READ_ONLY = exports.FIRST_KEY_INDEX = undefined;
  exports.FIRST_KEY_INDEX = 1;
  exports.IS_READ_ONLY = true;
  exports.transformArguments = transformArguments;
});

// node_modules/@redis/bloom/dist/commands/t-digest/TRIMMED_MEAN.js
var require_TRIMMED_MEAN = __commonJS((exports) => {
  var transformArguments = function(key, lowCutPercentile, highCutPercentile) {
    return [
      "TDIGEST.TRIMMED_MEAN",
      key,
      lowCutPercentile.toString(),
      highCutPercentile.toString()
    ];
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.transformReply = exports.transformArguments = exports.IS_READ_ONLY = exports.FIRST_KEY_INDEX = undefined;
  exports.FIRST_KEY_INDEX = 1;
  exports.IS_READ_ONLY = true;
  exports.transformArguments = transformArguments;
  var _1 = require_t_digest();
  Object.defineProperty(exports, "transformReply", { enumerable: true, get: function() {
    return _1.transformDoubleReply;
  } });
});

// node_modules/@redis/bloom/dist/commands/t-digest/index.js
var require_t_digest = __commonJS((exports) => {
  var pushCompressionArgument = function(args, options) {
    if (options?.COMPRESSION) {
      args.push("COMPRESSION", options.COMPRESSION.toString());
    }
    return args;
  };
  var transformDoubleReply = function(reply) {
    switch (reply) {
      case "inf":
        return Infinity;
      case "-inf":
        return (-Infinity);
      case "nan":
        return NaN;
      default:
        return parseFloat(reply);
    }
  };
  var transformDoublesReply = function(reply) {
    return reply.map(transformDoubleReply);
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.transformDoublesReply = exports.transformDoubleReply = exports.pushCompressionArgument = undefined;
  var ADD = require_ADD3();
  var BYRANK = require_BYRANK();
  var BYREVRANK = require_BYREVRANK();
  var CDF = require_CDF();
  var CREATE = require_CREATE();
  var INFO = require_INFO5();
  var MAX = require_MAX();
  var MERGE = require_MERGE2();
  var MIN = require_MIN();
  var QUANTILE = require_QUANTILE();
  var RANK = require_RANK();
  var RESET = require_RESET();
  var REVRANK = require_REVRANK();
  var TRIMMED_MEAN = require_TRIMMED_MEAN();
  exports.default = {
    ADD,
    add: ADD,
    BYRANK,
    byRank: BYRANK,
    BYREVRANK,
    byRevRank: BYREVRANK,
    CDF,
    cdf: CDF,
    CREATE,
    create: CREATE,
    INFO,
    info: INFO,
    MAX,
    max: MAX,
    MERGE,
    merge: MERGE,
    MIN,
    min: MIN,
    QUANTILE,
    quantile: QUANTILE,
    RANK,
    rank: RANK,
    RESET,
    reset: RESET,
    REVRANK,
    revRank: REVRANK,
    TRIMMED_MEAN,
    trimmedMean: TRIMMED_MEAN
  };
  exports.pushCompressionArgument = pushCompressionArgument;
  exports.transformDoubleReply = transformDoubleReply;
  exports.transformDoublesReply = transformDoublesReply;
});

// node_modules/@redis/bloom/dist/commands/top-k/ADD.js
var require_ADD4 = __commonJS((exports) => {
  var transformArguments = function(key, items) {
    return (0, generic_transformers_1.pushVerdictArguments)(["TOPK.ADD", key], items);
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.transformArguments = exports.FIRST_KEY_INDEX = undefined;
  var generic_transformers_1 = require_generic_transformers();
  exports.FIRST_KEY_INDEX = 1;
  exports.transformArguments = transformArguments;
});

// node_modules/@redis/bloom/dist/commands/top-k/COUNT.js
var require_COUNT2 = __commonJS((exports) => {
  var transformArguments = function(key, items) {
    return (0, generic_transformers_1.pushVerdictArguments)(["TOPK.COUNT", key], items);
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.transformArguments = exports.IS_READ_ONLY = exports.FIRST_KEY_INDEX = undefined;
  var generic_transformers_1 = require_generic_transformers();
  exports.FIRST_KEY_INDEX = 1;
  exports.IS_READ_ONLY = true;
  exports.transformArguments = transformArguments;
});

// node_modules/@redis/bloom/dist/commands/top-k/INCRBY.js
var require_INCRBY3 = __commonJS((exports) => {
  var transformArguments = function(key, items) {
    const args = ["TOPK.INCRBY", key];
    if (Array.isArray(items)) {
      for (const item of items) {
        pushIncrByItem(args, item);
      }
    } else {
      pushIncrByItem(args, items);
    }
    return args;
  };
  var pushIncrByItem = function(args, { item, incrementBy }) {
    args.push(item, incrementBy.toString());
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.transformArguments = exports.FIRST_KEY_INDEX = undefined;
  exports.FIRST_KEY_INDEX = 1;
  exports.transformArguments = transformArguments;
});

// node_modules/@redis/bloom/dist/commands/top-k/INFO.js
var require_INFO6 = __commonJS((exports) => {
  var transformArguments = function(key) {
    return ["TOPK.INFO", key];
  };
  var transformReply = function(reply) {
    return {
      k: reply[1],
      width: reply[3],
      depth: reply[5],
      decay: Number(reply[7])
    };
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.transformReply = exports.transformArguments = exports.IS_READ_ONLY = exports.FIRST_KEY_INDEX = undefined;
  exports.FIRST_KEY_INDEX = 1;
  exports.IS_READ_ONLY = true;
  exports.transformArguments = transformArguments;
  exports.transformReply = transformReply;
});

// node_modules/@redis/bloom/dist/commands/top-k/LIST_WITHCOUNT.js
var require_LIST_WITHCOUNT = __commonJS((exports) => {
  var transformArguments = function(key) {
    return ["TOPK.LIST", key, "WITHCOUNT"];
  };
  var transformReply = function(rawReply) {
    const reply = [];
    for (let i = 0;i < rawReply.length; i++) {
      reply.push({
        item: rawReply[i],
        count: rawReply[++i]
      });
    }
    return reply;
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.transformReply = exports.transformArguments = exports.IS_READ_ONLY = exports.FIRST_KEY_INDEX = undefined;
  exports.FIRST_KEY_INDEX = 1;
  exports.IS_READ_ONLY = true;
  exports.transformArguments = transformArguments;
  exports.transformReply = transformReply;
});

// node_modules/@redis/bloom/dist/commands/top-k/LIST.js
var require_LIST = __commonJS((exports) => {
  var transformArguments = function(key) {
    return ["TOPK.LIST", key];
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.transformArguments = exports.IS_READ_ONLY = exports.FIRST_KEY_INDEX = undefined;
  exports.FIRST_KEY_INDEX = 1;
  exports.IS_READ_ONLY = true;
  exports.transformArguments = transformArguments;
});

// node_modules/@redis/bloom/dist/commands/top-k/QUERY.js
var require_QUERY2 = __commonJS((exports) => {
  var transformArguments = function(key, items) {
    return (0, generic_transformers_1.pushVerdictArguments)(["TOPK.QUERY", key], items);
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.transformArguments = exports.IS_READ_ONLY = exports.FIRST_KEY_INDEX = undefined;
  var generic_transformers_1 = require_generic_transformers();
  exports.FIRST_KEY_INDEX = 1;
  exports.IS_READ_ONLY = true;
  exports.transformArguments = transformArguments;
});

// node_modules/@redis/bloom/dist/commands/top-k/RESERVE.js
var require_RESERVE3 = __commonJS((exports) => {
  var transformArguments = function(key, topK, options) {
    const args = ["TOPK.RESERVE", key, topK.toString()];
    if (options) {
      args.push(options.width.toString(), options.depth.toString(), options.decay.toString());
    }
    return args;
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.transformArguments = exports.IS_READ_ONLY = exports.FIRST_KEY_INDEX = undefined;
  exports.FIRST_KEY_INDEX = 1;
  exports.IS_READ_ONLY = true;
  exports.transformArguments = transformArguments;
});

// node_modules/@redis/bloom/dist/commands/top-k/index.js
var require_top_k = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  var ADD = require_ADD4();
  var COUNT = require_COUNT2();
  var INCRBY = require_INCRBY3();
  var INFO = require_INFO6();
  var LIST_WITHCOUNT = require_LIST_WITHCOUNT();
  var LIST = require_LIST();
  var QUERY = require_QUERY2();
  var RESERVE = require_RESERVE3();
  exports.default = {
    ADD,
    add: ADD,
    COUNT,
    count: COUNT,
    INCRBY,
    incrBy: INCRBY,
    INFO,
    info: INFO,
    LIST_WITHCOUNT,
    listWithCount: LIST_WITHCOUNT,
    LIST,
    list: LIST,
    QUERY,
    query: QUERY,
    RESERVE,
    reserve: RESERVE
  };
});

// node_modules/@redis/bloom/dist/commands/index.js
var require_commands4 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  var bloom_1 = require_bloom();
  var count_min_sketch_1 = require_count_min_sketch();
  var cuckoo_1 = require_cuckoo();
  var t_digest_1 = require_t_digest();
  var top_k_1 = require_top_k();
  exports.default = {
    bf: bloom_1.default,
    cms: count_min_sketch_1.default,
    cf: cuckoo_1.default,
    tDigest: t_digest_1.default,
    topK: top_k_1.default
  };
});

// node_modules/@redis/bloom/dist/index.js
var require_dist4 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.default = undefined;
  var commands_1 = require_commands4();
  Object.defineProperty(exports, "default", { enumerable: true, get: function() {
    return commands_1.default;
  } });
});

// node_modules/@redis/graph/dist/commands/CONFIG_GET.js
var require_CONFIG_GET2 = __commonJS((exports) => {
  var transformArguments = function(configKey) {
    return ["GRAPH.CONFIG", "GET", configKey];
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.transformArguments = exports.IS_READ_ONLY = undefined;
  exports.IS_READ_ONLY = true;
  exports.transformArguments = transformArguments;
});

// node_modules/@redis/graph/dist/commands/CONFIG_SET.js
var require_CONFIG_SET2 = __commonJS((exports) => {
  var transformArguments = function(configKey, value) {
    return [
      "GRAPH.CONFIG",
      "SET",
      configKey,
      value.toString()
    ];
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.transformArguments = undefined;
  exports.transformArguments = transformArguments;
});

// node_modules/@redis/graph/dist/commands/DELETE.js
var require_DELETE = __commonJS((exports) => {
  var transformArguments = function(key) {
    return ["GRAPH.DELETE", key];
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.transformArguments = exports.FIRST_KEY_INDEX = undefined;
  exports.FIRST_KEY_INDEX = 1;
  exports.transformArguments = transformArguments;
});

// node_modules/@redis/graph/dist/commands/EXPLAIN.js
var require_EXPLAIN = __commonJS((exports) => {
  var transformArguments = function(key, query4) {
    return ["GRAPH.EXPLAIN", key, query4];
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.transformArguments = exports.IS_READ_ONLY = exports.FIRST_KEY_INDEX = undefined;
  exports.FIRST_KEY_INDEX = 1;
  exports.IS_READ_ONLY = true;
  exports.transformArguments = transformArguments;
});

// node_modules/@redis/graph/dist/commands/LIST.js
var require_LIST2 = __commonJS((exports) => {
  var transformArguments = function() {
    return ["GRAPH.LIST"];
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.transformArguments = exports.IS_READ_ONLY = undefined;
  exports.IS_READ_ONLY = true;
  exports.transformArguments = transformArguments;
});

// node_modules/@redis/graph/dist/commands/PROFILE.js
var require_PROFILE = __commonJS((exports) => {
  var transformArguments = function(key, query4) {
    return ["GRAPH.PROFILE", key, query4];
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.transformArguments = exports.IS_READ_ONLY = exports.FIRST_KEY_INDEX = undefined;
  exports.FIRST_KEY_INDEX = 1;
  exports.IS_READ_ONLY = true;
  exports.transformArguments = transformArguments;
});

// node_modules/@redis/graph/dist/commands/QUERY.js
var require_QUERY3 = __commonJS((exports) => {
  var transformArguments = function(graph, query4, options, compact) {
    return (0, _1.pushQueryArguments)(["GRAPH.QUERY"], graph, query4, options, compact);
  };
  var transformReply = function(reply) {
    return reply.length === 1 ? {
      headers: undefined,
      data: undefined,
      metadata: reply[0]
    } : {
      headers: reply[0],
      data: reply[1],
      metadata: reply[2]
    };
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.transformReply = exports.transformArguments = exports.FIRST_KEY_INDEX = undefined;
  var _1 = require_commands5();
  exports.FIRST_KEY_INDEX = 1;
  exports.transformArguments = transformArguments;
  exports.transformReply = transformReply;
});

// node_modules/@redis/graph/dist/commands/RO_QUERY.js
var require_RO_QUERY = __commonJS((exports) => {
  var transformArguments = function(graph, query4, options, compact) {
    return (0, _1.pushQueryArguments)(["GRAPH.RO_QUERY"], graph, query4, options, compact);
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.transformReply = exports.transformArguments = exports.IS_READ_ONLY = exports.FIRST_KEY_INDEX = undefined;
  var _1 = require_commands5();
  var QUERY_1 = require_QUERY3();
  Object.defineProperty(exports, "FIRST_KEY_INDEX", { enumerable: true, get: function() {
    return QUERY_1.FIRST_KEY_INDEX;
  } });
  exports.IS_READ_ONLY = true;
  exports.transformArguments = transformArguments;
  var QUERY_2 = require_QUERY3();
  Object.defineProperty(exports, "transformReply", { enumerable: true, get: function() {
    return QUERY_2.transformReply;
  } });
});

// node_modules/@redis/graph/dist/commands/SLOWLOG.js
var require_SLOWLOG = __commonJS((exports) => {
  var transformArguments = function(key) {
    return ["GRAPH.SLOWLOG", key];
  };
  var transformReply = function(logs) {
    return logs.map(([timestamp, command, query4, took]) => ({
      timestamp: new Date(Number(timestamp) * 1000),
      command,
      query: query4,
      took: Number(took)
    }));
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.transformReply = exports.transformArguments = exports.FIRST_KEY_INDEX = exports.IS_READ_ONLY = undefined;
  exports.IS_READ_ONLY = true;
  exports.FIRST_KEY_INDEX = 1;
  exports.transformArguments = transformArguments;
  exports.transformReply = transformReply;
});

// node_modules/@redis/graph/dist/commands/index.js
var require_commands5 = __commonJS((exports) => {
  var pushQueryArguments = function(args, graph, query4, options, compact) {
    args.push(graph);
    if (typeof options === "number") {
      args.push(query4);
      pushTimeout(args, options);
    } else {
      args.push(options?.params ? `CYPHER ${queryParamsToString(options.params)} ${query4}` : query4);
      if (options?.TIMEOUT !== undefined) {
        pushTimeout(args, options.TIMEOUT);
      }
    }
    if (compact) {
      args.push("--compact");
    }
    return args;
  };
  var pushTimeout = function(args, timeout) {
    args.push("TIMEOUT", timeout.toString());
  };
  var queryParamsToString = function(params) {
    const parts = [];
    for (const [key, value] of Object.entries(params)) {
      parts.push(`${key}=${queryParamToString(value)}`);
    }
    return parts.join(" ");
  };
  var queryParamToString = function(param) {
    if (param === null) {
      return "null";
    }
    switch (typeof param) {
      case "string":
        return `"${param.replace(/["\\]/g, "\\$&")}"`;
      case "number":
      case "boolean":
        return param.toString();
    }
    if (Array.isArray(param)) {
      return `[${param.map(queryParamToString).join(",")}]`;
    } else if (typeof param === "object") {
      const body2 = [];
      for (const [key, value] of Object.entries(param)) {
        body2.push(`${key}:${queryParamToString(value)}`);
      }
      return `{${body2.join(",")}}`;
    } else {
      throw new TypeError(`Unexpected param type ${typeof param} ${param}`);
    }
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.pushQueryArguments = undefined;
  var CONFIG_GET = require_CONFIG_GET2();
  var CONFIG_SET = require_CONFIG_SET2();
  var DELETE = require_DELETE();
  var EXPLAIN = require_EXPLAIN();
  var LIST = require_LIST2();
  var PROFILE = require_PROFILE();
  var QUERY = require_QUERY3();
  var RO_QUERY = require_RO_QUERY();
  var SLOWLOG = require_SLOWLOG();
  exports.default = {
    CONFIG_GET,
    configGet: CONFIG_GET,
    CONFIG_SET,
    configSet: CONFIG_SET,
    DELETE,
    delete: DELETE,
    EXPLAIN,
    explain: EXPLAIN,
    LIST,
    list: LIST,
    PROFILE,
    profile: PROFILE,
    QUERY,
    query: QUERY,
    RO_QUERY,
    roQuery: RO_QUERY,
    SLOWLOG,
    slowLog: SLOWLOG
  };
  exports.pushQueryArguments = pushQueryArguments;
});

// node_modules/@redis/graph/dist/graph.js
var require_graph = __commonJS((exports) => {
  var __classPrivateFieldSet = exports && exports.__classPrivateFieldSet || function(receiver, state, value, kind, f) {
    if (kind === "m")
      throw new TypeError("Private method is not writable");
    if (kind === "a" && !f)
      throw new TypeError("Private accessor was defined without a setter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver))
      throw new TypeError("Cannot write private member to an object whose class did not declare it");
    return kind === "a" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value), value;
  };
  var __classPrivateFieldGet = exports && exports.__classPrivateFieldGet || function(receiver, state, kind, f) {
    if (kind === "a" && !f)
      throw new TypeError("Private accessor was defined without a getter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver))
      throw new TypeError("Cannot read private member from an object whose class did not declare it");
    return kind === "m" ? f : kind === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
  };
  var _Graph_instances;
  var _Graph_client;
  var _Graph_name;
  var _Graph_metadata;
  var _Graph_setMetadataPromise;
  var _Graph_updateMetadata;
  var _Graph_setMetadata;
  var _Graph_cleanMetadataArray;
  var _Graph_getMetadata;
  var _Graph_getMetadataAsync;
  var _Graph_parseReply;
  var _Graph_parseValue;
  var _Graph_parseEdge;
  var _Graph_parseNode;
  var _Graph_parseProperties;
  Object.defineProperty(exports, "__esModule", { value: true });
  var GraphValueTypes;
  (function(GraphValueTypes2) {
    GraphValueTypes2[GraphValueTypes2["UNKNOWN"] = 0] = "UNKNOWN";
    GraphValueTypes2[GraphValueTypes2["NULL"] = 1] = "NULL";
    GraphValueTypes2[GraphValueTypes2["STRING"] = 2] = "STRING";
    GraphValueTypes2[GraphValueTypes2["INTEGER"] = 3] = "INTEGER";
    GraphValueTypes2[GraphValueTypes2["BOOLEAN"] = 4] = "BOOLEAN";
    GraphValueTypes2[GraphValueTypes2["DOUBLE"] = 5] = "DOUBLE";
    GraphValueTypes2[GraphValueTypes2["ARRAY"] = 6] = "ARRAY";
    GraphValueTypes2[GraphValueTypes2["EDGE"] = 7] = "EDGE";
    GraphValueTypes2[GraphValueTypes2["NODE"] = 8] = "NODE";
    GraphValueTypes2[GraphValueTypes2["PATH"] = 9] = "PATH";
    GraphValueTypes2[GraphValueTypes2["MAP"] = 10] = "MAP";
    GraphValueTypes2[GraphValueTypes2["POINT"] = 11] = "POINT";
  })(GraphValueTypes || (GraphValueTypes = {}));

  class Graph {
    constructor(client, name) {
      _Graph_instances.add(this);
      _Graph_client.set(this, undefined);
      _Graph_name.set(this, undefined);
      _Graph_metadata.set(this, undefined);
      _Graph_setMetadataPromise.set(this, undefined);
      __classPrivateFieldSet(this, _Graph_client, client, "f");
      __classPrivateFieldSet(this, _Graph_name, name, "f");
    }
    async query(query4, options) {
      return __classPrivateFieldGet(this, _Graph_instances, "m", _Graph_parseReply).call(this, await __classPrivateFieldGet(this, _Graph_client, "f").graph.query(__classPrivateFieldGet(this, _Graph_name, "f"), query4, options, true));
    }
    async roQuery(query4, options) {
      return __classPrivateFieldGet(this, _Graph_instances, "m", _Graph_parseReply).call(this, await __classPrivateFieldGet(this, _Graph_client, "f").graph.roQuery(__classPrivateFieldGet(this, _Graph_name, "f"), query4, options, true));
    }
  }
  exports.default = Graph;
  _Graph_client = new WeakMap, _Graph_name = new WeakMap, _Graph_metadata = new WeakMap, _Graph_setMetadataPromise = new WeakMap, _Graph_instances = new WeakSet, _Graph_updateMetadata = function _Graph_updateMetadata() {
    __classPrivateFieldSet(this, _Graph_setMetadataPromise, __classPrivateFieldGet(this, _Graph_setMetadataPromise, "f") ?? __classPrivateFieldGet(this, _Graph_instances, "m", _Graph_setMetadata).call(this).finally(() => __classPrivateFieldSet(this, _Graph_setMetadataPromise, undefined, "f")), "f");
    return __classPrivateFieldGet(this, _Graph_setMetadataPromise, "f");
  }, _Graph_setMetadata = async function _Graph_setMetadata() {
    const [labels, relationshipTypes, propertyKeys] = await Promise.all([
      __classPrivateFieldGet(this, _Graph_client, "f").graph.roQuery(__classPrivateFieldGet(this, _Graph_name, "f"), "CALL db.labels()"),
      __classPrivateFieldGet(this, _Graph_client, "f").graph.roQuery(__classPrivateFieldGet(this, _Graph_name, "f"), "CALL db.relationshipTypes()"),
      __classPrivateFieldGet(this, _Graph_client, "f").graph.roQuery(__classPrivateFieldGet(this, _Graph_name, "f"), "CALL db.propertyKeys()")
    ]);
    __classPrivateFieldSet(this, _Graph_metadata, {
      labels: __classPrivateFieldGet(this, _Graph_instances, "m", _Graph_cleanMetadataArray).call(this, labels.data),
      relationshipTypes: __classPrivateFieldGet(this, _Graph_instances, "m", _Graph_cleanMetadataArray).call(this, relationshipTypes.data),
      propertyKeys: __classPrivateFieldGet(this, _Graph_instances, "m", _Graph_cleanMetadataArray).call(this, propertyKeys.data)
    }, "f");
    return __classPrivateFieldGet(this, _Graph_metadata, "f");
  }, _Graph_cleanMetadataArray = function _Graph_cleanMetadataArray(arr) {
    return arr.map(([value]) => value);
  }, _Graph_getMetadata = function _Graph_getMetadata(key, id) {
    return __classPrivateFieldGet(this, _Graph_metadata, "f")?.[key][id] ?? __classPrivateFieldGet(this, _Graph_instances, "m", _Graph_getMetadataAsync).call(this, key, id);
  }, _Graph_getMetadataAsync = async function _Graph_getMetadataAsync(key, id) {
    const value = (await __classPrivateFieldGet(this, _Graph_instances, "m", _Graph_updateMetadata).call(this))[key][id];
    if (value === undefined)
      throw new Error(`Cannot find value from ${key}[${id}]`);
    return value;
  }, _Graph_parseReply = async function _Graph_parseReply(reply) {
    if (!reply.data)
      return reply;
    const promises = [], parsed = {
      metadata: reply.metadata,
      data: reply.data.map((row) => {
        const data = {};
        for (let i = 0;i < row.length; i++) {
          data[reply.headers[i][1]] = __classPrivateFieldGet(this, _Graph_instances, "m", _Graph_parseValue).call(this, row[i], promises);
        }
        return data;
      })
    };
    if (promises.length)
      await Promise.all(promises);
    return parsed;
  }, _Graph_parseValue = function _Graph_parseValue([valueType, value], promises) {
    switch (valueType) {
      case GraphValueTypes.NULL:
        return null;
      case GraphValueTypes.STRING:
      case GraphValueTypes.INTEGER:
        return value;
      case GraphValueTypes.BOOLEAN:
        return value === "true";
      case GraphValueTypes.DOUBLE:
        return parseFloat(value);
      case GraphValueTypes.ARRAY:
        return value.map((x) => __classPrivateFieldGet(this, _Graph_instances, "m", _Graph_parseValue).call(this, x, promises));
      case GraphValueTypes.EDGE:
        return __classPrivateFieldGet(this, _Graph_instances, "m", _Graph_parseEdge).call(this, value, promises);
      case GraphValueTypes.NODE:
        return __classPrivateFieldGet(this, _Graph_instances, "m", _Graph_parseNode).call(this, value, promises);
      case GraphValueTypes.PATH:
        return {
          nodes: value[0][1].map(([, node4]) => __classPrivateFieldGet(this, _Graph_instances, "m", _Graph_parseNode).call(this, node4, promises)),
          edges: value[1][1].map(([, edge]) => __classPrivateFieldGet(this, _Graph_instances, "m", _Graph_parseEdge).call(this, edge, promises))
        };
      case GraphValueTypes.MAP:
        const map = {};
        for (let i = 0;i < value.length; i++) {
          map[value[i++]] = __classPrivateFieldGet(this, _Graph_instances, "m", _Graph_parseValue).call(this, value[i], promises);
        }
        return map;
      case GraphValueTypes.POINT:
        return {
          latitude: parseFloat(value[0]),
          longitude: parseFloat(value[1])
        };
      default:
        throw new Error(`unknown scalar type: ${valueType}`);
    }
  }, _Graph_parseEdge = function _Graph_parseEdge([id, relationshipTypeId, sourceId, destinationId, properties], promises) {
    const edge = {
      id,
      sourceId,
      destinationId,
      properties: __classPrivateFieldGet(this, _Graph_instances, "m", _Graph_parseProperties).call(this, properties, promises)
    };
    const relationshipType = __classPrivateFieldGet(this, _Graph_instances, "m", _Graph_getMetadata).call(this, "relationshipTypes", relationshipTypeId);
    if (relationshipType instanceof Promise) {
      promises.push(relationshipType.then((value) => edge.relationshipType = value));
    } else {
      edge.relationshipType = relationshipType;
    }
    return edge;
  }, _Graph_parseNode = function _Graph_parseNode([id, labelIds, properties], promises) {
    const labels = new Array(labelIds.length);
    for (let i = 0;i < labelIds.length; i++) {
      const value = __classPrivateFieldGet(this, _Graph_instances, "m", _Graph_getMetadata).call(this, "labels", labelIds[i]);
      if (value instanceof Promise) {
        promises.push(value.then((value2) => labels[i] = value2));
      } else {
        labels[i] = value;
      }
    }
    return {
      id,
      labels,
      properties: __classPrivateFieldGet(this, _Graph_instances, "m", _Graph_parseProperties).call(this, properties, promises)
    };
  }, _Graph_parseProperties = function _Graph_parseProperties(raw, promises) {
    const parsed = {};
    for (const [id, type, value] of raw) {
      const parsedValue = __classPrivateFieldGet(this, _Graph_instances, "m", _Graph_parseValue).call(this, [type, value], promises), key = __classPrivateFieldGet(this, _Graph_instances, "m", _Graph_getMetadata).call(this, "propertyKeys", id);
      if (key instanceof Promise) {
        promises.push(key.then((key2) => parsed[key2] = parsedValue));
      } else {
        parsed[key] = parsedValue;
      }
    }
    return parsed;
  };
});

// node_modules/@redis/graph/dist/index.js
var require_dist5 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.Graph = exports.default = undefined;
  var commands_1 = require_commands5();
  Object.defineProperty(exports, "default", { enumerable: true, get: function() {
    return commands_1.default;
  } });
  var graph_1 = require_graph();
  Object.defineProperty(exports, "Graph", { enumerable: true, get: function() {
    return graph_1.default;
  } });
});

// node_modules/@redis/json/dist/commands/ARRAPPEND.js
var require_ARRAPPEND = __commonJS((exports) => {
  var transformArguments = function(key, path, ...jsons) {
    const args = ["JSON.ARRAPPEND", key, path];
    for (const json of jsons) {
      args.push((0, _1.transformRedisJsonArgument)(json));
    }
    return args;
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.transformArguments = exports.FIRST_KEY_INDEX = undefined;
  var _1 = require_commands6();
  exports.FIRST_KEY_INDEX = 1;
  exports.transformArguments = transformArguments;
});

// node_modules/@redis/json/dist/commands/ARRINDEX.js
var require_ARRINDEX = __commonJS((exports) => {
  var transformArguments = function(key, path, json, start, stop) {
    const args = ["JSON.ARRINDEX", key, path, (0, _1.transformRedisJsonArgument)(json)];
    if (start !== undefined && start !== null) {
      args.push(start.toString());
      if (stop !== undefined && stop !== null) {
        args.push(stop.toString());
      }
    }
    return args;
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.transformArguments = exports.IS_READ_ONLY = exports.FIRST_KEY_INDEX = undefined;
  var _1 = require_commands6();
  exports.FIRST_KEY_INDEX = 1;
  exports.IS_READ_ONLY = true;
  exports.transformArguments = transformArguments;
});

// node_modules/@redis/json/dist/commands/ARRINSERT.js
var require_ARRINSERT = __commonJS((exports) => {
  var transformArguments = function(key, path, index, ...jsons) {
    const args = ["JSON.ARRINSERT", key, path, index.toString()];
    for (const json of jsons) {
      args.push((0, _1.transformRedisJsonArgument)(json));
    }
    return args;
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.transformArguments = exports.FIRST_KEY_INDEX = undefined;
  var _1 = require_commands6();
  exports.FIRST_KEY_INDEX = 1;
  exports.transformArguments = transformArguments;
});

// node_modules/@redis/json/dist/commands/ARRLEN.js
var require_ARRLEN = __commonJS((exports) => {
  var transformArguments = function(key, path) {
    const args = ["JSON.ARRLEN", key];
    if (path) {
      args.push(path);
    }
    return args;
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.transformArguments = exports.IS_READ_ONLY = exports.FIRST_KEY_INDEX = undefined;
  exports.FIRST_KEY_INDEX = 1;
  exports.IS_READ_ONLY = true;
  exports.transformArguments = transformArguments;
});

// node_modules/@redis/json/dist/commands/ARRPOP.js
var require_ARRPOP = __commonJS((exports) => {
  var transformArguments = function(key, path, index) {
    const args = ["JSON.ARRPOP", key];
    if (path) {
      args.push(path);
      if (index !== undefined && index !== null) {
        args.push(index.toString());
      }
    }
    return args;
  };
  var transformReply = function(reply) {
    if (reply === null)
      return null;
    if (Array.isArray(reply)) {
      return reply.map(_1.transformRedisJsonNullReply);
    }
    return (0, _1.transformRedisJsonNullReply)(reply);
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.transformReply = exports.transformArguments = exports.FIRST_KEY_INDEX = undefined;
  var _1 = require_commands6();
  exports.FIRST_KEY_INDEX = 1;
  exports.transformArguments = transformArguments;
  exports.transformReply = transformReply;
});

// node_modules/@redis/json/dist/commands/ARRTRIM.js
var require_ARRTRIM = __commonJS((exports) => {
  var transformArguments = function(key, path, start, stop) {
    return ["JSON.ARRTRIM", key, path, start.toString(), stop.toString()];
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.transformArguments = exports.FIRST_KEY_INDEX = undefined;
  exports.FIRST_KEY_INDEX = 1;
  exports.transformArguments = transformArguments;
});

// node_modules/@redis/json/dist/commands/DEBUG_MEMORY.js
var require_DEBUG_MEMORY = __commonJS((exports) => {
  var transformArguments = function(key, path) {
    const args = ["JSON.DEBUG", "MEMORY", key];
    if (path) {
      args.push(path);
    }
    return args;
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.transformArguments = exports.FIRST_KEY_INDEX = undefined;
  exports.FIRST_KEY_INDEX = 2;
  exports.transformArguments = transformArguments;
});

// node_modules/@redis/json/dist/commands/DEL.js
var require_DEL3 = __commonJS((exports) => {
  var transformArguments = function(key, path) {
    const args = ["JSON.DEL", key];
    if (path) {
      args.push(path);
    }
    return args;
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.transformArguments = exports.FIRST_KEY_INDEX = undefined;
  exports.FIRST_KEY_INDEX = 1;
  exports.transformArguments = transformArguments;
});

// node_modules/@redis/json/dist/commands/FORGET.js
var require_FORGET = __commonJS((exports) => {
  var transformArguments = function(key, path) {
    const args = ["JSON.FORGET", key];
    if (path) {
      args.push(path);
    }
    return args;
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.transformArguments = exports.FIRST_KEY_INDEX = undefined;
  exports.FIRST_KEY_INDEX = 1;
  exports.transformArguments = transformArguments;
});

// node_modules/@redis/json/dist/commands/GET.js
var require_GET2 = __commonJS((exports) => {
  var transformArguments = function(key, options) {
    let args = ["JSON.GET", key];
    if (options?.path) {
      args = (0, generic_transformers_1.pushVerdictArguments)(args, options.path);
    }
    if (options?.INDENT) {
      args.push("INDENT", options.INDENT);
    }
    if (options?.NEWLINE) {
      args.push("NEWLINE", options.NEWLINE);
    }
    if (options?.SPACE) {
      args.push("SPACE", options.SPACE);
    }
    if (options?.NOESCAPE) {
      args.push("NOESCAPE");
    }
    return args;
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.transformReply = exports.transformArguments = exports.IS_READ_ONLY = exports.FIRST_KEY_INDEX = undefined;
  var generic_transformers_1 = require_generic_transformers();
  exports.FIRST_KEY_INDEX = 1;
  exports.IS_READ_ONLY = true;
  exports.transformArguments = transformArguments;
  var _1 = require_commands6();
  Object.defineProperty(exports, "transformReply", { enumerable: true, get: function() {
    return _1.transformRedisJsonNullReply;
  } });
});

// node_modules/@redis/json/dist/commands/MGET.js
var require_MGET2 = __commonJS((exports) => {
  var transformArguments = function(keys, path) {
    return [
      "JSON.MGET",
      ...keys,
      path
    ];
  };
  var transformReply = function(reply) {
    return reply.map(_1.transformRedisJsonNullReply);
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.transformReply = exports.transformArguments = exports.FIRST_KEY_INDEX = undefined;
  var _1 = require_commands6();
  exports.FIRST_KEY_INDEX = 1;
  exports.transformArguments = transformArguments;
  exports.transformReply = transformReply;
});

// node_modules/@redis/json/dist/commands/NUMINCRBY.js
var require_NUMINCRBY = __commonJS((exports) => {
  var transformArguments = function(key, path, by) {
    return ["JSON.NUMINCRBY", key, path, by.toString()];
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.transformReply = exports.transformArguments = exports.FIRST_KEY_INDEX = undefined;
  exports.FIRST_KEY_INDEX = 1;
  exports.transformArguments = transformArguments;
  var _1 = require_commands6();
  Object.defineProperty(exports, "transformReply", { enumerable: true, get: function() {
    return _1.transformNumbersReply;
  } });
});

// node_modules/@redis/json/dist/commands/NUMMULTBY.js
var require_NUMMULTBY = __commonJS((exports) => {
  var transformArguments = function(key, path, by) {
    return ["JSON.NUMMULTBY", key, path, by.toString()];
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.transformReply = exports.transformArguments = exports.FIRST_KEY_INDEX = undefined;
  exports.FIRST_KEY_INDEX = 1;
  exports.transformArguments = transformArguments;
  var _1 = require_commands6();
  Object.defineProperty(exports, "transformReply", { enumerable: true, get: function() {
    return _1.transformNumbersReply;
  } });
});

// node_modules/@redis/json/dist/commands/OBJKEYS.js
var require_OBJKEYS = __commonJS((exports) => {
  var transformArguments = function(key, path) {
    const args = ["JSON.OBJKEYS", key];
    if (path) {
      args.push(path);
    }
    return args;
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.transformArguments = exports.FIRST_KEY_INDEX = undefined;
  exports.FIRST_KEY_INDEX = 1;
  exports.transformArguments = transformArguments;
});

// node_modules/@redis/json/dist/commands/OBJLEN.js
var require_OBJLEN = __commonJS((exports) => {
  var transformArguments = function(key, path) {
    const args = ["JSON.OBJLEN", key];
    if (path) {
      args.push(path);
    }
    return args;
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.transformArguments = exports.FIRST_KEY_INDEX = undefined;
  exports.FIRST_KEY_INDEX = 1;
  exports.transformArguments = transformArguments;
});

// node_modules/@redis/json/dist/commands/RESP.js
var require_RESP = __commonJS((exports) => {
  var transformArguments = function(key, path) {
    const args = ["JSON.RESP", key];
    if (path) {
      args.push(path);
    }
    return args;
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.transformArguments = exports.FIRST_KEY_INDEX = undefined;
  exports.FIRST_KEY_INDEX = 1;
  exports.transformArguments = transformArguments;
});

// node_modules/@redis/json/dist/commands/SET.js
var require_SET2 = __commonJS((exports) => {
  var transformArguments = function(key, path, json, options) {
    const args = ["JSON.SET", key, path, (0, _1.transformRedisJsonArgument)(json)];
    if (options?.NX) {
      args.push("NX");
    } else if (options?.XX) {
      args.push("XX");
    }
    return args;
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.transformArguments = exports.FIRST_KEY_INDEX = undefined;
  var _1 = require_commands6();
  exports.FIRST_KEY_INDEX = 1;
  exports.transformArguments = transformArguments;
});

// node_modules/@redis/json/dist/commands/STRAPPEND.js
var require_STRAPPEND = __commonJS((exports) => {
  var transformArguments = function(...[key, pathOrAppend, append]) {
    const args = ["JSON.STRAPPEND", key];
    if (append !== undefined && append !== null) {
      args.push(pathOrAppend, (0, _1.transformRedisJsonArgument)(append));
    } else {
      args.push((0, _1.transformRedisJsonArgument)(pathOrAppend));
    }
    return args;
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.transformArguments = exports.FIRST_KEY_INDEX = undefined;
  var _1 = require_commands6();
  exports.FIRST_KEY_INDEX = 1;
  exports.transformArguments = transformArguments;
});

// node_modules/@redis/json/dist/commands/STRLEN.js
var require_STRLEN2 = __commonJS((exports) => {
  var transformArguments = function(key, path) {
    const args = ["JSON.STRLEN", key];
    if (path) {
      args.push(path);
    }
    return args;
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.transformArguments = exports.IS_READ_ONLY = exports.FIRST_KEY_INDEX = undefined;
  exports.FIRST_KEY_INDEX = 1;
  exports.IS_READ_ONLY = true;
  exports.transformArguments = transformArguments;
});

// node_modules/@redis/json/dist/commands/TYPE.js
var require_TYPE2 = __commonJS((exports) => {
  var transformArguments = function(key, path) {
    const args = ["JSON.TYPE", key];
    if (path) {
      args.push(path);
    }
    return args;
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.transformArguments = exports.FIRST_KEY_INDEX = undefined;
  exports.FIRST_KEY_INDEX = 1;
  exports.transformArguments = transformArguments;
});

// node_modules/@redis/json/dist/commands/index.js
var require_commands6 = __commonJS((exports) => {
  var transformRedisJsonArgument = function(json) {
    return JSON.stringify(json);
  };
  var transformRedisJsonReply = function(json) {
    return JSON.parse(json);
  };
  var transformRedisJsonNullReply = function(json) {
    if (json === null)
      return null;
    return transformRedisJsonReply(json);
  };
  var transformNumbersReply = function(reply) {
    return JSON.parse(reply);
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.transformNumbersReply = exports.transformRedisJsonNullReply = exports.transformRedisJsonReply = exports.transformRedisJsonArgument = undefined;
  var ARRAPPEND = require_ARRAPPEND();
  var ARRINDEX = require_ARRINDEX();
  var ARRINSERT = require_ARRINSERT();
  var ARRLEN = require_ARRLEN();
  var ARRPOP = require_ARRPOP();
  var ARRTRIM = require_ARRTRIM();
  var DEBUG_MEMORY = require_DEBUG_MEMORY();
  var DEL = require_DEL3();
  var FORGET = require_FORGET();
  var GET = require_GET2();
  var MGET = require_MGET2();
  var NUMINCRBY = require_NUMINCRBY();
  var NUMMULTBY = require_NUMMULTBY();
  var OBJKEYS = require_OBJKEYS();
  var OBJLEN = require_OBJLEN();
  var RESP = require_RESP();
  var SET = require_SET2();
  var STRAPPEND = require_STRAPPEND();
  var STRLEN = require_STRLEN2();
  var TYPE = require_TYPE2();
  exports.default = {
    ARRAPPEND,
    arrAppend: ARRAPPEND,
    ARRINDEX,
    arrIndex: ARRINDEX,
    ARRINSERT,
    arrInsert: ARRINSERT,
    ARRLEN,
    arrLen: ARRLEN,
    ARRPOP,
    arrPop: ARRPOP,
    ARRTRIM,
    arrTrim: ARRTRIM,
    DEBUG_MEMORY,
    debugMemory: DEBUG_MEMORY,
    DEL,
    del: DEL,
    FORGET,
    forget: FORGET,
    GET,
    get: GET,
    MGET,
    mGet: MGET,
    NUMINCRBY,
    numIncrBy: NUMINCRBY,
    NUMMULTBY,
    numMultBy: NUMMULTBY,
    OBJKEYS,
    objKeys: OBJKEYS,
    OBJLEN,
    objLen: OBJLEN,
    RESP,
    resp: RESP,
    SET,
    set: SET,
    STRAPPEND,
    strAppend: STRAPPEND,
    STRLEN,
    strLen: STRLEN,
    TYPE,
    type: TYPE
  };
  exports.transformRedisJsonArgument = transformRedisJsonArgument;
  exports.transformRedisJsonReply = transformRedisJsonReply;
  exports.transformRedisJsonNullReply = transformRedisJsonNullReply;
  exports.transformNumbersReply = transformNumbersReply;
});

// node_modules/@redis/json/dist/index.js
var require_dist6 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.default = undefined;
  var commands_1 = require_commands6();
  Object.defineProperty(exports, "default", { enumerable: true, get: function() {
    return commands_1.default;
  } });
});

// node_modules/@redis/search/dist/commands/_LIST.js
var require__LIST = __commonJS((exports) => {
  var transformArguments = function() {
    return ["FT._LIST"];
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.transformArguments = undefined;
  exports.transformArguments = transformArguments;
});

// node_modules/@redis/search/dist/commands/ALTER.js
var require_ALTER = __commonJS((exports) => {
  var transformArguments = function(index, schema) {
    const args = ["FT.ALTER", index, "SCHEMA", "ADD"];
    (0, _1.pushSchema)(args, schema);
    return args;
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.transformArguments = undefined;
  var _1 = require_commands7();
  exports.transformArguments = transformArguments;
});

// node_modules/@redis/search/dist/commands/AGGREGATE.js
var require_AGGREGATE = __commonJS((exports) => {
  var transformArguments = function(index, query4, options) {
    return pushAggregatehOptions(["FT.AGGREGATE", index, query4], options);
  };
  var pushAggregatehOptions = function(args, options) {
    if (options?.VERBATIM) {
      args.push("VERBATIM");
    }
    if (options?.LOAD) {
      args.push("LOAD");
      (0, _1.pushArgumentsWithLength)(args, () => {
        if (Array.isArray(options.LOAD)) {
          for (const load of options.LOAD) {
            pushLoadField(args, load);
          }
        } else {
          pushLoadField(args, options.LOAD);
        }
      });
    }
    if (options?.STEPS) {
      for (const step of options.STEPS) {
        switch (step.type) {
          case AggregateSteps.GROUPBY:
            args.push("GROUPBY");
            if (!step.properties) {
              args.push("0");
            } else {
              (0, generic_transformers_1.pushVerdictArgument)(args, step.properties);
            }
            if (Array.isArray(step.REDUCE)) {
              for (const reducer of step.REDUCE) {
                pushGroupByReducer(args, reducer);
              }
            } else {
              pushGroupByReducer(args, step.REDUCE);
            }
            break;
          case AggregateSteps.SORTBY:
            (0, _1.pushSortByArguments)(args, "SORTBY", step.BY);
            if (step.MAX) {
              args.push("MAX", step.MAX.toString());
            }
            break;
          case AggregateSteps.APPLY:
            args.push("APPLY", step.expression, "AS", step.AS);
            break;
          case AggregateSteps.LIMIT:
            args.push("LIMIT", step.from.toString(), step.size.toString());
            break;
          case AggregateSteps.FILTER:
            args.push("FILTER", step.expression);
            break;
        }
      }
    }
    (0, _1.pushParamsArgs)(args, options?.PARAMS);
    if (options?.DIALECT) {
      args.push("DIALECT", options.DIALECT.toString());
    }
    if (options?.TIMEOUT !== undefined) {
      args.push("TIMEOUT", options.TIMEOUT.toString());
    }
    return args;
  };
  var pushLoadField = function(args, toLoad) {
    if (typeof toLoad === "string") {
      args.push(toLoad);
    } else {
      args.push(toLoad.identifier);
      if (toLoad.AS) {
        args.push("AS", toLoad.AS);
      }
    }
  };
  var pushGroupByReducer = function(args, reducer) {
    args.push("REDUCE", reducer.type);
    switch (reducer.type) {
      case AggregateGroupByReducers.COUNT:
        args.push("0");
        break;
      case AggregateGroupByReducers.COUNT_DISTINCT:
      case AggregateGroupByReducers.COUNT_DISTINCTISH:
      case AggregateGroupByReducers.SUM:
      case AggregateGroupByReducers.MIN:
      case AggregateGroupByReducers.MAX:
      case AggregateGroupByReducers.AVG:
      case AggregateGroupByReducers.STDDEV:
      case AggregateGroupByReducers.TOLIST:
        args.push("1", reducer.property);
        break;
      case AggregateGroupByReducers.QUANTILE:
        args.push("2", reducer.property, reducer.quantile.toString());
        break;
      case AggregateGroupByReducers.FIRST_VALUE: {
        (0, _1.pushArgumentsWithLength)(args, () => {
          args.push(reducer.property);
          if (reducer.BY) {
            args.push("BY");
            if (typeof reducer.BY === "string") {
              args.push(reducer.BY);
            } else {
              args.push(reducer.BY.property);
              if (reducer.BY.direction) {
                args.push(reducer.BY.direction);
              }
            }
          }
        });
        break;
      }
      case AggregateGroupByReducers.RANDOM_SAMPLE:
        args.push("2", reducer.property, reducer.sampleSize.toString());
        break;
    }
    if (reducer.AS) {
      args.push("AS", reducer.AS);
    }
  };
  var transformReply = function(rawReply) {
    const results = [];
    for (let i = 1;i < rawReply.length; i++) {
      results.push((0, generic_transformers_1.transformTuplesReply)(rawReply[i]));
    }
    return {
      total: rawReply[0],
      results
    };
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.transformReply = exports.pushAggregatehOptions = exports.transformArguments = exports.IS_READ_ONLY = exports.FIRST_KEY_INDEX = exports.AggregateGroupByReducers = exports.AggregateSteps = undefined;
  var generic_transformers_1 = require_generic_transformers();
  var _1 = require_commands7();
  var AggregateSteps;
  (function(AggregateSteps2) {
    AggregateSteps2["GROUPBY"] = "GROUPBY";
    AggregateSteps2["SORTBY"] = "SORTBY";
    AggregateSteps2["APPLY"] = "APPLY";
    AggregateSteps2["LIMIT"] = "LIMIT";
    AggregateSteps2["FILTER"] = "FILTER";
  })(AggregateSteps = exports.AggregateSteps || (exports.AggregateSteps = {}));
  var AggregateGroupByReducers;
  (function(AggregateGroupByReducers2) {
    AggregateGroupByReducers2["COUNT"] = "COUNT";
    AggregateGroupByReducers2["COUNT_DISTINCT"] = "COUNT_DISTINCT";
    AggregateGroupByReducers2["COUNT_DISTINCTISH"] = "COUNT_DISTINCTISH";
    AggregateGroupByReducers2["SUM"] = "SUM";
    AggregateGroupByReducers2["MIN"] = "MIN";
    AggregateGroupByReducers2["MAX"] = "MAX";
    AggregateGroupByReducers2["AVG"] = "AVG";
    AggregateGroupByReducers2["STDDEV"] = "STDDEV";
    AggregateGroupByReducers2["QUANTILE"] = "QUANTILE";
    AggregateGroupByReducers2["TOLIST"] = "TOLIST";
    AggregateGroupByReducers2["TO_LIST"] = "TOLIST";
    AggregateGroupByReducers2["FIRST_VALUE"] = "FIRST_VALUE";
    AggregateGroupByReducers2["RANDOM_SAMPLE"] = "RANDOM_SAMPLE";
  })(AggregateGroupByReducers = exports.AggregateGroupByReducers || (exports.AggregateGroupByReducers = {}));
  exports.FIRST_KEY_INDEX = 1;
  exports.IS_READ_ONLY = true;
  exports.transformArguments = transformArguments;
  exports.pushAggregatehOptions = pushAggregatehOptions;
  exports.transformReply = transformReply;
});

// node_modules/@redis/search/dist/commands/AGGREGATE_WITHCURSOR.js
var require_AGGREGATE_WITHCURSOR = __commonJS((exports) => {
  var transformArguments = function(index, query4, options) {
    const args = (0, AGGREGATE_1.transformArguments)(index, query4, options);
    args.push("WITHCURSOR");
    if (options?.COUNT) {
      args.push("COUNT", options.COUNT.toString());
    }
    return args;
  };
  var transformReply = function(reply) {
    return {
      ...(0, AGGREGATE_1.transformReply)(reply[0]),
      cursor: reply[1]
    };
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.transformReply = exports.transformArguments = exports.IS_READ_ONLY = exports.FIRST_KEY_INDEX = undefined;
  var AGGREGATE_1 = require_AGGREGATE();
  var AGGREGATE_2 = require_AGGREGATE();
  Object.defineProperty(exports, "FIRST_KEY_INDEX", { enumerable: true, get: function() {
    return AGGREGATE_2.FIRST_KEY_INDEX;
  } });
  Object.defineProperty(exports, "IS_READ_ONLY", { enumerable: true, get: function() {
    return AGGREGATE_2.IS_READ_ONLY;
  } });
  exports.transformArguments = transformArguments;
  exports.transformReply = transformReply;
});

// node_modules/@redis/search/dist/commands/ALIASADD.js
var require_ALIASADD = __commonJS((exports) => {
  var transformArguments = function(name, index) {
    return ["FT.ALIASADD", name, index];
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.transformArguments = undefined;
  exports.transformArguments = transformArguments;
});

// node_modules/@redis/search/dist/commands/ALIASDEL.js
var require_ALIASDEL = __commonJS((exports) => {
  var transformArguments = function(name, index) {
    return ["FT.ALIASDEL", name, index];
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.transformArguments = undefined;
  exports.transformArguments = transformArguments;
});

// node_modules/@redis/search/dist/commands/ALIASUPDATE.js
var require_ALIASUPDATE = __commonJS((exports) => {
  var transformArguments = function(name, index) {
    return ["FT.ALIASUPDATE", name, index];
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.transformArguments = undefined;
  exports.transformArguments = transformArguments;
});

// node_modules/@redis/search/dist/commands/CONFIG_GET.js
var require_CONFIG_GET3 = __commonJS((exports) => {
  var transformArguments = function(option) {
    return ["FT.CONFIG", "GET", option];
  };
  var transformReply = function(rawReply) {
    const transformedReply = Object.create(null);
    for (const [key, value] of rawReply) {
      transformedReply[key] = value;
    }
    return transformedReply;
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.transformReply = exports.transformArguments = undefined;
  exports.transformArguments = transformArguments;
  exports.transformReply = transformReply;
});

// node_modules/@redis/search/dist/commands/CONFIG_SET.js
var require_CONFIG_SET3 = __commonJS((exports) => {
  var transformArguments = function(option, value) {
    return ["FT.CONFIG", "SET", option, value];
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.transformArguments = undefined;
  exports.transformArguments = transformArguments;
});

// node_modules/@redis/search/dist/commands/CREATE.js
var require_CREATE2 = __commonJS((exports) => {
  var transformArguments = function(index, schema, options) {
    const args = ["FT.CREATE", index];
    if (options?.ON) {
      args.push("ON", options.ON);
    }
    (0, generic_transformers_1.pushOptionalVerdictArgument)(args, "PREFIX", options?.PREFIX);
    if (options?.FILTER) {
      args.push("FILTER", options.FILTER);
    }
    if (options?.LANGUAGE) {
      args.push("LANGUAGE", options.LANGUAGE);
    }
    if (options?.LANGUAGE_FIELD) {
      args.push("LANGUAGE_FIELD", options.LANGUAGE_FIELD);
    }
    if (options?.SCORE) {
      args.push("SCORE", options.SCORE.toString());
    }
    if (options?.SCORE_FIELD) {
      args.push("SCORE_FIELD", options.SCORE_FIELD);
    }
    if (options?.MAXTEXTFIELDS) {
      args.push("MAXTEXTFIELDS");
    }
    if (options?.TEMPORARY) {
      args.push("TEMPORARY", options.TEMPORARY.toString());
    }
    if (options?.NOOFFSETS) {
      args.push("NOOFFSETS");
    }
    if (options?.NOHL) {
      args.push("NOHL");
    }
    if (options?.NOFIELDS) {
      args.push("NOFIELDS");
    }
    if (options?.NOFREQS) {
      args.push("NOFREQS");
    }
    if (options?.SKIPINITIALSCAN) {
      args.push("SKIPINITIALSCAN");
    }
    (0, generic_transformers_1.pushOptionalVerdictArgument)(args, "STOPWORDS", options?.STOPWORDS);
    args.push("SCHEMA");
    (0, _1.pushSchema)(args, schema);
    return args;
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.transformArguments = undefined;
  var generic_transformers_1 = require_generic_transformers();
  var _1 = require_commands7();
  exports.transformArguments = transformArguments;
});

// node_modules/@redis/search/dist/commands/CURSOR_DEL.js
var require_CURSOR_DEL = __commonJS((exports) => {
  var transformArguments = function(index, cursorId) {
    return [
      "FT.CURSOR",
      "DEL",
      index,
      cursorId.toString()
    ];
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.transformArguments = exports.FIRST_KEY_INDEX = undefined;
  exports.FIRST_KEY_INDEX = 1;
  exports.transformArguments = transformArguments;
});

// node_modules/@redis/search/dist/commands/CURSOR_READ.js
var require_CURSOR_READ = __commonJS((exports) => {
  var transformArguments = function(index, cursor, options) {
    const args = [
      "FT.CURSOR",
      "READ",
      index,
      cursor.toString()
    ];
    if (options?.COUNT) {
      args.push("COUNT", options.COUNT.toString());
    }
    return args;
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.transformReply = exports.transformArguments = exports.IS_READ_ONLY = exports.FIRST_KEY_INDEX = undefined;
  exports.FIRST_KEY_INDEX = 1;
  exports.IS_READ_ONLY = true;
  exports.transformArguments = transformArguments;
  var AGGREGATE_WITHCURSOR_1 = require_AGGREGATE_WITHCURSOR();
  Object.defineProperty(exports, "transformReply", { enumerable: true, get: function() {
    return AGGREGATE_WITHCURSOR_1.transformReply;
  } });
});

// node_modules/@redis/search/dist/commands/DICTADD.js
var require_DICTADD = __commonJS((exports) => {
  var transformArguments = function(dictionary, term) {
    return (0, generic_transformers_1.pushVerdictArguments)(["FT.DICTADD", dictionary], term);
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.transformArguments = undefined;
  var generic_transformers_1 = require_generic_transformers();
  exports.transformArguments = transformArguments;
});

// node_modules/@redis/search/dist/commands/DICTDEL.js
var require_DICTDEL = __commonJS((exports) => {
  var transformArguments = function(dictionary, term) {
    return (0, generic_transformers_1.pushVerdictArguments)(["FT.DICTDEL", dictionary], term);
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.transformArguments = undefined;
  var generic_transformers_1 = require_generic_transformers();
  exports.transformArguments = transformArguments;
});

// node_modules/@redis/search/dist/commands/DICTDUMP.js
var require_DICTDUMP = __commonJS((exports) => {
  var transformArguments = function(dictionary) {
    return ["FT.DICTDUMP", dictionary];
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.transformArguments = undefined;
  exports.transformArguments = transformArguments;
});

// node_modules/@redis/search/dist/commands/DROPINDEX.js
var require_DROPINDEX = __commonJS((exports) => {
  var transformArguments = function(index, options) {
    const args = ["FT.DROPINDEX", index];
    if (options?.DD) {
      args.push("DD");
    }
    return args;
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.transformArguments = undefined;
  exports.transformArguments = transformArguments;
});

// node_modules/@redis/search/dist/commands/EXPLAIN.js
var require_EXPLAIN2 = __commonJS((exports) => {
  var transformArguments = function(index, query4, options) {
    const args = ["FT.EXPLAIN", index, query4];
    (0, _1.pushParamsArgs)(args, options?.PARAMS);
    if (options?.DIALECT) {
      args.push("DIALECT", options.DIALECT.toString());
    }
    return args;
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.transformArguments = exports.IS_READ_ONLY = undefined;
  var _1 = require_commands7();
  exports.IS_READ_ONLY = true;
  exports.transformArguments = transformArguments;
});

// node_modules/@redis/search/dist/commands/EXPLAINCLI.js
var require_EXPLAINCLI = __commonJS((exports) => {
  var transformArguments = function(index, query4) {
    return ["FT.EXPLAINCLI", index, query4];
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.transformArguments = exports.IS_READ_ONLY = undefined;
  exports.IS_READ_ONLY = true;
  exports.transformArguments = transformArguments;
});

// node_modules/@redis/search/dist/commands/INFO.js
var require_INFO7 = __commonJS((exports) => {
  var transformArguments = function(index) {
    return ["FT.INFO", index];
  };
  var transformReply = function(rawReply) {
    return {
      indexName: rawReply[1],
      indexOptions: rawReply[3],
      indexDefinition: (0, generic_transformers_1.transformTuplesReply)(rawReply[5]),
      attributes: rawReply[7].map((attribute) => (0, generic_transformers_1.transformTuplesReply)(attribute)),
      numDocs: rawReply[9],
      maxDocId: rawReply[11],
      numTerms: rawReply[13],
      numRecords: rawReply[15],
      invertedSzMb: rawReply[17],
      vectorIndexSzMb: rawReply[19],
      totalInvertedIndexBlocks: rawReply[21],
      offsetVectorsSzMb: rawReply[23],
      docTableSizeMb: rawReply[25],
      sortableValuesSizeMb: rawReply[27],
      keyTableSizeMb: rawReply[29],
      recordsPerDocAvg: rawReply[31],
      bytesPerRecordAvg: rawReply[33],
      offsetsPerTermAvg: rawReply[35],
      offsetBitsPerRecordAvg: rawReply[37],
      hashIndexingFailures: rawReply[39],
      indexing: rawReply[41],
      percentIndexed: rawReply[43],
      gcStats: {
        bytesCollected: rawReply[45][1],
        totalMsRun: rawReply[45][3],
        totalCycles: rawReply[45][5],
        averageCycleTimeMs: rawReply[45][7],
        lastRunTimeMs: rawReply[45][9],
        gcNumericTreesMissed: rawReply[45][11],
        gcBlocksDenied: rawReply[45][13]
      },
      cursorStats: {
        globalIdle: rawReply[47][1],
        globalTotal: rawReply[47][3],
        indexCapacity: rawReply[47][5],
        idnexTotal: rawReply[47][7]
      },
      stopWords: rawReply[49]
    };
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.transformReply = exports.transformArguments = undefined;
  var generic_transformers_1 = require_generic_transformers();
  exports.transformArguments = transformArguments;
  exports.transformReply = transformReply;
});

// node_modules/@redis/search/dist/commands/SEARCH.js
var require_SEARCH = __commonJS((exports) => {
  var transformArguments = function(index, query4, options) {
    return (0, _1.pushSearchOptions)(["FT.SEARCH", index, query4], options);
  };
  var transformReply = function(reply, withoutDocuments) {
    const documents = [];
    let i = 1;
    while (i < reply.length) {
      documents.push({
        id: reply[i++],
        value: withoutDocuments ? Object.create(null) : documentValue(reply[i++])
      });
    }
    return {
      total: reply[0],
      documents
    };
  };
  var documentValue = function(tuples2) {
    const message2 = Object.create(null);
    let i = 0;
    while (i < tuples2.length) {
      const key = tuples2[i++], value = tuples2[i++];
      if (key === "$") {
        try {
          Object.assign(message2, JSON.parse(value));
          continue;
        } catch {
        }
      }
      message2[key] = value;
    }
    return message2;
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.transformReply = exports.transformArguments = exports.IS_READ_ONLY = exports.FIRST_KEY_INDEX = undefined;
  var _1 = require_commands7();
  exports.FIRST_KEY_INDEX = 1;
  exports.IS_READ_ONLY = true;
  exports.transformArguments = transformArguments;
  exports.transformReply = transformReply;
});

// node_modules/@redis/search/dist/commands/PROFILE_SEARCH.js
var require_PROFILE_SEARCH = __commonJS((exports) => {
  var transformArguments = function(index, query4, options) {
    let args = ["FT.PROFILE", index, "SEARCH"];
    if (options?.LIMITED) {
      args.push("LIMITED");
    }
    args.push("QUERY", query4);
    return (0, _1.pushSearchOptions)(args, options);
  };
  var transformReply = function(reply, withoutDocuments) {
    return {
      results: (0, SEARCH_1.transformReply)(reply[0], withoutDocuments),
      profile: (0, _1.transformProfile)(reply[1])
    };
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.transformReply = exports.transformArguments = exports.IS_READ_ONLY = undefined;
  var SEARCH_1 = require_SEARCH();
  var _1 = require_commands7();
  exports.IS_READ_ONLY = true;
  exports.transformArguments = transformArguments;
  exports.transformReply = transformReply;
});

// node_modules/@redis/search/dist/commands/PROFILE_AGGREGATE.js
var require_PROFILE_AGGREGATE = __commonJS((exports) => {
  var transformArguments = function(index, query4, options) {
    const args = ["FT.PROFILE", index, "AGGREGATE"];
    if (options?.LIMITED) {
      args.push("LIMITED");
    }
    args.push("QUERY", query4);
    (0, AGGREGATE_1.pushAggregatehOptions)(args, options);
    return args;
  };
  var transformReply = function(reply) {
    return {
      results: (0, AGGREGATE_1.transformReply)(reply[0]),
      profile: (0, _1.transformProfile)(reply[1])
    };
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.transformReply = exports.transformArguments = exports.IS_READ_ONLY = undefined;
  var AGGREGATE_1 = require_AGGREGATE();
  var _1 = require_commands7();
  exports.IS_READ_ONLY = true;
  exports.transformArguments = transformArguments;
  exports.transformReply = transformReply;
});

// node_modules/@redis/search/dist/commands/SPELLCHECK.js
var require_SPELLCHECK = __commonJS((exports) => {
  var transformArguments = function(index, query4, options) {
    const args = ["FT.SPELLCHECK", index, query4];
    if (options?.DISTANCE) {
      args.push("DISTANCE", options.DISTANCE.toString());
    }
    if (options?.TERMS) {
      if (Array.isArray(options.TERMS)) {
        for (const term of options.TERMS) {
          pushTerms(args, term);
        }
      } else {
        pushTerms(args, options.TERMS);
      }
    }
    if (options?.DIALECT) {
      args.push("DIALECT", options.DIALECT.toString());
    }
    return args;
  };
  var pushTerms = function(args, { mode, dictionary }) {
    args.push("TERMS", mode, dictionary);
  };
  var transformReply = function(rawReply) {
    return rawReply.map(([, term, suggestions]) => ({
      term,
      suggestions: suggestions.map(([score, suggestion]) => ({
        score: Number(score),
        suggestion
      }))
    }));
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.transformReply = exports.transformArguments = undefined;
  exports.transformArguments = transformArguments;
  exports.transformReply = transformReply;
});

// node_modules/@redis/search/dist/commands/SUGADD.js
var require_SUGADD = __commonJS((exports) => {
  var transformArguments = function(key, string, score, options) {
    const args = ["FT.SUGADD", key, string, score.toString()];
    if (options?.INCR) {
      args.push("INCR");
    }
    if (options?.PAYLOAD) {
      args.push("PAYLOAD", options.PAYLOAD);
    }
    return args;
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.transformArguments = undefined;
  exports.transformArguments = transformArguments;
});

// node_modules/@redis/search/dist/commands/SUGDEL.js
var require_SUGDEL = __commonJS((exports) => {
  var transformArguments = function(key, string) {
    return ["FT.SUGDEL", key, string];
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.transformReply = exports.transformArguments = undefined;
  exports.transformArguments = transformArguments;
  var generic_transformers_1 = require_generic_transformers();
  Object.defineProperty(exports, "transformReply", { enumerable: true, get: function() {
    return generic_transformers_1.transformBooleanReply;
  } });
});

// node_modules/@redis/search/dist/commands/SUGGET.js
var require_SUGGET = __commonJS((exports) => {
  var transformArguments = function(key, prefix, options) {
    const args = ["FT.SUGGET", key, prefix];
    if (options?.FUZZY) {
      args.push("FUZZY");
    }
    if (options?.MAX) {
      args.push("MAX", options.MAX.toString());
    }
    return args;
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.transformArguments = exports.IS_READ_ONLY = undefined;
  exports.IS_READ_ONLY = true;
  exports.transformArguments = transformArguments;
});

// node_modules/@redis/search/dist/commands/SUGGET_WITHPAYLOADS.js
var require_SUGGET_WITHPAYLOADS = __commonJS((exports) => {
  var transformArguments = function(key, prefix, options) {
    return [
      ...(0, SUGGET_1.transformArguments)(key, prefix, options),
      "WITHPAYLOADS"
    ];
  };
  var transformReply = function(rawReply) {
    if (rawReply === null)
      return null;
    const transformedReply = [];
    for (let i = 0;i < rawReply.length; i += 2) {
      transformedReply.push({
        suggestion: rawReply[i],
        payload: rawReply[i + 1]
      });
    }
    return transformedReply;
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.transformReply = exports.transformArguments = exports.IS_READ_ONLY = undefined;
  var SUGGET_1 = require_SUGGET();
  var SUGGET_2 = require_SUGGET();
  Object.defineProperty(exports, "IS_READ_ONLY", { enumerable: true, get: function() {
    return SUGGET_2.IS_READ_ONLY;
  } });
  exports.transformArguments = transformArguments;
  exports.transformReply = transformReply;
});

// node_modules/@redis/search/dist/commands/SUGGET_WITHSCORES_WITHPAYLOADS.js
var require_SUGGET_WITHSCORES_WITHPAYLOADS = __commonJS((exports) => {
  var transformArguments = function(key, prefix, options) {
    return [
      ...(0, SUGGET_1.transformArguments)(key, prefix, options),
      "WITHSCORES",
      "WITHPAYLOADS"
    ];
  };
  var transformReply = function(rawReply) {
    if (rawReply === null)
      return null;
    const transformedReply = [];
    for (let i = 0;i < rawReply.length; i += 3) {
      transformedReply.push({
        suggestion: rawReply[i],
        score: Number(rawReply[i + 1]),
        payload: rawReply[i + 2]
      });
    }
    return transformedReply;
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.transformReply = exports.transformArguments = exports.IS_READ_ONLY = undefined;
  var SUGGET_1 = require_SUGGET();
  var SUGGET_2 = require_SUGGET();
  Object.defineProperty(exports, "IS_READ_ONLY", { enumerable: true, get: function() {
    return SUGGET_2.IS_READ_ONLY;
  } });
  exports.transformArguments = transformArguments;
  exports.transformReply = transformReply;
});

// node_modules/@redis/search/dist/commands/SUGGET_WITHSCORES.js
var require_SUGGET_WITHSCORES = __commonJS((exports) => {
  var transformArguments = function(key, prefix, options) {
    return [
      ...(0, SUGGET_1.transformArguments)(key, prefix, options),
      "WITHSCORES"
    ];
  };
  var transformReply = function(rawReply) {
    if (rawReply === null)
      return null;
    const transformedReply = [];
    for (let i = 0;i < rawReply.length; i += 2) {
      transformedReply.push({
        suggestion: rawReply[i],
        score: Number(rawReply[i + 1])
      });
    }
    return transformedReply;
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.transformReply = exports.transformArguments = exports.IS_READ_ONLY = undefined;
  var SUGGET_1 = require_SUGGET();
  var SUGGET_2 = require_SUGGET();
  Object.defineProperty(exports, "IS_READ_ONLY", { enumerable: true, get: function() {
    return SUGGET_2.IS_READ_ONLY;
  } });
  exports.transformArguments = transformArguments;
  exports.transformReply = transformReply;
});

// node_modules/@redis/search/dist/commands/SUGLEN.js
var require_SUGLEN = __commonJS((exports) => {
  var transformArguments = function(key) {
    return ["FT.SUGLEN", key];
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.transformArguments = exports.IS_READ_ONLY = undefined;
  exports.IS_READ_ONLY = true;
  exports.transformArguments = transformArguments;
});

// node_modules/@redis/search/dist/commands/SYNDUMP.js
var require_SYNDUMP = __commonJS((exports) => {
  var transformArguments = function(index) {
    return ["FT.SYNDUMP", index];
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.transformArguments = undefined;
  exports.transformArguments = transformArguments;
});

// node_modules/@redis/search/dist/commands/SYNUPDATE.js
var require_SYNUPDATE = __commonJS((exports) => {
  var transformArguments = function(index, groupId, terms, options) {
    const args = ["FT.SYNUPDATE", index, groupId];
    if (options?.SKIPINITIALSCAN) {
      args.push("SKIPINITIALSCAN");
    }
    return (0, generic_transformers_1.pushVerdictArguments)(args, terms);
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.transformArguments = undefined;
  var generic_transformers_1 = require_generic_transformers();
  exports.transformArguments = transformArguments;
});

// node_modules/@redis/search/dist/commands/TAGVALS.js
var require_TAGVALS = __commonJS((exports) => {
  var transformArguments = function(index, fieldName) {
    return ["FT.TAGVALS", index, fieldName];
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.transformArguments = undefined;
  exports.transformArguments = transformArguments;
});

// node_modules/@redis/search/dist/commands/index.js
var require_commands7 = __commonJS((exports) => {
  var pushSortByProperty = function(args, sortBy) {
    if (typeof sortBy === "string") {
      args.push(sortBy);
    } else {
      args.push(sortBy.BY);
      if (sortBy.DIRECTION) {
        args.push(sortBy.DIRECTION);
      }
    }
  };
  var pushSortByArguments = function(args, name, sortBy) {
    const lengthBefore = args.push(name, "");
    if (Array.isArray(sortBy)) {
      for (const field of sortBy) {
        pushSortByProperty(args, field);
      }
    } else {
      pushSortByProperty(args, sortBy);
    }
    args[lengthBefore - 1] = (args.length - lengthBefore).toString();
    return args;
  };
  var pushArgumentsWithLength = function(args, fn) {
    const lengthIndex = args.push("") - 1;
    fn(args);
    args[lengthIndex] = (args.length - lengthIndex - 1).toString();
    return args;
  };
  var pushSchema = function(args, schema) {
    for (const [field, fieldOptions] of Object.entries(schema)) {
      args.push(field);
      if (typeof fieldOptions === "string") {
        args.push(fieldOptions);
        continue;
      }
      if (fieldOptions.AS) {
        args.push("AS", fieldOptions.AS);
      }
      args.push(fieldOptions.type);
      switch (fieldOptions.type) {
        case SchemaFieldTypes.TEXT:
          if (fieldOptions.NOSTEM) {
            args.push("NOSTEM");
          }
          if (fieldOptions.WEIGHT) {
            args.push("WEIGHT", fieldOptions.WEIGHT.toString());
          }
          if (fieldOptions.PHONETIC) {
            args.push("PHONETIC", fieldOptions.PHONETIC);
          }
          if (fieldOptions.WITHSUFFIXTRIE) {
            args.push("WITHSUFFIXTRIE");
          }
          break;
        case SchemaFieldTypes.TAG:
          if (fieldOptions.SEPARATOR) {
            args.push("SEPARATOR", fieldOptions.SEPARATOR);
          }
          if (fieldOptions.CASESENSITIVE) {
            args.push("CASESENSITIVE");
          }
          if (fieldOptions.WITHSUFFIXTRIE) {
            args.push("WITHSUFFIXTRIE");
          }
          break;
        case SchemaFieldTypes.VECTOR:
          args.push(fieldOptions.ALGORITHM);
          pushArgumentsWithLength(args, () => {
            args.push("TYPE", fieldOptions.TYPE, "DIM", fieldOptions.DIM.toString(), "DISTANCE_METRIC", fieldOptions.DISTANCE_METRIC);
            if (fieldOptions.INITIAL_CAP) {
              args.push("INITIAL_CAP", fieldOptions.INITIAL_CAP.toString());
            }
            switch (fieldOptions.ALGORITHM) {
              case VectorAlgorithms.FLAT:
                if (fieldOptions.BLOCK_SIZE) {
                  args.push("BLOCK_SIZE", fieldOptions.BLOCK_SIZE.toString());
                }
                break;
              case VectorAlgorithms.HNSW:
                if (fieldOptions.M) {
                  args.push("M", fieldOptions.M.toString());
                }
                if (fieldOptions.EF_CONSTRUCTION) {
                  args.push("EF_CONSTRUCTION", fieldOptions.EF_CONSTRUCTION.toString());
                }
                if (fieldOptions.EF_RUNTIME) {
                  args.push("EF_RUNTIME", fieldOptions.EF_RUNTIME.toString());
                }
                break;
            }
          });
          continue;
      }
      if (fieldOptions.SORTABLE) {
        args.push("SORTABLE");
        if (fieldOptions.SORTABLE === "UNF") {
          args.push("UNF");
        }
      }
      if (fieldOptions.NOINDEX) {
        args.push("NOINDEX");
      }
    }
  };
  var pushParamsArgs = function(args, params) {
    if (params) {
      const enrties = Object.entries(params);
      args.push("PARAMS", (enrties.length * 2).toString());
      for (const [key, value] of enrties) {
        args.push(key, typeof value === "number" ? value.toString() : value);
      }
    }
    return args;
  };
  var pushSearchOptions = function(args, options) {
    if (options?.VERBATIM) {
      args.push("VERBATIM");
    }
    if (options?.NOSTOPWORDS) {
      args.push("NOSTOPWORDS");
    }
    (0, generic_transformers_1.pushOptionalVerdictArgument)(args, "INKEYS", options?.INKEYS);
    (0, generic_transformers_1.pushOptionalVerdictArgument)(args, "INFIELDS", options?.INFIELDS);
    (0, generic_transformers_1.pushOptionalVerdictArgument)(args, "RETURN", options?.RETURN);
    if (options?.SUMMARIZE) {
      args.push("SUMMARIZE");
      if (typeof options.SUMMARIZE === "object") {
        if (options.SUMMARIZE.FIELDS) {
          args.push("FIELDS");
          (0, generic_transformers_1.pushVerdictArgument)(args, options.SUMMARIZE.FIELDS);
        }
        if (options.SUMMARIZE.FRAGS) {
          args.push("FRAGS", options.SUMMARIZE.FRAGS.toString());
        }
        if (options.SUMMARIZE.LEN) {
          args.push("LEN", options.SUMMARIZE.LEN.toString());
        }
        if (options.SUMMARIZE.SEPARATOR) {
          args.push("SEPARATOR", options.SUMMARIZE.SEPARATOR);
        }
      }
    }
    if (options?.HIGHLIGHT) {
      args.push("HIGHLIGHT");
      if (typeof options.HIGHLIGHT === "object") {
        if (options.HIGHLIGHT.FIELDS) {
          args.push("FIELDS");
          (0, generic_transformers_1.pushVerdictArgument)(args, options.HIGHLIGHT.FIELDS);
        }
        if (options.HIGHLIGHT.TAGS) {
          args.push("TAGS", options.HIGHLIGHT.TAGS.open, options.HIGHLIGHT.TAGS.close);
        }
      }
    }
    if (options?.SLOP) {
      args.push("SLOP", options.SLOP.toString());
    }
    if (options?.INORDER) {
      args.push("INORDER");
    }
    if (options?.LANGUAGE) {
      args.push("LANGUAGE", options.LANGUAGE);
    }
    if (options?.EXPANDER) {
      args.push("EXPANDER", options.EXPANDER);
    }
    if (options?.SCORER) {
      args.push("SCORER", options.SCORER);
    }
    if (options?.SORTBY) {
      args.push("SORTBY");
      pushSortByProperty(args, options.SORTBY);
    }
    if (options?.LIMIT) {
      args.push("LIMIT", options.LIMIT.from.toString(), options.LIMIT.size.toString());
    }
    if (options?.PARAMS) {
      pushParamsArgs(args, options.PARAMS);
    }
    if (options?.DIALECT) {
      args.push("DIALECT", options.DIALECT.toString());
    }
    if (options?.RETURN?.length === 0) {
      args.preserve = true;
    }
    if (options?.TIMEOUT !== undefined) {
      args.push("TIMEOUT", options.TIMEOUT.toString());
    }
    return args;
  };
  var transformProfile = function(reply) {
    return {
      totalProfileTime: reply[0][1],
      parsingTime: reply[1][1],
      pipelineCreationTime: reply[2][1],
      iteratorsProfile: transformIterators(reply[3][1])
    };
  };
  var transformIterators = function(IteratorsProfile) {
    var res = {};
    for (let i = 0;i < IteratorsProfile.length; i += 2) {
      const value = IteratorsProfile[i + 1];
      switch (IteratorsProfile[i]) {
        case "Type":
          res.type = value;
          break;
        case "Counter":
          res.counter = value;
          break;
        case "Time":
          res.time = value;
          break;
        case "Query type":
          res.queryType = value;
          break;
        case "Child iterators":
          res.childIterators = value.map(transformChildIterators);
          break;
      }
    }
    return res;
  };
  var transformChildIterators = function(IteratorsProfile) {
    var res = {};
    for (let i = 1;i < IteratorsProfile.length; i += 2) {
      const value = IteratorsProfile[i + 1];
      switch (IteratorsProfile[i]) {
        case "Type":
          res.type = value;
          break;
        case "Counter":
          res.counter = value;
          break;
        case "Time":
          res.time = value;
          break;
        case "Size":
          res.size = value;
          break;
        case "Term":
          res.term = value;
          break;
        case "Child iterators":
          res.childIterators = value.map(transformChildIterators);
          break;
      }
    }
    return res;
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.transformProfile = exports.pushSearchOptions = exports.pushParamsArgs = exports.pushSchema = exports.VectorAlgorithms = exports.SchemaTextFieldPhonetics = exports.SchemaFieldTypes = exports.pushArgumentsWithLength = exports.pushSortByArguments = exports.pushSortByProperty = exports.RedisSearchLanguages = undefined;
  var _LIST = require__LIST();
  var ALTER = require_ALTER();
  var AGGREGATE_WITHCURSOR = require_AGGREGATE_WITHCURSOR();
  var AGGREGATE = require_AGGREGATE();
  var ALIASADD = require_ALIASADD();
  var ALIASDEL = require_ALIASDEL();
  var ALIASUPDATE = require_ALIASUPDATE();
  var CONFIG_GET = require_CONFIG_GET3();
  var CONFIG_SET = require_CONFIG_SET3();
  var CREATE = require_CREATE2();
  var CURSOR_DEL = require_CURSOR_DEL();
  var CURSOR_READ = require_CURSOR_READ();
  var DICTADD = require_DICTADD();
  var DICTDEL = require_DICTDEL();
  var DICTDUMP = require_DICTDUMP();
  var DROPINDEX = require_DROPINDEX();
  var EXPLAIN = require_EXPLAIN2();
  var EXPLAINCLI = require_EXPLAINCLI();
  var INFO = require_INFO7();
  var PROFILESEARCH = require_PROFILE_SEARCH();
  var PROFILEAGGREGATE = require_PROFILE_AGGREGATE();
  var SEARCH = require_SEARCH();
  var SPELLCHECK = require_SPELLCHECK();
  var SUGADD = require_SUGADD();
  var SUGDEL = require_SUGDEL();
  var SUGGET_WITHPAYLOADS = require_SUGGET_WITHPAYLOADS();
  var SUGGET_WITHSCORES_WITHPAYLOADS = require_SUGGET_WITHSCORES_WITHPAYLOADS();
  var SUGGET_WITHSCORES = require_SUGGET_WITHSCORES();
  var SUGGET = require_SUGGET();
  var SUGLEN = require_SUGLEN();
  var SYNDUMP = require_SYNDUMP();
  var SYNUPDATE = require_SYNUPDATE();
  var TAGVALS = require_TAGVALS();
  var generic_transformers_1 = require_generic_transformers();
  exports.default = {
    _LIST,
    _list: _LIST,
    ALTER,
    alter: ALTER,
    AGGREGATE_WITHCURSOR,
    aggregateWithCursor: AGGREGATE_WITHCURSOR,
    AGGREGATE,
    aggregate: AGGREGATE,
    ALIASADD,
    aliasAdd: ALIASADD,
    ALIASDEL,
    aliasDel: ALIASDEL,
    ALIASUPDATE,
    aliasUpdate: ALIASUPDATE,
    CONFIG_GET,
    configGet: CONFIG_GET,
    CONFIG_SET,
    configSet: CONFIG_SET,
    CREATE,
    create: CREATE,
    CURSOR_DEL,
    cursorDel: CURSOR_DEL,
    CURSOR_READ,
    cursorRead: CURSOR_READ,
    DICTADD,
    dictAdd: DICTADD,
    DICTDEL,
    dictDel: DICTDEL,
    DICTDUMP,
    dictDump: DICTDUMP,
    DROPINDEX,
    dropIndex: DROPINDEX,
    EXPLAIN,
    explain: EXPLAIN,
    EXPLAINCLI,
    explainCli: EXPLAINCLI,
    INFO,
    info: INFO,
    PROFILESEARCH,
    profileSearch: PROFILESEARCH,
    PROFILEAGGREGATE,
    profileAggregate: PROFILEAGGREGATE,
    SEARCH,
    search: SEARCH,
    SPELLCHECK,
    spellCheck: SPELLCHECK,
    SUGADD,
    sugAdd: SUGADD,
    SUGDEL,
    sugDel: SUGDEL,
    SUGGET_WITHPAYLOADS,
    sugGetWithPayloads: SUGGET_WITHPAYLOADS,
    SUGGET_WITHSCORES_WITHPAYLOADS,
    sugGetWithScoresWithPayloads: SUGGET_WITHSCORES_WITHPAYLOADS,
    SUGGET_WITHSCORES,
    sugGetWithScores: SUGGET_WITHSCORES,
    SUGGET,
    sugGet: SUGGET,
    SUGLEN,
    sugLen: SUGLEN,
    SYNDUMP,
    synDump: SYNDUMP,
    SYNUPDATE,
    synUpdate: SYNUPDATE,
    TAGVALS,
    tagVals: TAGVALS
  };
  var RedisSearchLanguages;
  (function(RedisSearchLanguages2) {
    RedisSearchLanguages2["ARABIC"] = "Arabic";
    RedisSearchLanguages2["BASQUE"] = "Basque";
    RedisSearchLanguages2["CATALANA"] = "Catalan";
    RedisSearchLanguages2["DANISH"] = "Danish";
    RedisSearchLanguages2["DUTCH"] = "Dutch";
    RedisSearchLanguages2["ENGLISH"] = "English";
    RedisSearchLanguages2["FINNISH"] = "Finnish";
    RedisSearchLanguages2["FRENCH"] = "French";
    RedisSearchLanguages2["GERMAN"] = "German";
    RedisSearchLanguages2["GREEK"] = "Greek";
    RedisSearchLanguages2["HUNGARIAN"] = "Hungarian";
    RedisSearchLanguages2["INDONESAIN"] = "Indonesian";
    RedisSearchLanguages2["IRISH"] = "Irish";
    RedisSearchLanguages2["ITALIAN"] = "Italian";
    RedisSearchLanguages2["LITHUANIAN"] = "Lithuanian";
    RedisSearchLanguages2["NEPALI"] = "Nepali";
    RedisSearchLanguages2["NORWEIGAN"] = "Norwegian";
    RedisSearchLanguages2["PORTUGUESE"] = "Portuguese";
    RedisSearchLanguages2["ROMANIAN"] = "Romanian";
    RedisSearchLanguages2["RUSSIAN"] = "Russian";
    RedisSearchLanguages2["SPANISH"] = "Spanish";
    RedisSearchLanguages2["SWEDISH"] = "Swedish";
    RedisSearchLanguages2["TAMIL"] = "Tamil";
    RedisSearchLanguages2["TURKISH"] = "Turkish";
    RedisSearchLanguages2["CHINESE"] = "Chinese";
  })(RedisSearchLanguages = exports.RedisSearchLanguages || (exports.RedisSearchLanguages = {}));
  exports.pushSortByProperty = pushSortByProperty;
  exports.pushSortByArguments = pushSortByArguments;
  exports.pushArgumentsWithLength = pushArgumentsWithLength;
  var SchemaFieldTypes;
  (function(SchemaFieldTypes2) {
    SchemaFieldTypes2["TEXT"] = "TEXT";
    SchemaFieldTypes2["NUMERIC"] = "NUMERIC";
    SchemaFieldTypes2["GEO"] = "GEO";
    SchemaFieldTypes2["TAG"] = "TAG";
    SchemaFieldTypes2["VECTOR"] = "VECTOR";
  })(SchemaFieldTypes = exports.SchemaFieldTypes || (exports.SchemaFieldTypes = {}));
  var SchemaTextFieldPhonetics;
  (function(SchemaTextFieldPhonetics2) {
    SchemaTextFieldPhonetics2["DM_EN"] = "dm:en";
    SchemaTextFieldPhonetics2["DM_FR"] = "dm:fr";
    SchemaTextFieldPhonetics2["FM_PT"] = "dm:pt";
    SchemaTextFieldPhonetics2["DM_ES"] = "dm:es";
  })(SchemaTextFieldPhonetics = exports.SchemaTextFieldPhonetics || (exports.SchemaTextFieldPhonetics = {}));
  var VectorAlgorithms;
  (function(VectorAlgorithms2) {
    VectorAlgorithms2["FLAT"] = "FLAT";
    VectorAlgorithms2["HNSW"] = "HNSW";
  })(VectorAlgorithms = exports.VectorAlgorithms || (exports.VectorAlgorithms = {}));
  exports.pushSchema = pushSchema;
  exports.pushParamsArgs = pushParamsArgs;
  exports.pushSearchOptions = pushSearchOptions;
  exports.transformProfile = transformProfile;
});

// node_modules/@redis/search/dist/index.js
var require_dist7 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.AggregateGroupByReducers = exports.AggregateSteps = exports.VectorAlgorithms = exports.SchemaTextFieldPhonetics = exports.SchemaFieldTypes = exports.default = undefined;
  var commands_1 = require_commands7();
  Object.defineProperty(exports, "default", { enumerable: true, get: function() {
    return commands_1.default;
  } });
  var commands_2 = require_commands7();
  Object.defineProperty(exports, "SchemaFieldTypes", { enumerable: true, get: function() {
    return commands_2.SchemaFieldTypes;
  } });
  Object.defineProperty(exports, "SchemaTextFieldPhonetics", { enumerable: true, get: function() {
    return commands_2.SchemaTextFieldPhonetics;
  } });
  Object.defineProperty(exports, "VectorAlgorithms", { enumerable: true, get: function() {
    return commands_2.VectorAlgorithms;
  } });
  var AGGREGATE_1 = require_AGGREGATE();
  Object.defineProperty(exports, "AggregateSteps", { enumerable: true, get: function() {
    return AGGREGATE_1.AggregateSteps;
  } });
  Object.defineProperty(exports, "AggregateGroupByReducers", { enumerable: true, get: function() {
    return AGGREGATE_1.AggregateGroupByReducers;
  } });
});

// node_modules/@redis/time-series/dist/commands/ADD.js
var require_ADD5 = __commonJS((exports) => {
  var transformArguments = function(key, timestamp, value, options) {
    const args = [
      "TS.ADD",
      key,
      (0, _1.transformTimestampArgument)(timestamp),
      value.toString()
    ];
    (0, _1.pushRetentionArgument)(args, options?.RETENTION);
    (0, _1.pushEncodingArgument)(args, options?.ENCODING);
    (0, _1.pushChunkSizeArgument)(args, options?.CHUNK_SIZE);
    if (options?.ON_DUPLICATE) {
      args.push("ON_DUPLICATE", options.ON_DUPLICATE);
    }
    (0, _1.pushLabelsArgument)(args, options?.LABELS);
    return args;
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.transformArguments = exports.FIRST_KEY_INDEX = undefined;
  var _1 = require_commands8();
  exports.FIRST_KEY_INDEX = 1;
  exports.transformArguments = transformArguments;
});

// node_modules/@redis/time-series/dist/commands/ALTER.js
var require_ALTER2 = __commonJS((exports) => {
  var transformArguments = function(key, options) {
    const args = ["TS.ALTER", key];
    (0, _1.pushRetentionArgument)(args, options?.RETENTION);
    (0, _1.pushChunkSizeArgument)(args, options?.CHUNK_SIZE);
    (0, _1.pushDuplicatePolicy)(args, options?.DUPLICATE_POLICY);
    (0, _1.pushLabelsArgument)(args, options?.LABELS);
    return args;
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.transformArguments = exports.FIRST_KEY_INDEX = undefined;
  var _1 = require_commands8();
  exports.FIRST_KEY_INDEX = 1;
  exports.transformArguments = transformArguments;
});

// node_modules/@redis/time-series/dist/commands/CREATE.js
var require_CREATE3 = __commonJS((exports) => {
  var transformArguments = function(key, options) {
    const args = ["TS.CREATE", key];
    (0, _1.pushRetentionArgument)(args, options?.RETENTION);
    (0, _1.pushEncodingArgument)(args, options?.ENCODING);
    (0, _1.pushChunkSizeArgument)(args, options?.CHUNK_SIZE);
    (0, _1.pushDuplicatePolicy)(args, options?.DUPLICATE_POLICY);
    (0, _1.pushLabelsArgument)(args, options?.LABELS);
    return args;
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.transformArguments = exports.FIRST_KEY_INDEX = undefined;
  var _1 = require_commands8();
  exports.FIRST_KEY_INDEX = 1;
  exports.transformArguments = transformArguments;
});

// node_modules/@redis/time-series/dist/commands/CREATERULE.js
var require_CREATERULE = __commonJS((exports) => {
  var transformArguments = function(sourceKey, destinationKey, aggregationType, bucketDuration, alignTimestamp) {
    const args = [
      "TS.CREATERULE",
      sourceKey,
      destinationKey,
      "AGGREGATION",
      aggregationType,
      bucketDuration.toString()
    ];
    if (alignTimestamp) {
      args.push(alignTimestamp.toString());
    }
    return args;
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.transformArguments = exports.FIRST_KEY_INDEX = undefined;
  exports.FIRST_KEY_INDEX = 1;
  exports.transformArguments = transformArguments;
});

// node_modules/@redis/time-series/dist/commands/DECRBY.js
var require_DECRBY2 = __commonJS((exports) => {
  var transformArguments = function(key, value, options) {
    return (0, _1.transformIncrDecrArguments)("TS.DECRBY", key, value, options);
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.transformArguments = exports.FIRST_KEY_INDEX = undefined;
  var _1 = require_commands8();
  exports.FIRST_KEY_INDEX = 1;
  exports.transformArguments = transformArguments;
});

// node_modules/@redis/time-series/dist/commands/DEL.js
var require_DEL4 = __commonJS((exports) => {
  var transformArguments = function(key, fromTimestamp, toTimestamp) {
    return [
      "TS.DEL",
      key,
      (0, _1.transformTimestampArgument)(fromTimestamp),
      (0, _1.transformTimestampArgument)(toTimestamp)
    ];
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.transformArguments = exports.FIRTS_KEY_INDEX = undefined;
  var _1 = require_commands8();
  exports.FIRTS_KEY_INDEX = 1;
  exports.transformArguments = transformArguments;
});

// node_modules/@redis/time-series/dist/commands/DELETERULE.js
var require_DELETERULE = __commonJS((exports) => {
  var transformArguments = function(sourceKey, destinationKey) {
    return [
      "TS.DELETERULE",
      sourceKey,
      destinationKey
    ];
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.transformArguments = exports.FIRST_KEY_INDEX = undefined;
  exports.FIRST_KEY_INDEX = 1;
  exports.transformArguments = transformArguments;
});

// node_modules/@redis/time-series/dist/commands/GET.js
var require_GET3 = __commonJS((exports) => {
  var transformArguments = function(key, options) {
    return (0, _1.pushLatestArgument)(["TS.GET", key], options?.LATEST);
  };
  var transformReply = function(reply) {
    if (reply.length === 0)
      return null;
    return (0, _1.transformSampleReply)(reply);
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.transformReply = exports.transformArguments = exports.IS_READ_ONLY = exports.FIRST_KEY_INDEX = undefined;
  var _1 = require_commands8();
  exports.FIRST_KEY_INDEX = 1;
  exports.IS_READ_ONLY = true;
  exports.transformArguments = transformArguments;
  exports.transformReply = transformReply;
});

// node_modules/@redis/time-series/dist/commands/INCRBY.js
var require_INCRBY4 = __commonJS((exports) => {
  var transformArguments = function(key, value, options) {
    return (0, _1.transformIncrDecrArguments)("TS.INCRBY", key, value, options);
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.transformArguments = exports.FIRST_KEY_INDEX = undefined;
  var _1 = require_commands8();
  exports.FIRST_KEY_INDEX = 1;
  exports.transformArguments = transformArguments;
});

// node_modules/@redis/time-series/dist/commands/INFO.js
var require_INFO8 = __commonJS((exports) => {
  var transformArguments = function(key) {
    return ["TS.INFO", key];
  };
  var transformReply = function(reply) {
    return {
      totalSamples: reply[1],
      memoryUsage: reply[3],
      firstTimestamp: reply[5],
      lastTimestamp: reply[7],
      retentionTime: reply[9],
      chunkCount: reply[11],
      chunkSize: reply[13],
      chunkType: reply[15],
      duplicatePolicy: reply[17],
      labels: reply[19].map(([name, value]) => ({
        name,
        value
      })),
      sourceKey: reply[21],
      rules: reply[23].map(([key, timeBucket, aggregationType]) => ({
        key,
        timeBucket,
        aggregationType
      }))
    };
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.transformReply = exports.transformArguments = exports.IS_READ_ONLY = exports.FIRST_KEY_INDEX = undefined;
  exports.FIRST_KEY_INDEX = 1;
  exports.IS_READ_ONLY = true;
  exports.transformArguments = transformArguments;
  exports.transformReply = transformReply;
});

// node_modules/@redis/time-series/dist/commands/INFO_DEBUG.js
var require_INFO_DEBUG = __commonJS((exports) => {
  var transformArguments = function(key) {
    const args = (0, INFO_1.transformArguments)(key);
    args.push("DEBUG");
    return args;
  };
  var transformReply = function(rawReply) {
    const reply = (0, INFO_1.transformReply)(rawReply);
    reply.keySelfName = rawReply[25];
    reply.chunks = rawReply[27].map((chunk) => ({
      startTimestamp: chunk[1],
      endTimestamp: chunk[3],
      samples: chunk[5],
      size: chunk[7],
      bytesPerSample: chunk[9]
    }));
    return reply;
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.transformReply = exports.transformArguments = exports.FIRST_KEY_INDEX = exports.IS_READ_ONLY = undefined;
  var INFO_1 = require_INFO8();
  var INFO_2 = require_INFO8();
  Object.defineProperty(exports, "IS_READ_ONLY", { enumerable: true, get: function() {
    return INFO_2.IS_READ_ONLY;
  } });
  Object.defineProperty(exports, "FIRST_KEY_INDEX", { enumerable: true, get: function() {
    return INFO_2.FIRST_KEY_INDEX;
  } });
  exports.transformArguments = transformArguments;
  exports.transformReply = transformReply;
});

// node_modules/@redis/time-series/dist/commands/MADD.js
var require_MADD2 = __commonJS((exports) => {
  var transformArguments = function(toAdd) {
    const args = ["TS.MADD"];
    for (const { key, timestamp, value } of toAdd) {
      args.push(key, (0, _1.transformTimestampArgument)(timestamp), value.toString());
    }
    return args;
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.transformArguments = exports.FIRST_KEY_INDEX = undefined;
  var _1 = require_commands8();
  exports.FIRST_KEY_INDEX = 1;
  exports.transformArguments = transformArguments;
});

// node_modules/@redis/time-series/dist/commands/MGET.js
var require_MGET3 = __commonJS((exports) => {
  var transformArguments = function(filter, options) {
    const args = (0, _1.pushLatestArgument)(["TS.MGET"], options?.LATEST);
    return (0, _1.pushFilterArgument)(args, filter);
  };
  var transformReply = function(reply) {
    return reply.map(([key, _, sample]) => ({
      key,
      sample: (0, _1.transformSampleReply)(sample)
    }));
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.transformReply = exports.transformArguments = exports.IS_READ_ONLY = undefined;
  var _1 = require_commands8();
  exports.IS_READ_ONLY = true;
  exports.transformArguments = transformArguments;
  exports.transformReply = transformReply;
});

// node_modules/@redis/time-series/dist/commands/MGET_WITHLABELS.js
var require_MGET_WITHLABELS = __commonJS((exports) => {
  var transformArguments = function(filter, options) {
    const args = (0, _1.pushWithLabelsArgument)(["TS.MGET"], options?.SELECTED_LABELS);
    return (0, _1.pushFilterArgument)(args, filter);
  };
  var transformReply = function(reply) {
    return reply.map(([key, labels, sample]) => ({
      key,
      labels: (0, _1.transformLablesReply)(labels),
      sample: (0, _1.transformSampleReply)(sample)
    }));
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.transformReply = exports.transformArguments = exports.IS_READ_ONLY = undefined;
  var _1 = require_commands8();
  exports.IS_READ_ONLY = true;
  exports.transformArguments = transformArguments;
  exports.transformReply = transformReply;
});

// node_modules/@redis/time-series/dist/commands/QUERYINDEX.js
var require_QUERYINDEX = __commonJS((exports) => {
  var transformArguments = function(filter) {
    return (0, generic_transformers_1.pushVerdictArguments)(["TS.QUERYINDEX"], filter);
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.transformArguments = exports.IS_READ_ONLY = undefined;
  var generic_transformers_1 = require_generic_transformers();
  exports.IS_READ_ONLY = true;
  exports.transformArguments = transformArguments;
});

// node_modules/@redis/time-series/dist/commands/RANGE.js
var require_RANGE = __commonJS((exports) => {
  var transformArguments = function(key, fromTimestamp, toTimestamp, options) {
    return (0, _1.pushRangeArguments)(["TS.RANGE", key], fromTimestamp, toTimestamp, options);
  };
  var transformReply = function(reply) {
    return (0, _1.transformRangeReply)(reply);
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.transformReply = exports.transformArguments = exports.IS_READ_ONLY = exports.FIRST_KEY_INDEX = undefined;
  var _1 = require_commands8();
  exports.FIRST_KEY_INDEX = 1;
  exports.IS_READ_ONLY = true;
  exports.transformArguments = transformArguments;
  exports.transformReply = transformReply;
});

// node_modules/@redis/time-series/dist/commands/REVRANGE.js
var require_REVRANGE = __commonJS((exports) => {
  var transformArguments = function(key, fromTimestamp, toTimestamp, options) {
    return (0, _1.pushRangeArguments)(["TS.REVRANGE", key], fromTimestamp, toTimestamp, options);
  };
  var transformReply = function(reply) {
    return (0, _1.transformRangeReply)(reply);
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.transformReply = exports.transformArguments = exports.IS_READ_ONLY = exports.FIRST_KEY_INDEX = undefined;
  var _1 = require_commands8();
  exports.FIRST_KEY_INDEX = 1;
  exports.IS_READ_ONLY = true;
  exports.transformArguments = transformArguments;
  exports.transformReply = transformReply;
});

// node_modules/@redis/time-series/dist/commands/MRANGE.js
var require_MRANGE = __commonJS((exports) => {
  var transformArguments = function(fromTimestamp, toTimestamp, filters, options) {
    return (0, _1.pushMRangeArguments)(["TS.MRANGE"], fromTimestamp, toTimestamp, filters, options);
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.transformReply = exports.transformArguments = exports.IS_READ_ONLY = undefined;
  var _1 = require_commands8();
  exports.IS_READ_ONLY = true;
  exports.transformArguments = transformArguments;
  var _2 = require_commands8();
  Object.defineProperty(exports, "transformReply", { enumerable: true, get: function() {
    return _2.transformMRangeReply;
  } });
});

// node_modules/@redis/time-series/dist/commands/MRANGE_WITHLABELS.js
var require_MRANGE_WITHLABELS = __commonJS((exports) => {
  var transformArguments = function(fromTimestamp, toTimestamp, filters, options) {
    return (0, _1.pushMRangeWithLabelsArguments)(["TS.MRANGE"], fromTimestamp, toTimestamp, filters, options);
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.transformReply = exports.transformArguments = exports.IS_READ_ONLY = undefined;
  var _1 = require_commands8();
  exports.IS_READ_ONLY = true;
  exports.transformArguments = transformArguments;
  var _2 = require_commands8();
  Object.defineProperty(exports, "transformReply", { enumerable: true, get: function() {
    return _2.transformMRangeWithLabelsReply;
  } });
});

// node_modules/@redis/time-series/dist/commands/MREVRANGE.js
var require_MREVRANGE = __commonJS((exports) => {
  var transformArguments = function(fromTimestamp, toTimestamp, filters, options) {
    return (0, _1.pushMRangeArguments)(["TS.MREVRANGE"], fromTimestamp, toTimestamp, filters, options);
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.transformReply = exports.transformArguments = exports.IS_READ_ONLY = undefined;
  var _1 = require_commands8();
  exports.IS_READ_ONLY = true;
  exports.transformArguments = transformArguments;
  var _2 = require_commands8();
  Object.defineProperty(exports, "transformReply", { enumerable: true, get: function() {
    return _2.transformMRangeReply;
  } });
});

// node_modules/@redis/time-series/dist/commands/MREVRANGE_WITHLABELS.js
var require_MREVRANGE_WITHLABELS = __commonJS((exports) => {
  var transformArguments = function(fromTimestamp, toTimestamp, filters, options) {
    return (0, _1.pushMRangeWithLabelsArguments)(["TS.MREVRANGE"], fromTimestamp, toTimestamp, filters, options);
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.transformReply = exports.transformArguments = exports.IS_READ_ONLY = undefined;
  var _1 = require_commands8();
  exports.IS_READ_ONLY = true;
  exports.transformArguments = transformArguments;
  var _2 = require_commands8();
  Object.defineProperty(exports, "transformReply", { enumerable: true, get: function() {
    return _2.transformMRangeWithLabelsReply;
  } });
});

// node_modules/@redis/time-series/dist/commands/index.js
var require_commands8 = __commonJS((exports) => {
  var transformTimestampArgument = function(timestamp) {
    if (typeof timestamp === "string")
      return timestamp;
    return (typeof timestamp === "number" ? timestamp : timestamp.getTime()).toString();
  };
  var pushRetentionArgument = function(args, retention) {
    if (retention !== undefined) {
      args.push("RETENTION", retention.toString());
    }
    return args;
  };
  var pushEncodingArgument = function(args, encoding) {
    if (encoding !== undefined) {
      args.push("ENCODING", encoding);
    }
    return args;
  };
  var pushChunkSizeArgument = function(args, chunkSize) {
    if (chunkSize !== undefined) {
      args.push("CHUNK_SIZE", chunkSize.toString());
    }
    return args;
  };
  var pushDuplicatePolicy = function(args, duplicatePolicy) {
    if (duplicatePolicy !== undefined) {
      args.push("DUPLICATE_POLICY", duplicatePolicy);
    }
    return args;
  };
  var transformLablesReply = function(reply) {
    const labels = {};
    for (const [key, value] of reply) {
      labels[key] = value;
    }
    return labels;
  };
  var pushLabelsArgument = function(args, labels) {
    if (labels) {
      args.push("LABELS");
      for (const [label, value] of Object.entries(labels)) {
        args.push(label, value);
      }
    }
    return args;
  };
  var transformIncrDecrArguments = function(command, key, value, options) {
    const args = [
      command,
      key,
      value.toString()
    ];
    if (options?.TIMESTAMP !== undefined && options?.TIMESTAMP !== null) {
      args.push("TIMESTAMP", transformTimestampArgument(options.TIMESTAMP));
    }
    pushRetentionArgument(args, options?.RETENTION);
    if (options?.UNCOMPRESSED) {
      args.push("UNCOMPRESSED");
    }
    pushChunkSizeArgument(args, options?.CHUNK_SIZE);
    pushLabelsArgument(args, options?.LABELS);
    return args;
  };
  var transformSampleReply = function(reply) {
    return {
      timestamp: reply[0],
      value: Number(reply[1])
    };
  };
  var pushRangeArguments = function(args, fromTimestamp, toTimestamp, options) {
    args.push(transformTimestampArgument(fromTimestamp), transformTimestampArgument(toTimestamp));
    pushLatestArgument(args, options?.LATEST);
    if (options?.FILTER_BY_TS) {
      args.push("FILTER_BY_TS");
      for (const ts of options.FILTER_BY_TS) {
        args.push(transformTimestampArgument(ts));
      }
    }
    if (options?.FILTER_BY_VALUE) {
      args.push("FILTER_BY_VALUE", options.FILTER_BY_VALUE.min.toString(), options.FILTER_BY_VALUE.max.toString());
    }
    if (options?.COUNT) {
      args.push("COUNT", options.COUNT.toString());
    }
    if (options?.ALIGN) {
      args.push("ALIGN", transformTimestampArgument(options.ALIGN));
    }
    if (options?.AGGREGATION) {
      args.push("AGGREGATION", options.AGGREGATION.type, transformTimestampArgument(options.AGGREGATION.timeBucket));
      if (options.AGGREGATION.BUCKETTIMESTAMP) {
        args.push("BUCKETTIMESTAMP", options.AGGREGATION.BUCKETTIMESTAMP);
      }
      if (options.AGGREGATION.EMPTY) {
        args.push("EMPTY");
      }
    }
    return args;
  };
  var pushMRangeGroupByArguments = function(args, groupBy) {
    if (groupBy) {
      args.push("GROUPBY", groupBy.label, "REDUCE", groupBy.reducer);
    }
    return args;
  };
  var pushFilterArgument = function(args, filter) {
    args.push("FILTER");
    return (0, generic_transformers_1.pushVerdictArguments)(args, filter);
  };
  var pushMRangeArguments = function(args, fromTimestamp, toTimestamp, filter, options) {
    args = pushRangeArguments(args, fromTimestamp, toTimestamp, options);
    args = pushFilterArgument(args, filter);
    return pushMRangeGroupByArguments(args, options?.GROUPBY);
  };
  var pushWithLabelsArgument = function(args, selectedLabels) {
    if (!selectedLabels) {
      args.push("WITHLABELS");
    } else {
      args.push("SELECTED_LABELS");
      args = (0, generic_transformers_1.pushVerdictArguments)(args, selectedLabels);
    }
    return args;
  };
  var pushMRangeWithLabelsArguments = function(args, fromTimestamp, toTimestamp, filter, options) {
    args = pushRangeArguments(args, fromTimestamp, toTimestamp, options);
    args = pushWithLabelsArgument(args, options?.SELECTED_LABELS);
    args = pushFilterArgument(args, filter);
    return pushMRangeGroupByArguments(args, options?.GROUPBY);
  };
  var transformRangeReply = function(reply) {
    return reply.map(transformSampleReply);
  };
  var transformMRangeReply = function(reply) {
    const args = [];
    for (const [key, _, sample] of reply) {
      args.push({
        key,
        samples: sample.map(transformSampleReply)
      });
    }
    return args;
  };
  var transformMRangeWithLabelsReply = function(reply) {
    const args = [];
    for (const [key, labels, samples] of reply) {
      args.push({
        key,
        labels: transformLablesReply(labels),
        samples: samples.map(transformSampleReply)
      });
    }
    return args;
  };
  var pushLatestArgument = function(args, latest) {
    if (latest) {
      args.push("LATEST");
    }
    return args;
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.pushLatestArgument = exports.transformMRangeWithLabelsReply = exports.transformMRangeReply = exports.transformRangeReply = exports.pushMRangeWithLabelsArguments = exports.pushWithLabelsArgument = exports.pushMRangeArguments = exports.pushFilterArgument = exports.pushMRangeGroupByArguments = exports.pushRangeArguments = exports.TimeSeriesBucketTimestamp = exports.transformSampleReply = exports.transformIncrDecrArguments = exports.pushLabelsArgument = exports.transformLablesReply = exports.pushDuplicatePolicy = exports.pushChunkSizeArgument = exports.pushEncodingArgument = exports.TimeSeriesEncoding = exports.pushRetentionArgument = exports.transformTimestampArgument = exports.TimeSeriesReducers = exports.TimeSeriesDuplicatePolicies = exports.TimeSeriesAggregationType = undefined;
  var ADD = require_ADD5();
  var ALTER = require_ALTER2();
  var CREATE = require_CREATE3();
  var CREATERULE = require_CREATERULE();
  var DECRBY = require_DECRBY2();
  var DEL = require_DEL4();
  var DELETERULE = require_DELETERULE();
  var GET = require_GET3();
  var INCRBY = require_INCRBY4();
  var INFO_DEBUG = require_INFO_DEBUG();
  var INFO = require_INFO8();
  var MADD = require_MADD2();
  var MGET = require_MGET3();
  var MGET_WITHLABELS = require_MGET_WITHLABELS();
  var QUERYINDEX = require_QUERYINDEX();
  var RANGE = require_RANGE();
  var REVRANGE = require_REVRANGE();
  var MRANGE = require_MRANGE();
  var MRANGE_WITHLABELS = require_MRANGE_WITHLABELS();
  var MREVRANGE = require_MREVRANGE();
  var MREVRANGE_WITHLABELS = require_MREVRANGE_WITHLABELS();
  var generic_transformers_1 = require_generic_transformers();
  exports.default = {
    ADD,
    add: ADD,
    ALTER,
    alter: ALTER,
    CREATE,
    create: CREATE,
    CREATERULE,
    createRule: CREATERULE,
    DECRBY,
    decrBy: DECRBY,
    DEL,
    del: DEL,
    DELETERULE,
    deleteRule: DELETERULE,
    GET,
    get: GET,
    INCRBY,
    incrBy: INCRBY,
    INFO_DEBUG,
    infoDebug: INFO_DEBUG,
    INFO,
    info: INFO,
    MADD,
    mAdd: MADD,
    MGET,
    mGet: MGET,
    MGET_WITHLABELS,
    mGetWithLabels: MGET_WITHLABELS,
    QUERYINDEX,
    queryIndex: QUERYINDEX,
    RANGE,
    range: RANGE,
    REVRANGE,
    revRange: REVRANGE,
    MRANGE,
    mRange: MRANGE,
    MRANGE_WITHLABELS,
    mRangeWithLabels: MRANGE_WITHLABELS,
    MREVRANGE,
    mRevRange: MREVRANGE,
    MREVRANGE_WITHLABELS,
    mRevRangeWithLabels: MREVRANGE_WITHLABELS
  };
  var TimeSeriesAggregationType;
  (function(TimeSeriesAggregationType2) {
    TimeSeriesAggregationType2["AVG"] = "AVG";
    TimeSeriesAggregationType2["AVERAGE"] = "AVG";
    TimeSeriesAggregationType2["FIRST"] = "FIRST";
    TimeSeriesAggregationType2["LAST"] = "LAST";
    TimeSeriesAggregationType2["MIN"] = "MIN";
    TimeSeriesAggregationType2["MINIMUM"] = "MIN";
    TimeSeriesAggregationType2["MAX"] = "MAX";
    TimeSeriesAggregationType2["MAXIMUM"] = "MAX";
    TimeSeriesAggregationType2["SUM"] = "SUM";
    TimeSeriesAggregationType2["RANGE"] = "RANGE";
    TimeSeriesAggregationType2["COUNT"] = "COUNT";
    TimeSeriesAggregationType2["STD_P"] = "STD.P";
    TimeSeriesAggregationType2["STD_S"] = "STD.S";
    TimeSeriesAggregationType2["VAR_P"] = "VAR.P";
    TimeSeriesAggregationType2["VAR_S"] = "VAR.S";
    TimeSeriesAggregationType2["TWA"] = "TWA";
  })(TimeSeriesAggregationType || (exports.TimeSeriesAggregationType = TimeSeriesAggregationType = {}));
  var TimeSeriesDuplicatePolicies;
  (function(TimeSeriesDuplicatePolicies2) {
    TimeSeriesDuplicatePolicies2["BLOCK"] = "BLOCK";
    TimeSeriesDuplicatePolicies2["FIRST"] = "FIRST";
    TimeSeriesDuplicatePolicies2["LAST"] = "LAST";
    TimeSeriesDuplicatePolicies2["MIN"] = "MIN";
    TimeSeriesDuplicatePolicies2["MAX"] = "MAX";
    TimeSeriesDuplicatePolicies2["SUM"] = "SUM";
  })(TimeSeriesDuplicatePolicies || (exports.TimeSeriesDuplicatePolicies = TimeSeriesDuplicatePolicies = {}));
  var TimeSeriesReducers;
  (function(TimeSeriesReducers2) {
    TimeSeriesReducers2["AVG"] = "AVG";
    TimeSeriesReducers2["SUM"] = "SUM";
    TimeSeriesReducers2["MIN"] = "MIN";
    TimeSeriesReducers2["MINIMUM"] = "MIN";
    TimeSeriesReducers2["MAX"] = "MAX";
    TimeSeriesReducers2["MAXIMUM"] = "MAX";
    TimeSeriesReducers2["RANGE"] = "range";
    TimeSeriesReducers2["COUNT"] = "COUNT";
    TimeSeriesReducers2["STD_P"] = "STD.P";
    TimeSeriesReducers2["STD_S"] = "STD.S";
    TimeSeriesReducers2["VAR_P"] = "VAR.P";
    TimeSeriesReducers2["VAR_S"] = "VAR.S";
  })(TimeSeriesReducers || (exports.TimeSeriesReducers = TimeSeriesReducers = {}));
  exports.transformTimestampArgument = transformTimestampArgument;
  exports.pushRetentionArgument = pushRetentionArgument;
  var TimeSeriesEncoding;
  (function(TimeSeriesEncoding2) {
    TimeSeriesEncoding2["COMPRESSED"] = "COMPRESSED";
    TimeSeriesEncoding2["UNCOMPRESSED"] = "UNCOMPRESSED";
  })(TimeSeriesEncoding || (exports.TimeSeriesEncoding = TimeSeriesEncoding = {}));
  exports.pushEncodingArgument = pushEncodingArgument;
  exports.pushChunkSizeArgument = pushChunkSizeArgument;
  exports.pushDuplicatePolicy = pushDuplicatePolicy;
  exports.transformLablesReply = transformLablesReply;
  exports.pushLabelsArgument = pushLabelsArgument;
  exports.transformIncrDecrArguments = transformIncrDecrArguments;
  exports.transformSampleReply = transformSampleReply;
  var TimeSeriesBucketTimestamp;
  (function(TimeSeriesBucketTimestamp2) {
    TimeSeriesBucketTimestamp2["LOW"] = "-";
    TimeSeriesBucketTimestamp2["HIGH"] = "+";
    TimeSeriesBucketTimestamp2["MID"] = "~";
  })(TimeSeriesBucketTimestamp || (exports.TimeSeriesBucketTimestamp = TimeSeriesBucketTimestamp = {}));
  exports.pushRangeArguments = pushRangeArguments;
  exports.pushMRangeGroupByArguments = pushMRangeGroupByArguments;
  exports.pushFilterArgument = pushFilterArgument;
  exports.pushMRangeArguments = pushMRangeArguments;
  exports.pushWithLabelsArgument = pushWithLabelsArgument;
  exports.pushMRangeWithLabelsArguments = pushMRangeWithLabelsArguments;
  exports.transformRangeReply = transformRangeReply;
  exports.transformMRangeReply = transformMRangeReply;
  exports.transformMRangeWithLabelsReply = transformMRangeWithLabelsReply;
  exports.pushLatestArgument = pushLatestArgument;
});

// node_modules/@redis/time-series/dist/index.js
var require_dist8 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.TimeSeriesBucketTimestamp = exports.TimeSeriesReducers = exports.TimeSeriesAggregationType = exports.TimeSeriesEncoding = exports.TimeSeriesDuplicatePolicies = exports.default = undefined;
  var commands_1 = require_commands8();
  Object.defineProperty(exports, "default", { enumerable: true, get: function() {
    return commands_1.default;
  } });
  var commands_2 = require_commands8();
  Object.defineProperty(exports, "TimeSeriesDuplicatePolicies", { enumerable: true, get: function() {
    return commands_2.TimeSeriesDuplicatePolicies;
  } });
  Object.defineProperty(exports, "TimeSeriesEncoding", { enumerable: true, get: function() {
    return commands_2.TimeSeriesEncoding;
  } });
  Object.defineProperty(exports, "TimeSeriesAggregationType", { enumerable: true, get: function() {
    return commands_2.TimeSeriesAggregationType;
  } });
  Object.defineProperty(exports, "TimeSeriesReducers", { enumerable: true, get: function() {
    return commands_2.TimeSeriesReducers;
  } });
  Object.defineProperty(exports, "TimeSeriesBucketTimestamp", { enumerable: true, get: function() {
    return commands_2.TimeSeriesBucketTimestamp;
  } });
});

// node_modules/redis/dist/index.js
var require_dist9 = __commonJS((exports) => {
  var createClient = function(options) {
    return (0, client_1.createClient)({
      ...options,
      modules: {
        ...modules,
        ...options?.modules
      }
    });
  };
  var createCluster = function(options) {
    return (0, client_1.createCluster)({
      ...options,
      modules: {
        ...modules,
        ...options?.modules
      }
    });
  };
  var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
    if (k2 === undefined)
      k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() {
        return m[k];
      } };
    }
    Object.defineProperty(o, k2, desc);
  } : function(o, m, k, k2) {
    if (k2 === undefined)
      k2 = k;
    o[k2] = m[k];
  });
  var __exportStar = exports && exports.__exportStar || function(m, exports2) {
    for (var p in m)
      if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports2, p))
        __createBinding(exports2, m, p);
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.createCluster = exports.createClient = undefined;
  var client_1 = require_dist3();
  var bloom_1 = require_dist4();
  var graph_1 = require_dist5();
  var json_1 = require_dist6();
  var search_1 = require_dist7();
  var time_series_1 = require_dist8();
  __exportStar(require_dist3(), exports);
  __exportStar(require_dist4(), exports);
  __exportStar(require_dist5(), exports);
  __exportStar(require_dist6(), exports);
  __exportStar(require_dist7(), exports);
  __exportStar(require_dist8(), exports);
  var modules = {
    ...bloom_1.default,
    graph: graph_1.default,
    json: json_1.default,
    ft: search_1.default,
    ts: time_series_1.default
  };
  exports.createClient = createClient;
  exports.createCluster = createCluster;
});

// node_modules/hono/dist/types.js
var FetchEventLike = class {
};

// node_modules/hono/dist/utils/url.js
var splitPath = (path) => {
  const paths = path.split("/");
  if (paths[0] === "") {
    paths.shift();
  }
  return paths;
};
var splitRoutingPath = (path) => {
  const groups = [];
  for (let i = 0;; ) {
    let replaced = false;
    path = path.replace(/\{[^}]+\}/g, (m) => {
      const mark = `@\\${i}`;
      groups[i] = [mark, m];
      i++;
      replaced = true;
      return mark;
    });
    if (!replaced) {
      break;
    }
  }
  const paths = path.split("/");
  if (paths[0] === "") {
    paths.shift();
  }
  for (let i = groups.length - 1;i >= 0; i--) {
    const [mark] = groups[i];
    for (let j = paths.length - 1;j >= 0; j--) {
      if (paths[j].indexOf(mark) !== -1) {
        paths[j] = paths[j].replace(mark, groups[i][1]);
        break;
      }
    }
  }
  return paths;
};
var patternCache = {};
var getPattern = (label) => {
  if (label === "*") {
    return "*";
  }
  const match = label.match(/^\:([^\{\}]+)(?:\{(.+)\})?$/);
  if (match) {
    if (!patternCache[label]) {
      if (match[2]) {
        patternCache[label] = [label, match[1], new RegExp("^" + match[2] + "$")];
      } else {
        patternCache[label] = [label, match[1], true];
      }
    }
    return patternCache[label];
  }
  return null;
};
var getPath = (request) => {
  const match = request.url.match(/^https?:\/\/[^/]+(\/[^?]*)/);
  return match ? match[1] : "";
};
var getQueryStrings = (url) => {
  const queryIndex = url.indexOf("?", 8);
  return queryIndex === -1 ? "" : "?" + url.slice(queryIndex + 1);
};
var getPathNoStrict = (request) => {
  const result = getPath(request);
  return result.length > 1 && result[result.length - 1] === "/" ? result.slice(0, -1) : result;
};
var mergePath = (...paths) => {
  let p = "";
  let endsWithSlash = false;
  for (let path of paths) {
    if (p[p.length - 1] === "/") {
      p = p.slice(0, -1);
      endsWithSlash = true;
    }
    if (path[0] !== "/") {
      path = `/${path}`;
    }
    if (path === "/" && endsWithSlash) {
      p = `${p}/`;
    } else if (path !== "/") {
      p = `${p}${path}`;
    }
    if (path === "/" && p === "") {
      p = "/";
    }
  }
  return p;
};
var checkOptionalParameter = (path) => {
  const match = path.match(/^(.+|)(\/\:[^\/]+)\?$/);
  if (!match)
    return null;
  const base = match[1];
  const optional = base + match[2];
  return [base === "" ? "/" : base.replace(/\/$/, ""), optional];
};
var _decodeURI = (value) => {
  if (!/[%+]/.test(value)) {
    return value;
  }
  if (value.indexOf("+") !== -1) {
    value = value.replace(/\+/g, " ");
  }
  return /%/.test(value) ? decodeURIComponent_(value) : value;
};
var _getQueryParam = (url, key, multiple) => {
  let encoded;
  if (!multiple && key && !/[%+]/.test(key)) {
    let keyIndex2 = url.indexOf(`?${key}`, 8);
    if (keyIndex2 === -1) {
      keyIndex2 = url.indexOf(`&${key}`, 8);
    }
    while (keyIndex2 !== -1) {
      const trailingKeyCode = url.charCodeAt(keyIndex2 + key.length + 1);
      if (trailingKeyCode === 61) {
        const valueIndex = keyIndex2 + key.length + 2;
        const endIndex = url.indexOf("&", valueIndex);
        return _decodeURI(url.slice(valueIndex, endIndex === -1 ? undefined : endIndex));
      } else if (trailingKeyCode == 38 || isNaN(trailingKeyCode)) {
        return "";
      }
      keyIndex2 = url.indexOf(`&${key}`, keyIndex2 + 1);
    }
    encoded = /[%+]/.test(url);
    if (!encoded) {
      return;
    }
  }
  const results = {};
  encoded ?? (encoded = /[%+]/.test(url));
  let keyIndex = url.indexOf("?", 8);
  while (keyIndex !== -1) {
    const nextKeyIndex = url.indexOf("&", keyIndex + 1);
    let valueIndex = url.indexOf("=", keyIndex);
    if (valueIndex > nextKeyIndex && nextKeyIndex !== -1) {
      valueIndex = -1;
    }
    let name = url.slice(keyIndex + 1, valueIndex === -1 ? nextKeyIndex === -1 ? undefined : nextKeyIndex : valueIndex);
    if (encoded) {
      name = _decodeURI(name);
    }
    keyIndex = nextKeyIndex;
    if (name === "") {
      continue;
    }
    let value;
    if (valueIndex === -1) {
      value = "";
    } else {
      value = url.slice(valueIndex + 1, nextKeyIndex === -1 ? undefined : nextKeyIndex);
      if (encoded) {
        value = _decodeURI(value);
      }
    }
    if (multiple) {
      (results[name] ?? (results[name] = [])).push(value);
    } else {
      results[name] ?? (results[name] = value);
    }
  }
  return key ? results[key] : results;
};
var getQueryParam = _getQueryParam;
var getQueryParams = (url, key) => {
  return _getQueryParam(url, key, true);
};
var decodeURIComponent_ = decodeURIComponent;

// node_modules/hono/dist/utils/cookie.js
var validCookieNameRegEx = /^[\w!#$%&'*.^`|~+-]+$/;
var validCookieValueRegEx = /^[ !#-:<-[\]-~]*$/;
var parse = (cookie, name) => {
  const pairs = cookie.trim().split(";");
  return pairs.reduce((parsedCookie, pairStr) => {
    pairStr = pairStr.trim();
    const valueStartPos = pairStr.indexOf("=");
    if (valueStartPos === -1)
      return parsedCookie;
    const cookieName = pairStr.substring(0, valueStartPos).trim();
    if (name && name !== cookieName || !validCookieNameRegEx.test(cookieName))
      return parsedCookie;
    let cookieValue = pairStr.substring(valueStartPos + 1).trim();
    if (cookieValue.startsWith('"') && cookieValue.endsWith('"'))
      cookieValue = cookieValue.slice(1, -1);
    if (validCookieValueRegEx.test(cookieValue))
      parsedCookie[cookieName] = decodeURIComponent_(cookieValue);
    return parsedCookie;
  }, {});
};
var _serialize = (name, value, opt = {}) => {
  let cookie = `${name}=${value}`;
  if (opt && typeof opt.maxAge === "number" && opt.maxAge >= 0) {
    cookie += `; Max-Age=${Math.floor(opt.maxAge)}`;
  }
  if (opt.domain) {
    cookie += "; Domain=" + opt.domain;
  }
  if (opt.path) {
    cookie += "; Path=" + opt.path;
  }
  if (opt.expires) {
    cookie += "; Expires=" + opt.expires.toUTCString();
  }
  if (opt.httpOnly) {
    cookie += "; HttpOnly";
  }
  if (opt.secure) {
    cookie += "; Secure";
  }
  if (opt.sameSite) {
    cookie += `; SameSite=${opt.sameSite}`;
  }
  return cookie;
};
var serialize = (name, value, opt = {}) => {
  value = encodeURIComponent(value);
  return _serialize(name, value, opt);
};

// node_modules/hono/dist/context.js
var Context = class {
  constructor(req, options) {
    this.env = {};
    this._var = {};
    this.finalized = false;
    this.error = undefined;
    this._status = 200;
    this._h = undefined;
    this._pH = undefined;
    this._init = true;
    this._renderer = (content) => this.html(content);
    this.notFoundHandler = () => new Response;
    this.render = (...args) => this._renderer(...args);
    this.setRenderer = (renderer) => {
      this._renderer = renderer;
    };
    this.header = (name, value, options2) => {
      if (value === undefined) {
        if (this._h) {
          this._h.delete(name);
        } else if (this._pH) {
          delete this._pH[name.toLocaleLowerCase()];
        }
        if (this.finalized) {
          this.res.headers.delete(name);
        }
        return;
      }
      if (options2?.append) {
        if (!this._h) {
          this._init = false;
          this._h = new Headers(this._pH);
          this._pH = {};
        }
        this._h.append(name, value);
      } else {
        if (this._h) {
          this._h.set(name, value);
        } else {
          this._pH ?? (this._pH = {});
          this._pH[name.toLowerCase()] = value;
        }
      }
      if (this.finalized) {
        if (options2?.append) {
          this.res.headers.append(name, value);
        } else {
          this.res.headers.set(name, value);
        }
      }
    };
    this.status = (status) => {
      this._status = status;
    };
    this.set = (key, value) => {
      this._var ?? (this._var = {});
      this._var[key] = value;
    };
    this.get = (key) => {
      return this._var ? this._var[key] : undefined;
    };
    this.newResponse = (data, arg, headers) => {
      if (this._init && !headers && !arg && this._status === 200) {
        return new Response(data, {
          headers: this._pH
        });
      }
      if (arg && typeof arg !== "number") {
        const res = new Response(data, arg);
        const contentType = this._pH?.["content-type"];
        if (contentType) {
          res.headers.set("content-type", contentType);
        }
        return res;
      }
      const status = arg ?? this._status;
      this._pH ?? (this._pH = {});
      this._h ?? (this._h = new Headers);
      for (const [k, v] of Object.entries(this._pH)) {
        this._h.set(k, v);
      }
      if (this._res) {
        this._res.headers.forEach((v, k) => {
          this._h?.set(k, v);
        });
        for (const [k, v] of Object.entries(this._pH)) {
          this._h.set(k, v);
        }
      }
      headers ?? (headers = {});
      for (const [k, v] of Object.entries(headers)) {
        if (typeof v === "string") {
          this._h.set(k, v);
        } else {
          this._h.delete(k);
          for (const v2 of v) {
            this._h.append(k, v2);
          }
        }
      }
      return new Response(data, {
        status,
        headers: this._h
      });
    };
    this.body = (data, arg, headers) => {
      return typeof arg === "number" ? this.newResponse(data, arg, headers) : this.newResponse(data, arg);
    };
    this.text = (text, arg, headers) => {
      if (!this._pH) {
        if (this._init && !headers && !arg) {
          return new Response(text);
        }
        this._pH = {};
      }
      if (this._pH["content-type"]) {
        this._pH["content-type"] = "text/plain; charset=UTF-8";
      }
      return typeof arg === "number" ? this.newResponse(text, arg, headers) : this.newResponse(text, arg);
    };
    this.json = (object, arg, headers) => {
      const body = JSON.stringify(object);
      this._pH ?? (this._pH = {});
      this._pH["content-type"] = "application/json; charset=UTF-8";
      return typeof arg === "number" ? this.newResponse(body, arg, headers) : this.newResponse(body, arg);
    };
    this.jsonT = (object, arg, headers) => {
      const response = typeof arg === "number" ? this.json(object, arg, headers) : this.json(object, arg);
      return {
        response,
        data: object,
        format: "json",
        status: response.status
      };
    };
    this.html = (html, arg, headers) => {
      this._pH ?? (this._pH = {});
      this._pH["content-type"] = "text/html; charset=UTF-8";
      return typeof arg === "number" ? this.newResponse(html, arg, headers) : this.newResponse(html, arg);
    };
    this.redirect = (location, status = 302) => {
      this._h ?? (this._h = new Headers);
      this._h.set("Location", location);
      return this.newResponse(null, status);
    };
    this.cookie = (name, value, opt) => {
      const cookie2 = serialize(name, value, opt);
      this.header("set-cookie", cookie2, { append: true });
    };
    this.notFound = () => {
      return this.notFoundHandler(this);
    };
    this.req = req;
    if (options) {
      this._exCtx = options.executionCtx;
      this.env = options.env;
      if (options.notFoundHandler) {
        this.notFoundHandler = options.notFoundHandler;
      }
    }
  }
  get event() {
    if (this._exCtx instanceof FetchEventLike) {
      return this._exCtx;
    } else {
      throw Error("This context has no FetchEvent");
    }
  }
  get executionCtx() {
    if (this._exCtx) {
      return this._exCtx;
    } else {
      throw Error("This context has no ExecutionContext");
    }
  }
  get res() {
    this._init = false;
    return this._res || (this._res = new Response("404 Not Found", { status: 404 }));
  }
  set res(_res) {
    this._init = false;
    if (this._res && _res) {
      this._res.headers.delete("content-type");
      this._res.headers.forEach((v, k) => {
        _res.headers.set(k, v);
      });
    }
    this._res = _res;
    this.finalized = true;
  }
  get var() {
    return { ...this._var };
  }
  get runtime() {
    const global2 = globalThis;
    if (global2?.Deno !== undefined) {
      return "deno";
    }
    if (global2?.Bun !== undefined) {
      return "bun";
    }
    if (typeof global2?.WebSocketPair === "function") {
      return "workerd";
    }
    if (typeof global2?.EdgeRuntime === "string") {
      return "edge-light";
    }
    if (global2?.fastly !== undefined) {
      return "fastly";
    }
    if (global2?.__lagon__ !== undefined) {
      return "lagon";
    }
    if (global2?.process?.release?.name === "node") {
      return "node";
    }
    return "other";
  }
};

// node_modules/hono/dist/compose.js
var compose = (middleware, onError, onNotFound) => {
  const middlewareLength = middleware.length;
  return (context2, next) => {
    let index = -1;
    return dispatch(0);
    function dispatch(i) {
      if (i <= index) {
        throw new Error("next() called multiple times");
      }
      let handler = middleware[i];
      index = i;
      if (i === middlewareLength && next)
        handler = next;
      let res;
      let isError = false;
      if (!handler) {
        if (context2 instanceof Context && context2.finalized === false && onNotFound) {
          res = onNotFound(context2);
        }
      } else {
        try {
          res = handler(context2, () => {
            const dispatchRes = dispatch(i + 1);
            return dispatchRes instanceof Promise ? dispatchRes : Promise.resolve(dispatchRes);
          });
        } catch (err) {
          if (err instanceof Error && context2 instanceof Context && onError) {
            context2.error = err;
            res = onError(err, context2);
            isError = true;
          } else {
            throw err;
          }
        }
      }
      if (!(res instanceof Promise)) {
        if (res !== undefined && ("response" in res)) {
          res = res["response"];
        }
        if (res && (context2.finalized === false || isError)) {
          context2.res = res;
        }
        return context2;
      } else {
        return res.then((res2) => {
          if (res2 !== undefined && ("response" in res2)) {
            res2 = res2["response"];
          }
          if (res2 && context2.finalized === false) {
            context2.res = res2;
          }
          return context2;
        }).catch(async (err) => {
          if (err instanceof Error && context2 instanceof Context && onError) {
            context2.error = err;
            context2.res = await onError(err, context2);
            return context2;
          }
          throw err;
        });
      }
    }
  };
};

// node_modules/hono/dist/http-exception.js
var HTTPException = class extends Error {
  constructor(status = 500, options) {
    super(options?.message);
    this.res = options?.res;
    this.status = status;
  }
  getResponse() {
    if (this.res) {
      return this.res;
    }
    return new Response(this.message, {
      status: this.status
    });
  }
};

// node_modules/hono/dist/utils/body.js
var parseBody = async (request) => {
  let body = {};
  const contentType = request.headers.get("Content-Type");
  if (contentType && (contentType.startsWith("multipart/form-data") || contentType.startsWith("application/x-www-form-urlencoded"))) {
    const formData = await request.formData();
    if (formData) {
      const form = {};
      formData.forEach((value, key) => {
        form[key] = value;
      });
      body = form;
    }
  }
  return body;
};

// node_modules/hono/dist/request.js
var HonoRequest = class {
  constructor(request, path = "/", paramData) {
    this.bodyCache = {};
    this.cachedBody = (key) => {
      const { bodyCache, raw } = this;
      const cachedBody = bodyCache[key];
      if (cachedBody)
        return cachedBody;
      if (bodyCache.arrayBuffer) {
        return (async () => {
          return await new Response(bodyCache.arrayBuffer)[key]();
        })();
      }
      return bodyCache[key] = raw[key]();
    };
    this.raw = request;
    this.path = path;
    this.paramData = paramData;
    this.vData = {};
  }
  param(key) {
    if (this.paramData) {
      if (key) {
        const param = this.paramData[key];
        return param ? /\%/.test(param) ? decodeURIComponent_(param) : param : undefined;
      } else {
        const decoded = {};
        for (const [key2, value] of Object.entries(this.paramData)) {
          if (value && typeof value === "string") {
            decoded[key2] = /\%/.test(value) ? decodeURIComponent_(value) : value;
          }
        }
        return decoded;
      }
    }
    return null;
  }
  query(key) {
    return getQueryParam(this.url, key);
  }
  queries(key) {
    return getQueryParams(this.url, key);
  }
  header(name) {
    if (name)
      return this.raw.headers.get(name.toLowerCase()) ?? undefined;
    const headerData = {};
    this.raw.headers.forEach((value, key) => {
      headerData[key] = value;
    });
    return headerData;
  }
  cookie(key) {
    const cookie3 = this.raw.headers.get("Cookie");
    if (!cookie3)
      return;
    const obj = parse(cookie3);
    if (key) {
      const value = obj[key];
      return value;
    } else {
      return obj;
    }
  }
  async parseBody() {
    if (this.bodyCache.parsedBody)
      return this.bodyCache.parsedBody;
    const parsedBody = await parseBody(this);
    this.bodyCache.parsedBody = parsedBody;
    return parsedBody;
  }
  json() {
    return this.cachedBody("json");
  }
  text() {
    return this.cachedBody("text");
  }
  arrayBuffer() {
    return this.cachedBody("arrayBuffer");
  }
  blob() {
    return this.cachedBody("blob");
  }
  formData() {
    return this.cachedBody("formData");
  }
  addValidatedData(target, data) {
    this.vData[target] = data;
  }
  valid(target) {
    return this.vData[target];
  }
  get url() {
    return this.raw.url;
  }
  get method() {
    return this.raw.method;
  }
  get headers() {
    return this.raw.headers;
  }
  get body() {
    return this.raw.body;
  }
  get bodyUsed() {
    return this.raw.bodyUsed;
  }
  get integrity() {
    return this.raw.integrity;
  }
  get keepalive() {
    return this.raw.keepalive;
  }
  get referrer() {
    return this.raw.referrer;
  }
  get signal() {
    return this.raw.signal;
  }
};

// node_modules/hono/dist/router.js
var METHOD_NAME_ALL = "ALL";
var METHOD_NAME_ALL_LOWERCASE = "all";
var METHODS = ["get", "post", "put", "delete", "options", "patch"];
var UnsupportedPathError = class extends Error {
};

// node_modules/hono/dist/hono-base.js
var defineDynamicClass = function() {
  return class {
  };
};
var notFoundHandler = (c) => {
  return c.text("404 Not Found", 404);
};
var errorHandler = (err, c) => {
  if (err instanceof HTTPException) {
    return err.getResponse();
  }
  console.trace(err);
  const message = "Internal Server Error";
  return c.text(message, 500);
};
var Hono = class extends defineDynamicClass() {
  constructor(init = {}) {
    super();
    this._basePath = "/";
    this.path = "/";
    this.routes = [];
    this.notFoundHandler = notFoundHandler;
    this.errorHandler = errorHandler;
    this.head = () => {
      console.warn("`app.head()` is no longer used. `app.get()` implicitly handles the HEAD method.");
      return this;
    };
    this.handleEvent = (event) => {
      return this.dispatch(event.request, event, undefined, event.request.method);
    };
    this.fetch = (request2, Env, executionCtx) => {
      return this.dispatch(request2, executionCtx, Env, request2.method);
    };
    this.request = (input, requestInit, Env, executionCtx) => {
      if (input instanceof Request) {
        if (requestInit !== undefined) {
          input = new Request(input, requestInit);
        }
        return this.fetch(input, Env, executionCtx);
      }
      input = input.toString();
      const path = /^https?:\/\//.test(input) ? input : `http://localhost${mergePath("/", input)}`;
      const req = new Request(path, requestInit);
      return this.fetch(req, Env, executionCtx);
    };
    this.fire = () => {
      addEventListener("fetch", (event) => {
        event.respondWith(this.dispatch(event.request, event, undefined, event.request.method));
      });
    };
    const allMethods = [...METHODS, METHOD_NAME_ALL_LOWERCASE];
    allMethods.map((method) => {
      this[method] = (args1, ...args) => {
        if (typeof args1 === "string") {
          this.path = args1;
        } else {
          this.addRoute(method, this.path, args1);
        }
        args.map((handler) => {
          if (typeof handler !== "string") {
            this.addRoute(method, this.path, handler);
          }
        });
        return this;
      };
    });
    this.on = (method, path, ...handlers) => {
      if (!method)
        return this;
      this.path = path;
      for (const m of [method].flat()) {
        handlers.map((handler) => {
          this.addRoute(m.toUpperCase(), this.path, handler);
        });
      }
      return this;
    };
    this.use = (arg1, ...handlers) => {
      if (typeof arg1 === "string") {
        this.path = arg1;
      } else {
        handlers.unshift(arg1);
      }
      handlers.map((handler) => {
        this.addRoute(METHOD_NAME_ALL, this.path, handler);
      });
      return this;
    };
    const strict = init.strict ?? true;
    delete init.strict;
    Object.assign(this, init);
    this.getPath = strict ? init.getPath ?? getPath : getPathNoStrict;
  }
  clone() {
    const clone = new Hono({
      router: this.router,
      getPath: this.getPath
    });
    clone.routes = this.routes;
    return clone;
  }
  route(path, app) {
    const subApp = this.basePath(path);
    if (!app) {
      return subApp;
    }
    app.routes.map((r) => {
      const handler = app.errorHandler === errorHandler ? r.handler : async (c, next) => (await compose([r.handler], app.errorHandler)(c, next)).res;
      subApp.addRoute(r.method, r.path, handler);
    });
    return this;
  }
  basePath(path) {
    const subApp = this.clone();
    subApp._basePath = mergePath(this._basePath, path);
    return subApp;
  }
  onError(handler) {
    this.errorHandler = handler;
    return this;
  }
  notFound(handler) {
    this.notFoundHandler = handler;
    return this;
  }
  showRoutes() {
    const length = 8;
    this.routes.map((route) => {
      console.log(`\x1B[32m${route.method}\x1B[0m ${" ".repeat(length - route.method.length)} ${route.path}`);
    });
  }
  mount(path, applicationHandler, optionHandler) {
    const mergedPath = mergePath(this._basePath, path);
    const pathPrefixLength = mergedPath === "/" ? 0 : mergedPath.length;
    const handler = async (c, next) => {
      let executionContext = undefined;
      try {
        executionContext = c.executionCtx;
      } catch {
      }
      const options = optionHandler ? optionHandler(c) : [c.env, executionContext];
      const optionsArray = Array.isArray(options) ? options : [options];
      const queryStrings = getQueryStrings(c.req.url);
      const res = await applicationHandler(new Request(new URL((c.req.path.slice(pathPrefixLength) || "/") + queryStrings, c.req.url), c.req.raw), ...optionsArray);
      if (res)
        return res;
      await next();
    };
    this.addRoute(METHOD_NAME_ALL, mergePath(path, "*"), handler);
    return this;
  }
  get routerName() {
    this.matchRoute("GET", "/");
    return this.router.name;
  }
  addRoute(method, path, handler) {
    method = method.toUpperCase();
    if (this._basePath) {
      path = mergePath(this._basePath, path);
    }
    this.router.add(method, path, handler);
    const r = { path, method, handler };
    this.routes.push(r);
  }
  matchRoute(method, path) {
    return this.router.match(method, path) || { handlers: [], params: {} };
  }
  handleError(err, c) {
    if (err instanceof Error) {
      return this.errorHandler(err, c);
    }
    throw err;
  }
  dispatch(request2, executionCtx, env, method) {
    const path = this.getPath(request2, { env });
    if (method === "HEAD") {
      return (async () => new Response(null, await this.dispatch(request2, executionCtx, env, "GET")))();
    }
    const { handlers, params } = this.matchRoute(method, path);
    const c = new Context(new HonoRequest(request2, path, params), {
      env,
      executionCtx,
      notFoundHandler: this.notFoundHandler
    });
    if (handlers.length === 1) {
      let res;
      try {
        res = handlers[0](c, async () => {
        });
        if (!res) {
          return this.notFoundHandler(c);
        }
      } catch (err) {
        return this.handleError(err, c);
      }
      if (res.constructor.name === "Response")
        return res;
      if ("response" in res) {
        res = res.response;
      }
      if (res.constructor.name === "Response")
        return res;
      return (async () => {
        let awaited;
        try {
          awaited = await res;
          if (awaited !== undefined && ("response" in awaited)) {
            awaited = awaited["response"];
          }
          if (!awaited) {
            return this.notFoundHandler(c);
          }
        } catch (err) {
          return this.handleError(err, c);
        }
        return awaited;
      })();
    }
    const composed = compose(handlers, this.errorHandler, this.notFoundHandler);
    return (async () => {
      try {
        const tmp = composed(c);
        const context3 = tmp.constructor.name === "Promise" ? await tmp : tmp;
        if (!context3.finalized) {
          throw new Error("Context is not finalized. You may forget returning Response object or `await next()`");
        }
        return context3.res;
      } catch (err) {
        return this.handleError(err, c);
      }
    })();
  }
};

// node_modules/hono/dist/router/reg-exp-router/node.js
var compareKey = function(a, b) {
  if (a.length === 1) {
    return b.length === 1 ? a < b ? -1 : 1 : -1;
  }
  if (b.length === 1) {
    return 1;
  }
  if (a === ONLY_WILDCARD_REG_EXP_STR || a === TAIL_WILDCARD_REG_EXP_STR) {
    return 1;
  } else if (b === ONLY_WILDCARD_REG_EXP_STR || b === TAIL_WILDCARD_REG_EXP_STR) {
    return -1;
  }
  if (a === LABEL_REG_EXP_STR) {
    return 1;
  } else if (b === LABEL_REG_EXP_STR) {
    return -1;
  }
  return a.length === b.length ? a < b ? -1 : 1 : b.length - a.length;
};
var LABEL_REG_EXP_STR = "[^/]+";
var ONLY_WILDCARD_REG_EXP_STR = ".*";
var TAIL_WILDCARD_REG_EXP_STR = "(?:|/.*)";
var PATH_ERROR = Symbol();
var Node = class {
  constructor() {
    this.children = {};
  }
  insert(tokens, index, paramMap, context3, pathErrorCheckOnly) {
    if (tokens.length === 0) {
      if (this.index !== undefined) {
        throw PATH_ERROR;
      }
      if (pathErrorCheckOnly) {
        return;
      }
      this.index = index;
      return;
    }
    const [token, ...restTokens] = tokens;
    const pattern = token === "*" ? restTokens.length === 0 ? ["", "", ONLY_WILDCARD_REG_EXP_STR] : ["", "", LABEL_REG_EXP_STR] : token === "/*" ? ["", "", TAIL_WILDCARD_REG_EXP_STR] : token.match(/^\:([^\{\}]+)(?:\{(.+)\})?$/);
    let node;
    if (pattern) {
      const name = pattern[1];
      const regexpStr = pattern[2] || LABEL_REG_EXP_STR;
      node = this.children[regexpStr];
      if (!node) {
        if (Object.keys(this.children).some((k) => k !== ONLY_WILDCARD_REG_EXP_STR && k !== TAIL_WILDCARD_REG_EXP_STR)) {
          throw PATH_ERROR;
        }
        if (pathErrorCheckOnly) {
          return;
        }
        node = this.children[regexpStr] = new Node;
        if (name !== "") {
          node.varIndex = context3.varIndex++;
        }
      }
      if (!pathErrorCheckOnly && name !== "") {
        if (paramMap.some((p) => p[0] === name)) {
          throw new Error("Duplicate param name");
        }
        paramMap.push([name, node.varIndex]);
      }
    } else {
      node = this.children[token];
      if (!node) {
        if (Object.keys(this.children).some((k) => k.length > 1 && k !== ONLY_WILDCARD_REG_EXP_STR && k !== TAIL_WILDCARD_REG_EXP_STR)) {
          throw PATH_ERROR;
        }
        if (pathErrorCheckOnly) {
          return;
        }
        node = this.children[token] = new Node;
      }
    }
    node.insert(restTokens, index, paramMap, context3, pathErrorCheckOnly);
  }
  buildRegExpStr() {
    const childKeys = Object.keys(this.children).sort(compareKey);
    const strList = childKeys.map((k) => {
      const c = this.children[k];
      return (typeof c.varIndex === "number" ? `(${k})@${c.varIndex}` : k) + c.buildRegExpStr();
    });
    if (typeof this.index === "number") {
      strList.unshift(`#${this.index}`);
    }
    if (strList.length === 0) {
      return "";
    }
    if (strList.length === 1) {
      return strList[0];
    }
    return "(?:" + strList.join("|") + ")";
  }
};

// node_modules/hono/dist/router/reg-exp-router/trie.js
var Trie = class {
  constructor() {
    this.context = { varIndex: 0 };
    this.root = new Node;
  }
  insert(path, index, pathErrorCheckOnly) {
    const paramMap = [];
    const groups = [];
    for (let i = 0;; ) {
      let replaced = false;
      path = path.replace(/\{[^}]+\}/g, (m) => {
        const mark = `@\\${i}`;
        groups[i] = [mark, m];
        i++;
        replaced = true;
        return mark;
      });
      if (!replaced) {
        break;
      }
    }
    const tokens = path.match(/(?::[^\/]+)|(?:\/\*$)|./g) || [];
    for (let i = groups.length - 1;i >= 0; i--) {
      const [mark] = groups[i];
      for (let j = tokens.length - 1;j >= 0; j--) {
        if (tokens[j].indexOf(mark) !== -1) {
          tokens[j] = tokens[j].replace(mark, groups[i][1]);
          break;
        }
      }
    }
    this.root.insert(tokens, index, paramMap, this.context, pathErrorCheckOnly);
    return paramMap;
  }
  buildRegExp() {
    let regexp = this.root.buildRegExpStr();
    if (regexp === "") {
      return [/^$/, [], []];
    }
    let captureIndex = 0;
    const indexReplacementMap = [];
    const paramReplacementMap = [];
    regexp = regexp.replace(/#(\d+)|@(\d+)|\.\*\$/g, (_, handlerIndex, paramIndex) => {
      if (typeof handlerIndex !== "undefined") {
        indexReplacementMap[++captureIndex] = Number(handlerIndex);
        return "$()";
      }
      if (typeof paramIndex !== "undefined") {
        paramReplacementMap[Number(paramIndex)] = ++captureIndex;
        return "";
      }
      return "";
    });
    return [new RegExp(`^${regexp}`), indexReplacementMap, paramReplacementMap];
  }
};

// node_modules/hono/dist/router/reg-exp-router/router.js
var buildWildcardRegExp = function(path) {
  return wildcardRegExpCache[path] ?? (wildcardRegExpCache[path] = new RegExp(path === "*" ? "" : `^${path.replace(/\/\*/, "(?:|/.*)")}\$`));
};
var clearWildcardRegExpCache = function() {
  wildcardRegExpCache = {};
};
var buildMatcherFromPreprocessedRoutes = function(routes) {
  const trie2 = new Trie;
  const handlerData = [];
  if (routes.length === 0) {
    return nullMatcher;
  }
  const routesWithStaticPathFlag = routes.map((route) => [!/\*|\/:/.test(route[0]), ...route]).sort(([isStaticA, pathA], [isStaticB, pathB]) => isStaticA ? 1 : isStaticB ? -1 : pathA.length - pathB.length);
  const staticMap = {};
  for (let i = 0, j = -1, len = routesWithStaticPathFlag.length;i < len; i++) {
    const [pathErrorCheckOnly, path, handlers] = routesWithStaticPathFlag[i];
    if (pathErrorCheckOnly) {
      staticMap[path] = { handlers, params: emptyParam };
    } else {
      j++;
    }
    let paramMap;
    try {
      paramMap = trie2.insert(path, j, pathErrorCheckOnly);
    } catch (e) {
      throw e === PATH_ERROR ? new UnsupportedPathError(path) : e;
    }
    if (pathErrorCheckOnly) {
      continue;
    }
    handlerData[j] = paramMap.length === 0 ? [{ handlers, params: emptyParam }, null] : [handlers, paramMap];
  }
  const [regexp, indexReplacementMap, paramReplacementMap] = trie2.buildRegExp();
  for (let i = 0, len = handlerData.length;i < len; i++) {
    const paramMap = handlerData[i][1];
    if (paramMap) {
      for (let j = 0, len2 = paramMap.length;j < len2; j++) {
        paramMap[j][1] = paramReplacementMap[paramMap[j][1]];
      }
    }
  }
  const handlerMap = [];
  for (const i in indexReplacementMap) {
    handlerMap[i] = handlerData[indexReplacementMap[i]];
  }
  return [regexp, handlerMap, staticMap];
};
var findMiddleware = function(middleware, path) {
  if (!middleware) {
    return;
  }
  for (const k of Object.keys(middleware).sort((a, b) => b.length - a.length)) {
    if (buildWildcardRegExp(k).test(path)) {
      return [...middleware[k]];
    }
  }
  return;
};
var methodNames = [METHOD_NAME_ALL, ...METHODS].map((method) => method.toUpperCase());
var emptyParam = {};
var nullMatcher = [/^$/, [], {}];
var wildcardRegExpCache = {};
var RegExpRouter = class {
  constructor() {
    this.name = "RegExpRouter";
    this.middleware = { [METHOD_NAME_ALL]: {} };
    this.routes = { [METHOD_NAME_ALL]: {} };
  }
  add(method, path, handler) {
    var _a;
    const { middleware, routes } = this;
    if (!middleware || !routes) {
      throw new Error("Can not add a route since the matcher is already built.");
    }
    if (methodNames.indexOf(method) === -1)
      methodNames.push(method);
    if (!middleware[method]) {
      [middleware, routes].forEach((handlerMap) => {
        handlerMap[method] = {};
        Object.keys(handlerMap[METHOD_NAME_ALL]).forEach((p) => {
          handlerMap[method][p] = [...handlerMap[METHOD_NAME_ALL][p]];
        });
      });
    }
    if (path === "/*") {
      path = "*";
    }
    if (/\*$/.test(path)) {
      const re = buildWildcardRegExp(path);
      if (method === METHOD_NAME_ALL) {
        Object.keys(middleware).forEach((m) => {
          var _a2;
          (_a2 = middleware[m])[path] || (_a2[path] = findMiddleware(middleware[m], path) || findMiddleware(middleware[METHOD_NAME_ALL], path) || []);
        });
      } else {
        (_a = middleware[method])[path] || (_a[path] = findMiddleware(middleware[method], path) || findMiddleware(middleware[METHOD_NAME_ALL], path) || []);
      }
      Object.keys(middleware).forEach((m) => {
        if (method === METHOD_NAME_ALL || method === m) {
          Object.keys(middleware[m]).forEach((p) => {
            re.test(p) && middleware[m][p].push(handler);
          });
        }
      });
      Object.keys(routes).forEach((m) => {
        if (method === METHOD_NAME_ALL || method === m) {
          Object.keys(routes[m]).forEach((p) => re.test(p) && routes[m][p].push(handler));
        }
      });
      return;
    }
    const paths = checkOptionalParameter(path) || [path];
    for (let i = 0, len = paths.length;i < len; i++) {
      const path2 = paths[i];
      Object.keys(routes).forEach((m) => {
        var _a2;
        if (method === METHOD_NAME_ALL || method === m) {
          (_a2 = routes[m])[path2] || (_a2[path2] = [
            ...findMiddleware(middleware[m], path2) || findMiddleware(middleware[METHOD_NAME_ALL], path2) || []
          ]);
          routes[m][path2].push(handler);
        }
      });
    }
  }
  match(method, path) {
    clearWildcardRegExpCache();
    const matchers = this.buildAllMatchers();
    this.match = (method2, path2) => {
      const matcher = matchers[method2];
      const staticMatch = matcher[2][path2];
      if (staticMatch) {
        return staticMatch;
      }
      const match = path2.match(matcher[0]);
      if (!match) {
        return null;
      }
      const index = match.indexOf("", 1);
      const [handlers, paramMap] = matcher[1][index];
      if (!paramMap) {
        return handlers;
      }
      const params = {};
      for (let i = 0, len = paramMap.length;i < len; i++) {
        params[paramMap[i][0]] = match[paramMap[i][1]];
      }
      return { handlers, params };
    };
    return this.match(method, path);
  }
  buildAllMatchers() {
    const matchers = {};
    methodNames.forEach((method) => {
      matchers[method] = this.buildMatcher(method) || matchers[METHOD_NAME_ALL];
    });
    this.middleware = this.routes = undefined;
    return matchers;
  }
  buildMatcher(method) {
    const routes = [];
    let hasOwnRoute = method === METHOD_NAME_ALL;
    [this.middleware, this.routes].forEach((r) => {
      const ownRoute = r[method] ? Object.keys(r[method]).map((path) => [path, r[method][path]]) : [];
      if (ownRoute.length !== 0) {
        hasOwnRoute || (hasOwnRoute = true);
        routes.push(...ownRoute);
      } else if (method !== METHOD_NAME_ALL) {
        routes.push(...Object.keys(r[METHOD_NAME_ALL]).map((path) => [path, r[METHOD_NAME_ALL][path]]));
      }
    });
    if (!hasOwnRoute) {
      return null;
    } else {
      return buildMatcherFromPreprocessedRoutes(routes);
    }
  }
};

// node_modules/hono/dist/router/smart-router/router.js
var SmartRouter = class {
  constructor(init) {
    this.name = "SmartRouter";
    this.routers = [];
    this.routes = [];
    Object.assign(this, init);
  }
  add(method, path, handler) {
    if (!this.routes) {
      throw new Error("Can not add a route since the matcher is already built.");
    }
    this.routes.push([method, path, handler]);
  }
  match(method, path) {
    if (!this.routes) {
      throw new Error("Fatal error");
    }
    const { routers, routes } = this;
    const len = routers.length;
    let i = 0;
    let res;
    for (;i < len; i++) {
      const router5 = routers[i];
      try {
        routes.forEach((args) => {
          router5.add(...args);
        });
        res = router5.match(method, path);
      } catch (e) {
        if (e instanceof UnsupportedPathError) {
          continue;
        }
        throw e;
      }
      this.match = router5.match.bind(router5);
      this.routers = [router5];
      this.routes = undefined;
      break;
    }
    if (i === len) {
      throw new Error("Fatal error");
    }
    this.name = `SmartRouter + ${this.activeRouter.name}`;
    return res || null;
  }
  get activeRouter() {
    if (this.routes || this.routers.length !== 1) {
      throw new Error("No active router has been determined yet.");
    }
    return this.routers[0];
  }
};

// node_modules/hono/dist/router/trie-router/node.js
var findParam = function(node3, name) {
  for (let i = 0, len = node3.patterns.length;i < len; i++) {
    if (typeof node3.patterns[i] === "object" && node3.patterns[i][1] === name) {
      return true;
    }
  }
  const nodes = Object.values(node3.children);
  for (let i = 0, len = nodes.length;i < len; i++) {
    if (findParam(nodes[i], name)) {
      return true;
    }
  }
  return false;
};
var Node2 = class {
  constructor(method, handler, children) {
    this.order = 0;
    this.children = children || {};
    this.methods = [];
    this.name = "";
    if (method && handler) {
      const m = {};
      m[method] = { handler, score: 0, name: this.name };
      this.methods = [m];
    }
    this.patterns = [];
    this.handlerSetCache = {};
  }
  insert(method, path, handler) {
    this.name = `${method} ${path}`;
    this.order = ++this.order;
    let curNode = this;
    const parts = splitRoutingPath(path);
    const parentPatterns = [];
    const errorMessage = (name) => {
      return `Duplicate param name, use another name instead of '${name}' - ${method} ${path} <--- '${name}'`;
    };
    for (let i = 0, len = parts.length;i < len; i++) {
      const p = parts[i];
      if (Object.keys(curNode.children).includes(p)) {
        parentPatterns.push(...curNode.patterns);
        curNode = curNode.children[p];
        continue;
      }
      curNode.children[p] = new Node2;
      const pattern = getPattern(p);
      if (pattern) {
        if (typeof pattern === "object") {
          for (let j = 0, len2 = parentPatterns.length;j < len2; j++) {
            if (typeof parentPatterns[j] === "object" && parentPatterns[j][1] === pattern[1]) {
              throw new Error(errorMessage(pattern[1]));
            }
          }
          if (Object.values(curNode.children).some((n) => findParam(n, pattern[1]))) {
            throw new Error(errorMessage(pattern[1]));
          }
        }
        curNode.patterns.push(pattern);
        parentPatterns.push(...curNode.patterns);
      }
      parentPatterns.push(...curNode.patterns);
      curNode = curNode.children[p];
    }
    if (!curNode.methods.length) {
      curNode.methods = [];
    }
    const m = {};
    const handlerSet = { handler, name: this.name, score: this.order };
    m[method] = handlerSet;
    curNode.methods.push(m);
    return curNode;
  }
  gHSets(node3, method, wildcard) {
    var _a, _b;
    return (_a = node3.handlerSetCache)[_b = `${method}:${wildcard ? "1" : "0"}`] || (_a[_b] = (() => {
      const handlerSets = [];
      for (let i = 0, len = node3.methods.length;i < len; i++) {
        const m = node3.methods[i];
        const handlerSet = m[method] || m[METHOD_NAME_ALL];
        if (handlerSet !== undefined) {
          handlerSets.push(handlerSet);
        }
      }
      return handlerSets;
    })());
  }
  search(method, path) {
    const handlerSets = [];
    const params = {};
    const curNode = this;
    let curNodes = [curNode];
    const parts = splitPath(path);
    for (let i = 0, len2 = parts.length;i < len2; i++) {
      const part = parts[i];
      const isLast = i === len2 - 1;
      const tempNodes = [];
      let matched = false;
      for (let j = 0, len22 = curNodes.length;j < len22; j++) {
        const node3 = curNodes[j];
        const nextNode = node3.children[part];
        if (nextNode) {
          if (isLast === true) {
            if (nextNode.children["*"]) {
              handlerSets.push(...this.gHSets(nextNode.children["*"], method, true));
            }
            handlerSets.push(...this.gHSets(nextNode, method));
            matched = true;
          } else {
            tempNodes.push(nextNode);
          }
        }
        for (let k = 0, len3 = node3.patterns.length;k < len3; k++) {
          const pattern = node3.patterns[k];
          if (pattern === "*") {
            const astNode = node3.children["*"];
            if (astNode) {
              handlerSets.push(...this.gHSets(astNode, method));
              tempNodes.push(astNode);
            }
            continue;
          }
          if (part === "")
            continue;
          const [key, name, matcher] = pattern;
          const child = node3.children[key];
          const restPathString = parts.slice(i).join("/");
          if (matcher instanceof RegExp && matcher.test(restPathString)) {
            handlerSets.push(...this.gHSets(child, method));
            params[name] = restPathString;
            continue;
          }
          if (matcher === true || matcher instanceof RegExp && matcher.test(part)) {
            if (typeof key === "string") {
              if (isLast === true) {
                handlerSets.push(...this.gHSets(child, method));
                if (child.children["*"]) {
                  handlerSets.push(...this.gHSets(child.children["*"], method));
                }
              } else {
                tempNodes.push(child);
              }
            }
            if (typeof name === "string" && !matched) {
              params[name] = part;
            } else {
              if (node3.children[part]) {
                params[name] = part;
              }
            }
          }
        }
      }
      curNodes = tempNodes;
    }
    const len = handlerSets.length;
    if (len === 0)
      return null;
    if (len === 1)
      return { handlers: [handlerSets[0].handler], params };
    const handlers = handlerSets.sort((a, b) => {
      return a.score - b.score;
    }).map((s) => {
      return s.handler;
    });
    return { handlers, params };
  }
};

// node_modules/hono/dist/router/trie-router/router.js
var TrieRouter = class {
  constructor() {
    this.name = "TrieRouter";
    this.node = new Node2;
  }
  add(method, path, handler) {
    const results = checkOptionalParameter(path);
    if (results) {
      for (const p of results) {
        this.node.insert(method, p, handler);
      }
      return;
    }
    this.node.insert(method, path, handler);
  }
  match(method, path) {
    return this.node.search(method, path);
  }
};

// node_modules/hono/dist/hono.js
var Hono2 = class extends Hono {
  constructor(init = {}) {
    super(init);
    this.router = init.router ?? new SmartRouter({
      routers: [new RegExpRouter, new TrieRouter]
    });
  }
};

// node_modules/hono/dist/middleware/cors/index.js
var cors = (options) => {
  const defaults = {
    origin: "*",
    allowMethods: ["GET", "HEAD", "PUT", "POST", "DELETE", "PATCH"],
    allowHeaders: [],
    exposeHeaders: []
  };
  const opts = {
    ...defaults,
    ...options
  };
  const findAllowOrigin = ((optsOrigin) => {
    if (typeof optsOrigin === "string") {
      return () => optsOrigin;
    } else if (typeof optsOrigin === "function") {
      return optsOrigin;
    } else {
      return (origin) => optsOrigin.includes(origin) ? origin : optsOrigin[0];
    }
  })(opts.origin);
  return async (c, next) => {
    function set(key, value) {
      c.res.headers.set(key, value);
    }
    const allowOrigin = findAllowOrigin(c.req.header("origin") || "");
    if (allowOrigin) {
      set("Access-Control-Allow-Origin", allowOrigin);
    }
    if (opts.origin !== "*") {
      set("Vary", "Origin");
    }
    if (opts.credentials) {
      set("Access-Control-Allow-Credentials", "true");
    }
    if (opts.exposeHeaders?.length) {
      set("Access-Control-Expose-Headers", opts.exposeHeaders.join(","));
    }
    if (c.req.method !== "OPTIONS") {
      await next();
    } else {
      if (opts.maxAge != null) {
        set("Access-Control-Max-Age", opts.maxAge.toString());
      }
      if (opts.allowMethods?.length) {
        set("Access-Control-Allow-Methods", opts.allowMethods.join(","));
      }
      let headers = opts.allowHeaders;
      if (!headers?.length) {
        const requestHeaders = c.req.header("Access-Control-Request-Headers");
        if (requestHeaders) {
          headers = requestHeaders.split(/\s*,\s*/);
        }
      }
      if (headers?.length) {
        set("Access-Control-Allow-Headers", headers.join(","));
        c.res.headers.append("Vary", "Access-Control-Request-Headers");
      }
      c.res.headers.delete("Content-Length");
      c.res.headers.delete("Content-Type");
      return new Response(null, {
        headers: c.res.headers,
        status: 204,
        statusText: c.res.statusText
      });
    }
  };
};

// node_modules/uuid/wrapper.mjs
var dist = __toESM(require_dist(), 1);
var v1 = dist.default.v1;
var v3 = dist.default.v3;
var v4 = dist.default.v4;
var v5 = dist.default.v5;
var NIL = dist.default.NIL;
var version = dist.default.version;
var validate = dist.default.validate;
var stringify = dist.default.stringify;
var parse2 = dist.default.parse;

// node_modules/postgres/src/index.js
import os from "os";
import fs from "fs";

// node_modules/postgres/src/query.js
var cachedError = function(xs) {
  if (originCache.has(xs))
    return originCache.get(xs);
  const x = Error.stackTraceLimit;
  Error.stackTraceLimit = 4;
  originCache.set(xs, new Error);
  Error.stackTraceLimit = x;
  return originCache.get(xs);
};
var originCache = new Map;
var originStackCache = new Map;
var originError = Symbol("OriginError");
var CLOSE = {};

class Query extends Promise {
  constructor(strings, args, handler, canceller, options = {}) {
    let resolve, reject;
    super((a, b) => {
      resolve = a;
      reject = b;
    });
    this.tagged = Array.isArray(strings.raw);
    this.strings = strings;
    this.args = args;
    this.handler = handler;
    this.canceller = canceller;
    this.options = options;
    this.state = null;
    this.statement = null;
    this.resolve = (x) => (this.active = false, resolve(x));
    this.reject = (x) => (this.active = false, reject(x));
    this.active = false;
    this.cancelled = null;
    this.executed = false;
    this.signature = "";
    this[originError] = this.handler.debug ? new Error : this.tagged && cachedError(this.strings);
  }
  get origin() {
    return this.handler.debug ? this[originError].stack : this.tagged ? originStackCache.has(this.strings) ? originStackCache.get(this.strings) : originStackCache.set(this.strings, this[originError].stack).get(this.strings) : "";
  }
  static get [Symbol.species]() {
    return Promise;
  }
  cancel() {
    return this.canceller && (this.canceller(this), this.canceller = null);
  }
  simple() {
    this.options.simple = true;
    this.options.prepare = false;
    return this;
  }
  async readable() {
    this.simple();
    this.streaming = true;
    return this;
  }
  async writable() {
    this.simple();
    this.streaming = true;
    return this;
  }
  cursor(rows = 1, fn) {
    this.options.simple = false;
    if (typeof rows === "function") {
      fn = rows;
      rows = 1;
    }
    this.cursorRows = rows;
    if (typeof fn === "function")
      return this.cursorFn = fn, this;
    let prev;
    return {
      [Symbol.asyncIterator]: () => ({
        next: () => {
          if (this.executed && !this.active)
            return { done: true };
          prev && prev();
          const promise = new Promise((resolve, reject) => {
            this.cursorFn = (value) => {
              resolve({ value, done: false });
              return new Promise((r) => prev = r);
            };
            this.resolve = () => (this.active = false, resolve({ done: true }));
            this.reject = (x) => (this.active = false, reject(x));
          });
          this.execute();
          return promise;
        },
        return() {
          prev && prev(CLOSE);
          return { done: true };
        }
      })
    };
  }
  describe() {
    this.options.simple = false;
    this.onlyDescribe = this.options.prepare = true;
    return this;
  }
  stream() {
    throw new Error(".stream has been renamed to .forEach");
  }
  forEach(fn) {
    this.forEachFn = fn;
    this.handle();
    return this;
  }
  raw() {
    this.isRaw = true;
    return this;
  }
  values() {
    this.isRaw = "values";
    return this;
  }
  async handle() {
    !this.executed && (this.executed = true) && await 1 && this.handler(this);
  }
  execute() {
    this.handle();
    return this;
  }
  then() {
    this.handle();
    return super.then.apply(this, arguments);
  }
  catch() {
    this.handle();
    return super.catch.apply(this, arguments);
  }
  finally() {
    this.handle();
    return super.finally.apply(this, arguments);
  }
}

// node_modules/postgres/src/errors.js
var connection = function(x, options, socket) {
  const { host, port } = socket || options;
  const error = Object.assign(new Error("write " + x + " " + (options.path || host + ":" + port)), {
    code: x,
    errno: x,
    address: options.path || host
  }, options.path ? {} : { port });
  Error.captureStackTrace(error, connection);
  return error;
};
var postgres = function(x) {
  const error = new PostgresError(x);
  Error.captureStackTrace(error, postgres);
  return error;
};
var generic = function(code, message) {
  const error = Object.assign(new Error(code + ": " + message), { code });
  Error.captureStackTrace(error, generic);
  return error;
};
var notSupported = function(x) {
  const error = Object.assign(new Error(x + " (B) is not supported"), {
    code: "MESSAGE_NOT_SUPPORTED",
    name: x
  });
  Error.captureStackTrace(error, notSupported);
  return error;
};

class PostgresError extends Error {
  constructor(x) {
    super(x.message);
    this.name = this.constructor.name;
    Object.assign(this, x);
  }
}
var Errors = {
  connection,
  postgres,
  generic,
  notSupported
};

// node_modules/postgres/src/types.js
function handleValue(x, parameters, types2, options) {
  let value = x instanceof Parameter ? x.value : x;
  if (value === undefined) {
    x instanceof Parameter ? x.value = options.transform.undefined : value = x = options.transform.undefined;
    if (value === undefined)
      throw Errors.generic("UNDEFINED_VALUE", "Undefined values are not allowed");
  }
  return "$" + types2.push(x instanceof Parameter ? (parameters.push(x.value), x.array ? x.array[x.type || inferType(x.value)] || x.type || firstIsString(x.value) : x.type) : (parameters.push(x), inferType(x)));
}
function stringify2(q, string, value, parameters, types2, options) {
  for (let i = 1;i < q.strings.length; i++) {
    string += stringifyValue(string, value, parameters, types2, options) + q.strings[i];
    value = q.args[i];
  }
  return string;
}
var stringifyValue = function(string, value, parameters, types2, o) {
  return value instanceof Builder ? value.build(string, parameters, types2, o) : value instanceof Query ? fragment(value, parameters, types2, o) : value instanceof Identifier ? value.value : value && value[0] instanceof Query ? value.reduce((acc, x) => acc + " " + fragment(x, parameters, types2, o), "") : handleValue(value, parameters, types2, o);
};
var fragment = function(q, parameters, types2, options) {
  q.fragment = true;
  return stringify2(q, q.strings[0], q.args[0], parameters, types2, options);
};
var valuesBuilder = function(first, parameters, types2, columns, options) {
  return first.map((row) => "(" + columns.map((column) => stringifyValue("values", row[column], parameters, types2, options)).join(",") + ")").join(",");
};
var values = function(first, rest, parameters, types2, options) {
  const multi = Array.isArray(first[0]);
  const columns = rest.length ? rest.flat() : Object.keys(multi ? first[0] : first);
  return valuesBuilder(multi ? first : [first], parameters, types2, columns, options);
};
var select = function(first, rest, parameters, types2, options) {
  typeof first === "string" && (first = [first].concat(rest));
  if (Array.isArray(first))
    return escapeIdentifiers(first, options);
  let value;
  const columns = rest.length ? rest.flat() : Object.keys(first);
  return columns.map((x) => {
    value = first[x];
    return (value instanceof Query ? fragment(value, parameters, types2, options) : value instanceof Identifier ? value.value : handleValue(value, parameters, types2, options)) + " as " + escapeIdentifier(options.transform.column.to ? options.transform.column.to(x) : x);
  }).join(",");
};
var notTagged = function() {
  throw Errors.generic("NOT_TAGGED_CALL", "Query not called as a tagged template literal");
};
var firstIsString = function(x) {
  if (Array.isArray(x))
    return firstIsString(x[0]);
  return typeof x === "string" ? 1009 : 0;
};
var typeHandlers = function(types2) {
  return Object.keys(types2).reduce((acc, k) => {
    types2[k].from && [].concat(types2[k].from).forEach((x) => acc.parsers[x] = types2[k].parse);
    acc.serializers[types2[k].to] = types2[k].serialize;
    types2[k].from && [].concat(types2[k].from).forEach((x) => acc.serializers[x] = types2[k].serialize);
    return acc;
  }, { parsers: {}, serializers: {} });
};
var escapeIdentifiers = function(xs, { transform: { column } }) {
  return xs.map((x) => escapeIdentifier(column.to ? column.to(x) : x)).join(",");
};
var arrayEscape = function(x) {
  return x.replace(escapeBackslash, "\\\\").replace(escapeQuote, '\\"');
};
var arrayParserLoop = function(s, x, parser, typarray) {
  const xs = [];
  const delimiter = typarray === 1020 ? ";" : ",";
  for (;s.i < x.length; s.i++) {
    s.char = x[s.i];
    if (s.quoted) {
      if (s.char === "\\") {
        s.str += x[++s.i];
      } else if (s.char === '"') {
        xs.push(parser ? parser(s.str) : s.str);
        s.str = "";
        s.quoted = x[s.i + 1] === '"';
        s.last = s.i + 2;
      } else {
        s.str += s.char;
      }
    } else if (s.char === '"') {
      s.quoted = true;
    } else if (s.char === "{") {
      s.last = ++s.i;
      xs.push(arrayParserLoop(s, x, parser, typarray));
    } else if (s.char === "}") {
      s.quoted = false;
      s.last < s.i && xs.push(parser ? parser(x.slice(s.last, s.i)) : x.slice(s.last, s.i));
      s.last = s.i + 1;
      break;
    } else if (s.char === delimiter && s.p !== "}" && s.p !== '"') {
      xs.push(parser ? parser(x.slice(s.last, s.i)) : x.slice(s.last, s.i));
      s.last = s.i + 1;
    }
    s.p = s.char;
  }
  s.last < s.i && xs.push(parser ? parser(x.slice(s.last, s.i + 1)) : x.slice(s.last, s.i + 1));
  return xs;
};
var createJsonTransform = function(fn) {
  return function jsonTransform(x, column) {
    return typeof x === "object" && x !== null && (column.type === 114 || column.type === 3802) ? Array.isArray(x) ? x.map((x2) => jsonTransform(x2, column)) : Object.entries(x).reduce((acc, [k, v]) => Object.assign(acc, { [fn(k)]: jsonTransform(v, column) }), {}) : x;
  };
};
var types2 = {
  string: {
    to: 25,
    from: null,
    serialize: (x) => "" + x
  },
  number: {
    to: 0,
    from: [21, 23, 26, 700, 701],
    serialize: (x) => "" + x,
    parse: (x) => +x
  },
  json: {
    to: 114,
    from: [114, 3802],
    serialize: (x) => JSON.stringify(x),
    parse: (x) => JSON.parse(x)
  },
  boolean: {
    to: 16,
    from: 16,
    serialize: (x) => x === true ? "t" : "f",
    parse: (x) => x === "t"
  },
  date: {
    to: 1184,
    from: [1082, 1114, 1184],
    serialize: (x) => (x instanceof Date ? x : new Date(x)).toISOString(),
    parse: (x) => new Date(x)
  },
  bytea: {
    to: 17,
    from: 17,
    serialize: (x) => "\\x" + Buffer.from(x).toString("hex"),
    parse: (x) => Buffer.from(x.slice(2), "hex")
  }
};

class NotTagged {
  then() {
    notTagged();
  }
  catch() {
    notTagged();
  }
  finally() {
    notTagged();
  }
}

class Identifier extends NotTagged {
  constructor(value) {
    super();
    this.value = escapeIdentifier(value);
  }
}

class Parameter extends NotTagged {
  constructor(value, type, array) {
    super();
    this.value = value;
    this.type = type;
    this.array = array;
  }
}

class Builder extends NotTagged {
  constructor(first, rest) {
    super();
    this.first = first;
    this.rest = rest;
  }
  build(before, parameters, types3, options) {
    const keyword = builders.map(([x, fn]) => ({ fn, i: before.search(x) })).sort((a, b) => a.i - b.i).pop();
    return keyword.i === -1 ? escapeIdentifiers(this.first, options) : keyword.fn(this.first, this.rest, parameters, types3, options);
  }
}
var defaultHandlers = typeHandlers(types2);
var builders = Object.entries({
  values,
  in: (...xs) => {
    const x = values(...xs);
    return x === "()" ? "(null)" : x;
  },
  select,
  as: select,
  returning: select,
  update(first, rest, parameters, types3, options) {
    return (rest.length ? rest.flat() : Object.keys(first)).map((x) => escapeIdentifier(options.transform.column.to ? options.transform.column.to(x) : x) + "=" + stringifyValue("values", first[x], parameters, types3, options));
  },
  insert(first, rest, parameters, types3, options) {
    const columns = rest.length ? rest.flat() : Object.keys(Array.isArray(first) ? first[0] : first);
    return "(" + escapeIdentifiers(columns, options) + ")values" + valuesBuilder(Array.isArray(first) ? first : [first], parameters, types3, columns, options);
  }
}).map(([x, fn]) => [new RegExp("((?:^|[\\s(])" + x + "(?:$|[\\s(]))(?![\\s\\S]*\\1)", "i"), fn]);
var serializers = defaultHandlers.serializers;
var parsers = defaultHandlers.parsers;
var mergeUserTypes = function(types3) {
  const user = typeHandlers(types3 || {});
  return {
    serializers: Object.assign({}, serializers, user.serializers),
    parsers: Object.assign({}, parsers, user.parsers)
  };
};
var escapeIdentifier = function escape2(str) {
  return '"' + str.replace(/"/g, '""').replace(/\./g, '"."') + '"';
};
var inferType = function inferType2(x) {
  return x instanceof Parameter ? x.type : x instanceof Date ? 1184 : x instanceof Uint8Array ? 17 : x === true || x === false ? 16 : typeof x === "bigint" ? 20 : Array.isArray(x) ? inferType2(x[0]) : 0;
};
var escapeBackslash = /\\/g;
var escapeQuote = /"/g;
var arraySerializer = function arraySerializer2(xs, serializer, options, typarray) {
  if (Array.isArray(xs) === false)
    return xs;
  if (!xs.length)
    return "{}";
  const first = xs[0];
  const delimiter = typarray === 1020 ? ";" : ",";
  if (Array.isArray(first) && !first.type)
    return "{" + xs.map((x) => arraySerializer2(x, serializer, options, typarray)).join(delimiter) + "}";
  return "{" + xs.map((x) => {
    if (x === undefined) {
      x = options.transform.undefined;
      if (x === undefined)
        throw Errors.generic("UNDEFINED_VALUE", "Undefined values are not allowed");
    }
    return x === null ? "null" : '"' + arrayEscape(serializer ? serializer(x.type ? x.value : x) : "" + x) + '"';
  }).join(delimiter) + "}";
};
var arrayParserState = {
  i: 0,
  char: null,
  str: "",
  quoted: false,
  last: 0
};
var arrayParser = function arrayParser2(x, parser, typarray) {
  arrayParserState.i = arrayParserState.last = 0;
  return arrayParserLoop(arrayParserState, x, parser, typarray);
};
var toCamel = (x) => {
  let str = x[0];
  for (let i = 1;i < x.length; i++)
    str += x[i] === "_" ? x[++i].toUpperCase() : x[i];
  return str;
};
var toPascal = (x) => {
  let str = x[0].toUpperCase();
  for (let i = 1;i < x.length; i++)
    str += x[i] === "_" ? x[++i].toUpperCase() : x[i];
  return str;
};
var toKebab = (x) => x.replace(/_/g, "-");
var fromCamel = (x) => x.replace(/([A-Z])/g, "_$1").toLowerCase();
var fromPascal = (x) => (x.slice(0, 1) + x.slice(1).replace(/([A-Z])/g, "_$1")).toLowerCase();
var fromKebab = (x) => x.replace(/-/g, "_");
toCamel.column = { from: toCamel };
toCamel.value = { from: createJsonTransform(toCamel) };
fromCamel.column = { to: fromCamel };
var camel = { ...toCamel };
camel.column.to = fromCamel;
toPascal.column = { from: toPascal };
toPascal.value = { from: createJsonTransform(toPascal) };
fromPascal.column = { to: fromPascal };
var pascal = { ...toPascal };
pascal.column.to = fromPascal;
toKebab.column = { from: toKebab };
toKebab.value = { from: createJsonTransform(toKebab) };
fromKebab.column = { to: fromKebab };
var kebab = { ...toKebab };
kebab.column.to = fromKebab;

// node_modules/postgres/src/connection.js
import net from "net";
import tls from "tls";
import crypto2 from "crypto";
import Stream from "stream";

// node_modules/postgres/src/result.js
class Result extends Array {
  constructor() {
    super();
    Object.defineProperties(this, {
      count: { value: null, writable: true },
      state: { value: null, writable: true },
      command: { value: null, writable: true },
      columns: { value: null, writable: true },
      statement: { value: null, writable: true }
    });
  }
  static get [Symbol.species]() {
    return Array;
  }
}

// node_modules/postgres/src/queue.js
var Queue = function(initial = []) {
  let xs = initial.slice();
  let index = 0;
  return {
    get length() {
      return xs.length - index;
    },
    remove: (x) => {
      const index2 = xs.indexOf(x);
      return index2 === -1 ? null : (xs.splice(index2, 1), x);
    },
    push: (x) => (xs.push(x), x),
    shift: () => {
      const out = xs[index++];
      if (index === xs.length) {
        index = 0;
        xs = [];
      } else {
        xs[index - 1] = undefined;
      }
      return out;
    }
  };
};
var queue_default = Queue;

// node_modules/postgres/src/bytes.js
var fit = function(x) {
  if (buffer.length - b.i < x) {
    const prev = buffer, length = prev.length;
    buffer = Buffer.allocUnsafe(length + (length >> 1) + x);
    prev.copy(buffer);
  }
};
var reset = function() {
  b.i = 0;
  return b;
};
var size = 256;
var buffer = Buffer.allocUnsafe(size);
var messages = "BCcDdEFfHPpQSX".split("").reduce((acc, x) => {
  const v = x.charCodeAt(0);
  acc[x] = () => {
    buffer[0] = v;
    b.i = 5;
    return b;
  };
  return acc;
}, {});
var b = Object.assign(reset, messages, {
  N: String.fromCharCode(0),
  i: 0,
  inc(x) {
    b.i += x;
    return b;
  },
  str(x) {
    const length = Buffer.byteLength(x);
    fit(length);
    b.i += buffer.write(x, b.i, length, "utf8");
    return b;
  },
  i16(x) {
    fit(2);
    buffer.writeUInt16BE(x, b.i);
    b.i += 2;
    return b;
  },
  i32(x, i) {
    if (i || i === 0) {
      buffer.writeUInt32BE(x, i);
      return b;
    }
    fit(4);
    buffer.writeUInt32BE(x, b.i);
    b.i += 4;
    return b;
  },
  z(x) {
    fit(x);
    buffer.fill(0, b.i, b.i + x);
    b.i += x;
    return b;
  },
  raw(x) {
    buffer = Buffer.concat([buffer.subarray(0, b.i), x]);
    b.i = buffer.length;
    return b;
  },
  end(at = 1) {
    buffer.writeUInt32BE(b.i - at, at);
    const out = buffer.subarray(0, b.i);
    b.i = 0;
    buffer = Buffer.allocUnsafe(size);
    return out;
  }
});
var bytes_default = b;

// node_modules/postgres/src/connection.js
var Connection = function(options, queues = {}, { onopen = noop, onend = noop, onclose = noop } = {}) {
  const {
    ssl,
    max,
    user,
    host,
    port,
    database,
    parsers: parsers2,
    transform,
    onnotice,
    onnotify,
    onparameter,
    max_pipeline,
    keep_alive,
    backoff,
    target_session_attrs
  } = options;
  const sent = queue_default(), id = uid++, backend = { pid: null, secret: null }, idleTimer = timer(end, options.idle_timeout), lifeTimer = timer(end, options.max_lifetime), connectTimer = timer(connectTimedOut, options.connect_timeout);
  let socket = null, cancelMessage, result2 = new Result, incoming = Buffer.alloc(0), needsTypes = options.fetch_types, backendParameters = {}, statements = {}, statementId = Math.random().toString(36).slice(2), statementCount = 1, closedDate = 0, remaining = 0, hostIndex = 0, retries = 0, length = 0, delay = 0, rows = 0, serverSignature = null, nextWriteTimer = null, terminated = false, incomings = null, results = null, initial = null, ending = null, stream = null, chunk = null, ended = null, nonce = null, query3 = null, final = null;
  const connection2 = {
    queue: queues.closed,
    idleTimer,
    connect(query4) {
      initial = query4;
      reconnect();
    },
    terminate,
    execute,
    cancel,
    end,
    count: 0,
    id
  };
  queues.closed && queues.closed.push(connection2);
  return connection2;
  async function createSocket() {
    let x;
    try {
      x = options.socket ? await Promise.resolve(options.socket(options)) : net.Socket();
    } catch (e) {
      error(e);
      return;
    }
    x.on("error", error);
    x.on("close", closed);
    x.on("drain", drain);
    return x;
  }
  async function cancel({ pid, secret }, resolve, reject) {
    try {
      cancelMessage = bytes_default().i32(16).i32(80877102).i32(pid).i32(secret).end(16);
      await connect();
      socket.once("error", reject);
      socket.once("close", resolve);
    } catch (error2) {
      reject(error2);
    }
  }
  function execute(q) {
    if (terminated)
      return queryError(q, Errors.connection("CONNECTION_DESTROYED", options));
    if (q.cancelled)
      return;
    try {
      q.state = backend;
      query3 ? sent.push(q) : (query3 = q, query3.active = true);
      build(q);
      return write(toBuffer(q)) && !q.describeFirst && !q.cursorFn && sent.length < max_pipeline && (!q.options.onexecute || q.options.onexecute(connection2));
    } catch (error2) {
      sent.length === 0 && write(Sync);
      errored(error2);
      return true;
    }
  }
  function toBuffer(q) {
    if (q.parameters.length >= 65534)
      throw Errors.generic("MAX_PARAMETERS_EXCEEDED", "Max number of parameters (65534) exceeded");
    return q.options.simple ? bytes_default().Q().str(q.statement.string + bytes_default.N).end() : q.describeFirst ? Buffer.concat([describe(q), Flush]) : q.prepare ? q.prepared ? prepared(q) : Buffer.concat([describe(q), prepared(q)]) : unnamed(q);
  }
  function describe(q) {
    return Buffer.concat([
      Parse(q.statement.string, q.parameters, q.statement.types, q.statement.name),
      Describe("S", q.statement.name)
    ]);
  }
  function prepared(q) {
    return Buffer.concat([
      Bind(q.parameters, q.statement.types, q.statement.name, q.cursorName),
      q.cursorFn ? Execute("", q.cursorRows) : ExecuteUnnamed
    ]);
  }
  function unnamed(q) {
    return Buffer.concat([
      Parse(q.statement.string, q.parameters, q.statement.types),
      DescribeUnnamed,
      prepared(q)
    ]);
  }
  function build(q) {
    const parameters = [], types4 = [];
    const string = stringify2(q, q.strings[0], q.args[0], parameters, types4, options);
    !q.tagged && q.args.forEach((x) => handleValue(x, parameters, types4, options));
    q.prepare = options.prepare && ("prepare" in q.options ? q.options.prepare : true);
    q.string = string;
    q.signature = q.prepare && types4 + string;
    q.onlyDescribe && delete statements[q.signature];
    q.parameters = q.parameters || parameters;
    q.prepared = q.prepare && (q.signature in statements);
    q.describeFirst = q.onlyDescribe || parameters.length && !q.prepared;
    q.statement = q.prepared ? statements[q.signature] : { string, types: types4, name: q.prepare ? statementId + statementCount++ : "" };
    typeof options.debug === "function" && options.debug(id, string, parameters, types4);
  }
  function write(x, fn) {
    chunk = chunk ? Buffer.concat([chunk, x]) : Buffer.from(x);
    if (fn || chunk.length >= 1024)
      return nextWrite(fn);
    nextWriteTimer === null && (nextWriteTimer = setImmediate(nextWrite));
    return true;
  }
  function nextWrite(fn) {
    const x = socket.write(chunk, fn);
    nextWriteTimer !== null && clearImmediate(nextWriteTimer);
    chunk = nextWriteTimer = null;
    return x;
  }
  function connectTimedOut() {
    errored(Errors.connection("CONNECT_TIMEOUT", options, socket));
    socket.destroy();
  }
  async function secure() {
    write(SSLRequest);
    const canSSL = await new Promise((r) => socket.once("data", (x) => r(x[0] === 83)));
    if (!canSSL && ssl === "prefer")
      return connected();
    socket.removeAllListeners();
    socket = tls.connect({
      socket,
      servername: net.isIP(socket.host) ? undefined : socket.host,
      ...ssl === "require" || ssl === "allow" || ssl === "prefer" ? { rejectUnauthorized: false } : ssl === "verify-full" ? {} : typeof ssl === "object" ? ssl : {}
    });
    socket.on("secureConnect", connected);
    socket.on("error", error);
    socket.on("close", closed);
    socket.on("drain", drain);
  }
  function drain() {
    !query3 && onopen(connection2);
  }
  function data(x) {
    if (incomings) {
      incomings.push(x);
      remaining -= x.length;
      if (remaining >= 0)
        return;
    }
    incoming = incomings ? Buffer.concat(incomings, length - remaining) : incoming.length === 0 ? x : Buffer.concat([incoming, x], incoming.length + x.length);
    while (incoming.length > 4) {
      length = incoming.readUInt32BE(1);
      if (length >= incoming.length) {
        remaining = length - incoming.length;
        incomings = [incoming];
        break;
      }
      try {
        handle(incoming.subarray(0, length + 1));
      } catch (e) {
        query3 && (query3.cursorFn || query3.describeFirst) && write(Sync);
        errored(e);
      }
      incoming = incoming.subarray(length + 1);
      remaining = 0;
      incomings = null;
    }
  }
  async function connect() {
    terminated = false;
    backendParameters = {};
    socket || (socket = await createSocket());
    if (!socket)
      return;
    connectTimer.start();
    if (options.socket)
      return ssl ? secure() : connected();
    socket.on("connect", ssl ? secure : connected);
    if (options.path)
      return socket.connect(options.path);
    socket.connect(port[hostIndex], host[hostIndex]);
    socket.host = host[hostIndex];
    socket.port = port[hostIndex];
    hostIndex = (hostIndex + 1) % port.length;
  }
  function reconnect() {
    setTimeout(connect, closedDate ? closedDate + delay - Number(process.hrtime.bigint() / 1000000n) : 0);
  }
  function connected() {
    try {
      statements = {};
      needsTypes = options.fetch_types;
      statementId = Math.random().toString(36).slice(2);
      statementCount = 1;
      lifeTimer.start();
      socket.on("data", data);
      keep_alive && socket.setKeepAlive && socket.setKeepAlive(true, 1000 * keep_alive);
      const s = StartupMessage();
      write(s);
    } catch (err) {
      error(err);
    }
  }
  function error(err) {
    if (connection2.queue === queues.connecting && options.host[retries + 1])
      return;
    errored(err);
    while (sent.length)
      queryError(sent.shift(), err);
  }
  function errored(err) {
    stream && (stream.destroy(err), stream = null);
    query3 && queryError(query3, err);
    initial && (queryError(initial, err), initial = null);
  }
  function queryError(query4, err) {
    query4.reject(Object.create(err, {
      stack: { value: err.stack + query4.origin.replace(/.*\n/, "\n"), enumerable: options.debug },
      query: { value: query4.string, enumerable: options.debug },
      parameters: { value: query4.parameters, enumerable: options.debug },
      args: { value: query4.args, enumerable: options.debug },
      types: { value: query4.statement && query4.statement.types, enumerable: options.debug }
    }));
  }
  function end() {
    return ending || (!connection2.reserved && onend(connection2), !connection2.reserved && !initial && !query3 && sent.length === 0 ? (terminate(), new Promise((r) => socket && socket.readyState !== "closed" ? socket.once("close", r) : r())) : ending = new Promise((r) => ended = r));
  }
  function terminate() {
    terminated = true;
    if (stream || query3 || initial || sent.length)
      error(Errors.connection("CONNECTION_DESTROYED", options));
    clearImmediate(nextWriteTimer);
    if (socket) {
      socket.removeListener("data", data);
      socket.removeListener("connect", connected);
      socket.readyState === "open" && socket.end(bytes_default().X().end());
    }
    ended && (ended(), ending = ended = null);
  }
  async function closed(hadError) {
    incoming = Buffer.alloc(0);
    remaining = 0;
    incomings = null;
    clearImmediate(nextWriteTimer);
    socket.removeListener("data", data);
    socket.removeListener("connect", connected);
    idleTimer.cancel();
    lifeTimer.cancel();
    connectTimer.cancel();
    if (socket.encrypted) {
      socket.removeAllListeners();
      socket = null;
    }
    if (initial)
      return reconnect();
    !hadError && (query3 || sent.length) && error(Errors.connection("CONNECTION_CLOSED", options, socket));
    closedDate = Number(process.hrtime.bigint() / 1000000n);
    hadError && options.shared.retries++;
    delay = (typeof backoff === "function" ? backoff(options.shared.retries) : backoff) * 1000;
    onclose(connection2);
  }
  function handle(xs, x = xs[0]) {
    (x === 68 ? DataRow : x === 100 ? CopyData : x === 65 ? NotificationResponse : x === 83 ? ParameterStatus : x === 90 ? ReadyForQuery : x === 67 ? CommandComplete : x === 50 ? BindComplete : x === 49 ? ParseComplete : x === 116 ? ParameterDescription : x === 84 ? RowDescription : x === 82 ? Authentication : x === 110 ? NoData : x === 75 ? BackendKeyData : x === 69 ? ErrorResponse : x === 115 ? PortalSuspended : x === 51 ? CloseComplete : x === 71 ? CopyInResponse : x === 78 ? NoticeResponse : x === 72 ? CopyOutResponse : x === 99 ? CopyDone : x === 73 ? EmptyQueryResponse : x === 86 ? FunctionCallResponse : x === 118 ? NegotiateProtocolVersion : x === 87 ? CopyBothResponse : UnknownMessage)(xs);
  }
  function DataRow(x) {
    let index = 7;
    let length2;
    let column;
    let value;
    const row = query3.isRaw ? new Array(query3.statement.columns.length) : {};
    for (let i = 0;i < query3.statement.columns.length; i++) {
      column = query3.statement.columns[i];
      length2 = x.readInt32BE(index);
      index += 4;
      value = length2 === -1 ? null : query3.isRaw === true ? x.subarray(index, index += length2) : column.parser === undefined ? x.toString("utf8", index, index += length2) : column.parser.array === true ? column.parser(x.toString("utf8", index + 1, index += length2)) : column.parser(x.toString("utf8", index, index += length2));
      query3.isRaw ? row[i] = query3.isRaw === true ? value : transform.value.from ? transform.value.from(value, column) : value : row[column.name] = transform.value.from ? transform.value.from(value, column) : value;
    }
    query3.forEachFn ? query3.forEachFn(transform.row.from ? transform.row.from(row) : row, result2) : result2[rows++] = transform.row.from ? transform.row.from(row) : row;
  }
  function ParameterStatus(x) {
    const [k, v] = x.toString("utf8", 5, x.length - 1).split(bytes_default.N);
    backendParameters[k] = v;
    if (options.parameters[k] !== v) {
      options.parameters[k] = v;
      onparameter && onparameter(k, v);
    }
  }
  function ReadyForQuery(x) {
    query3 && query3.options.simple && query3.resolve(results || result2);
    query3 = results = null;
    result2 = new Result;
    connectTimer.cancel();
    if (initial) {
      if (target_session_attrs) {
        if (!backendParameters.in_hot_standby || !backendParameters.default_transaction_read_only)
          return fetchState();
        else if (tryNext(target_session_attrs, backendParameters))
          return terminate();
      }
      if (needsTypes)
        return fetchArrayTypes();
      execute(initial);
      options.shared.retries = retries = initial = 0;
      return;
    }
    while (sent.length && (query3 = sent.shift()) && (query3.active = true, query3.cancelled))
      Connection(options).cancel(query3.state, query3.cancelled.resolve, query3.cancelled.reject);
    if (query3)
      return;
    connection2.reserved ? x[5] === 73 ? ending ? terminate() : (connection2.reserved = null, onopen(connection2)) : connection2.reserved() : ending ? terminate() : onopen(connection2);
  }
  function CommandComplete(x) {
    rows = 0;
    for (let i = x.length - 1;i > 0; i--) {
      if (x[i] === 32 && x[i + 1] < 58 && result2.count === null)
        result2.count = +x.toString("utf8", i + 1, x.length - 1);
      if (x[i - 1] >= 65) {
        result2.command = x.toString("utf8", 5, i);
        result2.state = backend;
        break;
      }
    }
    final && (final(), final = null);
    if (result2.command === "BEGIN" && max !== 1 && !connection2.reserved)
      return errored(Errors.generic("UNSAFE_TRANSACTION", "Only use sql.begin or max: 1"));
    if (query3.options.simple)
      return BindComplete();
    if (query3.cursorFn) {
      result2.count && query3.cursorFn(result2);
      write(Sync);
    }
    query3.resolve(result2);
  }
  function ParseComplete() {
    query3.parsing = false;
  }
  function BindComplete() {
    !result2.statement && (result2.statement = query3.statement);
    result2.columns = query3.statement.columns;
  }
  function ParameterDescription(x) {
    const length2 = x.readUInt16BE(5);
    for (let i = 0;i < length2; ++i)
      !query3.statement.types[i] && (query3.statement.types[i] = x.readUInt32BE(7 + i * 4));
    query3.prepare && (statements[query3.signature] = query3.statement);
    query3.describeFirst && !query3.onlyDescribe && (write(prepared(query3)), query3.describeFirst = false);
  }
  function RowDescription(x) {
    if (result2.command) {
      results = results || [result2];
      results.push(result2 = new Result);
      result2.count = null;
      query3.statement.columns = null;
    }
    const length2 = x.readUInt16BE(5);
    let index = 7;
    let start;
    query3.statement.columns = Array(length2);
    for (let i = 0;i < length2; ++i) {
      start = index;
      while (x[index++] !== 0)
        ;
      const table = x.readUInt32BE(index);
      const number = x.readUInt16BE(index + 4);
      const type = x.readUInt32BE(index + 6);
      query3.statement.columns[i] = {
        name: transform.column.from ? transform.column.from(x.toString("utf8", start, index - 1)) : x.toString("utf8", start, index - 1),
        parser: parsers2[type],
        table,
        number,
        type
      };
      index += 18;
    }
    result2.statement = query3.statement;
    if (query3.onlyDescribe)
      return query3.resolve(query3.statement), write(Sync);
  }
  async function Authentication(x, type = x.readUInt32BE(5)) {
    (type === 3 ? AuthenticationCleartextPassword : type === 5 ? AuthenticationMD5Password : type === 10 ? SASL : type === 11 ? SASLContinue : type === 12 ? SASLFinal : type !== 0 ? UnknownAuth : noop)(x, type);
  }
  async function AuthenticationCleartextPassword() {
    write(bytes_default().p().str(await Pass()).z(1).end());
  }
  async function AuthenticationMD5Password(x) {
    write(bytes_default().p().str("md5" + md5(Buffer.concat([Buffer.from(md5(await Pass() + user)), x.subarray(9)]))).z(1).end());
  }
  function SASL() {
    bytes_default().p().str("SCRAM-SHA-256" + bytes_default.N);
    const i = bytes_default.i;
    nonce = crypto2.randomBytes(18).toString("base64");
    write(bytes_default.inc(4).str("n,,n=*,r=" + nonce).i32(bytes_default.i - i - 4, i).end());
  }
  async function SASLContinue(x) {
    const res = x.toString("utf8", 9).split(",").reduce((acc, x2) => (acc[x2[0]] = x2.slice(2), acc), {});
    const saltedPassword = crypto2.pbkdf2Sync(await Pass(), Buffer.from(res.s, "base64"), parseInt(res.i), 32, "sha256");
    const clientKey = hmac(saltedPassword, "Client Key");
    const auth = "n=*,r=" + nonce + ",r=" + res.r + ",s=" + res.s + ",i=" + res.i + ",c=biws,r=" + res.r;
    serverSignature = hmac(hmac(saltedPassword, "Server Key"), auth).toString("base64");
    write(bytes_default().p().str("c=biws,r=" + res.r + ",p=" + xor(clientKey, hmac(sha256(clientKey), auth)).toString("base64")).end());
  }
  function SASLFinal(x) {
    if (x.toString("utf8", 9).split(bytes_default.N, 1)[0].slice(2) === serverSignature)
      return;
    errored(Errors.generic("SASL_SIGNATURE_MISMATCH", "The server did not return the correct signature"));
    socket.destroy();
  }
  function Pass() {
    return Promise.resolve(typeof options.pass === "function" ? options.pass() : options.pass);
  }
  function NoData() {
    result2.statement = query3.statement;
    result2.statement.columns = [];
    if (query3.onlyDescribe)
      return query3.resolve(query3.statement), write(Sync);
  }
  function BackendKeyData(x) {
    backend.pid = x.readUInt32BE(5);
    backend.secret = x.readUInt32BE(9);
  }
  async function fetchArrayTypes() {
    needsTypes = false;
    const types4 = await new Query([`
      select b.oid, b.typarray
      from pg_catalog.pg_type a
      left join pg_catalog.pg_type b on b.oid = a.typelem
      where a.typcategory = 'A'
      group by b.oid, b.typarray
      order by b.oid
    `], [], execute);
    types4.forEach(({ oid, typarray }) => addArrayType(oid, typarray));
  }
  function addArrayType(oid, typarray) {
    if (!!options.parsers[typarray] && !!options.serializers[typarray])
      return;
    const parser = options.parsers[oid];
    options.shared.typeArrayMap[oid] = typarray;
    options.parsers[typarray] = (xs) => arrayParser(xs, parser, typarray);
    options.parsers[typarray].array = true;
    options.serializers[typarray] = (xs) => arraySerializer(xs, options.serializers[oid], options, typarray);
  }
  function tryNext(x, xs) {
    return x === "read-write" && xs.default_transaction_read_only === "on" || x === "read-only" && xs.default_transaction_read_only === "off" || x === "primary" && xs.in_hot_standby === "on" || x === "standby" && xs.in_hot_standby === "off" || x === "prefer-standby" && xs.in_hot_standby === "off" && options.host[retries];
  }
  function fetchState() {
    const query4 = new Query([`
      show transaction_read_only;
      select pg_catalog.pg_is_in_recovery()
    `], [], execute, null, { simple: true });
    query4.resolve = ([[a], [b2]]) => {
      backendParameters.default_transaction_read_only = a.transaction_read_only;
      backendParameters.in_hot_standby = b2.pg_is_in_recovery ? "on" : "off";
    };
    query4.execute();
  }
  function ErrorResponse(x) {
    query3 && (query3.cursorFn || query3.describeFirst) && write(Sync);
    const error2 = Errors.postgres(parseError(x));
    query3 && query3.retried ? errored(query3.retried) : query3 && retryRoutines.has(error2.routine) ? retry(query3, error2) : errored(error2);
  }
  function retry(q, error2) {
    delete statements[q.signature];
    q.retried = error2;
    execute(q);
  }
  function NotificationResponse(x) {
    if (!onnotify)
      return;
    let index = 9;
    while (x[index++] !== 0)
      ;
    onnotify(x.toString("utf8", 9, index - 1), x.toString("utf8", index, x.length - 1));
  }
  async function PortalSuspended() {
    try {
      const x = await Promise.resolve(query3.cursorFn(result2));
      rows = 0;
      x === CLOSE ? write(Close(query3.portal)) : (result2 = new Result, write(Execute("", query3.cursorRows)));
    } catch (err) {
      write(Sync);
      query3.reject(err);
    }
  }
  function CloseComplete() {
    result2.count && query3.cursorFn(result2);
    query3.resolve(result2);
  }
  function CopyInResponse() {
    stream = new Stream.Writable({
      autoDestroy: true,
      write(chunk2, encoding, callback) {
        socket.write(bytes_default().d().raw(chunk2).end(), callback);
      },
      destroy(error2, callback) {
        callback(error2);
        socket.write(bytes_default().f().str(error2 + bytes_default.N).end());
        stream = null;
      },
      final(callback) {
        socket.write(bytes_default().c().end());
        final = callback;
      }
    });
    query3.resolve(stream);
  }
  function CopyOutResponse() {
    stream = new Stream.Readable({
      read() {
        socket.resume();
      }
    });
    query3.resolve(stream);
  }
  function CopyBothResponse() {
    stream = new Stream.Duplex({
      autoDestroy: true,
      read() {
        socket.resume();
      },
      write(chunk2, encoding, callback) {
        socket.write(bytes_default().d().raw(chunk2).end(), callback);
      },
      destroy(error2, callback) {
        callback(error2);
        socket.write(bytes_default().f().str(error2 + bytes_default.N).end());
        stream = null;
      },
      final(callback) {
        socket.write(bytes_default().c().end());
        final = callback;
      }
    });
    query3.resolve(stream);
  }
  function CopyData(x) {
    stream && (stream.push(x.subarray(5)) || socket.pause());
  }
  function CopyDone() {
    stream && stream.push(null);
    stream = null;
  }
  function NoticeResponse(x) {
    onnotice ? onnotice(parseError(x)) : console.log(parseError(x));
  }
  function EmptyQueryResponse() {
  }
  function FunctionCallResponse() {
    errored(Errors.notSupported("FunctionCallResponse"));
  }
  function NegotiateProtocolVersion() {
    errored(Errors.notSupported("NegotiateProtocolVersion"));
  }
  function UnknownMessage(x) {
    console.error("Postgres.js : Unknown Message:", x[0]);
  }
  function UnknownAuth(x, type) {
    console.error("Postgres.js : Unknown Auth:", type);
  }
  function Bind(parameters, types4, statement = "", portal = "") {
    let prev, type;
    bytes_default().B().str(portal + bytes_default.N).str(statement + bytes_default.N).i16(0).i16(parameters.length);
    parameters.forEach((x, i) => {
      if (x === null)
        return bytes_default.i32(4294967295);
      type = types4[i];
      parameters[i] = x = (type in options.serializers) ? options.serializers[type](x) : "" + x;
      prev = bytes_default.i;
      bytes_default.inc(4).str(x).i32(bytes_default.i - prev - 4, prev);
    });
    bytes_default.i16(0);
    return bytes_default.end();
  }
  function Parse(str, parameters, types4, name = "") {
    bytes_default().P().str(name + bytes_default.N).str(str + bytes_default.N).i16(parameters.length);
    parameters.forEach((x, i) => bytes_default.i32(types4[i] || 0));
    return bytes_default.end();
  }
  function Describe(x, name = "") {
    return bytes_default().D().str(x).str(name + bytes_default.N).end();
  }
  function Execute(portal = "", rows2 = 0) {
    return Buffer.concat([
      bytes_default().E().str(portal + bytes_default.N).i32(rows2).end(),
      Flush
    ]);
  }
  function Close(portal = "") {
    return Buffer.concat([
      bytes_default().C().str("P").str(portal + bytes_default.N).end(),
      bytes_default().S().end()
    ]);
  }
  function StartupMessage() {
    return cancelMessage || bytes_default().inc(4).i16(3).z(2).str(Object.entries(Object.assign({
      user,
      database,
      client_encoding: "UTF8"
    }, options.connection)).filter(([, v]) => v).map(([k, v]) => k + bytes_default.N + v).join(bytes_default.N)).z(2).end(0);
  }
};
var parseError = function(x) {
  const error = {};
  let start = 5;
  for (let i = 5;i < x.length - 1; i++) {
    if (x[i] === 0) {
      error[errorFields[x[start]]] = x.toString("utf8", start + 1, i);
      start = i + 1;
    }
  }
  return error;
};
var md5 = function(x) {
  return crypto2.createHash("md5").update(x).digest("hex");
};
var hmac = function(key, x) {
  return crypto2.createHmac("sha256", key).update(x).digest();
};
var sha256 = function(x) {
  return crypto2.createHash("sha256").update(x).digest();
};
var xor = function(a, b2) {
  const length = Math.max(a.length, b2.length);
  const buffer2 = Buffer.allocUnsafe(length);
  for (let i = 0;i < length; i++)
    buffer2[i] = a[i] ^ b2[i];
  return buffer2;
};
var timer = function(fn, seconds) {
  seconds = typeof seconds === "function" ? seconds() : seconds;
  if (!seconds)
    return { cancel: noop, start: noop };
  let timer2;
  return {
    cancel() {
      timer2 && (clearTimeout(timer2), timer2 = null);
    },
    start() {
      timer2 && clearTimeout(timer2);
      timer2 = setTimeout(done, seconds * 1000, arguments);
    }
  };
  function done(args) {
    fn.apply(null, args);
    timer2 = null;
  }
};
var connection_default = Connection;
var uid = 1;
var Sync = bytes_default().S().end();
var Flush = bytes_default().H().end();
var SSLRequest = bytes_default().i32(8).i32(80877103).end(8);
var ExecuteUnnamed = Buffer.concat([bytes_default().E().str(bytes_default.N).i32(0).end(), Sync]);
var DescribeUnnamed = bytes_default().D().str("S").str(bytes_default.N).end();
var noop = () => {
};
var retryRoutines = new Set([
  "FetchPreparedStatement",
  "RevalidateCachedQuery",
  "transformAssignedExpr"
]);
var errorFields = {
  83: "severity_local",
  86: "severity",
  67: "code",
  77: "message",
  68: "detail",
  72: "hint",
  80: "position",
  112: "internal_position",
  113: "internal_query",
  87: "where",
  115: "schema_name",
  116: "table_name",
  99: "column_name",
  100: "data type_name",
  110: "constraint_name",
  70: "file",
  76: "line",
  82: "routine"
};

// node_modules/postgres/src/subscribe.js
var Time = function(x) {
  return new Date(Date.UTC(2000, 0, 1) + Number(x / BigInt(1000)));
};
var parse3 = function(x, state, parsers2, handle, transform) {
  const char = (acc, [k, v]) => (acc[k.charCodeAt(0)] = v, acc);
  Object.entries({
    R: (x2) => {
      let i = 1;
      const r = state[x2.readUInt32BE(i)] = {
        schema: x2.toString("utf8", i += 4, i = x2.indexOf(0, i)) || "pg_catalog",
        table: x2.toString("utf8", i + 1, i = x2.indexOf(0, i + 1)),
        columns: Array(x2.readUInt16BE(i += 2)),
        keys: []
      };
      i += 2;
      let columnIndex = 0, column;
      while (i < x2.length) {
        column = r.columns[columnIndex++] = {
          key: x2[i++],
          name: transform.column.from ? transform.column.from(x2.toString("utf8", i, i = x2.indexOf(0, i))) : x2.toString("utf8", i, i = x2.indexOf(0, i)),
          type: x2.readUInt32BE(i += 1),
          parser: parsers2[x2.readUInt32BE(i)],
          atttypmod: x2.readUInt32BE(i += 4)
        };
        column.key && r.keys.push(column);
        i += 4;
      }
    },
    Y: () => {
    },
    O: () => {
    },
    B: (x2) => {
      state.date = Time(x2.readBigInt64BE(9));
      state.lsn = x2.subarray(1, 9);
    },
    I: (x2) => {
      let i = 1;
      const relation = state[x2.readUInt32BE(i)];
      const { row } = tuples(x2, relation.columns, i += 7, transform);
      handle(row, {
        command: "insert",
        relation
      });
    },
    D: (x2) => {
      let i = 1;
      const relation = state[x2.readUInt32BE(i)];
      i += 4;
      const key = x2[i] === 75;
      handle(key || x2[i] === 79 ? tuples(x2, key ? relation.keys : relation.columns, i += 3, transform).row : null, {
        command: "delete",
        relation,
        key
      });
    },
    U: (x2) => {
      let i = 1;
      const relation = state[x2.readUInt32BE(i)];
      i += 4;
      const key = x2[i] === 75;
      const xs = key || x2[i] === 79 ? tuples(x2, key ? relation.keys : relation.columns, i += 3, transform) : null;
      xs && (i = xs.i);
      const { row } = tuples(x2, relation.columns, i + 3, transform);
      handle(row, {
        command: "update",
        relation,
        key,
        old: xs && xs.row
      });
    },
    T: () => {
    },
    C: () => {
    }
  }).reduce(char, {})[x[0]](x);
};
var tuples = function(x, columns, xi, transform) {
  let type, column, value;
  const row = transform.raw ? new Array(columns.length) : {};
  for (let i = 0;i < columns.length; i++) {
    type = x[xi++];
    column = columns[i];
    value = type === 110 ? null : type === 117 ? undefined : column.parser === undefined ? x.toString("utf8", xi + 4, xi += 4 + x.readUInt32BE(xi)) : column.parser.array === true ? column.parser(x.toString("utf8", xi + 5, xi += 4 + x.readUInt32BE(xi))) : column.parser(x.toString("utf8", xi + 4, xi += 4 + x.readUInt32BE(xi)));
    transform.raw ? row[i] = transform.raw === true ? value : transform.value.from ? transform.value.from(value, column) : value : row[column.name] = transform.value.from ? transform.value.from(value, column) : value;
  }
  return { i: xi, row: transform.row.from ? transform.row.from(row) : row };
};
var parseEvent = function(x) {
  const xs = x.match(/^(\*|insert|update|delete)?:?([^.]+?\.?[^=]+)?=?(.+)?/i) || [];
  if (!xs)
    throw new Error("Malformed subscribe pattern: " + x);
  const [, command, path, key] = xs;
  return (command || "*") + (path ? ":" + (path.indexOf(".") === -1 ? "public." + path : path) : "") + (key ? "=" + key : "");
};
var noop2 = () => {
};
function Subscribe(postgres2, options) {
  const subscribers = new Map, slot = "postgresjs_" + Math.random().toString(36).slice(2), state = {};
  let connection2, stream, ended = false;
  const sql = subscribe.sql = postgres2({
    ...options,
    transform: { column: {}, value: {}, row: {} },
    max: 1,
    fetch_types: false,
    idle_timeout: null,
    max_lifetime: null,
    connection: {
      ...options.connection,
      replication: "database"
    },
    onclose: async function() {
      if (ended)
        return;
      stream = null;
      state.pid = state.secret = undefined;
      connected(await init(sql, slot, options.publications));
      subscribers.forEach((event) => event.forEach(({ onsubscribe }) => onsubscribe()));
    },
    no_subscribe: true
  });
  const { end, close } = sql;
  sql.end = async () => {
    ended = true;
    stream && await new Promise((r) => (stream.once("close", r), stream.end()));
    return end();
  };
  sql.close = async () => {
    stream && await new Promise((r) => (stream.once("close", r), stream.end()));
    return close();
  };
  return subscribe;
  async function subscribe(event, fn, onsubscribe = noop2) {
    event = parseEvent(event);
    if (!connection2)
      connection2 = init(sql, slot, options.publications);
    const subscriber = { fn, onsubscribe };
    const fns = subscribers.has(event) ? subscribers.get(event).add(subscriber) : subscribers.set(event, new Set([subscriber])).get(event);
    const unsubscribe = () => {
      fns.delete(subscriber);
      fns.size === 0 && subscribers.delete(event);
    };
    return connection2.then((x) => {
      connected(x);
      onsubscribe();
      return { unsubscribe, state, sql };
    });
  }
  function connected(x) {
    stream = x.stream;
    state.pid = x.state.pid;
    state.secret = x.state.secret;
  }
  async function init(sql2, slot2, publications) {
    if (!publications)
      throw new Error("Missing publication names");
    const xs = await sql2.unsafe(`CREATE_REPLICATION_SLOT ${slot2} TEMPORARY LOGICAL pgoutput NOEXPORT_SNAPSHOT`);
    const [x] = xs;
    const stream2 = await sql2.unsafe(`START_REPLICATION SLOT ${slot2} LOGICAL ${x.consistent_point} (proto_version '1', publication_names '${publications}')`).writable();
    const state2 = {
      lsn: Buffer.concat(x.consistent_point.split("/").map((x2) => Buffer.from(("00000000" + x2).slice(-8), "hex")))
    };
    stream2.on("data", data);
    stream2.on("error", sql2.close);
    stream2.on("close", sql2.close);
    return { stream: stream2, state: xs.state };
    function data(x2) {
      if (x2[0] === 119)
        parse3(x2.subarray(25), state2, sql2.options.parsers, handle, options.transform);
      else if (x2[0] === 107 && x2[17])
        pong();
    }
    function handle(a, b2) {
      const path = b2.relation.schema + "." + b2.relation.table;
      call("*", a, b2);
      call("*:" + path, a, b2);
      b2.relation.keys.length && call("*:" + path + "=" + b2.relation.keys.map((x2) => a[x2.name]), a, b2);
      call(b2.command, a, b2);
      call(b2.command + ":" + path, a, b2);
      b2.relation.keys.length && call(b2.command + ":" + path + "=" + b2.relation.keys.map((x2) => a[x2.name]), a, b2);
    }
    function pong() {
      const x2 = Buffer.alloc(34);
      x2[0] = "r".charCodeAt(0);
      x2.fill(state2.lsn, 1);
      x2.writeBigInt64BE(BigInt(Date.now() - Date.UTC(2000, 0, 1)) * BigInt(1000), 25);
      stream2.write(x2);
    }
  }
  function call(x, a, b2) {
    subscribers.has(x) && subscribers.get(x).forEach(({ fn }) => fn(a, b2, x));
  }
}

// node_modules/postgres/src/large.js
import Stream2 from "stream";
function largeObject(sql, oid, mode = 131072 | 262144) {
  return new Promise(async (resolve, reject) => {
    await sql.begin(async (sql2) => {
      let finish;
      !oid && ([{ oid }] = await sql2`select lo_creat(-1) as oid`);
      const [{ fd }] = await sql2`select lo_open(${oid}, ${mode}) as fd`;
      const lo = {
        writable,
        readable,
        close: () => sql2`select lo_close(${fd})`.then(finish),
        tell: () => sql2`select lo_tell64(${fd})`,
        read: (x) => sql2`select loread(${fd}, ${x}) as data`,
        write: (x) => sql2`select lowrite(${fd}, ${x})`,
        truncate: (x) => sql2`select lo_truncate64(${fd}, ${x})`,
        seek: (x, whence = 0) => sql2`select lo_lseek64(${fd}, ${x}, ${whence})`,
        size: () => sql2`
          select
            lo_lseek64(${fd}, location, 0) as position,
            seek.size
          from (
            select
              lo_lseek64($1, 0, 2) as size,
              tell.location
            from (select lo_tell64($1) as location) tell
          ) seek
        `
      };
      resolve(lo);
      return new Promise(async (r) => finish = r);
      async function readable({
        highWaterMark = 2048 * 8,
        start = 0,
        end = Infinity
      } = {}) {
        let max = end - start;
        start && await lo.seek(start);
        return new Stream2.Readable({
          highWaterMark,
          async read(size2) {
            const l = size2 > max ? size2 - max : size2;
            max -= size2;
            const [{ data }] = await lo.read(l);
            this.push(data);
            if (data.length < size2)
              this.push(null);
          }
        });
      }
      async function writable({
        highWaterMark = 2048 * 8,
        start = 0
      } = {}) {
        start && await lo.seek(start);
        return new Stream2.Writable({
          highWaterMark,
          write(chunk, encoding, callback) {
            lo.write(chunk).then(() => callback(), callback);
          }
        });
      }
    }).catch(reject);
  });
}

// node_modules/postgres/src/index.js
var Postgres = function(a, b2) {
  const options = parseOptions(a, b2), subscribe2 = options.no_subscribe || Subscribe(Postgres, { ...options });
  let ending = false;
  const queries = queue_default(), connecting = queue_default(), reserved = queue_default(), closed = queue_default(), ended = queue_default(), open = queue_default(), busy = queue_default(), full = queue_default(), queues = { connecting, reserved, closed, ended, open, busy, full };
  const connections = [...Array(options.max)].map(() => connection_default(options, queues, { onopen, onend, onclose }));
  const sql = Sql(handler);
  Object.assign(sql, {
    get parameters() {
      return options.parameters;
    },
    largeObject: largeObject.bind(null, sql),
    subscribe: subscribe2,
    CLOSE,
    END: CLOSE,
    PostgresError,
    options,
    listen,
    notify,
    begin,
    close,
    end
  });
  return sql;
  function Sql(handler2, instant) {
    handler2.debug = options.debug;
    Object.entries(options.types).reduce((acc, [name, type]) => {
      acc[name] = (x) => new Parameter(x, type.to);
      return acc;
    }, typed);
    Object.assign(sql2, {
      types: typed,
      typed,
      unsafe,
      array,
      json,
      file
    });
    return sql2;
    function typed(value, type) {
      return new Parameter(value, type);
    }
    function sql2(strings, ...args) {
      const query4 = strings && Array.isArray(strings.raw) ? new Query(strings, args, handler2, cancel) : typeof strings === "string" && !args.length ? new Identifier(options.transform.column.to ? options.transform.column.to(strings) : strings) : new Builder(strings, args);
      instant && query4 instanceof Query && query4.execute();
      return query4;
    }
    function unsafe(string, args = [], options2 = {}) {
      arguments.length === 2 && !Array.isArray(args) && (options2 = args, args = []);
      const query4 = new Query([string], args, handler2, cancel, {
        prepare: false,
        ...options2,
        simple: "simple" in options2 ? options2.simple : args.length === 0
      });
      instant && query4.execute();
      return query4;
    }
    function file(path, args = [], options2 = {}) {
      arguments.length === 2 && !Array.isArray(args) && (options2 = args, args = []);
      const query4 = new Query([], args, (query5) => {
        fs.readFile(path, "utf8", (err, string) => {
          if (err)
            return query5.reject(err);
          query5.strings = [string];
          handler2(query5);
        });
      }, cancel, {
        ...options2,
        simple: "simple" in options2 ? options2.simple : args.length === 0
      });
      instant && query4.execute();
      return query4;
    }
  }
  async function listen(name, fn, onlisten) {
    const listener = { fn, onlisten };
    const sql2 = listen.sql || (listen.sql = Postgres({
      ...options,
      max: 1,
      idle_timeout: null,
      max_lifetime: null,
      fetch_types: false,
      onclose() {
        Object.entries(listen.channels).forEach(([name2, { listeners }]) => {
          delete listen.channels[name2];
          Promise.all(listeners.map((l) => listen(name2, l.fn, l.onlisten).catch(() => {
          })));
        });
      },
      onnotify(c, x) {
        (c in listen.channels) && listen.channels[c].listeners.forEach((l) => l.fn(x));
      }
    }));
    const channels = listen.channels || (listen.channels = {}), exists = name in channels;
    if (exists) {
      channels[name].listeners.push(listener);
      const result3 = await channels[name].result;
      listener.onlisten && listener.onlisten();
      return { state: result3.state, unlisten };
    }
    channels[name] = { result: sql2`listen ${sql2.unsafe('"' + name.replace(/"/g, '""') + '"')}`, listeners: [listener] };
    const result2 = await channels[name].result;
    listener.onlisten && listener.onlisten();
    return { state: result2.state, unlisten };
    async function unlisten() {
      if ((name in channels) === false)
        return;
      channels[name].listeners = channels[name].listeners.filter((x) => x !== listener);
      if (channels[name].listeners.length)
        return;
      delete channels[name];
      return sql2`unlisten ${sql2.unsafe('"' + name.replace(/"/g, '""') + '"')}`;
    }
  }
  async function notify(channel, payload) {
    return await sql`select pg_notify(${channel}, ${"" + payload})`;
  }
  async function begin(options2, fn) {
    !fn && (fn = options2, options2 = "");
    const queries2 = queue_default();
    let savepoints = 0, connection3;
    try {
      await sql.unsafe("begin " + options2.replace(/[^a-z ]/ig, ""), [], { onexecute }).execute();
      return await scope(connection3, fn);
    } catch (error) {
      throw error;
    }
    async function scope(c, fn2, name) {
      const sql2 = Sql(handler2);
      sql2.savepoint = savepoint;
      let uncaughtError, result2;
      name && await sql2`savepoint ${sql2(name)}`;
      try {
        result2 = await new Promise((resolve, reject) => {
          const x = fn2(sql2);
          Promise.resolve(Array.isArray(x) ? Promise.all(x) : x).then(resolve, reject);
        });
        if (uncaughtError)
          throw uncaughtError;
      } catch (e) {
        await (name ? sql2`rollback to ${sql2(name)}` : sql2`rollback`);
        throw e instanceof PostgresError && e.code === "25P02" && uncaughtError || e;
      }
      !name && await sql2`commit`;
      return result2;
      function savepoint(name2, fn3) {
        if (name2 && Array.isArray(name2.raw))
          return savepoint((sql3) => sql3.apply(sql3, arguments));
        arguments.length === 1 && (fn3 = name2, name2 = null);
        return scope(c, fn3, "s" + savepoints++ + (name2 ? "_" + name2 : ""));
      }
      function handler2(q) {
        q.catch((e) => uncaughtError || (uncaughtError = e));
        c.queue === full ? queries2.push(q) : c.execute(q) || move(c, full);
      }
    }
    function onexecute(c) {
      connection3 = c;
      move(c, reserved);
      c.reserved = () => queries2.length ? c.execute(queries2.shift()) : move(c, reserved);
    }
  }
  function move(c, queue3) {
    c.queue.remove(c);
    queue3.push(c);
    c.queue = queue3;
    queue3 === open ? c.idleTimer.start() : c.idleTimer.cancel();
  }
  function json(x) {
    return new Parameter(x, 3802);
  }
  function array(x, type) {
    if (!Array.isArray(x))
      return array(Array.from(arguments));
    return new Parameter(x, type || (x.length ? inferType(x) || 25 : 0), options.shared.typeArrayMap);
  }
  function handler(query4) {
    if (ending)
      return query4.reject(Errors.connection("CONNECTION_ENDED", options, options));
    if (open.length)
      return go(open.shift(), query4);
    if (closed.length)
      return connect(closed.shift(), query4);
    busy.length ? go(busy.shift(), query4) : queries.push(query4);
  }
  function go(c, query4) {
    return c.execute(query4) ? move(c, busy) : move(c, full);
  }
  function cancel(query4) {
    return new Promise((resolve, reject) => {
      query4.state ? query4.active ? connection_default(options).cancel(query4.state, resolve, reject) : query4.cancelled = { resolve, reject } : (queries.remove(query4), query4.cancelled = true, query4.reject(Errors.generic("57014", "canceling statement due to user request")), resolve());
    });
  }
  async function end({ timeout = null } = {}) {
    if (ending)
      return ending;
    await 1;
    let timer2;
    return ending = Promise.race([
      new Promise((r) => timeout !== null && (timer2 = setTimeout(destroy, timeout * 1000, r))),
      Promise.all(connections.map((c) => c.end()).concat(listen.sql ? listen.sql.end({ timeout: 0 }) : [], subscribe2.sql ? subscribe2.sql.end({ timeout: 0 }) : []))
    ]).then(() => clearTimeout(timer2));
  }
  async function close() {
    await Promise.all(connections.map((c) => c.end()));
  }
  async function destroy(resolve) {
    await Promise.all(connections.map((c) => c.terminate()));
    while (queries.length)
      queries.shift().reject(Errors.connection("CONNECTION_DESTROYED", options));
    resolve();
  }
  function connect(c, query4) {
    move(c, connecting);
    c.connect(query4);
  }
  function onend(c) {
    move(c, ended);
  }
  function onopen(c) {
    if (queries.length === 0)
      return move(c, open);
    let max = Math.ceil(queries.length / (connecting.length + 1)), ready = true;
    while (ready && queries.length && max-- > 0)
      ready = c.execute(queries.shift());
    ready ? move(c, busy) : move(c, full);
  }
  function onclose(c) {
    move(c, closed);
    c.reserved = null;
    options.onclose && options.onclose(c.id);
    queries.length && connect(c, queries.shift());
  }
};
var parseOptions = function(a, b2) {
  if (a && a.shared)
    return a;
  const env = process.env, o = (typeof a === "string" ? b2 : a) || {}, { url: url7, multihost } = parseUrl(a), query4 = [...url7.searchParams].reduce((a2, [b3, c]) => (a2[b3] = c, a2), {}), host = o.hostname || o.host || multihost || url7.hostname || env.PGHOST || "localhost", port = o.port || url7.port || env.PGPORT || 5432, user = o.user || o.username || url7.username || env.PGUSERNAME || env.PGUSER || osUsername();
  o.no_prepare && (o.prepare = false);
  query4.sslmode && (query4.ssl = query4.sslmode, delete query4.sslmode);
  ("timeout" in o) && (console.log("The timeout option is deprecated, use idle_timeout instead"), o.idle_timeout = o.timeout);
  const defaults = {
    max: 10,
    ssl: false,
    idle_timeout: null,
    connect_timeout: 30,
    max_lifetime,
    max_pipeline: 100,
    backoff,
    keep_alive: 60,
    prepare: true,
    debug: false,
    fetch_types: true,
    publications: "alltables",
    target_session_attrs: null
  };
  return {
    host: Array.isArray(host) ? host : host.split(",").map((x) => x.split(":")[0]),
    port: Array.isArray(port) ? port : host.split(",").map((x) => parseInt(x.split(":")[1] || port)),
    path: o.path || host.indexOf("/") > -1 && host + "/.s.PGSQL." + port,
    database: o.database || o.db || (url7.pathname || "").slice(1) || env.PGDATABASE || user,
    user,
    pass: o.pass || o.password || url7.password || env.PGPASSWORD || "",
    ...Object.entries(defaults).reduce((acc, [k, d]) => (acc[k] = (k in o) ? o[k] : (k in query4) ? query4[k] === "disable" || query4[k] === "false" ? false : query4[k] : env["PG" + k.toUpperCase()] || d, acc), {}),
    connection: {
      application_name: "postgres.js",
      ...o.connection,
      ...Object.entries(query4).reduce((acc, [k, v]) => ((k in defaults) || (acc[k] = v), acc), {})
    },
    types: o.types || {},
    target_session_attrs: tsa(o, url7, env),
    onnotice: o.onnotice,
    onnotify: o.onnotify,
    onclose: o.onclose,
    onparameter: o.onparameter,
    socket: o.socket,
    transform: parseTransform(o.transform || { undefined: undefined }),
    parameters: {},
    shared: { retries: 0, typeArrayMap: {} },
    ...mergeUserTypes(o.types)
  };
};
var tsa = function(o, url7, env) {
  const x = o.target_session_attrs || url7.searchParams.get("target_session_attrs") || env.PGTARGETSESSIONATTRS;
  if (!x || ["read-write", "read-only", "primary", "standby", "prefer-standby"].includes(x))
    return x;
  throw new Error("target_session_attrs " + x + " is not supported");
};
var backoff = function(retries) {
  return (0.5 + Math.random() / 2) * Math.min(3 ** retries / 100, 20);
};
var max_lifetime = function() {
  return 60 * (30 + Math.random() * 30);
};
var parseTransform = function(x) {
  return {
    undefined: x.undefined,
    column: {
      from: typeof x.column === "function" ? x.column : x.column && x.column.from,
      to: x.column && x.column.to
    },
    value: {
      from: typeof x.value === "function" ? x.value : x.value && x.value.from,
      to: x.value && x.value.to
    },
    row: {
      from: typeof x.row === "function" ? x.row : x.row && x.row.from,
      to: x.row && x.row.to
    }
  };
};
var parseUrl = function(url7) {
  if (typeof url7 !== "string")
    return { url: { searchParams: new Map } };
  let host = url7;
  host = host.slice(host.indexOf("://") + 3).split(/[?/]/)[0];
  host = decodeURIComponent(host.slice(host.indexOf("@") + 1));
  const urlObj = new URL(url7.replace(host, host.split(",")[0]));
  return {
    url: {
      username: decodeURIComponent(urlObj.username),
      password: decodeURIComponent(urlObj.password),
      host: urlObj.host,
      hostname: urlObj.hostname,
      port: urlObj.port,
      pathname: urlObj.pathname,
      searchParams: urlObj.searchParams
    },
    multihost: host.indexOf(",") > -1 && host
  };
};
var osUsername = function() {
  try {
    return os.userInfo().username;
  } catch (_) {
    return process.env.USERNAME || process.env.USER || process.env.LOGNAME;
  }
};
Object.assign(Postgres, {
  PostgresError,
  toPascal,
  pascal,
  toCamel,
  camel,
  toKebab,
  kebab,
  fromPascal,
  fromCamel,
  fromKebab,
  BigInt: {
    to: 20,
    from: [20],
    parse: (x) => BigInt(x),
    serialize: (x) => x.toString()
  }
});
var src_default = Postgres;

// src/db.ts
var sql = src_default(process.env.DATABASE_URL);
var db_default = sql;

// src/modules/users/users.service.ts
class UsersService {
  async findByUsername(username) {
    const users = await db_default`
      select
        user_id, password
      from users
      where username = ${username}
    `;
    return users[0];
  }
  async findByEmail(email) {
    const users = await db_default`
      select
        user_id, password
      from users
      where email = ${email}
    `;
    return users[0];
  }
  async insertUser({ username, email, password }) {
    const users = await db_default`
      insert into users
        (user_id, username, email, password)
      values
        (${v4()}, ${username}, ${email}, ${password})
      returning user_id, username
    `;
    return users[0];
  }
}
var users_service_default = new UsersService;

// src/modules/users/users.controller.ts
class UsersController {
  async create(c) {
    const { username, email, password } = await c.req.json();
    const hash = await Bun.password.hash(password, {
      algorithm: "bcrypt"
    });
    const user = await users_service_default.insertUser({ username, email, password: hash });
    return c.json(user);
  }
}
var users_controller_default = new UsersController;

// src/modules/users/users.router.ts
var users3 = new Hono2;
users3.post("/register", users_controller_default.create);

// node_modules/jose/dist/node/esm/runtime/base64url.js
import {Buffer as Buffer2} from "buffer";

// node_modules/jose/dist/node/esm/lib/buffer_utils.js
function concat(...buffers) {
  const size2 = buffers.reduce((acc, { length }) => acc + length, 0);
  const buf = new Uint8Array(size2);
  let i = 0;
  buffers.forEach((buffer2) => {
    buf.set(buffer2, i);
    i += buffer2.length;
  });
  return buf;
}
var encoder = new TextEncoder;
var decoder = new TextDecoder;
var MAX_INT32 = 2 ** 32;

// node_modules/jose/dist/node/esm/runtime/base64url.js
var normalize = function(input) {
  let encoded = input;
  if (encoded instanceof Uint8Array) {
    encoded = decoder.decode(encoded);
  }
  return encoded;
};
var encode;
if (Buffer2.isEncoding("base64url")) {
  encode = (input) => Buffer2.from(input).toString("base64url");
} else {
  encode = (input) => Buffer2.from(input).toString("base64").replace(/=/g, "").replace(/\+/g, "-").replace(/\//g, "_");
}
var decode = (input) => Buffer2.from(normalize(input), "base64");

// node_modules/jose/dist/node/esm/util/errors.js
class JOSEError extends Error {
  static get code() {
    return "ERR_JOSE_GENERIC";
  }
  constructor(message) {
    var _a;
    super(message);
    this.code = "ERR_JOSE_GENERIC";
    this.name = this.constructor.name;
    (_a = Error.captureStackTrace) === null || _a === undefined || _a.call(Error, this, this.constructor);
  }
}

class JWTClaimValidationFailed extends JOSEError {
  static get code() {
    return "ERR_JWT_CLAIM_VALIDATION_FAILED";
  }
  constructor(message, claim = "unspecified", reason = "unspecified") {
    super(message);
    this.code = "ERR_JWT_CLAIM_VALIDATION_FAILED";
    this.claim = claim;
    this.reason = reason;
  }
}

class JWTExpired extends JOSEError {
  static get code() {
    return "ERR_JWT_EXPIRED";
  }
  constructor(message, claim = "unspecified", reason = "unspecified") {
    super(message);
    this.code = "ERR_JWT_EXPIRED";
    this.claim = claim;
    this.reason = reason;
  }
}

class JOSEAlgNotAllowed extends JOSEError {
  constructor() {
    super(...arguments);
    this.code = "ERR_JOSE_ALG_NOT_ALLOWED";
  }
  static get code() {
    return "ERR_JOSE_ALG_NOT_ALLOWED";
  }
}

class JOSENotSupported extends JOSEError {
  constructor() {
    super(...arguments);
    this.code = "ERR_JOSE_NOT_SUPPORTED";
  }
  static get code() {
    return "ERR_JOSE_NOT_SUPPORTED";
  }
}
class JWSInvalid extends JOSEError {
  constructor() {
    super(...arguments);
    this.code = "ERR_JWS_INVALID";
  }
  static get code() {
    return "ERR_JWS_INVALID";
  }
}

class JWTInvalid extends JOSEError {
  constructor() {
    super(...arguments);
    this.code = "ERR_JWT_INVALID";
  }
  static get code() {
    return "ERR_JWT_INVALID";
  }
}
Symbol.asyncIterator;
class JWSSignatureVerificationFailed extends JOSEError {
  constructor() {
    super(...arguments);
    this.code = "ERR_JWS_SIGNATURE_VERIFICATION_FAILED";
    this.message = "signature verification failed";
  }
  static get code() {
    return "ERR_JWS_SIGNATURE_VERIFICATION_FAILED";
  }
}

// node_modules/jose/dist/node/esm/runtime/is_key_object.js
import {KeyObject} from "crypto";
import * as util from "util";
var is_key_object_default = util.types.isKeyObject ? (obj) => util.types.isKeyObject(obj) : (obj) => obj != null && obj instanceof KeyObject;

// node_modules/jose/dist/node/esm/runtime/webcrypto.js
import * as crypto3 from "crypto";
import * as util2 from "util";
var webcrypto2 = crypto3.webcrypto;
var webcrypto_default = webcrypto2;
var isCryptoKey = util2.types.isCryptoKey ? (key) => util2.types.isCryptoKey(key) : (key) => false;

// node_modules/jose/dist/node/esm/lib/crypto_key.js
var unusable = function(name, prop = "algorithm.name") {
  return new TypeError(`CryptoKey does not support this operation, its ${prop} must be ${name}`);
};
var isAlgorithm = function(algorithm, name) {
  return algorithm.name === name;
};
var getHashLength = function(hash) {
  return parseInt(hash.name.slice(4), 10);
};
var getNamedCurve = function(alg) {
  switch (alg) {
    case "ES256":
      return "P-256";
    case "ES384":
      return "P-384";
    case "ES512":
      return "P-521";
    default:
      throw new Error("unreachable");
  }
};
var checkUsage = function(key, usages) {
  if (usages.length && !usages.some((expected) => key.usages.includes(expected))) {
    let msg = "CryptoKey does not support this operation, its usages must include ";
    if (usages.length > 2) {
      const last = usages.pop();
      msg += `one of ${usages.join(", ")}, or ${last}.`;
    } else if (usages.length === 2) {
      msg += `one of ${usages[0]} or ${usages[1]}.`;
    } else {
      msg += `${usages[0]}.`;
    }
    throw new TypeError(msg);
  }
};
function checkSigCryptoKey(key, alg, ...usages) {
  switch (alg) {
    case "HS256":
    case "HS384":
    case "HS512": {
      if (!isAlgorithm(key.algorithm, "HMAC"))
        throw unusable("HMAC");
      const expected = parseInt(alg.slice(2), 10);
      const actual = getHashLength(key.algorithm.hash);
      if (actual !== expected)
        throw unusable(`SHA-${expected}`, "algorithm.hash");
      break;
    }
    case "RS256":
    case "RS384":
    case "RS512": {
      if (!isAlgorithm(key.algorithm, "RSASSA-PKCS1-v1_5"))
        throw unusable("RSASSA-PKCS1-v1_5");
      const expected = parseInt(alg.slice(2), 10);
      const actual = getHashLength(key.algorithm.hash);
      if (actual !== expected)
        throw unusable(`SHA-${expected}`, "algorithm.hash");
      break;
    }
    case "PS256":
    case "PS384":
    case "PS512": {
      if (!isAlgorithm(key.algorithm, "RSA-PSS"))
        throw unusable("RSA-PSS");
      const expected = parseInt(alg.slice(2), 10);
      const actual = getHashLength(key.algorithm.hash);
      if (actual !== expected)
        throw unusable(`SHA-${expected}`, "algorithm.hash");
      break;
    }
    case "EdDSA": {
      if (key.algorithm.name !== "Ed25519" && key.algorithm.name !== "Ed448") {
        throw unusable("Ed25519 or Ed448");
      }
      break;
    }
    case "ES256":
    case "ES384":
    case "ES512": {
      if (!isAlgorithm(key.algorithm, "ECDSA"))
        throw unusable("ECDSA");
      const expected = getNamedCurve(alg);
      const actual = key.algorithm.namedCurve;
      if (actual !== expected)
        throw unusable(expected, "algorithm.namedCurve");
      break;
    }
    default:
      throw new TypeError("CryptoKey does not support this operation");
  }
  checkUsage(key, usages);
}

// node_modules/jose/dist/node/esm/lib/invalid_key_input.js
var message = function(msg, actual, ...types7) {
  if (types7.length > 2) {
    const last = types7.pop();
    msg += `one of type ${types7.join(", ")}, or ${last}.`;
  } else if (types7.length === 2) {
    msg += `one of type ${types7[0]} or ${types7[1]}.`;
  } else {
    msg += `of type ${types7[0]}.`;
  }
  if (actual == null) {
    msg += ` Received ${actual}`;
  } else if (typeof actual === "function" && actual.name) {
    msg += ` Received function ${actual.name}`;
  } else if (typeof actual === "object" && actual != null) {
    if (actual.constructor && actual.constructor.name) {
      msg += ` Received an instance of ${actual.constructor.name}`;
    }
  }
  return msg;
};
function withAlg(alg, actual, ...types7) {
  return message(`Key for the ${alg} algorithm must be `, actual, ...types7);
}
var invalid_key_input_default = (actual, ...types7) => {
  return message("Key must be ", actual, ...types7);
};

// node_modules/jose/dist/node/esm/runtime/is_key_like.js
var is_key_like_default = (key) => is_key_object_default(key) || isCryptoKey(key);
var types7 = ["KeyObject"];
if (globalThis.CryptoKey || (webcrypto_default === null || webcrypto_default === undefined ? undefined : webcrypto_default.CryptoKey)) {
  types7.push("CryptoKey");
}

// node_modules/jose/dist/node/esm/lib/is_disjoint.js
var isDisjoint = (...headers) => {
  const sources = headers.filter(Boolean);
  if (sources.length === 0 || sources.length === 1) {
    return true;
  }
  let acc;
  for (const header of sources) {
    const parameters = Object.keys(header);
    if (!acc || acc.size === 0) {
      acc = new Set(parameters);
      continue;
    }
    for (const parameter of parameters) {
      if (acc.has(parameter)) {
        return false;
      }
      acc.add(parameter);
    }
  }
  return true;
};
var is_disjoint_default = isDisjoint;

// node_modules/jose/dist/node/esm/lib/is_object.js
var isObjectLike = function(value) {
  return typeof value === "object" && value !== null;
};
function isObject(input) {
  if (!isObjectLike(input) || Object.prototype.toString.call(input) !== "[object Object]") {
    return false;
  }
  if (Object.getPrototypeOf(input) === null) {
    return true;
  }
  let proto = input;
  while (Object.getPrototypeOf(proto) !== null) {
    proto = Object.getPrototypeOf(proto);
  }
  return Object.getPrototypeOf(input) === proto;
}

// node_modules/jose/dist/node/esm/runtime/get_named_curve.js
import {Buffer as Buffer3} from "buffer";
import {createPublicKey, KeyObject as KeyObject2} from "crypto";
var p256 = Buffer3.from([42, 134, 72, 206, 61, 3, 1, 7]);
var p384 = Buffer3.from([43, 129, 4, 0, 34]);
var p521 = Buffer3.from([43, 129, 4, 0, 35]);
var secp256k1 = Buffer3.from([43, 129, 4, 0, 10]);
var weakMap = new WeakMap;
var namedCurveToJOSE = (namedCurve) => {
  switch (namedCurve) {
    case "prime256v1":
      return "P-256";
    case "secp384r1":
      return "P-384";
    case "secp521r1":
      return "P-521";
    case "secp256k1":
      return "secp256k1";
    default:
      throw new JOSENotSupported("Unsupported key curve for this operation");
  }
};
var getNamedCurve2 = (kee, raw) => {
  var _a;
  let key;
  if (isCryptoKey(kee)) {
    key = KeyObject2.from(kee);
  } else if (is_key_object_default(kee)) {
    key = kee;
  } else {
    throw new TypeError(invalid_key_input_default(kee, ...types7));
  }
  if (key.type === "secret") {
    throw new TypeError('only "private" or "public" type keys can be used for this operation');
  }
  switch (key.asymmetricKeyType) {
    case "ed25519":
    case "ed448":
      return `Ed${key.asymmetricKeyType.slice(2)}`;
    case "x25519":
    case "x448":
      return `X${key.asymmetricKeyType.slice(1)}`;
    case "ec": {
      if (weakMap.has(key)) {
        return weakMap.get(key);
      }
      let namedCurve = (_a = key.asymmetricKeyDetails) === null || _a === undefined ? undefined : _a.namedCurve;
      if (!namedCurve && key.type === "private") {
        namedCurve = getNamedCurve2(createPublicKey(key), true);
      } else if (!namedCurve) {
        const buf = key.export({ format: "der", type: "spki" });
        const i = buf[1] < 128 ? 14 : 15;
        const len = buf[i];
        const curveOid = buf.slice(i + 1, i + 1 + len);
        if (curveOid.equals(p256)) {
          namedCurve = "prime256v1";
        } else if (curveOid.equals(p384)) {
          namedCurve = "secp384r1";
        } else if (curveOid.equals(p521)) {
          namedCurve = "secp521r1";
        } else if (curveOid.equals(secp256k1)) {
          namedCurve = "secp256k1";
        } else {
          throw new JOSENotSupported("Unsupported key curve for this operation");
        }
      }
      if (raw)
        return namedCurve;
      const curve = namedCurveToJOSE(namedCurve);
      weakMap.set(key, curve);
      return curve;
    }
    default:
      throw new TypeError("Invalid asymmetric key type for this operation");
  }
};
var get_named_curve_default = getNamedCurve2;

// node_modules/jose/dist/node/esm/runtime/check_modulus_length.js
var weakMap2 = new WeakMap;
var getLength = (buf, index) => {
  let len = buf.readUInt8(1);
  if ((len & 128) === 0) {
    if (index === 0) {
      return len;
    }
    return getLength(buf.subarray(2 + len), index - 1);
  }
  const num = len & 127;
  len = 0;
  for (let i = 0;i < num; i++) {
    len <<= 8;
    const j = buf.readUInt8(2 + i);
    len |= j;
  }
  if (index === 0) {
    return len;
  }
  return getLength(buf.subarray(2 + len), index - 1);
};
var getLengthOfSeqIndex = (sequence, index) => {
  const len = sequence.readUInt8(1);
  if ((len & 128) === 0) {
    return getLength(sequence.subarray(2), index);
  }
  const num = len & 127;
  return getLength(sequence.subarray(2 + num), index);
};
var getModulusLength = (key) => {
  var _a, _b;
  if (weakMap2.has(key)) {
    return weakMap2.get(key);
  }
  const modulusLength = (_b = (_a = key.asymmetricKeyDetails) === null || _a === undefined ? undefined : _a.modulusLength) !== null && _b !== undefined ? _b : getLengthOfSeqIndex(key.export({ format: "der", type: "pkcs1" }), key.type === "private" ? 1 : 0) - 1 << 3;
  weakMap2.set(key, modulusLength);
  return modulusLength;
};
var check_modulus_length_default = (key, alg) => {
  if (getModulusLength(key) < 2048) {
    throw new TypeError(`${alg} requires key modulusLength to be 2048 bits or larger`);
  }
};

// node_modules/jose/dist/node/esm/runtime/flags.js
var [major, minor] = process.versions.node.split(".").map((str) => parseInt(str, 10));
var oneShotCallback = major >= 16 || major === 15 && minor >= 13;
var rsaPssParams = !("electron" in process.versions) && (major >= 17 || major === 16 && minor >= 9);
var jwkExport = major >= 16 || major === 15 && minor >= 9;
var jwkImport = major >= 16 || major === 15 && minor >= 12;

// node_modules/jose/dist/node/esm/lib/check_key_type.js
var symmetricTypeCheck = (alg, key) => {
  if (key instanceof Uint8Array)
    return;
  if (!is_key_like_default(key)) {
    throw new TypeError(withAlg(alg, key, ...types7, "Uint8Array"));
  }
  if (key.type !== "secret") {
    throw new TypeError(`${types7.join(" or ")} instances for symmetric algorithms must be of type "secret"`);
  }
};
var asymmetricTypeCheck = (alg, key, usage) => {
  if (!is_key_like_default(key)) {
    throw new TypeError(withAlg(alg, key, ...types7));
  }
  if (key.type === "secret") {
    throw new TypeError(`${types7.join(" or ")} instances for asymmetric algorithms must not be of type "secret"`);
  }
  if (usage === "sign" && key.type === "public") {
    throw new TypeError(`${types7.join(" or ")} instances for asymmetric algorithm signing must be of type "private"`);
  }
  if (usage === "decrypt" && key.type === "public") {
    throw new TypeError(`${types7.join(" or ")} instances for asymmetric algorithm decryption must be of type "private"`);
  }
  if (key.algorithm && usage === "verify" && key.type === "private") {
    throw new TypeError(`${types7.join(" or ")} instances for asymmetric algorithm verifying must be of type "public"`);
  }
  if (key.algorithm && usage === "encrypt" && key.type === "private") {
    throw new TypeError(`${types7.join(" or ")} instances for asymmetric algorithm encryption must be of type "public"`);
  }
};
var checkKeyType = (alg, key, usage) => {
  const symmetric = alg.startsWith("HS") || alg === "dir" || alg.startsWith("PBES2") || /^A\d{3}(?:GCM)?KW$/.test(alg);
  if (symmetric) {
    symmetricTypeCheck(alg, key);
  } else {
    asymmetricTypeCheck(alg, key, usage);
  }
};
var check_key_type_default = checkKeyType;

// node_modules/jose/dist/node/esm/lib/validate_crit.js
var validateCrit = function(Err, recognizedDefault, recognizedOption, protectedHeader, joseHeader) {
  if (joseHeader.crit !== undefined && protectedHeader.crit === undefined) {
    throw new Err('"crit" (Critical) Header Parameter MUST be integrity protected');
  }
  if (!protectedHeader || protectedHeader.crit === undefined) {
    return new Set;
  }
  if (!Array.isArray(protectedHeader.crit) || protectedHeader.crit.length === 0 || protectedHeader.crit.some((input) => typeof input !== "string" || input.length === 0)) {
    throw new Err('"crit" (Critical) Header Parameter MUST be an array of non-empty strings when present');
  }
  let recognized;
  if (recognizedOption !== undefined) {
    recognized = new Map([...Object.entries(recognizedOption), ...recognizedDefault.entries()]);
  } else {
    recognized = recognizedDefault;
  }
  for (const parameter of protectedHeader.crit) {
    if (!recognized.has(parameter)) {
      throw new JOSENotSupported(`Extension Header Parameter "${parameter}" is not recognized`);
    }
    if (joseHeader[parameter] === undefined) {
      throw new Err(`Extension Header Parameter "${parameter}" is missing`);
    } else if (recognized.get(parameter) && protectedHeader[parameter] === undefined) {
      throw new Err(`Extension Header Parameter "${parameter}" MUST be integrity protected`);
    }
  }
  return new Set(protectedHeader.crit);
};
var validate_crit_default = validateCrit;

// node_modules/jose/dist/node/esm/lib/validate_algorithms.js
var validateAlgorithms = (option, algorithms) => {
  if (algorithms !== undefined && (!Array.isArray(algorithms) || algorithms.some((s) => typeof s !== "string"))) {
    throw new TypeError(`"${option}" option must be an array of strings`);
  }
  if (!algorithms) {
    return;
  }
  return new Set(algorithms);
};
var validate_algorithms_default = validateAlgorithms;

// node_modules/jose/dist/node/esm/runtime/verify.js
import * as crypto5 from "crypto";
import {promisify as promisify2} from "util";

// node_modules/jose/dist/node/esm/runtime/dsa_digest.js
function dsaDigest(alg) {
  switch (alg) {
    case "PS256":
    case "RS256":
    case "ES256":
    case "ES256K":
      return "sha256";
    case "PS384":
    case "RS384":
    case "ES384":
      return "sha384";
    case "PS512":
    case "RS512":
    case "ES512":
      return "sha512";
    case "EdDSA":
      return;
    default:
      throw new JOSENotSupported(`alg ${alg} is not supported either by JOSE or your javascript runtime`);
  }
}

// node_modules/jose/dist/node/esm/runtime/node_key.js
import {constants} from "crypto";
var PSS = {
  padding: constants.RSA_PKCS1_PSS_PADDING,
  saltLength: constants.RSA_PSS_SALTLEN_DIGEST
};
var ecCurveAlgMap = new Map([
  ["ES256", "P-256"],
  ["ES256K", "secp256k1"],
  ["ES384", "P-384"],
  ["ES512", "P-521"]
]);
function keyForCrypto(alg, key) {
  switch (alg) {
    case "EdDSA":
      if (!["ed25519", "ed448"].includes(key.asymmetricKeyType)) {
        throw new TypeError("Invalid key for this operation, its asymmetricKeyType must be ed25519 or ed448");
      }
      return key;
    case "RS256":
    case "RS384":
    case "RS512":
      if (key.asymmetricKeyType !== "rsa") {
        throw new TypeError("Invalid key for this operation, its asymmetricKeyType must be rsa");
      }
      check_modulus_length_default(key, alg);
      return key;
    case (rsaPssParams && "PS256"):
    case (rsaPssParams && "PS384"):
    case (rsaPssParams && "PS512"):
      if (key.asymmetricKeyType === "rsa-pss") {
        const { hashAlgorithm, mgf1HashAlgorithm, saltLength } = key.asymmetricKeyDetails;
        const length = parseInt(alg.slice(-3), 10);
        if (hashAlgorithm !== undefined && (hashAlgorithm !== `sha${length}` || mgf1HashAlgorithm !== hashAlgorithm)) {
          throw new TypeError(`Invalid key for this operation, its RSA-PSS parameters do not meet the requirements of "alg" ${alg}`);
        }
        if (saltLength !== undefined && saltLength > length >> 3) {
          throw new TypeError(`Invalid key for this operation, its RSA-PSS parameter saltLength does not meet the requirements of "alg" ${alg}`);
        }
      } else if (key.asymmetricKeyType !== "rsa") {
        throw new TypeError("Invalid key for this operation, its asymmetricKeyType must be rsa or rsa-pss");
      }
      check_modulus_length_default(key, alg);
      return { key, ...PSS };
    case (!rsaPssParams && "PS256"):
    case (!rsaPssParams && "PS384"):
    case (!rsaPssParams && "PS512"):
      if (key.asymmetricKeyType !== "rsa") {
        throw new TypeError("Invalid key for this operation, its asymmetricKeyType must be rsa");
      }
      check_modulus_length_default(key, alg);
      return { key, ...PSS };
    case "ES256":
    case "ES256K":
    case "ES384":
    case "ES512": {
      if (key.asymmetricKeyType !== "ec") {
        throw new TypeError("Invalid key for this operation, its asymmetricKeyType must be ec");
      }
      const actual = get_named_curve_default(key);
      const expected = ecCurveAlgMap.get(alg);
      if (actual !== expected) {
        throw new TypeError(`Invalid key curve for the algorithm, its curve must be ${expected}, got ${actual}`);
      }
      return { dsaEncoding: "ieee-p1363", key };
    }
    default:
      throw new JOSENotSupported(`alg ${alg} is not supported either by JOSE or your javascript runtime`);
  }
}

// node_modules/jose/dist/node/esm/runtime/sign.js
import * as crypto4 from "crypto";
import {promisify} from "util";

// node_modules/jose/dist/node/esm/runtime/hmac_digest.js
function hmacDigest(alg) {
  switch (alg) {
    case "HS256":
      return "sha256";
    case "HS384":
      return "sha384";
    case "HS512":
      return "sha512";
    default:
      throw new JOSENotSupported(`alg ${alg} is not supported either by JOSE or your javascript runtime`);
  }
}

// node_modules/jose/dist/node/esm/runtime/get_sign_verify_key.js
import {KeyObject as KeyObject3, createSecretKey} from "crypto";
function getSignVerifyKey(alg, key, usage) {
  if (key instanceof Uint8Array) {
    if (!alg.startsWith("HS")) {
      throw new TypeError(invalid_key_input_default(key, ...types7));
    }
    return createSecretKey(key);
  }
  if (key instanceof KeyObject3) {
    return key;
  }
  if (isCryptoKey(key)) {
    checkSigCryptoKey(key, alg, usage);
    return KeyObject3.from(key);
  }
  throw new TypeError(invalid_key_input_default(key, ...types7, "Uint8Array"));
}

// node_modules/jose/dist/node/esm/runtime/sign.js
var oneShotSign;
if (crypto4.sign.length > 3) {
  oneShotSign = promisify(crypto4.sign);
} else {
  oneShotSign = crypto4.sign;
}
var sign2 = async (alg, key, data) => {
  const keyObject = getSignVerifyKey(alg, key, "sign");
  if (alg.startsWith("HS")) {
    const hmac2 = crypto4.createHmac(hmacDigest(alg), keyObject);
    hmac2.update(data);
    return hmac2.digest();
  }
  return oneShotSign(dsaDigest(alg), data, keyForCrypto(alg, keyObject));
};
var sign_default = sign2;

// node_modules/jose/dist/node/esm/runtime/verify.js
var oneShotVerify;
if (crypto5.verify.length > 4 && oneShotCallback) {
  oneShotVerify = promisify2(crypto5.verify);
} else {
  oneShotVerify = crypto5.verify;
}
var verify2 = async (alg, key, signature, data) => {
  const keyObject = getSignVerifyKey(alg, key, "verify");
  if (alg.startsWith("HS")) {
    const expected = await sign_default(alg, keyObject, data);
    const actual = signature;
    try {
      return crypto5.timingSafeEqual(actual, expected);
    } catch {
      return false;
    }
  }
  const algorithm = dsaDigest(alg);
  const keyInput = keyForCrypto(alg, keyObject);
  try {
    return await oneShotVerify(algorithm, data, keyInput, signature);
  } catch {
    return false;
  }
};
var verify_default = verify2;

// node_modules/jose/dist/node/esm/jws/flattened/verify.js
async function flattenedVerify(jws, key, options) {
  var _a;
  if (!isObject(jws)) {
    throw new JWSInvalid("Flattened JWS must be an object");
  }
  if (jws.protected === undefined && jws.header === undefined) {
    throw new JWSInvalid('Flattened JWS must have either of the "protected" or "header" members');
  }
  if (jws.protected !== undefined && typeof jws.protected !== "string") {
    throw new JWSInvalid("JWS Protected Header incorrect type");
  }
  if (jws.payload === undefined) {
    throw new JWSInvalid("JWS Payload missing");
  }
  if (typeof jws.signature !== "string") {
    throw new JWSInvalid("JWS Signature missing or incorrect type");
  }
  if (jws.header !== undefined && !isObject(jws.header)) {
    throw new JWSInvalid("JWS Unprotected Header incorrect type");
  }
  let parsedProt = {};
  if (jws.protected) {
    try {
      const protectedHeader = decode(jws.protected);
      parsedProt = JSON.parse(decoder.decode(protectedHeader));
    } catch {
      throw new JWSInvalid("JWS Protected Header is invalid");
    }
  }
  if (!is_disjoint_default(parsedProt, jws.header)) {
    throw new JWSInvalid("JWS Protected and JWS Unprotected Header Parameter names must be disjoint");
  }
  const joseHeader = {
    ...parsedProt,
    ...jws.header
  };
  const extensions = validate_crit_default(JWSInvalid, new Map([["b64", true]]), options === null || options === undefined ? undefined : options.crit, parsedProt, joseHeader);
  let b64 = true;
  if (extensions.has("b64")) {
    b64 = parsedProt.b64;
    if (typeof b64 !== "boolean") {
      throw new JWSInvalid('The "b64" (base64url-encode payload) Header Parameter must be a boolean');
    }
  }
  const { alg } = joseHeader;
  if (typeof alg !== "string" || !alg) {
    throw new JWSInvalid('JWS "alg" (Algorithm) Header Parameter missing or invalid');
  }
  const algorithms = options && validate_algorithms_default("algorithms", options.algorithms);
  if (algorithms && !algorithms.has(alg)) {
    throw new JOSEAlgNotAllowed('"alg" (Algorithm) Header Parameter not allowed');
  }
  if (b64) {
    if (typeof jws.payload !== "string") {
      throw new JWSInvalid("JWS Payload must be a string");
    }
  } else if (typeof jws.payload !== "string" && !(jws.payload instanceof Uint8Array)) {
    throw new JWSInvalid("JWS Payload must be a string or an Uint8Array instance");
  }
  let resolvedKey = false;
  if (typeof key === "function") {
    key = await key(parsedProt, jws);
    resolvedKey = true;
  }
  check_key_type_default(alg, key, "verify");
  const data = concat(encoder.encode((_a = jws.protected) !== null && _a !== undefined ? _a : ""), encoder.encode("."), typeof jws.payload === "string" ? encoder.encode(jws.payload) : jws.payload);
  let signature;
  try {
    signature = decode(jws.signature);
  } catch {
    throw new JWSInvalid("Failed to base64url decode the signature");
  }
  const verified = await verify_default(alg, key, signature, data);
  if (!verified) {
    throw new JWSSignatureVerificationFailed;
  }
  let payload;
  if (b64) {
    try {
      payload = decode(jws.payload);
    } catch {
      throw new JWSInvalid("Failed to base64url decode the payload");
    }
  } else if (typeof jws.payload === "string") {
    payload = encoder.encode(jws.payload);
  } else {
    payload = jws.payload;
  }
  const result2 = { payload };
  if (jws.protected !== undefined) {
    result2.protectedHeader = parsedProt;
  }
  if (jws.header !== undefined) {
    result2.unprotectedHeader = jws.header;
  }
  if (resolvedKey) {
    return { ...result2, key };
  }
  return result2;
}

// node_modules/jose/dist/node/esm/jws/compact/verify.js
async function compactVerify(jws, key, options) {
  if (jws instanceof Uint8Array) {
    jws = decoder.decode(jws);
  }
  if (typeof jws !== "string") {
    throw new JWSInvalid("Compact JWS must be a string or Uint8Array");
  }
  const { 0: protectedHeader, 1: payload, 2: signature, length } = jws.split(".");
  if (length !== 3) {
    throw new JWSInvalid("Invalid Compact JWS");
  }
  const verified = await flattenedVerify({ payload, protected: protectedHeader, signature }, key, options);
  const result2 = { payload: verified.payload, protectedHeader: verified.protectedHeader };
  if (typeof key === "function") {
    return { ...result2, key: verified.key };
  }
  return result2;
}

// node_modules/jose/dist/node/esm/lib/epoch.js
var epoch_default = (date) => Math.floor(date.getTime() / 1000);

// node_modules/jose/dist/node/esm/lib/secs.js
var minute = 60;
var hour = minute * 60;
var day = hour * 24;
var week = day * 7;
var year = day * 365.25;
var REGEX = /^(\d+|\d+\.\d+) ?(seconds?|secs?|s|minutes?|mins?|m|hours?|hrs?|h|days?|d|weeks?|w|years?|yrs?|y)$/i;
var secs_default = (str) => {
  const matched = REGEX.exec(str);
  if (!matched) {
    throw new TypeError("Invalid time period format");
  }
  const value = parseFloat(matched[1]);
  const unit = matched[2].toLowerCase();
  switch (unit) {
    case "sec":
    case "secs":
    case "second":
    case "seconds":
    case "s":
      return Math.round(value);
    case "minute":
    case "minutes":
    case "min":
    case "mins":
    case "m":
      return Math.round(value * minute);
    case "hour":
    case "hours":
    case "hr":
    case "hrs":
    case "h":
      return Math.round(value * hour);
    case "day":
    case "days":
    case "d":
      return Math.round(value * day);
    case "week":
    case "weeks":
    case "w":
      return Math.round(value * week);
    default:
      return Math.round(value * year);
  }
};

// node_modules/jose/dist/node/esm/lib/jwt_claims_set.js
var normalizeTyp = (value) => value.toLowerCase().replace(/^application\//, "");
var checkAudiencePresence = (audPayload, audOption) => {
  if (typeof audPayload === "string") {
    return audOption.includes(audPayload);
  }
  if (Array.isArray(audPayload)) {
    return audOption.some(Set.prototype.has.bind(new Set(audPayload)));
  }
  return false;
};
var jwt_claims_set_default = (protectedHeader, encodedPayload, options = {}) => {
  const { typ } = options;
  if (typ && (typeof protectedHeader.typ !== "string" || normalizeTyp(protectedHeader.typ) !== normalizeTyp(typ))) {
    throw new JWTClaimValidationFailed('unexpected "typ" JWT header value', "typ", "check_failed");
  }
  let payload;
  try {
    payload = JSON.parse(decoder.decode(encodedPayload));
  } catch {
  }
  if (!isObject(payload)) {
    throw new JWTInvalid("JWT Claims Set must be a top-level JSON object");
  }
  const { requiredClaims = [], issuer, subject, audience, maxTokenAge } = options;
  if (maxTokenAge !== undefined)
    requiredClaims.push("iat");
  if (audience !== undefined)
    requiredClaims.push("aud");
  if (subject !== undefined)
    requiredClaims.push("sub");
  if (issuer !== undefined)
    requiredClaims.push("iss");
  for (const claim of new Set(requiredClaims.reverse())) {
    if (!(claim in payload)) {
      throw new JWTClaimValidationFailed(`missing required "${claim}" claim`, claim, "missing");
    }
  }
  if (issuer && !(Array.isArray(issuer) ? issuer : [issuer]).includes(payload.iss)) {
    throw new JWTClaimValidationFailed('unexpected "iss" claim value', "iss", "check_failed");
  }
  if (subject && payload.sub !== subject) {
    throw new JWTClaimValidationFailed('unexpected "sub" claim value', "sub", "check_failed");
  }
  if (audience && !checkAudiencePresence(payload.aud, typeof audience === "string" ? [audience] : audience)) {
    throw new JWTClaimValidationFailed('unexpected "aud" claim value', "aud", "check_failed");
  }
  let tolerance;
  switch (typeof options.clockTolerance) {
    case "string":
      tolerance = secs_default(options.clockTolerance);
      break;
    case "number":
      tolerance = options.clockTolerance;
      break;
    case "undefined":
      tolerance = 0;
      break;
    default:
      throw new TypeError("Invalid clockTolerance option type");
  }
  const { currentDate } = options;
  const now = epoch_default(currentDate || new Date);
  if ((payload.iat !== undefined || maxTokenAge) && typeof payload.iat !== "number") {
    throw new JWTClaimValidationFailed('"iat" claim must be a number', "iat", "invalid");
  }
  if (payload.nbf !== undefined) {
    if (typeof payload.nbf !== "number") {
      throw new JWTClaimValidationFailed('"nbf" claim must be a number', "nbf", "invalid");
    }
    if (payload.nbf > now + tolerance) {
      throw new JWTClaimValidationFailed('"nbf" claim timestamp check failed', "nbf", "check_failed");
    }
  }
  if (payload.exp !== undefined) {
    if (typeof payload.exp !== "number") {
      throw new JWTClaimValidationFailed('"exp" claim must be a number', "exp", "invalid");
    }
    if (payload.exp <= now - tolerance) {
      throw new JWTExpired('"exp" claim timestamp check failed', "exp", "check_failed");
    }
  }
  if (maxTokenAge) {
    const age = now - payload.iat;
    const max = typeof maxTokenAge === "number" ? maxTokenAge : secs_default(maxTokenAge);
    if (age - tolerance > max) {
      throw new JWTExpired('"iat" claim timestamp check failed (too far in the past)', "iat", "check_failed");
    }
    if (age < 0 - tolerance) {
      throw new JWTClaimValidationFailed('"iat" claim timestamp check failed (it should be in the past)', "iat", "check_failed");
    }
  }
  return payload;
};

// node_modules/jose/dist/node/esm/jwt/verify.js
async function jwtVerify(jwt, key, options) {
  var _a;
  const verified = await compactVerify(jwt, key, options);
  if (((_a = verified.protectedHeader.crit) === null || _a === undefined ? undefined : _a.includes("b64")) && verified.protectedHeader.b64 === false) {
    throw new JWTInvalid("JWTs MUST NOT use unencoded payload");
  }
  const payload = jwt_claims_set_default(verified.protectedHeader, verified.payload, options);
  const result2 = { payload, protectedHeader: verified.protectedHeader };
  if (typeof key === "function") {
    return { ...result2, key: verified.key };
  }
  return result2;
}
// node_modules/jose/dist/node/esm/jws/flattened/sign.js
class FlattenedSign {
  constructor(payload) {
    if (!(payload instanceof Uint8Array)) {
      throw new TypeError("payload must be an instance of Uint8Array");
    }
    this._payload = payload;
  }
  setProtectedHeader(protectedHeader) {
    if (this._protectedHeader) {
      throw new TypeError("setProtectedHeader can only be called once");
    }
    this._protectedHeader = protectedHeader;
    return this;
  }
  setUnprotectedHeader(unprotectedHeader) {
    if (this._unprotectedHeader) {
      throw new TypeError("setUnprotectedHeader can only be called once");
    }
    this._unprotectedHeader = unprotectedHeader;
    return this;
  }
  async sign(key, options) {
    if (!this._protectedHeader && !this._unprotectedHeader) {
      throw new JWSInvalid("either setProtectedHeader or setUnprotectedHeader must be called before #sign()");
    }
    if (!is_disjoint_default(this._protectedHeader, this._unprotectedHeader)) {
      throw new JWSInvalid("JWS Protected and JWS Unprotected Header Parameter names must be disjoint");
    }
    const joseHeader = {
      ...this._protectedHeader,
      ...this._unprotectedHeader
    };
    const extensions = validate_crit_default(JWSInvalid, new Map([["b64", true]]), options === null || options === undefined ? undefined : options.crit, this._protectedHeader, joseHeader);
    let b64 = true;
    if (extensions.has("b64")) {
      b64 = this._protectedHeader.b64;
      if (typeof b64 !== "boolean") {
        throw new JWSInvalid('The "b64" (base64url-encode payload) Header Parameter must be a boolean');
      }
    }
    const { alg } = joseHeader;
    if (typeof alg !== "string" || !alg) {
      throw new JWSInvalid('JWS "alg" (Algorithm) Header Parameter missing or invalid');
    }
    check_key_type_default(alg, key, "sign");
    let payload = this._payload;
    if (b64) {
      payload = encoder.encode(encode(payload));
    }
    let protectedHeader;
    if (this._protectedHeader) {
      protectedHeader = encoder.encode(encode(JSON.stringify(this._protectedHeader)));
    } else {
      protectedHeader = encoder.encode("");
    }
    const data = concat(protectedHeader, encoder.encode("."), payload);
    const signature = await sign_default(alg, key, data);
    const jws = {
      signature: encode(signature),
      payload: ""
    };
    if (b64) {
      jws.payload = decoder.decode(payload);
    }
    if (this._unprotectedHeader) {
      jws.header = this._unprotectedHeader;
    }
    if (this._protectedHeader) {
      jws.protected = decoder.decode(protectedHeader);
    }
    return jws;
  }
}

// node_modules/jose/dist/node/esm/jws/compact/sign.js
class CompactSign {
  constructor(payload) {
    this._flattened = new FlattenedSign(payload);
  }
  setProtectedHeader(protectedHeader) {
    this._flattened.setProtectedHeader(protectedHeader);
    return this;
  }
  async sign(key, options) {
    const jws = await this._flattened.sign(key, options);
    if (jws.payload === undefined) {
      throw new TypeError("use the flattened module for creating JWS with b64: false");
    }
    return `${jws.protected}.${jws.payload}.${jws.signature}`;
  }
}

// node_modules/jose/dist/node/esm/jwt/produce.js
class ProduceJWT {
  constructor(payload) {
    if (!isObject(payload)) {
      throw new TypeError("JWT Claims Set MUST be an object");
    }
    this._payload = payload;
  }
  setIssuer(issuer) {
    this._payload = { ...this._payload, iss: issuer };
    return this;
  }
  setSubject(subject) {
    this._payload = { ...this._payload, sub: subject };
    return this;
  }
  setAudience(audience) {
    this._payload = { ...this._payload, aud: audience };
    return this;
  }
  setJti(jwtId) {
    this._payload = { ...this._payload, jti: jwtId };
    return this;
  }
  setNotBefore(input) {
    if (typeof input === "number") {
      this._payload = { ...this._payload, nbf: input };
    } else {
      this._payload = { ...this._payload, nbf: epoch_default(new Date) + secs_default(input) };
    }
    return this;
  }
  setExpirationTime(input) {
    if (typeof input === "number") {
      this._payload = { ...this._payload, exp: input };
    } else {
      this._payload = { ...this._payload, exp: epoch_default(new Date) + secs_default(input) };
    }
    return this;
  }
  setIssuedAt(input) {
    if (typeof input === "undefined") {
      this._payload = { ...this._payload, iat: epoch_default(new Date) };
    } else {
      this._payload = { ...this._payload, iat: input };
    }
    return this;
  }
}

// node_modules/jose/dist/node/esm/jwt/sign.js
class SignJWT extends ProduceJWT {
  setProtectedHeader(protectedHeader) {
    this._protectedHeader = protectedHeader;
    return this;
  }
  async sign(key, options) {
    var _a;
    const sig = new CompactSign(encoder.encode(JSON.stringify(this._payload)));
    sig.setProtectedHeader(this._protectedHeader);
    if (Array.isArray((_a = this._protectedHeader) === null || _a === undefined ? undefined : _a.crit) && this._protectedHeader.crit.includes("b64") && this._protectedHeader.b64 === false) {
      throw new JWTInvalid("JWTs MUST NOT use unencoded payload");
    }
    return sig.sign(key, options);
  }
}
// src/modules/auth/auth.service.ts
class AuthService {
  async signIn(identifier, password, type) {
    let user = null;
    if (type === "email") {
      user = await users_service_default.findByEmail(identifier);
    } else {
      user = await users_service_default.findByUsername(identifier);
    }
    if (!user)
      throw new HTTPException(404, { message: "User not found." });
    const isValidPassword = await Bun.password.verify(password, user.password, "bcrypt");
    if (!isValidPassword)
      throw new HTTPException(401, { message: "Unauthorized" });
    const secret = new TextEncoder().encode(process.env.JWT_SECRET);
    const accessToken = await new SignJWT({ id: user.user_id }).setProtectedHeader({ alg: "HS256" }).setIssuedAt().setExpirationTime("2d").sign(secret);
    return { accessToken };
  }
}
var auth_service_default = new AuthService;

// src/modules/auth/auth.controller.ts
var isEmail = function(str) {
  const emailRegex = /^[a-zA-Z0-9._-]+@[a-zA-Z0-9.-]+\.[a-zA-Z]{2,6}$/;
  return emailRegex.test(str);
};

class AuthController {
  async signIn(c) {
    const { identifier, password } = await c.req.json();
    let type = "username";
    if (isEmail(identifier)) {
      type = "email";
    } else {
      type = "username";
    }
    const data = await auth_service_default.signIn(identifier, password, type);
    return c.json(data);
  }
}
var auth_controller_default = new AuthController;

// src/modules/auth/auth.router.ts
var auth3 = new Hono2;
auth3.post("/", auth_controller_default.signIn);

// src/modules/rss/rss.controller.ts
var import_celery_node = __toESM(require_dist2(), 1);
var import_redis = __toESM(require_dist9(), 1);

// src/modules/rss/rss.service.ts
class RssService {
  async getFeed(feed_url) {
    const feeds = await db_default`
      select feed_id from feeds
      where feed_url = ${feed_url}
    `;
    return feeds[0].feed_id;
  }
  async insertFeeds(feed_url) {
    const feeds = await db_default`
      insert into feeds
        (feed_id, feed_url)
      values
        (${v4()}, ${feed_url})
      on conflict (feed_url) do nothing
      returning feed_id
    `;
    return feeds[0] ? feeds[0].feed_id : null;
  }
  async insertUserFeeds({ user_id, feed_id }) {
    const feeds = await db_default`
      insert into user_feeds
        (user_feed_id, user_id, feed_id)
      values
        (${v4()}, ${user_id}, ${feed_id})
      on conflict (user_id, feed_id) do nothing
      returning user_feed_id
    `;
    return feeds[0] ? feeds[0].user_feed_id : null;
  }
  async insertUserArticle({ user_id, article_id, feed_id }) {
    const user_articles = await db_default`
      insert into user_articles
        (user_article_id, user_id, article_id, feed_id)
      values
        (${v4()}, ${user_id}, ${article_id}, ${feed_id})
      on conflict (user_id, article_id) do nothing
      returning user_article_id
    `;
    return user_articles[0] ? user_articles[0].user_article_id : null;
  }
  async deleteUserFeed({ user_id, feed_id }) {
    const feeds = await db_default`
      delete from user_feeds
      where user_id = ${user_id} and feed_id = ${feed_id}
      returning 1
    `;
    return feeds[0];
  }
  async deleteUserArticles({ user_id, feed_id }) {
    const articles = await db_default`
      delete from user_articles
      where user_id = ${user_id} and feed_id = ${feed_id}
      returning 1
    `;
    return articles[0];
  }
}
var rss_service_default = new RssService;

// src/shared/utils/jwtUtils.ts
function isJwtPayload(object) {
  return ("id" in object) && typeof object.id === "string" && ("iat" in object) && typeof object.iat === "number" && ("exp" in object) && typeof object.exp === "number";
}
async function getUserIdFromHeader(req) {
  const header = req.header("Authorization").split(" ")[1];
  const secretUint8Array = new TextEncoder().encode(process.env.JWT_SECRET);
  const { payload } = await jwtVerify(header, secretUint8Array);
  if (!isJwtPayload(payload)) {
    throw new Error("Invalid payload");
  }
  return payload.id;
}

// src/modules/rss/rss.controller.ts
var redisClient = import_redis.default.createClient({
  url: `${process.env.REDIS_URL}/3`
});
redisClient.connect();
var celeryClient = import_celery_node.default.createClient(`${process.env.REDIS_URL}/0`, `${process.env.REDIS_URL}/1`);
redisClient.on("error", (err) => {
  throw new Error("Redis Client Error", err);
});

class RssController {
  async addFeeds(c) {
    try {
      const user_id = await getUserIdFromHeader(c.req);
      const feeds = await c.req.json();
      for (const url7 of feeds) {
        const feed_key = `feed:${url7}`;
        const articlesRaw = await redisClient.hGet(feed_key, "articles");
        if (articlesRaw) {
          const articles = JSON.parse(articlesRaw);
          const feed_id = await redisClient.hGet(feed_key, "feed_id");
          for (const article of articles) {
            await rss_service_default.insertUserFeeds({ user_id, feed_id });
            await rss_service_default.insertUserArticle({
              user_id,
              article_id: article.article_id,
              feed_id
            });
          }
        } else {
          const feed_id = await rss_service_default.insertFeeds(url7);
          await rss_service_default.insertUserFeeds({ user_id, feed_id });
          const task = celeryClient.createTask("tasks.process_feed");
          task.applyAsync([], { feed_id, user_id, feed_url: url7 });
        }
      }
      return c.json({ message: "Processing started" });
    } catch (error) {
      console.log(error);
      throw new HTTPException(500, { message: "Invalid Authorization Token. Sign In again to get new token." });
    }
  }
  async getAllFeeds(c) {
  }
  async deleteFeed(c) {
    const user_id = await getUserIdFromHeader(c.req);
    const feeds = await c.req.json();
    for (const url7 of feeds) {
      const feed_id = await rss_service_default.getFeed(url7);
      await rss_service_default.deleteUserFeed({ user_id, feed_id });
      await rss_service_default.deleteUserArticles({ user_id, feed_id });
    }
    return c.json({ message: "All requested feeds and their articles are deleted." });
  }
}
var rss_controller_default = new RssController;

// node_modules/hono/dist/utils/jwt/jwt.js
var exports_jwt = {};
__export(exports_jwt, {
  verify: () => {
    {
      return verify6;
    }
  },
  sign: () => {
    {
      return sign7;
    }
  },
  decode: () => {
    {
      return decode2;
    }
  }
});

// node_modules/hono/dist/utils/encode.js
var decodeBase64Url = (str) => {
  return decodeBase64(str.replace(/_|-/g, (m) => ({ _: "/", "-": "+" })[m] ?? m));
};
var encodeBase64Url = (buf) => encodeBase64(buf).replace(/\/|\+/g, (m) => ({ "/": "_", "+": "-" })[m] ?? m);
var encodeBase64 = (buf) => {
  let binary = "";
  const bytes2 = new Uint8Array(buf);
  for (let i = 0;i < bytes2.length; i++) {
    binary += String.fromCharCode(bytes2[i]);
  }
  return btoa(binary);
};
var decodeBase64 = (str) => {
  const binary = atob(str);
  const bytes2 = new Uint8Array(new ArrayBuffer(binary.length));
  const half = binary.length / 2;
  for (let i = 0, j = binary.length - 1;i <= half; i++, j--) {
    bytes2[i] = binary.charCodeAt(i);
    bytes2[j] = binary.charCodeAt(j);
  }
  return bytes2;
};

// node_modules/hono/dist/utils/jwt/types.js
var JwtAlgorithmNotImplemented = class extends Error {
  constructor(token) {
    super(`invalid JWT token: ${token}`);
    this.name = "JwtAlgorithmNotImplemented";
  }
};
var JwtTokenInvalid = class extends Error {
  constructor(token) {
    super(`invalid JWT token: ${token}`);
    this.name = "JwtTokenInvalid";
  }
};
var JwtTokenNotBefore = class extends Error {
  constructor(token) {
    super(`token (${token}) is being used before it's valid`);
    this.name = "JwtTokenNotBefore";
  }
};
var JwtTokenExpired = class extends Error {
  constructor(token) {
    super(`token (${token}) expired`);
    this.name = "JwtTokenExpired";
  }
};
var JwtTokenIssuedAt = class extends Error {
  constructor(currentTimestamp, iat) {
    super(`Incorrect "iat" claim must be a older than "${currentTimestamp}" (iat: "${iat}")`);
    this.name = "JwtTokenIssuedAt";
  }
};
var JwtTokenSignatureMismatched = class extends Error {
  constructor(token) {
    super(`token(${token}) signature mismatched`);
    this.name = "JwtTokenSignatureMismatched";
  }
};
var AlgorithmTypes = ((AlgorithmTypes2) => {
  AlgorithmTypes2["HS256"] = "HS256";
  AlgorithmTypes2["HS384"] = "HS384";
  AlgorithmTypes2["HS512"] = "HS512";
  return AlgorithmTypes2;
})(AlgorithmTypes || {});

// node_modules/hono/dist/utils/jwt/jwt.js
var utf8Encoder = new TextEncoder;
var utf8Decoder = new TextDecoder;
var encodeJwtPart = (part) => encodeBase64Url(utf8Encoder.encode(JSON.stringify(part))).replace(/=/g, "");
var encodeSignaturePart = (buf) => encodeBase64Url(buf).replace(/=/g, "");
var decodeJwtPart = (part) => JSON.parse(utf8Decoder.decode(decodeBase64Url(part)));
var param = (name) => {
  switch (name.toUpperCase()) {
    case "HS256":
      return {
        name: "HMAC",
        hash: {
          name: "SHA-256"
        }
      };
    case "HS384":
      return {
        name: "HMAC",
        hash: {
          name: "SHA-384"
        }
      };
    case "HS512":
      return {
        name: "HMAC",
        hash: {
          name: "SHA-512"
        }
      };
    default:
      throw new JwtAlgorithmNotImplemented(name);
  }
};
var signing = async (data, secret, alg = AlgorithmTypes.HS256) => {
  if (!crypto.subtle || !crypto.subtle.importKey) {
    throw new Error("`crypto.subtle.importKey` is undefined. JWT auth middleware requires it.");
  }
  const utf8Encoder2 = new TextEncoder;
  const cryptoKey = await crypto.subtle.importKey("raw", utf8Encoder2.encode(secret), param(alg), false, ["sign"]);
  return await crypto.subtle.sign(param(alg), cryptoKey, utf8Encoder2.encode(data));
};
var sign7 = async (payload, secret, alg = AlgorithmTypes.HS256) => {
  const encodedPayload = encodeJwtPart(payload);
  const encodedHeader = encodeJwtPart({ alg, typ: "JWT" });
  const partialToken = `${encodedHeader}.${encodedPayload}`;
  const signaturePart = await signing(partialToken, secret, alg);
  const signature = encodeSignaturePart(signaturePart);
  return `${partialToken}.${signature}`;
};
var verify6 = async (token, secret, alg = AlgorithmTypes.HS256) => {
  const tokenParts = token.split(".");
  if (tokenParts.length !== 3) {
    throw new JwtTokenInvalid(token);
  }
  const { payload } = decode2(token);
  const now = Math.floor(Date.now() / 1000);
  if (payload.nbf && payload.nbf > now) {
    throw new JwtTokenNotBefore(token);
  }
  if (payload.exp && payload.exp <= now) {
    throw new JwtTokenExpired(token);
  }
  if (payload.iat && now < payload.iat) {
    throw new JwtTokenIssuedAt(now, payload.iat);
  }
  const signaturePart = tokenParts.slice(0, 2).join(".");
  const signature = await signing(signaturePart, secret, alg);
  const encodedSignature = encodeSignaturePart(signature);
  if (encodedSignature !== tokenParts[2]) {
    throw new JwtTokenSignatureMismatched(token);
  }
  return payload;
};
var decode2 = (token) => {
  try {
    const [h, p] = token.split(".");
    const header = decodeJwtPart(h);
    const payload = decodeJwtPart(p);
    return {
      header,
      payload
    };
  } catch (e) {
    throw new JwtTokenInvalid(token);
  }
};

// node_modules/hono/dist/middleware/jwt/index.js
var jwt2 = (options) => {
  if (!options) {
    throw new Error('JWT auth middleware requires options for "secret');
  }
  if (!crypto.subtle || !crypto.subtle.importKey) {
    throw new Error("`crypto.subtle.importKey` is undefined. JWT auth middleware requires it.");
  }
  return async (ctx, next) => {
    const credentials = ctx.req.headers.get("Authorization");
    let token;
    if (credentials) {
      const parts = credentials.split(/\s+/);
      if (parts.length !== 2) {
        const res = new Response("Unauthorized", {
          status: 401,
          headers: {
            "WWW-Authenticate": `Bearer realm="${ctx.req.url}",error="invalid_request",error_description="invalid credentials structure"`
          }
        });
        throw new HTTPException(401, { res });
      } else {
        token = parts[1];
      }
    } else if (options.cookie) {
      token = ctx.req.cookie(options.cookie);
    }
    if (!token) {
      const res = new Response("Unauthorized", {
        status: 401,
        headers: {
          "WWW-Authenticate": `Bearer realm="${ctx.req.url}",error="invalid_request",error_description="no authorization included in request"`
        }
      });
      throw new HTTPException(401, { res });
    }
    let payload;
    let msg = "";
    try {
      payload = await exports_jwt.verify(token, options.secret, options.alg);
    } catch (e) {
      msg = `${e}`;
    }
    if (!payload) {
      const res = new Response("Unauthorized", {
        status: 401,
        statusText: msg,
        headers: {
          "WWW-Authenticate": `Bearer realm="${ctx.req.url}",error="invalid_token",error_description="token verification failure"`
        }
      });
      throw new HTTPException(401, { res });
    }
    ctx.set("jwtPayload", payload);
    await next();
  };
};

// src/shared/middlewares/auth-middleware.ts
function authMiddleware() {
  return jwt2({ secret: process.env.JWT_SECRET });
}

// src/modules/rss/rss.router.ts
var rss3 = new Hono2;
rss3.post("/add", authMiddleware(), rss_controller_default.addFeeds);
rss3.get("/list", authMiddleware(), rss_controller_default.getAllFeeds);
rss3.post("/delete", authMiddleware(), rss_controller_default.deleteFeed);

// src/router.ts
var healthcheck = new Hono2;
healthcheck.get("/", (c) => {
  return c.jsonT({ ok: true });
});
var router8 = new Hono2;
router8.route("/healthcheck", healthcheck);
router8.route("/users", users3);
router8.route("/auth", auth3);
router8.route("/feeds", rss3);

// src/index.ts
var api = new Hono2;
api.use(cors());
api.route("/", router8);
var src_default2 = api;
export {
  src_default2 as default
};
